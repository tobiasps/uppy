(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Adapted from https://github.com/Flet/prettier-bytes/
// Changing 1000 bytes to 1024, so we can keep uppercase KB vs kB
// ISC License (c) Dan Flettre https://github.com/Flet/prettier-bytes/blob/master/LICENSE
module.exports = function prettierBytes (num) {
  if (typeof num !== 'number' || isNaN(num)) {
    throw new TypeError('Expected a number, got ' + typeof num)
  }

  var neg = num < 0
  var units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']

  if (neg) {
    num = -num
  }

  if (num < 1) {
    return (neg ? '-' : '') + num + ' B'
  }

  var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1)
  num = Number(num / Math.pow(1024, exponent))
  var unit = units[exponent]

  if (num >= 10 || num % 1 === 0) {
    // Do not show decimals when the number is two-digit, or if the number has no
    // decimal component.
    return (neg ? '-' : '') + num.toFixed(0) + ' ' + unit
  } else {
    return (neg ? '-' : '') + num.toFixed(1) + ' ' + unit
  }
}

},{}],2:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],3:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],4:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],5:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],6:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],7:[function(require,module,exports){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

},{}],8:[function(require,module,exports){

},{}],9:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":6,"buffer":9,"ieee754":27}],10:[function(require,module,exports){
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],11:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],12:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],13:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

var fingerprint = require('./lib/fingerprint.js');
var pad = require('./lib/pad.js');
var getRandomValue = require('./lib/getRandomValue.js');

var c = 0,
  blockSize = 4,
  base = 36,
  discreteValues = Math.pow(base, blockSize);

function randomBlock () {
  return pad((getRandomValue() *
    discreteValues << 0)
    .toString(base), blockSize);
}

function safeCounter () {
  c = c < discreteValues ? c : 0;
  c++; // this is not subliminal
  return c - 1;
}

function cuid () {
  // Starting with a lowercase letter makes
  // it HTML element ID friendly.
  var letter = 'c', // hard-coded allows for sequential access

    // timestamp
    // warning: this exposes the exact date and time
    // that the uid was created.
    timestamp = (new Date().getTime()).toString(base),

    // Prevent same-machine collisions.
    counter = pad(safeCounter().toString(base), blockSize),

    // A few chars to generate distinct ids for different
    // clients (so different computers are far less
    // likely to generate the same id)
    print = fingerprint(),

    // Grab some more chars from Math.random()
    random = randomBlock() + randomBlock();

  return letter + timestamp + counter + print + random;
}

cuid.slug = function slug () {
  var date = new Date().getTime().toString(36),
    counter = safeCounter().toString(36).slice(-4),
    print = fingerprint().slice(0, 1) +
      fingerprint().slice(-1),
    random = randomBlock().slice(-2);

  return date.slice(-2) +
    counter + print + random;
};

cuid.isCuid = function isCuid (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  if (stringToCheck.startsWith('c')) return true;
  return false;
};

cuid.isSlug = function isSlug (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  var stringLength = stringToCheck.length;
  if (stringLength >= 7 && stringLength <= 10) return true;
  return false;
};

cuid.fingerprint = fingerprint;

module.exports = cuid;

},{"./lib/fingerprint.js":14,"./lib/getRandomValue.js":15,"./lib/pad.js":16}],14:[function(require,module,exports){
var pad = require('./pad.js');

var env = typeof window === 'object' ? window : self;
var globalCount = Object.keys(env).length;
var mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
var clientId = pad((mimeTypesLength +
  navigator.userAgent.length).toString(36) +
  globalCount.toString(36), 4);

module.exports = function fingerprint () {
  return clientId;
};

},{"./pad.js":16}],15:[function(require,module,exports){

var getRandomValue;

var crypto = typeof window !== 'undefined' &&
  (window.crypto || window.msCrypto) ||
  typeof self !== 'undefined' &&
  self.crypto;

if (crypto) {
    var lim = Math.pow(2, 32) - 1;
    getRandomValue = function () {
        return Math.abs(crypto.getRandomValues(new Uint32Array(1))[0] / lim);
    };
} else {
    getRandomValue = Math.random;
}

module.exports = getRandomValue;

},{}],16:[function(require,module,exports){
module.exports = function pad (num, size) {
  var s = '000000000' + num;
  return s.substr(s.length - size);
};

},{}],17:[function(require,module,exports){
module.exports = dragDrop

var flatten = require('flatten')
var parallel = require('run-parallel')

function dragDrop (elem, listeners) {
  if (typeof elem === 'string') {
    var selector = elem
    elem = window.document.querySelector(elem)
    if (!elem) {
      throw new Error('"' + selector + '" does not match any HTML elements')
    }
  }

  if (!elem) {
    throw new Error('"' + elem + '" is not a valid HTML element')
  }

  if (typeof listeners === 'function') {
    listeners = { onDrop: listeners }
  }

  var timeout

  elem.addEventListener('dragenter', onDragEnter, false)
  elem.addEventListener('dragover', onDragOver, false)
  elem.addEventListener('dragleave', onDragLeave, false)
  elem.addEventListener('drop', onDrop, false)

  // Function to remove drag-drop listeners
  return function remove () {
    removeDragClass()
    elem.removeEventListener('dragenter', onDragEnter, false)
    elem.removeEventListener('dragover', onDragOver, false)
    elem.removeEventListener('dragleave', onDragLeave, false)
    elem.removeEventListener('drop', onDrop, false)
  }

  function onDragEnter (e) {
    if (listeners.onDragEnter) {
      listeners.onDragEnter(e)
    }

    // Prevent event
    e.stopPropagation()
    e.preventDefault()
    return false
  }

  function onDragOver (e) {
    e.stopPropagation()
    e.preventDefault()

    if (listeners.onDragOver) {
      listeners.onDragOver(e)
    }

    if (e.dataTransfer.items) {
      // Only add "drag" class when `items` contains items that are able to be
      // handled by the registered listeners (files vs. text)
      var items = Array.from(e.dataTransfer.items)
      var fileItems = items.filter(function (item) { return item.kind === 'file' })
      var textItems = items.filter(function (item) { return item.kind === 'string' })

      if (fileItems.length === 0 && !listeners.onDropText) return
      if (textItems.length === 0 && !listeners.onDrop) return
      if (fileItems.length === 0 && textItems.length === 0) return
    }

    elem.classList.add('drag')
    clearTimeout(timeout)

    e.dataTransfer.dropEffect = 'copy'

    return false
  }

  function onDragLeave (e) {
    e.stopPropagation()
    e.preventDefault()

    if (listeners.onDragLeave) {
      listeners.onDragLeave(e)
    }

    clearTimeout(timeout)
    timeout = setTimeout(removeDragClass, 50)

    return false
  }

  function onDrop (e) {
    e.stopPropagation()
    e.preventDefault()

    if (listeners.onDragLeave) {
      listeners.onDragLeave(e)
    }

    clearTimeout(timeout)
    removeDragClass()

    var pos = {
      x: e.clientX,
      y: e.clientY
    }

    // text drop support
    var text = e.dataTransfer.getData('text')
    if (text && listeners.onDropText) {
      listeners.onDropText(text, pos)
    }

    // File drop support. The `dataTransfer.items` API supports directories, so we
    // use it instead of `dataTransfer.files`, even though it's much more
    // complicated to use.
    // See: https://github.com/feross/drag-drop/issues/39
    if (listeners.onDrop && e.dataTransfer.items) {
      var fileList = e.dataTransfer.files

      // Handle directories in Chrome using the proprietary FileSystem API
      var items = Array.from(e.dataTransfer.items).filter(function (item) {
        return item.kind === 'file'
      })

      if (items.length === 0) return

      parallel(items.map(function (item) {
        return function (cb) {
          processEntry(item.webkitGetAsEntry(), cb)
        }
      }), function (err, results) {
        // This catches permission errors with file:// in Chrome. This should never
        // throw in production code, so the user does not need to use try-catch.
        if (err) throw err

        var entries = flatten(results)

        var files = entries.filter(function (item) {
          return item.isFile
        })

        var directories = entries.filter(function (item) {
          return item.isDirectory
        })

        listeners.onDrop(files, pos, fileList, directories)
      })
    }

    return false
  }

  function removeDragClass () {
    elem.classList.remove('drag')
  }
}

function processEntry (entry, cb) {
  var entries = []

  if (entry.isFile) {
    entry.file(function (file) {
      file.fullPath = entry.fullPath // preserve pathing for consumer
      file.isFile = true
      file.isDirectory = false
      cb(null, file)
    }, function (err) {
      cb(err)
    })
  } else if (entry.isDirectory) {
    var reader = entry.createReader()
    readEntries()
  }

  function readEntries () {
    reader.readEntries(function (entries_) {
      if (entries_.length > 0) {
        entries = entries.concat(Array.from(entries_))
        readEntries() // continue reading entries until `readEntries` returns no more
      } else {
        doneEntries()
      }
    })
  }

  function doneEntries () {
    parallel(entries.map(function (entry) {
      return function (cb) {
        processEntry(entry, cb)
      }
    }), function (err, results) {
      if (err) {
        cb(err)
      } else {
        results.push({
          fullPath: entry.fullPath,
          name: entry.name,
          isFile: false,
          isDirectory: true
        })
        cb(null, results)
      }
    })
  }
}

},{"flatten":18,"run-parallel":44}],18:[function(require,module,exports){
module.exports = function flatten(list, depth) {
  depth = (typeof depth == 'number') ? depth : Infinity;

  if (!depth) {
    if (Array.isArray(list)) {
      return list.map(function(i) { return i; });
    }
    return list;
  }

  return _flatten(list, 1);

  function _flatten(list, d) {
    return list.reduce(function (acc, item) {
      if (Array.isArray(item) && d < depth) {
        return acc.concat(_flatten(item, d + 1));
      }
      else {
        return acc.concat(item);
      }
    }, []);
  }
};

},{}],19:[function(require,module,exports){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary2');
var sliceBuffer = require('arraybuffer.slice');
var after = require('after');
var utf8 = require('./utf8');

var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = require('base64-arraybuffer');
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

},{"./keys":20,"./utf8":21,"after":2,"arraybuffer.slice":3,"base64-arraybuffer":5,"blob":7,"has-binary2":24}],20:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],21:[function(require,module,exports){
/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, it’s not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};

},{}],22:[function(require,module,exports){
(function (process,global,Buffer){(function (){
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define("exifr",["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).exifr={})}(this,(function(e){"use strict";function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}});var n=["prototype","__proto__","caller","arguments","length","name"];Object.getOwnPropertyNames(t).forEach((function(r){-1===n.indexOf(r)&&e[r]!==t[r]&&(e[r]=t[r])})),t&&u(e,t)}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function o(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function f(e,t,n){return(f=o()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&u(i,n.prototype),i}).apply(null,arguments)}function c(e){var t="function"==typeof Map?new Map:void 0;return(c=function(e){if(null===e||(n=e,-1===Function.toString.call(n).indexOf("[native code]")))return e;var n;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return f(e,arguments,s(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),u(r,e)})(e)}function h(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function l(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?h(e):t}function d(e){var t=o();return function(){var n,r=s(e);if(t){var i=s(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return l(this,n)}}function v(e,t,n){return(v="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=s(e)););return e}(e,t);if(r){var i=Object.getOwnPropertyDescriptor(r,t);return i.get?i.get.call(n):i.value}})(e,t,n||e)}var p=Object.values||function(e){var t=[];for(var n in e)t.push(e[n]);return t},y=Object.entries||function(e){var t=[];for(var n in e)t.push([n,e[n]]);return t},g=Object.assign||function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return n.forEach((function(t){for(var n in t)e[n]=t[n]})),e},k=Object.fromEntries||function(e){var t={};return m(e).forEach((function(e){var n=e[0],r=e[1];t[n]=r})),t},m=Array.from||function(e){if(e instanceof P){var t=[];return e.forEach((function(e,n){return t.push([n,e])})),t}return Array.prototype.slice.call(e)};function b(e){return-1!==this.indexOf(e)}Array.prototype.includes||(Array.prototype.includes=b),String.prototype.includes||(String.prototype.includes=b),String.prototype.startsWith||(String.prototype.startsWith=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.substring(t,t+e.length)===e}),String.prototype.endsWith||(String.prototype.endsWith=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.length;return this.substring(t-e.length,t)===e});var A="undefined"!=typeof self?self:global,w=A.fetch||function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new Promise((function(n,r){var i=new XMLHttpRequest;if(i.open("get",e,!0),i.responseType="arraybuffer",i.onerror=r,t.headers)for(var a in t.headers)i.setRequestHeader(a,t.headers[a]);i.onload=function(){n({ok:i.status>=200&&i.status<300,status:i.status,arrayBuffer:function(){return Promise.resolve(i.response)}})},i.send(null)}))},O=function(e){var t=[];if(Object.defineProperties(t,{size:{get:function(){return this.length}},has:{value:function(e){return-1!==this.indexOf(e)}},add:{value:function(e){this.has(e)||this.push(e)}},delete:{value:function(e){if(this.has(e)){var t=this.indexOf(e);this.splice(t,1)}}}}),Array.isArray(e))for(var n=0;n<e.length;n++)t.add(e[n]);return t},S=function(e){return new P(e)},P=void 0!==A.Map&&void 0!==A.Map.prototype.keys?A.Map:function(){function e(n){if(t(this,e),this.clear(),n)for(var r=0;r<n.length;r++)this.set(n[r][0],n[r][1])}return r(e,[{key:"clear",value:function(){this._map={},this._keys=[]}},{key:"size",get:function(){return this._keys.length}},{key:"get",value:function(e){return this._map["map_"+e]}},{key:"set",value:function(e,t){return this._map["map_"+e]=t,this._keys.indexOf(e)<0&&this._keys.push(e),this}},{key:"has",value:function(e){return this._keys.indexOf(e)>=0}},{key:"delete",value:function(e){var t=this._keys.indexOf(e);return!(t<0)&&(delete this._map["map_"+e],this._keys.splice(t,1),!0)}},{key:"keys",value:function(){return this._keys.slice(0)}},{key:"values",value:function(){var e=this;return this._keys.map((function(t){return e.get(t)}))}},{key:"entries",value:function(){var e=this;return this._keys.map((function(t){return[t,e.get(t)]}))}},{key:"forEach",value:function(e,t){for(var n=0;n<this._keys.length;n++)e.call(t,this._map["map_"+this._keys[n]],this._keys[n],this)}}]),e}(),U="undefined"!=typeof self?self:global,x="undefined"!=typeof navigator,C=x&&"undefined"==typeof HTMLImageElement,B=!("undefined"==typeof global||"undefined"==typeof process||!process.versions||!process.versions.node),j=U.Buffer,_=!!j;var V=function(e){return void 0!==e};function I(e){return void 0===e||(e instanceof P?0===e.size:0===p(e).filter(V).length)}function L(e){var t=new Error(e);throw delete t.stack,t}function T(e){var t=function(e){var t=0;return e.ifd0.enabled&&(t+=1024),e.exif.enabled&&(t+=2048),e.makerNote&&(t+=2048),e.userComment&&(t+=1024),e.gps.enabled&&(t+=512),e.interop.enabled&&(t+=100),e.ifd1.enabled&&(t+=1024),t+2048}(e);return e.jfif.enabled&&(t+=50),e.xmp.enabled&&(t+=2e4),e.iptc.enabled&&(t+=14e3),e.icc.enabled&&(t+=6e3),t}var z=function(e){return String.fromCharCode.apply(null,e)},F="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):void 0;function E(e){return F?F.decode(e):_?Buffer.from(e).toString("utf8"):decodeURIComponent(escape(z(e)))}var D=function(){function e(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(t(this,e),"boolean"==typeof a&&(this.le=a),Array.isArray(n)&&(n=new Uint8Array(n)),0===n)this.byteOffset=0,this.byteLength=0;else if(n instanceof ArrayBuffer){void 0===i&&(i=n.byteLength-r);var s=new DataView(n,r,i);this._swapDataView(s)}else if(n instanceof Uint8Array||n instanceof DataView||n instanceof e){void 0===i&&(i=n.byteLength-r),(r+=n.byteOffset)+i>n.byteOffset+n.byteLength&&L("Creating view outside of available memory in ArrayBuffer");var u=new DataView(n.buffer,r,i);this._swapDataView(u)}else if("number"==typeof n){var o=new DataView(new ArrayBuffer(n));this._swapDataView(o)}else L("Invalid input argument for BufferView: "+n)}return r(e,[{key:"_swapArrayBuffer",value:function(e){this._swapDataView(new DataView(e))}},{key:"_swapBuffer",value:function(e){this._swapDataView(new DataView(e.buffer,e.byteOffset,e.byteLength))}},{key:"_swapDataView",value:function(e){this.dataView=e,this.buffer=e.buffer,this.byteOffset=e.byteOffset,this.byteLength=e.byteLength}},{key:"_lengthToEnd",value:function(e){return this.byteLength-e}},{key:"set",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;t instanceof DataView||t instanceof e?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer&&(t=new Uint8Array(t)),t instanceof Uint8Array||L("BufferView.set(): Invalid data argument.");var i=this.toUint8();return i.set(t,n),new r(this,n,t.byteLength)}},{key:"subarray",value:function(t,n){return new e(this,t,n=n||this._lengthToEnd(t))}},{key:"toUint8",value:function(){return new Uint8Array(this.buffer,this.byteOffset,this.byteLength)}},{key:"getUint8Array",value:function(e,t){return new Uint8Array(this.buffer,this.byteOffset+e,t)}},{key:"getString",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=this.getUint8Array(e,t);return E(n)}},{key:"getLatin1String",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=this.getUint8Array(e,t);return z(n)}},{key:"getUnicodeString",value:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=[],r=0;r<t&&e+r<this.byteLength;r+=2)n.push(this.getUint16(e+r));return z(n)}},{key:"getInt8",value:function(e){return this.dataView.getInt8(e)}},{key:"getUint8",value:function(e){return this.dataView.getUint8(e)}},{key:"getInt16",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getInt16(e,t)}},{key:"getInt32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getInt32(e,t)}},{key:"getUint16",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getUint16(e,t)}},{key:"getUint32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getUint32(e,t)}},{key:"getFloat32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat32(e,t)}},{key:"getFloat64",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat64(e,t)}},{key:"getFloat",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat32(e,t)}},{key:"getDouble",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat64(e,t)}},{key:"getUintBytes",value:function(e,t,n){switch(t){case 1:return this.getUint8(e,n);case 2:return this.getUint16(e,n);case 4:return this.getUint32(e,n);case 8:return this.getUint64&&this.getUint64(e,n)}}},{key:"getUint",value:function(e,t,n){switch(t){case 8:return this.getUint8(e,n);case 16:return this.getUint16(e,n);case 32:return this.getUint32(e,n);case 64:return this.getUint64&&this.getUint64(e,n)}}},{key:"toString",value:function(e){return this.dataView.toString(e,this.constructor.name)}},{key:"ensureChunk",value:function(){}}],[{key:"from",value:function(t,n){return t instanceof this&&t.le===n?t:new e(t,void 0,void 0,n)}}]),e}();function R(e,t){L("".concat(e," '").concat(t,"' was not loaded, try using full build of exifr."))}var N=function(e){a(i,e);var n=d(i);function i(e){var r;return t(this,i),(r=n.call(this)).kind=e,r}return r(i,[{key:"get",value:function(e,t){return this.has(e)||R(this.kind,e),t&&(e in t||function(e,t){L("Unknown ".concat(e," '").concat(t,"'."))}(this.kind,e),t[e].enabled||R(this.kind,e)),v(s(i.prototype),"get",this).call(this,e)}},{key:"keyList",value:function(){return m(this.keys())}}]),i}(c(P)),M=new N("file parser"),W=new N("segment parser"),K=new N("file reader");function H(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}function X(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var Y=H((function(e){return new Promise((function(t,n){var r=new FileReader;r.onloadend=function(){return t(r.result||new ArrayBuffer)},r.onerror=n,r.readAsArrayBuffer(e)}))})),G=H((function(e){return w(e).then((function(e){return e.arrayBuffer()}))})),J=H((function(e,t){return X(t(e),(function(e){return new D(e)}))})),q=H((function(e,t,n){var r=new(K.get(n))(e,t);return X(r.read(),(function(){return r}))})),Q=H((function(e,t,n,r){return K.has(n)?q(e,t,n):r?J(e,r):(L("Parser ".concat(n," is not loaded")),X())})),Z="Invalid input argument";function $(e,t){return(n=e).startsWith("data:")||n.length>1e4?q(e,t,"base64"):x?Q(e,t,"url",G):B?q(e,t,"fs"):void L(Z);var n}var ee=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"tagKeys",get:function(){return this.allKeys||(this.allKeys=m(this.keys())),this.allKeys}},{key:"tagValues",get:function(){return this.allValues||(this.allValues=m(this.values())),this.allValues}}]),i}(c(P));function te(e,t,n){var r=new ee,i=n;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){var s=i[a],u=s[0],o=s[1];r.set(u,o)}if(Array.isArray(t)){var f=t;Array.isArray(f)||("function"==typeof f.entries&&(f=f.entries()),f=m(f));for(var c=0;c<f.length;c++){var h=f[c];e.set(h,r)}}else e.set(t,r);return r}function ne(e,t,n){var r,i=e.get(t),a=n;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)r=a[s],i.set(r[0],r[1])}var re=S(),ie=S(),ae=S(),se=37500,ue=37510,oe=33723,fe=34675,ce=34665,he=34853,le=40965,de=["chunked","firstChunkSize","firstChunkSizeNode","firstChunkSizeBrowser","chunkSize","chunkLimit"],ve=["jfif","xmp","icc","iptc","ihdr"],pe=["tiff"].concat(ve),ye=["ifd0","ifd1","exif","gps","interop"],ge=[].concat(pe,ye),ke=["makerNote","userComment"],me=["translateKeys","translateValues","reviveValues","multiSegment"],be=[].concat(me,["sanitize","mergeOutput","silentErrors"]),Ae=function(){function e(){t(this,e)}return r(e,[{key:"translate",get:function(){return this.translateKeys||this.translateValues||this.reviveValues}}]),e}(),we=function(e){a(s,e);var n=d(s);function s(e,r,a,u){var o;if(t(this,s),i(h(o=n.call(this)),"enabled",!1),i(h(o),"skip",O()),i(h(o),"pick",O()),i(h(o),"deps",O()),i(h(o),"translateKeys",!1),i(h(o),"translateValues",!1),i(h(o),"reviveValues",!1),o.key=e,o.enabled=r,o.parse=o.enabled,o.applyInheritables(u),o.canBeFiltered=ye.includes(e),o.canBeFiltered&&(o.dict=re.get(e)),void 0!==a)if(Array.isArray(a))o.parse=o.enabled=!0,o.canBeFiltered&&a.length>0&&o.translateTagSet(a,o.pick);else if("object"==typeof a){if(o.enabled=!0,o.parse=!1!==a.parse,o.canBeFiltered){var f=a.pick,c=a.skip;f&&f.length>0&&o.translateTagSet(f,o.pick),c&&c.length>0&&o.translateTagSet(c,o.skip)}o.applyInheritables(a)}else!0===a||!1===a?o.parse=o.enabled=a:L("Invalid options argument: ".concat(a));return o}return r(s,[{key:"needed",get:function(){return this.enabled||this.deps.size>0}},{key:"applyInheritables",value:function(e){var t,n,r=me;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)void 0!==(n=e[t=r[i]])&&(this[t]=n)}},{key:"translateTagSet",value:function(e,t){if(this.dict){var n,r,i=this.dict,a=i.tagKeys,s=i.tagValues,u=e;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)"string"==typeof(n=u[o])?(-1===(r=s.indexOf(n))&&(r=a.indexOf(Number(n))),-1!==r&&t.add(Number(a[r]))):t.add(n)}else{var f=e;Array.isArray(f)||("function"==typeof f.entries&&(f=f.entries()),f=m(f));for(var c=0;c<f.length;c++){var h=f[c];t.add(h)}}}},{key:"finalizeFilters",value:function(){!this.enabled&&this.deps.size>0?(this.enabled=!0,Ce(this.pick,this.deps)):this.enabled&&this.pick.size>0&&Ce(this.pick,this.deps)}}]),s}(Ae),Oe={jfif:!1,tiff:!0,xmp:!1,icc:!1,iptc:!1,ifd0:!0,ifd1:!1,exif:!0,gps:!0,interop:!1,ihdr:void 0,makerNote:!1,userComment:!1,multiSegment:!1,skip:[],pick:[],translateKeys:!0,translateValues:!0,reviveValues:!0,sanitize:!0,mergeOutput:!0,silentErrors:!0,chunked:!0,firstChunkSize:void 0,firstChunkSizeNode:512,firstChunkSizeBrowser:65536,chunkSize:65536,chunkLimit:5},Se=S(),Pe=function(e){a(i,e);var n=d(i);function i(e){var r;return t(this,i),r=n.call(this),!0===e?r.setupFromTrue():void 0===e?r.setupFromUndefined():Array.isArray(e)?r.setupFromArray(e):"object"==typeof e?r.setupFromObject(e):L("Invalid options argument ".concat(e)),void 0===r.firstChunkSize&&(r.firstChunkSize=x?r.firstChunkSizeBrowser:r.firstChunkSizeNode),r.mergeOutput&&(r.ifd1.enabled=!1),r.filterNestedSegmentTags(),r.traverseTiffDependencyTree(),r.checkLoadedPlugins(),r}return r(i,[{key:"setupFromUndefined",value:function(){var e,t=de;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++)this[e=t[n]]=Oe[e];var r=be;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)this[e=r[i]]=Oe[e];var a=ke;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)this[e=a[s]]=Oe[e];var u=ge;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)this[e=u[o]]=new we(e,Oe[e],void 0,this)}},{key:"setupFromTrue",value:function(){var e,t=de;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++)this[e=t[n]]=Oe[e];var r=be;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)this[e=r[i]]=Oe[e];var a=ke;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)this[e=a[s]]=!0;var u=ge;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)this[e=u[o]]=new we(e,!0,void 0,this)}},{key:"setupFromArray",value:function(e){var t,n=de;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++)this[t=n[r]]=Oe[t];var i=be;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)this[t=i[a]]=Oe[t];var s=ke;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++)this[t=s[u]]=Oe[t];var o=ge;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)this[t=o[f]]=new we(t,!1,void 0,this);this.setupGlobalFilters(e,void 0,ye)}},{key:"setupFromObject",value:function(e){var t;ye.ifd0=ye.ifd0||ye.image,ye.ifd1=ye.ifd1||ye.thumbnail,g(this,e);var n=de;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++)this[t=n[r]]=xe(e[t],Oe[t]);var i=be;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)this[t=i[a]]=xe(e[t],Oe[t]);var s=ke;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++)this[t=s[u]]=xe(e[t],Oe[t]);var o=pe;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)this[t=o[f]]=new we(t,Oe[t],e[t],this);var c=ye;Array.isArray(c)||("function"==typeof c.entries&&(c=c.entries()),c=m(c));for(var h=0;h<c.length;h++)this[t=c[h]]=new we(t,Oe[t],e[t],this.tiff);this.setupGlobalFilters(e.pick,e.skip,ye,ge),!0===e.tiff?this.batchEnableWithBool(ye,!0):!1===e.tiff?this.batchEnableWithUserValue(ye,e):Array.isArray(e.tiff)?this.setupGlobalFilters(e.tiff,void 0,ye):"object"==typeof e.tiff&&this.setupGlobalFilters(e.tiff.pick,e.tiff.skip,ye)}},{key:"batchEnableWithBool",value:function(e,t){var n=e;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){this[n[r]].enabled=t}}},{key:"batchEnableWithUserValue",value:function(e,t){var n=e;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=t[i];this[i].enabled=!1!==a&&void 0!==a}}},{key:"setupGlobalFilters",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;if(e&&e.length){var i=r;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){var s=i[a];this[s].enabled=!1}var u=Ue(e,n),o=u;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++){var c=o[f],h=c[0],l=c[1];Ce(this[h].pick,l),this[h].enabled=!0}}else if(t&&t.length){var d=Ue(t,n),v=d;Array.isArray(v)||("function"==typeof v.entries&&(v=v.entries()),v=m(v));for(var p=0;p<v.length;p++){var y=v[p],g=y[0],k=y[1];Ce(this[g].skip,k)}}}},{key:"filterNestedSegmentTags",value:function(){var e=this.ifd0,t=this.exif,n=this.xmp,r=this.iptc,i=this.icc;this.makerNote?t.deps.add(se):t.skip.add(se),this.userComment?t.deps.add(ue):t.skip.add(ue),n.enabled||e.skip.add(700),r.enabled||e.skip.add(oe),i.enabled||e.skip.add(fe)}},{key:"traverseTiffDependencyTree",value:function(){var e=this,t=this.ifd0,n=this.exif,r=this.gps;this.interop.needed&&(n.deps.add(le),t.deps.add(le)),n.needed&&t.deps.add(ce),r.needed&&t.deps.add(he),this.tiff.enabled=ye.some((function(t){return!0===e[t].enabled}))||this.makerNote||this.userComment;var i=ye;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){this[i[a]].finalizeFilters()}}},{key:"onlyTiff",get:function(){var e=this;return!ve.map((function(t){return e[t].enabled})).some((function(e){return!0===e}))&&this.tiff.enabled}},{key:"checkLoadedPlugins",value:function(){var e=pe;Array.isArray(e)||("function"==typeof e.entries&&(e=e.entries()),e=m(e));for(var t=0;t<e.length;t++){var n=e[t];this[n].enabled&&!W.has(n)&&R("segment parser",n)}}}],[{key:"useCached",value:function(e){var t=Se.get(e);return void 0!==t||(t=new this(e),Se.set(e,t)),t}}]),i}(Ae);function Ue(e,t){var n,r,i,a=[],s=t;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++){r=s[u],n=[];var o=re.get(r);Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)i=o[f],(e.includes(i[0])||e.includes(i[1]))&&n.push(i[0]);n.length&&a.push([r,n])}return a}function xe(e,t){return void 0!==e?e:void 0!==t?t:void 0}function Ce(e,t){var n=t;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r];e.add(i)}}function Be(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}function je(){}function _e(e,t){if(!t)return e&&e.then?e.then(je):Promise.resolve()}function Ve(e,t){var n=e();return n&&n.then?n.then(t):t(n)}i(Pe,"default",Oe);var Ie=function(){function e(n){t(this,e),i(this,"parsers",{}),this.options=Pe.useCached(n)}return r(e,[{key:"setup",value:function(){if(!this.fileParser){var e=this.file,t=e.getUint16(0),n=M;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=i[0],s=i[1];if(s.canHandle(e,t))return this.fileParser=new s(this.options,this.file,this.parsers),e[a]=!0}L("Unknown file format")}}},{key:"read",value:function(e){try{var t=this;return Be(function(e,t){return"string"==typeof e?$(e,t):x&&!C&&e instanceof HTMLImageElement?$(e.src,t):e instanceof Uint8Array||e instanceof ArrayBuffer||e instanceof DataView?new D(e):x&&e instanceof Blob?Q(e,t,"blob",Y):void L(Z)}(e,t.options),(function(e){t.file=e}))}catch(e){return Promise.reject(e)}}},{key:"parse",value:function(){try{var e=this;e.setup();var t={},n=[];return Ve((function(){return e.options.silentErrors?Be(e.doParse(t,n).catch((function(e){return n.push(e)})),(function(){n.push.apply(n,e.fileParser.errors)})):_e(e.doParse(t,n))}),(function(){return e.file.close&&e.file.close(),e.options.silentErrors&&n.length>0&&(t.errors=n),I(r=t)?void 0:r;var r}))}catch(e){return Promise.reject(e)}}},{key:"doParse",value:function(e,t){try{var n=this;return Be(n.fileParser.parse(),(function(){var r,i=p(n.parsers).map((r=function(t){return Be(t.parse(),(function(n){t.assignToOutput(e,n)}))},function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];try{return Promise.resolve(r.apply(this,e))}catch(e){return Promise.reject(e)}}));if(n.options.silentErrors){var a=function(e){return t.push(e)};i=i.map((function(e){return e.catch(a)}))}return _e(Promise.all(i))}))}catch(e){return Promise.reject(e)}}},{key:"extractThumbnail",value:function(){try{var e=this;e.setup();var t,n=e.options,r=e.file,i=W.get("tiff",n);return Ve((function(){if(!r.tiff)return function(e){var t=e();if(t&&t.then)return t.then(je)}((function(){if(r.jpeg)return Be(e.fileParser.getOrFindSegment("tiff"),(function(e){t=e}))}));t={start:0,type:"tiff"}}),(function(){if(void 0!==t)return Be(e.fileParser.ensureSegmentChunk(t),(function(t){return Be((e.parsers.tiff=new i(t,n,r)).extractThumbnail(),(function(e){return r.close&&r.close(),e}))}))}))}catch(e){return Promise.reject(e)}}}]),e}();var Le,Te=(Le=function(e,t){var n,r,i,a=new Ie(t);return n=a.read(e),r=function(){return a.parse()},i?r?r(n):n:(n&&n.then||(n=Promise.resolve(n)),r?n.then(r):n)},function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];try{return Promise.resolve(Le.apply(this,e))}catch(e){return Promise.reject(e)}}),ze=Object.freeze({__proto__:null,parse:Te,Exifr:Ie,fileParsers:M,segmentParsers:W,fileReaders:K,tagKeys:re,tagValues:ie,tagRevivers:ae,createDictionary:te,extendDictionary:ne,fetchUrlAsArrayBuffer:G,readBlobAsArrayBuffer:Y,chunkedProps:de,otherSegments:ve,segments:pe,tiffBlocks:ye,segmentsAndBlocks:ge,tiffExtractables:ke,inheritables:me,allFormatters:be,Options:Pe});function Fe(){}var Ee=function(){function e(n,r,a){var s=this;t(this,e),i(this,"errors",[]),i(this,"ensureSegmentChunk",function(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}((function(e){var t,n,r,i=e.start,a=e.size||65536;return t=function(){if(s.file.chunked)return function(e){var t=e();if(t&&t.then)return t.then(Fe)}((function(){if(!s.file.available(i,a))return function(e){if(e&&e.then)return e.then(Fe)}(function(e,t){try{var n=e()}catch(e){return t(e)}return n&&n.then?n.then(void 0,t):n}((function(){return t=s.file.readChunk(i,a),n=function(t){e.chunk=t},r?n?n(t):t:(t&&t.then||(t=Promise.resolve(t)),n?t.then(n):t);var t,n,r}),(function(t){L("Couldn't read segment: ".concat(JSON.stringify(e),". ").concat(t.message))})));e.chunk=s.file.subarray(i,a)}));s.file.byteLength>i+a?e.chunk=s.file.subarray(i,a):void 0===e.size?e.chunk=s.file.subarray(i):L("Segment unreachable: "+JSON.stringify(e))},n=function(){return e.chunk},(r=t())&&r.then?r.then(n):n(r)}))),this.extendOptions&&this.extendOptions(n),this.options=n,this.file=r,this.parsers=a}return r(e,[{key:"injectSegment",value:function(e,t){this.options[e].enabled&&this.createParser(e,t)}},{key:"createParser",value:function(e,t){var n=new(W.get(e))(t,this.options,this.file);return this.parsers[e]=n}},{key:"createParsers",value:function(e){var t=e;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++){var r=t[n],i=r.type,a=r.chunk,s=this.options[i];if(s&&s.enabled){var u=this.parsers[i];u&&u.append||u||this.createParser(i,a)}}}},{key:"readSegments",value:function(e){try{var t=e.map(this.ensureSegmentChunk);return function(e,t){if(!t)return e&&e.then?e.then(Fe):Promise.resolve()}(Promise.all(t))}catch(e){return Promise.reject(e)}}}]),e}(),De=function(){function e(n){var r=this,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=arguments.length>2?arguments[2]:void 0;t(this,e),i(this,"errors",[]),i(this,"raw",S()),i(this,"handleError",(function(e){if(!r.options.silentErrors)throw e;r.errors.push(e.message)})),this.chunk=this.normalizeInput(n),this.file=s,this.type=this.constructor.type,this.globalOptions=this.options=a,this.localOptions=a[this.type],this.canTranslate=this.localOptions&&this.localOptions.translate}return r(e,[{key:"normalizeInput",value:function(e){return e instanceof D?e:new D(e)}},{key:"translate",value:function(){this.canTranslate&&(this.translated=this.translateBlock(this.raw,this.type))}},{key:"output",get:function(){return this.translated?this.translated:this.raw?k(this.raw):void 0}},{key:"translateBlock",value:function(e,t){var n=ae.get(t),r=ie.get(t),i=re.get(t),a=this.options[t],s=a.reviveValues&&!!n,u=a.translateValues&&!!r,o=a.translateKeys&&!!i,f={},c=e;Array.isArray(c)||("function"==typeof c.entries&&(c=c.entries()),c=m(c));for(var h=0;h<c.length;h++){var l=c[h],d=l[0],v=l[1];s&&n.has(d)?v=n.get(d)(v):u&&r.has(d)&&(v=this.translateValue(v,r.get(d))),o&&i.has(d)&&(d=i.get(d)||d),f[d]=v}return f}},{key:"translateValue",value:function(e,t){return t[e]||t.DEFAULT||e}},{key:"assignToOutput",value:function(e,t){this.assignObjectToOutput(e,this.constructor.type,t)}},{key:"assignObjectToOutput",value:function(e,t,n){if(this.globalOptions.mergeOutput)return g(e,n);e[t]?g(e[t],n):e[t]=n}}],[{key:"findPosition",value:function(e,t){var n=e.getUint16(t+2)+2,r="function"==typeof this.headerLength?this.headerLength(e,t,n):this.headerLength,i=t+r,a=n-r;return{offset:t,length:n,headerLength:r,start:i,size:a,end:i+a}}},{key:"parse",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=new Pe(i({},this.type,t)),r=new this(e,n);return r.parse()}}]),e}();function Re(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}i(De,"headerLength",4),i(De,"type",void 0),i(De,"multiSegment",!1),i(De,"canHandle",(function(){return!1}));function Ne(){}function Me(e,t){if(!t)return e&&e.then?e.then(Ne):Promise.resolve()}function We(e){var t=e();if(t&&t.then)return t.then(Ne)}function Ke(e,t){var n=e();return n&&n.then?n.then(t):t(n)}function He(e,t,n){if(!e.s){if(n instanceof Xe){if(!n.s)return void(n.o=He.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(He.bind(null,e,t),He.bind(null,e,2));e.s=t,e.v=n;var r=e.o;r&&r(e)}}var Xe=function(){function e(){}return e.prototype.then=function(t,n){var r=new e,i=this.s;if(i){var a=1&i?t:n;if(a){try{He(r,1,a(this.v))}catch(e){He(r,2,e)}return r}return this}return this.o=function(e){try{var i=e.v;1&e.s?He(r,1,t?t(i):i):n?He(r,1,n(i)):He(r,2,i)}catch(e){He(r,2,e)}},r},e}();function Ye(e){return e instanceof Xe&&1&e.s}function Ge(e,t,n){for(var r;;){var i=e();if(Ye(i)&&(i=i.v),!i)return a;if(i.then){r=0;break}var a=n();if(a&&a.then){if(!Ye(a)){r=1;break}a=a.s}if(t){var s=t();if(s&&s.then&&!Ye(s)){r=2;break}}}var u=new Xe,o=He.bind(null,u,2);return(0===r?i.then(c):1===r?a.then(f):s.then(h)).then(void 0,o),u;function f(r){a=r;do{if(t&&(s=t())&&s.then&&!Ye(s))return void s.then(h).then(void 0,o);if(!(i=e())||Ye(i)&&!i.v)return void He(u,1,a);if(i.then)return void i.then(c).then(void 0,o);Ye(a=n())&&(a=a.v)}while(!a||!a.then);a.then(f).then(void 0,o)}function c(e){e?(a=n())&&a.then?a.then(f).then(void 0,o):f(a):He(u,1,a)}function h(){(i=e())?i.then?i.then(c).then(void 0,o):c(i):He(u,1,a)}}function Je(e){return 192===e||194===e||196===e||219===e||221===e||218===e||254===e}function qe(e){return e>=224&&e<=239}function Qe(e,t,n){var r=W;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++){var a=r[i],s=a[0];if(a[1].canHandle(e,t,n))return s}}var Ze=function(e){a(s,e);var n=d(s);function s(){var e;t(this,s);for(var r=arguments.length,a=new Array(r),u=0;u<r;u++)a[u]=arguments[u];return i(h(e=n.call.apply(n,[this].concat(a))),"appSegments",[]),i(h(e),"jpegSegments",[]),i(h(e),"unknownSegments",[]),e}return r(s,[{key:"parse",value:function(){try{var e=this;return Re(e.findAppSegments(),(function(){return Re(e.readSegments(e.appSegments),(function(){e.mergeMultiSegments(),e.createParsers(e.mergedAppSegments||e.appSegments)}))}))}catch(e){return Promise.reject(e)}}},{key:"setupSegmentFinderArgs",value:function(e){var t=this;!0===e?(this.findAll=!0,this.wanted=O(W.keyList())):(e=void 0===e?W.keyList().filter((function(e){return t.options[e].enabled})):e.filter((function(e){return t.options[e].enabled&&W.has(e)})),this.findAll=!1,this.remaining=O(e),this.wanted=O(e)),this.unfinishedMultiSegment=!1}},{key:"findAppSegments",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;try{var n=this;n.setupSegmentFinderArgs(t);var r=n.file,i=n.findAll,a=n.wanted,s=n.remaining;return Ke((function(){if(!i&&n.file.chunked)return i=m(a).some((function(e){var t=W.get(e),r=n.options[e];return t.multiSegment&&r.multiSegment})),We((function(){if(i)return Me(n.file.readWhole())}))}),(function(){var t=!1;if(e=n.findAppSegmentsInRange(e,r.byteLength),!n.options.onlyTiff)return function(){if(r.chunked){var i=!1;return Ge((function(){return!t&&s.size>0&&!i&&(!!r.canReadNextChunk||!!n.unfinishedMultiSegment)}),void 0,(function(){var a=r.nextChunkOffset,s=n.appSegments.some((function(e){return!n.file.available(e.offset||e.start,e.length||e.size)}));return Ke((function(){return e>a&&!s?Re(r.readNextChunk(e),(function(e){i=!e})):Re(r.readNextChunk(a),(function(e){i=!e}))}),(function(){void 0===(e=n.findAppSegmentsInRange(e,r.byteLength))&&(t=!0)}))}))}}()}))}catch(e){return Promise.reject(e)}}},{key:"findAppSegmentsInRange",value:function(e,t){t-=2;for(var n,r,i,a,s,u,o=this.file,f=this.findAll,c=this.wanted,h=this.remaining,l=this.options;e<t;e++)if(255===o.getUint8(e))if(qe(n=o.getUint8(e+1))){if(r=o.getUint16(e+2),(i=Qe(o,e,r))&&c.has(i)&&(s=(a=W.get(i)).findPosition(o,e),u=l[i],s.type=i,this.appSegments.push(s),!f&&(a.multiSegment&&u.multiSegment?(this.unfinishedMultiSegment=s.chunkNumber<s.chunkCount,this.unfinishedMultiSegment||h.delete(i)):h.delete(i),0===h.size)))break;l.recordUnknownSegments&&((s=De.findPosition(o,e)).marker=n,this.unknownSegments.push(s)),e+=r+1}else if(Je(n)){if(r=o.getUint16(e+2),218===n&&!1!==l.stopAfterSos)return;l.recordJpegSegments&&this.jpegSegments.push({offset:e,length:r,marker:n}),e+=r+1}return e}},{key:"mergeMultiSegments",value:function(){var e=this;if(this.appSegments.some((function(e){return e.multiSegment}))){var t=function(e,t){for(var n,r,i,a=S(),s=0;s<e.length;s++)r=(n=e[s])[t],a.has(r)?i=a.get(r):a.set(r,i=[]),i.push(n);return m(a)}(this.appSegments,"type");this.mergedAppSegments=t.map((function(t){var n=t[0],r=t[1],i=W.get(n,e.options);return i.handleMultiSegments?{type:n,chunk:i.handleMultiSegments(r)}:r[0]}))}}},{key:"getSegment",value:function(e){return this.appSegments.find((function(t){return t.type===e}))}},{key:"getOrFindSegment",value:function(e){try{var t=this,n=t.getSegment(e);return Ke((function(){if(void 0===n)return Re(t.findAppSegments(0,[e]),(function(){n=t.getSegment(e)}))}),(function(){return n}))}catch(e){return Promise.reject(e)}}}],[{key:"canHandle",value:function(e,t){return 65496===t}}]),s}(Ee);function $e(){}i(Ze,"type","jpeg"),M.set("jpeg",Ze);function et(e,t){if(!t)return e&&e.then?e.then($e):Promise.resolve()}function tt(e,t){var n=e();return n&&n.then?n.then(t):t(n)}var nt=[void 0,1,1,2,4,8,1,1,2,4,8,4,8,4];var rt=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"parse",value:function(){try{var e=this;e.parseHeader();var t=e.options;return tt((function(){if(t.ifd0.enabled)return et(e.parseIfd0Block())}),(function(){return tt((function(){if(t.exif.enabled)return et(e.safeParse("parseExifBlock"))}),(function(){return tt((function(){if(t.gps.enabled)return et(e.safeParse("parseGpsBlock"))}),(function(){return tt((function(){if(t.interop.enabled)return et(e.safeParse("parseInteropBlock"))}),(function(){return tt((function(){if(t.ifd1.enabled)return et(e.safeParse("parseThumbnailBlock"))}),(function(){return e.createOutput()}))}))}))}))}))}catch(e){return Promise.reject(e)}}},{key:"safeParse",value:function(e){var t=this[e]();return void 0!==t.catch&&(t=t.catch(this.handleError)),t}},{key:"findIfd0Offset",value:function(){void 0===this.ifd0Offset&&(this.ifd0Offset=this.chunk.getUint32(4))}},{key:"findIfd1Offset",value:function(){if(void 0===this.ifd1Offset){this.findIfd0Offset();var e=this.chunk.getUint16(this.ifd0Offset),t=this.ifd0Offset+2+12*e;this.ifd1Offset=this.chunk.getUint32(t)}}},{key:"parseBlock",value:function(e,t){var n=S();return this[t]=n,this.parseTags(e,t,n),n}},{key:"parseIfd0Block",value:function(){try{var e=this;if(e.ifd0)return;var t=e.file;return e.findIfd0Offset(),e.ifd0Offset<8&&L("Malformed EXIF data"),!t.chunked&&e.ifd0Offset>t.byteLength&&L("IFD0 offset points to outside of file.\nthis.ifd0Offset: ".concat(e.ifd0Offset,", file.byteLength: ").concat(t.byteLength)),tt((function(){if(t.tiff)return et(t.ensureChunk(e.ifd0Offset,T(e.options)))}),(function(){var t=e.parseBlock(e.ifd0Offset,"ifd0");if(0!==t.size)return e.exifOffset=t.get(ce),e.interopOffset=t.get(le),e.gpsOffset=t.get(he),e.xmp=t.get(700),e.iptc=t.get(oe),e.icc=t.get(fe),e.options.sanitize&&(t.delete(ce),t.delete(le),t.delete(he),t.delete(700),t.delete(oe),t.delete(fe)),t}))}catch(e){return Promise.reject(e)}}},{key:"parseExifBlock",value:function(){try{var e=this;if(e.exif)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){if(void 0!==e.exifOffset)return tt((function(){if(e.file.tiff)return et(e.file.ensureChunk(e.exifOffset,T(e.options)))}),(function(){var t=e.parseBlock(e.exifOffset,"exif");return e.interopOffset||(e.interopOffset=t.get(le)),e.makerNote=t.get(se),e.userComment=t.get(ue),e.options.sanitize&&(t.delete(le),t.delete(se),t.delete(ue)),e.unpack(t,41728),e.unpack(t,41729),t}))}))}catch(e){return Promise.reject(e)}}},{key:"unpack",value:function(e,t){var n=e.get(t);n&&1===n.length&&e.set(t,n[0])}},{key:"parseGpsBlock",value:function(){try{var e=this;if(e.gps)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){if(void 0!==e.gpsOffset){var t=e.parseBlock(e.gpsOffset,"gps");return t&&t.has(2)&&t.has(4)&&(t.set("latitude",it.apply(void 0,t.get(2).concat([t.get(1)]))),t.set("longitude",it.apply(void 0,t.get(4).concat([t.get(3)])))),t}}))}catch(e){return Promise.reject(e)}}},{key:"parseInteropBlock",value:function(){try{var e=this;if(e.interop)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){return tt((function(){if(void 0===e.interopOffset&&!e.exif)return et(e.parseExifBlock())}),(function(){if(void 0!==e.interopOffset)return e.parseBlock(e.interopOffset,"interop")}))}))}catch(e){return Promise.reject(e)}}},{key:"parseThumbnailBlock",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];try{var t=this;if(t.ifd1||t.ifd1Parsed)return;if(t.options.mergeOutput&&!e)return;return t.findIfd1Offset(),t.ifd1Offset>0&&(t.parseBlock(t.ifd1Offset,"ifd1"),t.ifd1Parsed=!0),t.ifd1}catch(e){return Promise.reject(e)}}},{key:"extractThumbnail",value:function(){try{var e=this;return e.headerParsed||e.parseHeader(),tt((function(){if(!e.ifd1Parsed)return et(e.parseThumbnailBlock(!0))}),(function(){if(void 0!==e.ifd1){var t=e.ifd1.get(513),n=e.ifd1.get(514);return e.chunk.getUint8Array(t,n)}}))}catch(e){return Promise.reject(e)}}},{key:"image",get:function(){return this.ifd0}},{key:"thumbnail",get:function(){return this.ifd1}},{key:"createOutput",value:function(){var e,t,n,r={},i=ye;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)if(!I(e=this[t=i[a]]))if(n=this.canTranslate?this.translateBlock(e,t):k(e),this.options.mergeOutput){if("ifd1"===t)continue;g(r,n)}else r[t]=n;return this.makerNote&&(r.makerNote=this.makerNote),this.userComment&&(r.userComment=this.userComment),r}},{key:"assignToOutput",value:function(e,t){if(this.globalOptions.mergeOutput)g(e,t);else{var n=y(t);Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=i[0],s=i[1];this.assignObjectToOutput(e,a,s)}}}}],[{key:"canHandle",value:function(e,t){return 225===e.getUint8(t+1)&&1165519206===e.getUint32(t+4)&&0===e.getUint16(t+8)}}]),i}(function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"parseHeader",value:function(){var e=this.chunk.getUint16();18761===e?this.le=!0:19789===e&&(this.le=!1),this.chunk.le=this.le,this.headerParsed=!0}},{key:"parseTags",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:S(),r=this.options[t],i=r.pick,a=r.skip,s=(i=O(i)).size>0,u=0===a.size,o=this.chunk.getUint16(e);e+=2;for(var f=0;f<o;f++){var c=this.chunk.getUint16(e);if(s){if(i.has(c)&&(n.set(c,this.parseTag(e,c,t)),i.delete(c),0===i.size))break}else!u&&a.has(c)||n.set(c,this.parseTag(e,c,t));e+=12}return n}},{key:"parseTag",value:function(e,t,n){var r,i=this.chunk,a=i.getUint16(e+2),s=i.getUint32(e+4),u=nt[a];if(u*s<=4?e+=8:e=i.getUint32(e+8),(a<1||a>13)&&L("Invalid TIFF value type. block: ".concat(n.toUpperCase(),", tag: ").concat(t.toString(16),", type: ").concat(a,", offset ").concat(e)),e>i.byteLength&&L("Invalid TIFF value offset. block: ".concat(n.toUpperCase(),", tag: ").concat(t.toString(16),", type: ").concat(a,", offset ").concat(e," is outside of chunk size ").concat(i.byteLength)),1===a)return i.getUint8Array(e,s);if(2===a)return""===(r=function(e){for(;e.endsWith("\0");)e=e.slice(0,-1);return e}(r=i.getString(e,s)).trim())?void 0:r;if(7===a)return i.getUint8Array(e,s);if(1===s)return this.parseTagValue(a,e);for(var o=new(function(e){switch(e){case 1:return Uint8Array;case 3:return Uint16Array;case 4:return Uint32Array;case 5:return Array;case 6:return Int8Array;case 8:return Int16Array;case 9:return Int32Array;case 10:return Array;case 11:return Float32Array;case 12:return Float64Array;default:return Array}}(a))(s),f=u,c=0;c<s;c++)o[c]=this.parseTagValue(a,e),e+=f;return o}},{key:"parseTagValue",value:function(e,t){var n=this.chunk;switch(e){case 1:return n.getUint8(t);case 3:return n.getUint16(t);case 4:return n.getUint32(t);case 5:return n.getUint32(t)/n.getUint32(t+4);case 6:return n.getInt8(t);case 8:return n.getInt16(t);case 9:return n.getInt32(t);case 10:return n.getInt32(t)/n.getInt32(t+4);case 11:return n.getFloat(t);case 12:return n.getDouble(t);case 13:return n.getUint32(t);default:L("Invalid tiff type ".concat(e))}}}]),i}(De));function it(e,t,n,r){var i=e+t/60+n/3600;return"S"!==r&&"W"!==r||(i*=-1),i}i(rt,"type","tiff"),i(rt,"headerLength",10),W.set("tiff",rt);var at=Object.freeze({__proto__:null,default:ze,Exifr:Ie,fileParsers:M,segmentParsers:W,fileReaders:K,tagKeys:re,tagValues:ie,tagRevivers:ae,createDictionary:te,extendDictionary:ne,fetchUrlAsArrayBuffer:G,readBlobAsArrayBuffer:Y,chunkedProps:de,otherSegments:ve,segments:pe,tiffBlocks:ye,segmentsAndBlocks:ge,tiffExtractables:ke,inheritables:me,allFormatters:be,Options:Pe,parse:Te});function st(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}function ut(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}var ot=ut((function(e){var t=new Ie(vt);return st(t.read(e),(function(){return st(t.parse(),(function(e){if(e&&e.ifd0)return e.ifd0[274]}))}))})),ft=ut((function(e){var t=new Ie(dt);return st(t.read(e),(function(){return st(t.parse(),(function(e){if(e&&e.gps){var t=e.gps;return{latitude:t.latitude,longitude:t.longitude}}}))}))})),ct=ut((function(e){return st(this.thumbnail(e),(function(e){if(void 0!==e){var t=new Blob([e]);return URL.createObjectURL(t)}}))})),ht=ut((function(e){var t=new Ie(pt);return st(t.read(e),(function(){return st(t.extractThumbnail(),(function(e){return e&&_?j.from(e):e}))}))})),lt={ifd0:!1,ifd1:!1,exif:!1,gps:!1,interop:!1,sanitize:!1,reviveValues:!0,translateKeys:!1,translateValues:!1,mergeOutput:!1},dt=g({},lt,{firstChunkSize:4e4,gps:[1,2,3,4]}),vt=g({},lt,{firstChunkSize:4e4,ifd0:[274]}),pt=g({},lt,{tiff:!1,ifd1:!0,mergeOutput:!1}),yt=Object.freeze({1:{dimensionSwapped:!1,scaleX:1,scaleY:1,deg:0,rad:0},2:{dimensionSwapped:!1,scaleX:-1,scaleY:1,deg:0,rad:0},3:{dimensionSwapped:!1,scaleX:1,scaleY:1,deg:180,rad:180*Math.PI/180},4:{dimensionSwapped:!1,scaleX:-1,scaleY:1,deg:180,rad:180*Math.PI/180},5:{dimensionSwapped:!0,scaleX:1,scaleY:-1,deg:90,rad:90*Math.PI/180},6:{dimensionSwapped:!0,scaleX:1,scaleY:1,deg:90,rad:90*Math.PI/180},7:{dimensionSwapped:!0,scaleX:1,scaleY:-1,deg:270,rad:270*Math.PI/180},8:{dimensionSwapped:!0,scaleX:1,scaleY:1,deg:270,rad:270*Math.PI/180}});if(e.rotateCanvas=!0,e.rotateCss=!0,"object"==typeof navigator){var gt=navigator.userAgent;if(gt.includes("iPad")||gt.includes("iPhone")){var kt=gt.match(/OS (\d+)_(\d+)/);if(kt){var mt=kt[1],bt=kt[2],At=Number(mt)+.1*Number(bt);e.rotateCanvas=At<13.4,e.rotateCss=!1}}else if(gt.includes("OS X 10")){var wt=gt.match(/OS X 10[_.](\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(wt)<15}if(gt.includes("Chrome/")){var Ot=gt.match(/Chrome\/(\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(Ot)<81}else if(gt.includes("Firefox/")){var St=gt.match(/Firefox\/(\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(St)<77}}function Pt(){}var Ut=function(e){a(u,e);var n=d(u);function u(){var e;t(this,u);for(var r=arguments.length,a=new Array(r),s=0;s<r;s++)a[s]=arguments[s];return i(h(e=n.call.apply(n,[this].concat(a))),"ranges",new xt),0!==e.byteLength&&e.ranges.add(0,e.byteLength),e}return r(u,[{key:"_tryExtend",value:function(e,t,n){if(0===e&&0===this.byteLength&&n){var r=new DataView(n.buffer||n,n.byteOffset,n.byteLength);this._swapDataView(r)}else{var i=e+t;if(i>this.byteLength){var a=this._extend(i).dataView;this._swapDataView(a)}}}},{key:"_extend",value:function(e){var t;t=_?j.allocUnsafe(e):new Uint8Array(e);var n=new DataView(t.buffer,t.byteOffset,t.byteLength);return t.set(new Uint8Array(this.buffer,this.byteOffset,this.byteLength),0),{uintView:t,dataView:n}}},{key:"subarray",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t=t||this._lengthToEnd(e),n&&this._tryExtend(e,t),this.ranges.add(e,t),v(s(u.prototype),"subarray",this).call(this,e,t)}},{key:"set",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n&&this._tryExtend(t,e.byteLength,e);var r=v(s(u.prototype),"set",this).call(this,e,t);return this.ranges.add(t,r.byteLength),r}},{key:"ensureChunk",value:function(e,t){try{var n=this;if(!n.chunked)return;if(n.ranges.available(e,t))return;return function(e,t){if(!t)return e&&e.then?e.then(Pt):Promise.resolve()}(n.readChunk(e,t))}catch(e){return Promise.reject(e)}}},{key:"available",value:function(e,t){return this.ranges.available(e,t)}}]),u}(D),xt=function(){function e(){t(this,e),i(this,"list",[])}return r(e,[{key:"length",get:function(){return this.list.length}},{key:"add",value:function(e,t){var n=e+t,r=this.list.filter((function(t){return Ct(e,t.offset,n)||Ct(e,t.end,n)}));if(r.length>0){e=Math.min.apply(Math,[e].concat(r.map((function(e){return e.offset})))),t=(n=Math.max.apply(Math,[n].concat(r.map((function(e){return e.end})))))-e;var i=r.shift();i.offset=e,i.length=t,i.end=n,this.list=this.list.filter((function(e){return!r.includes(e)}))}else this.list.push({offset:e,length:t,end:n})}},{key:"available",value:function(e,t){var n=e+t;return this.list.some((function(t){return t.offset<=e&&n<=t.end}))}}]),e}();function Ct(e,t,n){return e<=t&&t<=n}function Bt(){}function jt(e,t){if(!t)return e&&e.then?e.then(Bt):Promise.resolve()}function _t(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var Vt=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"readWhole",value:function(){try{var e=this;return e.chunked=!1,_t(Y(e.input),(function(t){e._swapArrayBuffer(t)}))}catch(e){return Promise.reject(e)}}},{key:"readChunked",value:function(){return this.chunked=!0,this.size=this.input.size,v(s(i.prototype),"readChunked",this).call(this)}},{key:"_readChunk",value:function(e,t){try{var n=this,r=t?e+t:void 0,i=n.input.slice(e,r);return _t(Y(i),(function(t){return n.set(t,e,!0)}))}catch(e){return Promise.reject(e)}}}]),i}(function(e){a(s,e);var n=d(s);function s(e,r){var a;return t(this,s),i(h(a=n.call(this,0)),"chunksRead",0),a.input=e,a.options=r,a}return r(s,[{key:"readWhole",value:function(){try{var e=this;return e.chunked=!1,jt(e.readChunk(e.nextChunkOffset))}catch(e){return Promise.reject(e)}}},{key:"readChunked",value:function(){try{var e=this;return e.chunked=!0,jt(e.readChunk(0,e.options.firstChunkSize))}catch(e){return Promise.reject(e)}}},{key:"readNextChunk",value:function(e){try{var t=this;if(void 0===e&&(e=t.nextChunkOffset),t.fullyRead)return t.chunksRead++,!1;var n=t.options.chunkSize;return r=t.readChunk(e,n),i=function(e){return!!e&&e.byteLength===n},a?i?i(r):r:(r&&r.then||(r=Promise.resolve(r)),i?r.then(i):r)}catch(e){return Promise.reject(e)}var r,i,a}},{key:"readChunk",value:function(e,t){try{var n=this;if(n.chunksRead++,0===(t=n.safeWrapAddress(e,t)))return;return n._readChunk(e,t)}catch(e){return Promise.reject(e)}}},{key:"safeWrapAddress",value:function(e,t){return void 0!==this.size&&e+t>this.size?Math.max(0,this.size-e):t}},{key:"nextChunkOffset",get:function(){if(0!==this.ranges.list.length)return this.ranges.list[0].length}},{key:"canReadNextChunk",get:function(){return this.chunksRead<this.options.chunkLimit}},{key:"fullyRead",get:function(){return void 0!==this.size&&this.nextChunkOffset===this.size}},{key:"read",value:function(){return this.options.chunked?this.readChunked():this.readWhole()}},{key:"close",value:function(){}}]),s}(Ut));K.set("blob",Vt),e.Exifr=Ie,e.Options=Pe,e.allFormatters=be,e.chunkedProps=de,e.createDictionary=te,e.default=at,e.disableAllOptions=lt,e.extendDictionary=ne,e.fetchUrlAsArrayBuffer=G,e.fileParsers=M,e.fileReaders=K,e.gps=ft,e.gpsOnlyOptions=dt,e.inheritables=me,e.orientation=ot,e.orientationOnlyOptions=vt,e.otherSegments=ve,e.parse=Te,e.readBlobAsArrayBuffer=Y,e.rotation=function(t){return st(ot(t),(function(t){return g({canvas:e.rotateCanvas,css:e.rotateCss},yt[t])}))},e.rotations=yt,e.segmentParsers=W,e.segments=pe,e.segmentsAndBlocks=ge,e.tagKeys=re,e.tagRevivers=ae,e.tagValues=ie,e.thumbnail=ht,e.thumbnailOnlyOptions=pt,e.thumbnailUrl=ct,e.tiffBlocks=ye,e.tiffExtractables=ke,Object.defineProperty(e,"__esModule",{value:!0})}));

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":38,"buffer":9}],23:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = getFormData;
exports.getFieldData = getFieldData;
var NODE_LIST_CLASSES = {
  '[object HTMLCollection]': true,
  '[object NodeList]': true,
  '[object RadioNodeList]': true

  // .type values for elements which can appear in .elements and should be ignored
};var IGNORED_ELEMENT_TYPES = {
  'button': true,
  'fieldset': true,
  'reset': true,
  'submit': true
};

var CHECKED_INPUT_TYPES = {
  'checkbox': true,
  'radio': true
};

var TRIM_RE = /^\s+|\s+$/g;

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * @param {HTMLFormElement} form
 * @param {Object} options
 * @return {Object.<string,(string|Array.<string>)>} an object containing
 *   submittable value(s) held in the form's .elements collection, with
 *   properties named as per element names or ids.
 */

function getFormData(form) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { trim: false };

  if (!form) {
    throw new Error('A form is required by getFormData, was given form=' + form);
  }

  var data = {};
  var elementName = void 0;
  var elementNames = [];
  var elementNameLookup = {};

  // Get unique submittable element names for the form
  for (var i = 0, l = form.elements.length; i < l; i++) {
    var element = form.elements[i];
    if (IGNORED_ELEMENT_TYPES[element.type] || element.disabled) {
      continue;
    }
    elementName = element.name || element.id;
    if (elementName && !elementNameLookup[elementName]) {
      elementNames.push(elementName);
      elementNameLookup[elementName] = true;
    }
  }

  // Extract element data name-by-name for consistent handling of special cases
  // around elements which contain multiple inputs.
  for (var _i = 0, _l = elementNames.length; _i < _l; _i++) {
    elementName = elementNames[_i];
    var value = getFieldData(form, elementName, options);
    if (value != null) {
      data[elementName] = value;
    }
  }

  return data;
}

/**
 * @param {HTMLFormElement} form
 * @param {string} fieldName
 * @param {Object} options
 * @return {(string|Array.<string>)} submittable value(s) in the form for a
 *   named element from its .elements collection, or null if there was no
 *   element with that name or the element had no submittable value(s).
 */
function getFieldData(form, fieldName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { trim: false };

  if (!form) {
    throw new Error('A form is required by getFieldData, was given form=' + form);
  }
  if (!fieldName && toString.call(fieldName) !== '[object String]') {
    throw new Error('A field name is required by getFieldData, was given fieldName=' + fieldName);
  }

  var element = form.elements[fieldName];
  if (!element || element.disabled) {
    return null;
  }

  if (!NODE_LIST_CLASSES[toString.call(element)]) {
    return getFormElementValue(element, options.trim);
  }

  // Deal with multiple form controls which have the same name
  var data = [];
  var allRadios = true;
  for (var i = 0, l = element.length; i < l; i++) {
    if (element[i].disabled) {
      continue;
    }
    if (allRadios && element[i].type !== 'radio') {
      allRadios = false;
    }
    var value = getFormElementValue(element[i], options.trim);
    if (value != null) {
      data = data.concat(value);
    }
  }

  // Special case for an element with multiple same-named inputs which were all
  // radio buttons: if there was a selected value, only return the value.
  if (allRadios && data.length === 1) {
    return data[0];
  }

  return data.length > 0 ? data : null;
}

/**
 * @param {HTMLElement} element a form element.
 * @param {booleam} trim should values for text entry inputs be trimmed?
 * @return {(string|Array.<string>|File|Array.<File>)} the element's submittable
 *   value(s), or null if it had none.
 */
function getFormElementValue(element, trim) {
  var value = null;
  var type = element.type;


  if (type === 'select-one') {
    if (element.options.length) {
      value = element.options[element.selectedIndex].value;
    }
    return value;
  }

  if (type === 'select-multiple') {
    value = [];
    for (var i = 0, l = element.options.length; i < l; i++) {
      if (element.options[i].selected) {
        value.push(element.options[i].value);
      }
    }
    if (value.length === 0) {
      value = null;
    }
    return value;
  }

  // If a file input doesn't have a files attribute, fall through to using its
  // value attribute.
  if (type === 'file' && 'files' in element) {
    if (element.multiple) {
      value = slice.call(element.files);
      if (value.length === 0) {
        value = null;
      }
    } else {
      // Should be null if not present, according to the spec
      value = element.files[0];
    }
    return value;
  }

  if (!CHECKED_INPUT_TYPES[type]) {
    value = trim ? element.value.replace(TRIM_RE, '') : element.value;
  } else if (element.checked) {
    value = element.value;
  }

  return value;
}

// For UMD build access to getFieldData
getFormData.getFieldData = getFieldData;
},{}],24:[function(require,module,exports){
(function (Buffer){(function (){
/* global Blob File */

/*
 * Module requirements.
 */

var isArray = require('isarray');

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":9,"isarray":25}],25:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],26:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],27:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],28:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],29:[function(require,module,exports){
module.exports = function isShallowEqual (a, b) {
  if (a === b) return true
  for (var i in a) if (!(i in b)) return false
  for (var i in b) if (a[i] !== b[i]) return false
  return true
}

},{}],30:[function(require,module,exports){
(function (global){(function (){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.6.4";
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa && typeof global.btoa == 'function'
        ? function(b){ return global.btoa(b) } : function(b) {
        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
            'The string contains invalid characters.'
        );
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(String(u)));
    };
    var mkUriSafe = function (b64) {
        return b64.replace(/[+\/]/g, function(m0) {
            return m0 == '+' ? '-' : '_';
        }).replace(/=/g, '');
    };
    var encode = function(u, urisafe) {
        return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
    };
    var encodeURI = function(u) { return encode(u, true) };
    var fromUint8Array;
    if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
        // return btoa(fromCharCode.apply(null, a));
        var b64 = '';
        for (var i = 0, l = a.length; i < l; i += 3) {
            var a0 = a[i], a1 = a[i+1], a2 = a[i+2];
            var ord = a0 << 16 | a1 << 8 | a2;
            b64 +=    b64chars.charAt( ord >>> 18)
                +     b64chars.charAt((ord >>> 12) & 63)
                + ( typeof a1 != 'undefined'
                    ? b64chars.charAt((ord >>>  6) & 63) : '=')
                + ( typeof a2 != 'undefined'
                    ? b64chars.charAt( ord         & 63) : '=');
        }
        return urisafe ? mkUriSafe(b64) : b64;
    };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob && typeof global.atob == 'function'
        ? function(a){ return global.atob(a) } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = function(a) { return btou(_atob(a)) };
    var _fromURI = function(a) {
        return String(a).replace(/[-_]/g, function(m0) {
            return m0 == '-' ? '+' : '/'
        }).replace(/[^A-Za-z0-9\+\/]/g, '');
    };
    var decode = function(a){
        return _decode(_fromURI(a));
    };
    var toUint8Array;
    if (global.Uint8Array) toUint8Array = function(a) {
        return Uint8Array.from(atob(_fromURI(a)), function(c) {
            return c.charCodeAt(0);
        });
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],32:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = throttle;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],33:[function(require,module,exports){
'use strict';
module.exports = Math.log2 || function (x) {
	return Math.log(x) * Math.LOG2E;
};

},{}],34:[function(require,module,exports){
'use strict';

function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (newInputs[i] !== lastInputs[i]) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

module.exports = memoizeOne;

},{}],35:[function(require,module,exports){
var wildcard = require('wildcard');
var reMimePartSplit = /[\/\+\.]/;

/**
  # mime-match

  A simple function to checker whether a target mime type matches a mime-type
  pattern (e.g. image/jpeg matches image/jpeg OR image/*).

  ## Example Usage

  <<< example.js

**/
module.exports = function(target, pattern) {
  function test(pattern) {
    var result = wildcard(pattern, target, reMimePartSplit);

    // ensure that we have a valid mime type (should have two parts)
    return result && result.length >= 2;
  }

  return pattern ? test(pattern.split(';')[0]) : test;
};

},{"wildcard":61}],36:[function(require,module,exports){
/**
* Create an event emitter with namespaces
* @name createNamespaceEmitter
* @example
* var emitter = require('./index')()
*
* emitter.on('*', function () {
*   console.log('all events emitted', this.event)
* })
*
* emitter.on('example', function () {
*   console.log('example event emitted')
* })
*/
module.exports = function createNamespaceEmitter () {
  var emitter = {}
  var _fns = emitter._fns = {}

  /**
  * Emit an event. Optionally namespace the event. Handlers are fired in the order in which they were added with exact matches taking precedence. Separate the namespace and event with a `:`
  * @name emit
  * @param {String} event – the name of the event, with optional namespace
  * @param {...*} data – up to 6 arguments that are passed to the event listener
  * @example
  * emitter.emit('example')
  * emitter.emit('demo:test')
  * emitter.emit('data', { example: true}, 'a string', 1)
  */
  emitter.emit = function emit (event, arg1, arg2, arg3, arg4, arg5, arg6) {
    var toEmit = getListeners(event)

    if (toEmit.length) {
      emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6])
    }
  }

  /**
  * Create en event listener.
  * @name on
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.on('example', function () {})
  * emitter.on('demo', function () {})
  */
  emitter.on = function on (event, fn) {
    if (!_fns[event]) {
      _fns[event] = []
    }

    _fns[event].push(fn)
  }

  /**
  * Create en event listener that fires once.
  * @name once
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.once('example', function () {})
  * emitter.once('demo', function () {})
  */
  emitter.once = function once (event, fn) {
    function one () {
      fn.apply(this, arguments)
      emitter.off(event, one)
    }
    this.on(event, one)
  }

  /**
  * Stop listening to an event. Stop all listeners on an event by only passing the event name. Stop a single listener by passing that event handler as a callback.
  * You must be explicit about what will be unsubscribed: `emitter.off('demo')` will unsubscribe an `emitter.on('demo')` listener,
  * `emitter.off('demo:example')` will unsubscribe an `emitter.on('demo:example')` listener
  * @name off
  * @param {String} event
  * @param {Function} [fn] – the specific handler
  * @example
  * emitter.off('example')
  * emitter.off('demo', function () {})
  */
  emitter.off = function off (event, fn) {
    var keep = []

    if (event && fn) {
      var fns = this._fns[event]
      var i = 0
      var l = fns ? fns.length : 0

      for (i; i < l; i++) {
        if (fns[i] !== fn) {
          keep.push(fns[i])
        }
      }
    }

    keep.length ? this._fns[event] = keep : delete this._fns[event]
  }

  function getListeners (e) {
    var out = _fns[e] ? _fns[e] : []
    var idx = e.indexOf(':')
    var args = (idx === -1) ? [e] : [e.substring(0, idx), e.substring(idx + 1)]

    var keys = Object.keys(_fns)
    var i = 0
    var l = keys.length

    for (i; i < l; i++) {
      var key = keys[i]
      if (key === '*') {
        out = out.concat(_fns[key])
      }

      if (args.length === 2 && args[0] === key) {
        out = out.concat(_fns[key])
        break
      }
    }

    return out
  }

  function emitAll (e, fns, args) {
    var i = 0
    var l = fns.length

    for (i; i < l; i++) {
      if (!fns[i]) break
      fns[i].event = e
      fns[i].apply(fns[i], args)
    }
  }

  return emitter
}

},{}],37:[function(require,module,exports){
!function() {
    'use strict';
    function VNode() {}
    function h(nodeName, attributes) {
        var lastSimple, child, simple, i, children = EMPTY_CHILDREN;
        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);
        if (attributes && null != attributes.children) {
            if (!stack.length) stack.push(attributes.children);
            delete attributes.children;
        }
        while (stack.length) if ((child = stack.pop()) && void 0 !== child.pop) for (i = child.length; i--; ) stack.push(child[i]); else {
            if ('boolean' == typeof child) child = null;
            if (simple = 'function' != typeof nodeName) if (null == child) child = ''; else if ('number' == typeof child) child = String(child); else if ('string' != typeof child) simple = !1;
            if (simple && lastSimple) children[children.length - 1] += child; else if (children === EMPTY_CHILDREN) children = [ child ]; else children.push(child);
            lastSimple = simple;
        }
        var p = new VNode();
        p.nodeName = nodeName;
        p.children = children;
        p.attributes = null == attributes ? void 0 : attributes;
        p.key = null == attributes ? void 0 : attributes.key;
        if (void 0 !== options.vnode) options.vnode(p);
        return p;
    }
    function extend(obj, props) {
        for (var i in props) obj[i] = props[i];
        return obj;
    }
    function cloneElement(vnode, props) {
        return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
    }
    function enqueueRender(component) {
        if (!component.__d && (component.__d = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);
    }
    function rerender() {
        var p, list = items;
        items = [];
        while (p = list.pop()) if (p.__d) renderComponent(p);
    }
    function isSameNodeType(node, vnode, hydrating) {
        if ('string' == typeof vnode || 'number' == typeof vnode) return void 0 !== node.splitText;
        if ('string' == typeof vnode.nodeName) return !node._componentConstructor && isNamedNode(node, vnode.nodeName); else return hydrating || node._componentConstructor === vnode.nodeName;
    }
    function isNamedNode(node, nodeName) {
        return node.__n === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
    }
    function getNodeProps(vnode) {
        var props = extend({}, vnode.attributes);
        props.children = vnode.children;
        var defaultProps = vnode.nodeName.defaultProps;
        if (void 0 !== defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];
        return props;
    }
    function createNode(nodeName, isSvg) {
        var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
        node.__n = nodeName;
        return node;
    }
    function removeNode(node) {
        var parentNode = node.parentNode;
        if (parentNode) parentNode.removeChild(node);
    }
    function setAccessor(node, name, old, value, isSvg) {
        if ('className' === name) name = 'class';
        if ('key' === name) ; else if ('ref' === name) {
            if (old) old(null);
            if (value) value(node);
        } else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {
            if (!value || 'string' == typeof value || 'string' == typeof old) node.style.cssText = value || '';
            if (value && 'object' == typeof value) {
                if ('string' != typeof old) for (var i in old) if (!(i in value)) node.style[i] = '';
                for (var i in value) node.style[i] = 'number' == typeof value[i] && !1 === IS_NON_DIMENSIONAL.test(i) ? value[i] + 'px' : value[i];
            }
        } else if ('dangerouslySetInnerHTML' === name) {
            if (value) node.innerHTML = value.__html || '';
        } else if ('o' == name[0] && 'n' == name[1]) {
            var useCapture = name !== (name = name.replace(/Capture$/, ''));
            name = name.toLowerCase().substring(2);
            if (value) {
                if (!old) node.addEventListener(name, eventProxy, useCapture);
            } else node.removeEventListener(name, eventProxy, useCapture);
            (node.__l || (node.__l = {}))[name] = value;
        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {
            setProperty(node, name, null == value ? '' : value);
            if (null == value || !1 === value) node.removeAttribute(name);
        } else {
            var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));
            if (null == value || !1 === value) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase()); else node.removeAttribute(name); else if ('function' != typeof value) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value); else node.setAttribute(name, value);
        }
    }
    function setProperty(node, name, value) {
        try {
            node[name] = value;
        } catch (e) {}
    }
    function eventProxy(e) {
        return this.__l[e.type](options.event && options.event(e) || e);
    }
    function flushMounts() {
        var c;
        while (c = mounts.pop()) {
            if (options.afterMount) options.afterMount(c);
            if (c.componentDidMount) c.componentDidMount();
        }
    }
    function diff(dom, vnode, context, mountAll, parent, componentRoot) {
        if (!diffLevel++) {
            isSvgMode = null != parent && void 0 !== parent.ownerSVGElement;
            hydrating = null != dom && !('__preactattr_' in dom);
        }
        var ret = idiff(dom, vnode, context, mountAll, componentRoot);
        if (parent && ret.parentNode !== parent) parent.appendChild(ret);
        if (!--diffLevel) {
            hydrating = !1;
            if (!componentRoot) flushMounts();
        }
        return ret;
    }
    function idiff(dom, vnode, context, mountAll, componentRoot) {
        var out = dom, prevSvgMode = isSvgMode;
        if (null == vnode || 'boolean' == typeof vnode) vnode = '';
        if ('string' == typeof vnode || 'number' == typeof vnode) {
            if (dom && void 0 !== dom.splitText && dom.parentNode && (!dom._component || componentRoot)) {
                if (dom.nodeValue != vnode) dom.nodeValue = vnode;
            } else {
                out = document.createTextNode(vnode);
                if (dom) {
                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                    recollectNodeTree(dom, !0);
                }
            }
            out.__preactattr_ = !0;
            return out;
        }
        var vnodeName = vnode.nodeName;
        if ('function' == typeof vnodeName) return buildComponentFromVNode(dom, vnode, context, mountAll);
        isSvgMode = 'svg' === vnodeName ? !0 : 'foreignObject' === vnodeName ? !1 : isSvgMode;
        vnodeName = String(vnodeName);
        if (!dom || !isNamedNode(dom, vnodeName)) {
            out = createNode(vnodeName, isSvgMode);
            if (dom) {
                while (dom.firstChild) out.appendChild(dom.firstChild);
                if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                recollectNodeTree(dom, !0);
            }
        }
        var fc = out.firstChild, props = out.__preactattr_, vchildren = vnode.children;
        if (null == props) {
            props = out.__preactattr_ = {};
            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;
        }
        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && null != fc && void 0 !== fc.splitText && null == fc.nextSibling) {
            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];
        } else if (vchildren && vchildren.length || null != fc) innerDiffNode(out, vchildren, context, mountAll, hydrating || null != props.dangerouslySetInnerHTML);
        diffAttributes(out, vnode.attributes, props);
        isSvgMode = prevSvgMode;
        return out;
    }
    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
        var j, c, f, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0;
        if (0 !== len) for (var i = 0; i < len; i++) {
            var _child = originalChildren[i], props = _child.__preactattr_, key = vlen && props ? _child._component ? _child._component.__k : props.key : null;
            if (null != key) {
                keyedLen++;
                keyed[key] = _child;
            } else if (props || (void 0 !== _child.splitText ? isHydrating ? _child.nodeValue.trim() : !0 : isHydrating)) children[childrenLen++] = _child;
        }
        if (0 !== vlen) for (var i = 0; i < vlen; i++) {
            vchild = vchildren[i];
            child = null;
            var key = vchild.key;
            if (null != key) {
                if (keyedLen && void 0 !== keyed[key]) {
                    child = keyed[key];
                    keyed[key] = void 0;
                    keyedLen--;
                }
            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) if (void 0 !== children[j] && isSameNodeType(c = children[j], vchild, isHydrating)) {
                child = c;
                children[j] = void 0;
                if (j === childrenLen - 1) childrenLen--;
                if (j === min) min++;
                break;
            }
            child = idiff(child, vchild, context, mountAll);
            f = originalChildren[i];
            if (child && child !== dom && child !== f) if (null == f) dom.appendChild(child); else if (child === f.nextSibling) removeNode(f); else dom.insertBefore(child, f);
        }
        if (keyedLen) for (var i in keyed) if (void 0 !== keyed[i]) recollectNodeTree(keyed[i], !1);
        while (min <= childrenLen) if (void 0 !== (child = children[childrenLen--])) recollectNodeTree(child, !1);
    }
    function recollectNodeTree(node, unmountOnly) {
        var component = node._component;
        if (component) unmountComponent(component); else {
            if (null != node.__preactattr_ && node.__preactattr_.ref) node.__preactattr_.ref(null);
            if (!1 === unmountOnly || null == node.__preactattr_) removeNode(node);
            removeChildren(node);
        }
    }
    function removeChildren(node) {
        node = node.lastChild;
        while (node) {
            var next = node.previousSibling;
            recollectNodeTree(node, !0);
            node = next;
        }
    }
    function diffAttributes(dom, attrs, old) {
        var name;
        for (name in old) if ((!attrs || null == attrs[name]) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);
        for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
    }
    function collectComponent(component) {
        var name = component.constructor.name;
        (components[name] || (components[name] = [])).push(component);
    }
    function createComponent(Ctor, props, context) {
        var inst, list = components[Ctor.name];
        if (Ctor.prototype && Ctor.prototype.render) {
            inst = new Ctor(props, context);
            Component.call(inst, props, context);
        } else {
            inst = new Component(props, context);
            inst.constructor = Ctor;
            inst.render = doRender;
        }
        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {
            inst.__b = list[i].__b;
            list.splice(i, 1);
            break;
        }
        return inst;
    }
    function doRender(props, state, context) {
        return this.constructor(props, context);
    }
    function setComponentProps(component, props, opts, context, mountAll) {
        if (!component.__x) {
            component.__x = !0;
            if (component.__r = props.ref) delete props.ref;
            if (component.__k = props.key) delete props.key;
            if (!component.base || mountAll) {
                if (component.componentWillMount) component.componentWillMount();
            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);
            if (context && context !== component.context) {
                if (!component.__c) component.__c = component.context;
                component.context = context;
            }
            if (!component.__p) component.__p = component.props;
            component.props = props;
            component.__x = !1;
            if (0 !== opts) if (1 === opts || !1 !== options.syncComponentUpdates || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);
            if (component.__r) component.__r(component);
        }
    }
    function renderComponent(component, opts, mountAll, isChild) {
        if (!component.__x) {
            var rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.__p || props, previousState = component.__s || state, previousContext = component.__c || context, isUpdate = component.base, nextBase = component.__b, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = !1;
            if (isUpdate) {
                component.props = previousProps;
                component.state = previousState;
                component.context = previousContext;
                if (2 !== opts && component.shouldComponentUpdate && !1 === component.shouldComponentUpdate(props, state, context)) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);
                component.props = props;
                component.state = state;
                component.context = context;
            }
            component.__p = component.__s = component.__c = component.__b = null;
            component.__d = !1;
            if (!skip) {
                rendered = component.render(props, state, context);
                if (component.getChildContext) context = extend(extend({}, context), component.getChildContext());
                var toUnmount, base, childComponent = rendered && rendered.nodeName;
                if ('function' == typeof childComponent) {
                    var childProps = getNodeProps(rendered);
                    inst = initialChildComponent;
                    if (inst && inst.constructor === childComponent && childProps.key == inst.__k) setComponentProps(inst, childProps, 1, context, !1); else {
                        toUnmount = inst;
                        component._component = inst = createComponent(childComponent, childProps, context);
                        inst.__b = inst.__b || nextBase;
                        inst.__u = component;
                        setComponentProps(inst, childProps, 0, context, !1);
                        renderComponent(inst, 1, mountAll, !0);
                    }
                    base = inst.base;
                } else {
                    cbase = initialBase;
                    toUnmount = initialChildComponent;
                    if (toUnmount) cbase = component._component = null;
                    if (initialBase || 1 === opts) {
                        if (cbase) cbase._component = null;
                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);
                    }
                }
                if (initialBase && base !== initialBase && inst !== initialChildComponent) {
                    var baseParent = initialBase.parentNode;
                    if (baseParent && base !== baseParent) {
                        baseParent.replaceChild(base, initialBase);
                        if (!toUnmount) {
                            initialBase._component = null;
                            recollectNodeTree(initialBase, !1);
                        }
                    }
                }
                if (toUnmount) unmountComponent(toUnmount);
                component.base = base;
                if (base && !isChild) {
                    var componentRef = component, t = component;
                    while (t = t.__u) (componentRef = t).base = base;
                    base._component = componentRef;
                    base._componentConstructor = componentRef.constructor;
                }
            }
            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {
                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);
                if (options.afterUpdate) options.afterUpdate(component);
            }
            if (null != component.__h) while (component.__h.length) component.__h.pop().call(component);
            if (!diffLevel && !isChild) flushMounts();
        }
    }
    function buildComponentFromVNode(dom, vnode, context, mountAll) {
        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);
        while (c && !isOwner && (c = c.__u)) isOwner = c.constructor === vnode.nodeName;
        if (c && isOwner && (!mountAll || c._component)) {
            setComponentProps(c, props, 3, context, mountAll);
            dom = c.base;
        } else {
            if (originalComponent && !isDirectOwner) {
                unmountComponent(originalComponent);
                dom = oldDom = null;
            }
            c = createComponent(vnode.nodeName, props, context);
            if (dom && !c.__b) {
                c.__b = dom;
                oldDom = null;
            }
            setComponentProps(c, props, 1, context, mountAll);
            dom = c.base;
            if (oldDom && dom !== oldDom) {
                oldDom._component = null;
                recollectNodeTree(oldDom, !1);
            }
        }
        return dom;
    }
    function unmountComponent(component) {
        if (options.beforeUnmount) options.beforeUnmount(component);
        var base = component.base;
        component.__x = !0;
        if (component.componentWillUnmount) component.componentWillUnmount();
        component.base = null;
        var inner = component._component;
        if (inner) unmountComponent(inner); else if (base) {
            if (base.__preactattr_ && base.__preactattr_.ref) base.__preactattr_.ref(null);
            component.__b = base;
            removeNode(base);
            collectComponent(component);
            removeChildren(base);
        }
        if (component.__r) component.__r(null);
    }
    function Component(props, context) {
        this.__d = !0;
        this.context = context;
        this.props = props;
        this.state = this.state || {};
    }
    function render(vnode, parent, merge) {
        return diff(merge, vnode, {}, !1, parent, !1);
    }
    var options = {};
    var stack = [];
    var EMPTY_CHILDREN = [];
    var defer = 'function' == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
    var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    var items = [];
    var mounts = [];
    var diffLevel = 0;
    var isSvgMode = !1;
    var hydrating = !1;
    var components = {};
    extend(Component.prototype, {
        setState: function(state, callback) {
            var s = this.state;
            if (!this.__s) this.__s = extend({}, s);
            extend(s, 'function' == typeof state ? state(s, this.props) : state);
            if (callback) (this.__h = this.__h || []).push(callback);
            enqueueRender(this);
        },
        forceUpdate: function(callback) {
            if (callback) (this.__h = this.__h || []).push(callback);
            renderComponent(this, 2);
        },
        render: function() {}
    });
    var preact = {
        h: h,
        createElement: h,
        cloneElement: cloneElement,
        Component: Component,
        render: render,
        rerender: rerender,
        options: options
    };
    if ('undefined' != typeof module) module.exports = preact; else self.preact = preact;
}();

},{}],38:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],39:[function(require,module,exports){
var has = Object.prototype.hasOwnProperty

/**
 * Stringify an object for use in a query string.
 *
 * @param {Object} obj - The object.
 * @param {string} prefix - When nesting, the parent key.
 *     keys in `obj` will be stringified as `prefix[key]`.
 * @returns {string}
 */

module.exports = function queryStringify (obj, prefix) {
  var pairs = []
  for (var key in obj) {
    if (!has.call(obj, key)) {
      continue
    }

    var value = obj[key]
    var enkey = encodeURIComponent(key)
    var pair
    if (typeof value === 'object') {
      pair = queryStringify(value, prefix ? prefix + '[' + enkey + ']' : enkey)
    } else {
      pair = (prefix ? prefix + '[' + enkey + ']' : enkey) + '=' + encodeURIComponent(value)
    }
    pairs.push(pair)
  }
  return pairs.join('&')
}

},{}],40:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],41:[function(require,module,exports){
(function (global){(function (){
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],42:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],43:[function(require,module,exports){
(function (global){(function (){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ResizeObserver = factory());
}(this, (function () { 'use strict';

    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    var MapShim = (function () {
        if (typeof Map !== 'undefined') {
            return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */
        function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
                if (entry[0] === key) {
                    result = index;
                    return true;
                }
                return false;
            });
            return result;
        }
        return /** @class */ (function () {
            function class_1() {
                this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                    return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */
            class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */
            class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                    this.__entries__[index][1] = value;
                }
                else {
                    this.__entries__.push([key, value]);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                    entries.splice(index, 1);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */
            class_1.prototype.clear = function () {
                this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */
            class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) { ctx = null; }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    callback.call(ctx, entry[1], entry[0]);
                }
            };
            return class_1;
        }());
    })();

    /**
     * Detects whether window and document objects are available in current environment.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

    // Returns global object of a current environment.
    var global$1 = (function () {
        if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
        }
        if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
        }
        if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
        }
        // eslint-disable-next-line no-new-func
        return Function('return this')();
    })();

    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */
    var requestAnimationFrame$1 = (function () {
        if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
        }
        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
    })();

    // Defines minimum timeout before adding a trailing call.
    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */
    function throttle (callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */
        function resolvePending() {
            if (leadingCall) {
                leadingCall = false;
                callback();
            }
            if (trailingCall) {
                proxy();
            }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */
        function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */
        function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
                // Reject immediately following calls.
                if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                }
                // Schedule new call to be in invoked when the pending one is resolved.
                // This is important for "transitions" which never actually start
                // immediately so there is a chance that we might miss one if change
                // happens amids the pending invocation.
                trailingCall = true;
            }
            else {
                leadingCall = true;
                trailingCall = false;
                setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
        }
        return proxy;
    }

    // Minimum delay before invoking the update of observers.
    var REFRESH_DELAY = 20;
    // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.
    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
    // Check if MutationObserver is available.
    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */
    var ResizeObserverController = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */
        ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
                this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
                this.connect_();
            }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */
        ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
                observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
                this.disconnect_();
            }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */
        ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
                this.refresh();
            }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */
        ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
                return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
            return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
                return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
                this.mutationsObserver_ = new MutationObserver(this.refresh);
                this.mutationsObserver_.observe(document, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
            else {
                document.addEventListener('DOMSubtreeModified', this.refresh);
                this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
                return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
                this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
                document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */
        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
                return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
                this.refresh();
            }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */
        ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
                this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */
        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
    }());

    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */
    var defineConfigurable = (function (target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
                value: props[key],
                enumerable: false,
                writable: false,
                configurable: true
            });
        }
        return target;
    });

    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */
    var getWindowOf = (function (target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        // Return the local global object if it's not possible extract one from
        // provided element.
        return ownerGlobal || global$1;
    });

    // Placeholder of an empty content rectangle.
    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */
    function toFloat(value) {
        return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */
    function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
        }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */
    function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
        }
        return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */
    function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */
    function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.
        if (!clientWidth && !clientHeight) {
            return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.
        var width = toFloat(styles.width), height = toFloat(styles.height);
        // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).
        if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
                width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
        }
        // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.
        if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
                width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
                height -= horizScrollbar;
            }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    var isSVGGraphicsElement = (function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
        }
        // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens
        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
            typeof target.getBBox === 'function'); };
    })();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */
    function getContentRect(target) {
        if (!isBrowser) {
            return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */
    function createReadOnlyRect(_a) {
        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        // If DOMRectReadOnly is available use it as a prototype for the rectangle.
        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        // Rectangle's properties are not writable and non-enumerable.
        defineConfigurable(rect, {
            x: x, y: y, width: width, height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
        });
        return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */
    function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
    }

    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */
    var ResizeObservation = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */
        ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth ||
                rect.height !== this.broadcastHeight);
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */
        ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
        };
        return ResizeObservation;
    }());

    var ResizeObserverEntry = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target: target, contentRect: contentRect });
        }
        return ResizeObserverEntry;
    }());

    var ResizeObserverSPI = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
                throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
                return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
                return;
            }
            observations.delete(target);
            if (!observations.size) {
                this.controller_.removeObserver(this);
            }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
                if (observation.isActive()) {
                    _this.activeObservations_.push(observation);
                }
            });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
                return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
                return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */
        ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI;
    }());

    // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.
    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */
    var ResizeObserver = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
                throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
        }
        return ResizeObserver;
    }());
    // Expose public methods of ResizeObserver.
    [
        'observe',
        'unobserve',
        'disconnect'
    ].forEach(function (method) {
        ResizeObserver.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
        };
    });

    var index = (function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
        }
        return ResizeObserver;
    })();

    return index;

})));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runParallel

const queueMicrotask = require('queue-microtask')

function runParallel (tasks, cb) {
  let results, pending, keys
  let isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) queueMicrotask(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}

},{"queue-microtask":41}],45:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova.default)()) {
        return (0, _readAsByteArray.default)(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader, chunkSize) {
    _classCallCheck(this, StreamSource);

    this._chunkSize = chunkSize;
    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error("Unknown data type");
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative.default)() && input && typeof input.uri !== "undefined") {
        return (0, _uriToBlob.default)(input.uri).then(function (blob) {
          return new FileSource(blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. " + err);
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === "function" && typeof input.size !== "undefined") {
        return Promise.resolve(new FileSource(input));
      }

      if (typeof input.read === "function") {
        chunkSize = +chunkSize;

        if (!isFinite(chunkSize)) {
          return Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option"));
        }

        return Promise.resolve(new StreamSource(input, chunkSize));
      }

      return Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment"));
    }
  }]);

  return FileReader;
}();

exports.default = FileReader;
},{"./isCordova":50,"./isReactNative":51,"./readAsByteArray":52,"./uriToBlob":53}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */
function fingerprint(file, options) {
  if ((0, _isReactNative.default)()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(["tus-br", file.name, file.type, file.size, file.lastModified, options.endpoint].join("-"));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : "noexif";
  return ["tus-rn", file.name || "noname", file.size || "nosize", exifHash, options.endpoint].join("/");
}

function hashCode(str) {
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return hash;
}
},{"./isReactNative":51}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return "XHRHttpStack";
    }
  }]);

  return XHRHttpStack;
}();

exports.default = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!("upload" in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();
},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function () {
    return _logger.enableDebugLog;
  }
});
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function () {
    return _urlStorage.canStoreURLs;
  }
});
exports.isSupported = exports.defaultOptions = exports.Upload = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/* global window */


var defaultOptions = _objectSpread({}, _upload.default.defaultOptions, {
  httpStack: new _httpStack.default(),
  fileReader: new _fileReader.default(),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage.default(),
  fingerprint: _fingerprint.default
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread({}, defaultOptions, {}, options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      options = _objectSpread({}, defaultOptions, {}, options);
      return _upload.default.terminate(url, options, cb);
    }
  }]);

  return Upload;
}(_upload.default);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === "function";
exports.isSupported = isSupported;
},{"../logger":56,"../noopUrlStorage":57,"../upload":58,"./fileReader":46,"./fingerprint":47,"./httpStack":48,"./urlStorage":54}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isCordova = function isCordova() {
  return typeof window != "undefined" && (typeof window.PhoneGap != "undefined" || typeof window.Cordova != "undefined" || typeof window.cordova != "undefined");
};

var _default = isCordova;
exports.default = _default;
},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
};

var _default = isReactNative;
exports.default = _default;
},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = readAsByteArray;

/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */
function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}
},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uriToBlob;

/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */
function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = "blob";

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open("GET", uri);
    xhr.send();
  });
}
},{}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebStorageUrlStorage = exports.canStoreURLs = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window, localStorage */


var hasStorage = false;

try {
  hasStorage = "localStorage" in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = "tusSupport";
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries("tus::");

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;
},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader("X-Request-ID") || "n/a";
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : "n/a";
      var body = res ? res.getBody() || "" : "n/a";
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return DetailedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports.default = _default;
},{}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;

/* eslint no-console: "off" */
var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}
},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports.default = NoopUrlStorage;
},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _error = _interopRequireDefault(require("./error"));

var _uuid = _interopRequireDefault(require("./uuid"));

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _logger = require("./logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ("resume" in options) {
      console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead."); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error("tus: no file or stream to upload provided"));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== "[object Array]") {
        this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        ["uploadUrl", "uploadSize", "uploadLengthDeferred"].forEach(function (optionName) {
          if (_this2.options[optionName]) {
            _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
          }
        });
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.");
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        } else {
          return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
        }
      }).then(function (source) {
        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.

        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this3 = this;

      var totalSize = this._size = this._source.size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs

      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective
      // upload is completed.

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread({}, _this3.options, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread({}, _this3.options.headers, {
                "Upload-Concat": "partial"
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;

                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return !!u;
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options);
            upload.start(); // Store the upload in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest("POST", _this3.options.endpoint);
        req.setHeader("Upload-Concat", "final;".concat(_this3._parallelUploadUrls.join(" "))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== "") {
          req.setHeader("Upload-Metadata", metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this3._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = +this.options.uploadSize;

        if (isNaN(this._size)) {
          this._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));

          return;
        }
      } else {
        this._size = this._source.size;

        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option"));

          return;
        }
      } // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.


      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.url));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)("Creating a new upload");

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate, cb) {
      var _this4 = this;

      if (typeof cb === "function") {
        throw new Error("tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead");
      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort();

        this._source.close();
      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error.default(message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === "function") {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === "function") {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === "function") {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === "function") {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));

        return;
      }

      var req = this._openRequest("POST", this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader("Upload-Defer-Length", 1);
      } else {
        req.setHeader("Upload-Length", this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== "") {
        req.setHeader("Upload-Metadata", metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this6._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this6.url = resolveUrl(_this6.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === "function") {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess();

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage();

        if (_this6.options.uploadDataDuringCreation) {
          _this6._handleUploadResponse(req, res);
        } else {
          _this6._offset = 0;

          _this6._performUpload();
        }
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, "tus: failed to create upload", err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest("HEAD", this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          } // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.


          if (status === 423) {
            _this7._emitHttpError(req, res, "tus: upload is currently locked; retry later");

            return;
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, "tus: unable to resume upload (new upload cannot be created without an endpoint)");

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader("Upload-Offset"), 10);

        if (isNaN(offset)) {
          _this7._emitHttpError(req, res, "tus: invalid or missing offset value");

          return;
        }

        var length = parseInt(res.getHeader("Upload-Length"), 10);

        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, "tus: invalid or missing length value");

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === "function") {
          _this7.options._onUploadUrlAvailable();
        } // Upload has already been completed and we do not need to send additional
        // data to the server


        if (offset === length) {
          _this7._emitProgress(length, length);

          _this7._emitSuccess();

          return;
        }

        _this7._offset = offset;

        _this7._performUpload();
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, "tus: failed to resume upload", err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest("POST", this.url);
        req.setHeader("X-HTTP-Method-Override", "PATCH");
      } else {
        req = this._openRequest("PATCH", this.url);
      }

      req.setHeader("Upload-Offset", this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, "tus: unexpected response while uploading chunk");

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset " + _this8._offset, err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader("Content-Type", "application/offset+octet-stream"); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader("Upload-Length", _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        } else {
          _this9._emitProgress(_this9._offset, _this9._size);

          return _this9._sendRequest(req, value);
        }
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader("Upload-Offset"), 10);

      if (isNaN(offset)) {
        this._emitHttpError(req, res, "tus: invalid or missing offset value");

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset == this._size) {
        // Yay, finally done :)
        this._emitSuccess();

        this._source.close();

        return;
      }

      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this10._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.


      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {
        return;
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        return _this11._urlStorageKey = urlStorageKey;
      })["catch"](function (err) {
        _this11._emitError(err);
      });
    }
    /**
     * Send a request with the provided body while invoking the onBeforeRequest
     * and onAfterResponse callbacks.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var _this12 = this;

      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (typeof this.options.onBeforeRequest === "function") {
        this.options.onBeforeRequest(req);
      }

      return req.send(body).then(function (res) {
        if (typeof _this12.options.onAfterResponse === "function") {
          _this12.options.onAfterResponse(req, res);
        }

        return res;
      });
    }
  }], [{
    key: "terminate",
    value: function terminate(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 ? arguments[2] : undefined;

      if (typeof options === "function" || typeof cb === "function") {
        throw new Error("tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead");
      }

      var req = openRequest("DELETE", url, options);
      var promise = req.send();
      return promise.then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error.default("tus: unexpected response while terminating upload", null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error.default)) {
          err = new _error.default("tus: failed to terminate upload", err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread({}, options, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  var encoded = [];

  for (var key in metadata) {
    encoded.push(key + " " + _jsBase.Base64.encode(metadata[key]));
  }

  return encoded.join(",");
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader("Tus-Resumable", "1.0.0");
  var headers = options.headers || {};

  for (var name in headers) {
    req.setHeader(name, headers[name]);
  }

  if (options.addRequestId) {
    var requestId = (0, _uuid.default)();
    req.setHeader("X-Request-ID", requestId);
  }

  return req;
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== "undefined" && "navigator" in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. no a status 4xx or a 409 or 423) and
  // - the browser does not indicate that we are offline
  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;
  return options.retryDelays != null && retryAttempt < options.retryDelays.length && err.originalRequest != null && isServerError && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse.default(link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @param {string[]} previousUrls The upload URLs for previous parts.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount, previousUrls) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.

  if (previousUrls) {
    parts.forEach(function (part, index) {
      part.uploadUrl = previousUrls[index] || null;
    });
  }

  return parts;
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports.default = _default;
},{"./error":55,"./logger":56,"./uuid":59,"js-base64":30,"url-parse":60}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uuid;

/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
},{}],60:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);

  var match = protocolre.exec(address)
    , protocol = match[1] ? match[1].toLowerCase() : ''
    , slashes = !!(match[2] && match[2].length >= 2)
    , rest =  match[2] && match[2].length === 1 ? '/' + match[3] : match[3];

  return {
    protocol: protocol,
    slashes: slashes,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && url.hostname) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":40,"requires-port":42}],61:[function(require,module,exports){
/* jshint node: true */
'use strict';

/**
  # wildcard

  Very simple wildcard matching, which is designed to provide the same
  functionality that is found in the
  [eve](https://github.com/adobe-webplatform/eve) eventing library.

  ## Usage

  It works with strings:

  <<< examples/strings.js

  Arrays:

  <<< examples/arrays.js

  Objects (matching against keys):

  <<< examples/objects.js

  While the library works in Node, if you are are looking for file-based
  wildcard matching then you should have a look at:

  <https://github.com/isaacs/node-glob>
**/

function WildcardMatcher(text, separator) {
  this.text = text = text || '';
  this.hasWild = ~text.indexOf('*');
  this.separator = separator;
  this.parts = text.split(separator);
}

WildcardMatcher.prototype.match = function(input) {
  var matches = true;
  var parts = this.parts;
  var ii;
  var partsCount = parts.length;
  var testParts;

  if (typeof input == 'string' || input instanceof String) {
    if (!this.hasWild && this.text != input) {
      matches = false;
    } else {
      testParts = (input || '').split(this.separator);
      for (ii = 0; matches && ii < partsCount; ii++) {
        if (parts[ii] === '*')  {
          continue;
        } else if (ii < testParts.length) {
          matches = parts[ii] === testParts[ii];
        } else {
          matches = false;
        }
      }

      // If matches, then return the component parts
      matches = matches && testParts;
    }
  }
  else if (typeof input.splice == 'function') {
    matches = [];

    for (ii = input.length; ii--; ) {
      if (this.match(input[ii])) {
        matches[matches.length] = input[ii];
      }
    }
  }
  else if (typeof input == 'object') {
    matches = {};

    for (var key in input) {
      if (this.match(key)) {
        matches[key] = input[key];
      }
    }
  }

  return matches;
};

module.exports = function(text, test, separator) {
  var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
  if (typeof test != 'undefined') {
    return matcher.match(test);
  }

  return matcher;
};

},{}],62:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],63:[function(require,module,exports){
module.exports={
  "name": "@uppy/companion-client",
  "description": "Client library for communication with Companion. Intended for use in Uppy plugins.",
  "version": "1.10.1",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "companion",
    "provider"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "namespace-emitter": "^2.0.1",
    "qs-stringify": "^1.1.0",
    "url-parse": "^1.4.7"
  }
}

},{}],64:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AuthError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AuthError, _Error);

  function AuthError() {
    var _this;

    _this = _Error.call(this, 'Authorization required') || this;
    _this.name = 'AuthError';
    _this.isAuthError = true;
    return _this;
  }

  return AuthError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

module.exports = AuthError;

},{}],65:[function(require,module,exports){
'use strict';

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var qsStringify = require('qs-stringify');

var URL = require('url-parse');

var RequestClient = require('./RequestClient');

var tokenStorage = require('./tokenStorage');

var _getName = function _getName(id) {
  return id.split('-').map(function (s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }).join(' ');
};

module.exports = /*#__PURE__*/function (_RequestClient) {
  _inheritsLoose(Provider, _RequestClient);

  function Provider(uppy, opts) {
    var _this;

    _this = _RequestClient.call(this, uppy, opts) || this;
    _this.provider = opts.provider;
    _this.id = _this.provider;
    _this.name = _this.opts.name || _getName(_this.id);
    _this.pluginId = _this.opts.pluginId;
    _this.tokenKey = "companion-" + _this.pluginId + "-auth-token";
    _this.companionKeysParams = _this.opts.companionKeysParams;
    _this.preAuthToken = null;
    return _this;
  }

  var _proto = Provider.prototype;

  _proto.headers = function headers() {
    var _this2 = this;

    return Promise.all([_RequestClient.prototype.headers.call(this), this.getAuthToken()]).then(function (_ref) {
      var headers = _ref[0],
          token = _ref[1];
      var authHeaders = {};

      if (token) {
        authHeaders['uppy-auth-token'] = token;
      }

      if (_this2.companionKeysParams) {
        authHeaders['uppy-credentials-params'] = btoa(JSON.stringify({
          params: _this2.companionKeysParams
        }));
      }

      return _extends({}, headers, authHeaders);
    });
  };

  _proto.onReceiveResponse = function onReceiveResponse(response) {
    response = _RequestClient.prototype.onReceiveResponse.call(this, response);
    var plugin = this.uppy.getPlugin(this.pluginId);
    var oldAuthenticated = plugin.getPluginState().authenticated;
    var authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
    plugin.setPluginState({
      authenticated: authenticated
    });
    return response;
  } // @todo(i.olarewaju) consider whether or not this method should be exposed
  ;

  _proto.setAuthToken = function setAuthToken(token) {
    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
  };

  _proto.getAuthToken = function getAuthToken() {
    return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
  };

  _proto.authUrl = function authUrl(queries) {
    if (queries === void 0) {
      queries = {};
    }

    if (this.preAuthToken) {
      queries.uppyPreAuthToken = this.preAuthToken;
    }

    var strigifiedQueries = qsStringify(queries);
    strigifiedQueries = strigifiedQueries ? "?" + strigifiedQueries : strigifiedQueries;
    return this.hostname + "/" + this.id + "/connect" + strigifiedQueries;
  };

  _proto.fileUrl = function fileUrl(id) {
    return this.hostname + "/" + this.id + "/get/" + id;
  };

  _proto.fetchPreAuthToken = function fetchPreAuthToken() {
    var _this3 = this;

    if (!this.companionKeysParams) {
      return Promise.resolve();
    }

    return this.post(this.id + "/preauth/", {
      params: this.companionKeysParams
    }).then(function (res) {
      _this3.preAuthToken = res.token;
    }).catch(function (err) {
      _this3.uppy.log("[CompanionClient] unable to fetch preAuthToken " + err, 'warning');
    });
  };

  _proto.list = function list(directory) {
    return this.get(this.id + "/list/" + (directory || ''));
  };

  _proto.logout = function logout() {
    var _this4 = this;

    return this.get(this.id + "/logout").then(function (response) {
      return Promise.all([response, _this4.uppy.getPlugin(_this4.pluginId).storage.removeItem(_this4.tokenKey)]);
    }).then(function (_ref2) {
      var response = _ref2[0];
      return response;
    });
  };

  Provider.initPlugin = function initPlugin(plugin, opts, defaultOpts) {
    plugin.type = 'acquirer';
    plugin.files = [];

    if (defaultOpts) {
      plugin.opts = _extends({}, defaultOpts, opts);
    }

    if (opts.serverUrl || opts.serverPattern) {
      throw new Error('`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`');
    }

    if (opts.companionAllowedHosts) {
      var pattern = opts.companionAllowedHosts; // validate companionAllowedHosts param

      if (typeof pattern !== 'string' && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
        throw new TypeError(plugin.id + ": the option \"companionAllowedHosts\" must be one of string, Array, RegExp");
      }

      plugin.opts.companionAllowedHosts = pattern;
    } else {
      // does not start with https://
      if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
        plugin.opts.companionAllowedHosts = "https://" + opts.companionUrl.replace(/^\/\//, '');
      } else {
        plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
      }
    }

    plugin.storage = plugin.opts.storage || tokenStorage;
  };

  return Provider;
}(RequestClient);

},{"./RequestClient":66,"./tokenStorage":70,"qs-stringify":39,"url-parse":60}],66:[function(require,module,exports){
'use strict';

var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AuthError = require('./AuthError');

var fetchWithNetworkError = require('./../../utils/lib/fetchWithNetworkError'); // Remove the trailing slash so we can always safely append /xyz.


function stripSlash(url) {
  return url.replace(/\/$/, '');
}

module.exports = (_temp = _class = /*#__PURE__*/function () {
  function RequestClient(uppy, opts) {
    this.uppy = uppy;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    this.allowedHeaders = ['accept', 'content-type', 'uppy-auth-token'];
    this.preflightDone = false;
  }

  var _proto = RequestClient.prototype;

  _proto.headers = function headers() {
    var userHeaders = this.opts.companionHeaders || this.opts.serverHeaders || {};
    return Promise.resolve(_extends({}, this.defaultHeaders, userHeaders));
  };

  _proto._getPostResponseFunc = function _getPostResponseFunc(skip) {
    var _this = this;

    return function (response) {
      if (!skip) {
        return _this.onReceiveResponse(response);
      }

      return response;
    };
  };

  _proto.onReceiveResponse = function onReceiveResponse(response) {
    var state = this.uppy.getState();
    var companion = state.companion || {};
    var host = this.opts.companionUrl;
    var headers = response.headers; // Store the self-identified domain name for the Companion instance we just hit.

    if (headers.has('i-am') && headers.get('i-am') !== companion[host]) {
      var _extends2;

      this.uppy.setState({
        companion: _extends({}, companion, (_extends2 = {}, _extends2[host] = headers.get('i-am'), _extends2))
      });
    }

    return response;
  };

  _proto._getUrl = function _getUrl(url) {
    if (/^(https?:|)\/\//.test(url)) {
      return url;
    }

    return this.hostname + "/" + url;
  };

  _proto._json = function _json(res) {
    if (res.status === 401) {
      throw new AuthError();
    }

    if (res.status < 200 || res.status > 300) {
      var errMsg = "Failed request with status: " + res.status + ". " + res.statusText;
      return res.json().then(function (errData) {
        errMsg = errData.message ? errMsg + " message: " + errData.message : errMsg;
        errMsg = errData.requestId ? errMsg + " request-Id: " + errData.requestId : errMsg;
        throw new Error(errMsg);
      }).catch(function () {
        throw new Error(errMsg);
      });
    }

    return res.json();
  };

  _proto.preflight = function preflight(path) {
    var _this2 = this;

    if (this.preflightDone) {
      return Promise.resolve(this.allowedHeaders.slice());
    }

    return fetch(this._getUrl(path), {
      method: 'OPTIONS'
    }).then(function (response) {
      if (response.headers.has('access-control-allow-headers')) {
        _this2.allowedHeaders = response.headers.get('access-control-allow-headers').split(',').map(function (headerName) {
          return headerName.trim().toLowerCase();
        });
      }

      _this2.preflightDone = true;
      return _this2.allowedHeaders.slice();
    }).catch(function (err) {
      _this2.uppy.log("[CompanionClient] unable to make preflight request " + err, 'warning');

      _this2.preflightDone = true;
      return _this2.allowedHeaders.slice();
    });
  };

  _proto.preflightAndHeaders = function preflightAndHeaders(path) {
    var _this3 = this;

    return Promise.all([this.preflight(path), this.headers()]).then(function (_ref) {
      var allowedHeaders = _ref[0],
          headers = _ref[1];
      // filter to keep only allowed Headers
      Object.keys(headers).forEach(function (header) {
        if (allowedHeaders.indexOf(header.toLowerCase()) === -1) {
          _this3.uppy.log("[CompanionClient] excluding unallowed header " + header);

          delete headers[header];
        }
      });
      return headers;
    });
  };

  _proto.get = function get(path, skipPostResponse) {
    var _this4 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this4._getUrl(path), {
        method: 'get',
        headers: headers,
        credentials: _this4.opts.companionCookiesRule || 'same-origin'
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this4._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not get " + _this4._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _proto.post = function post(path, data, skipPostResponse) {
    var _this5 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this5._getUrl(path), {
        method: 'post',
        headers: headers,
        credentials: _this5.opts.companionCookiesRule || 'same-origin',
        body: JSON.stringify(data)
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this5._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not post " + _this5._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _proto.delete = function _delete(path, data, skipPostResponse) {
    var _this6 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this6.hostname + "/" + path, {
        method: 'delete',
        headers: headers,
        credentials: _this6.opts.companionCookiesRule || 'same-origin',
        body: data ? JSON.stringify(data) : null
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this6._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not delete " + _this6._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _createClass(RequestClient, [{
    key: "hostname",
    get: function get() {
      var _this$uppy$getState = this.uppy.getState(),
          companion = _this$uppy$getState.companion;

      var host = this.opts.companionUrl;
      return stripSlash(companion && companion[host] ? companion[host] : host);
    }
  }, {
    key: "defaultHeaders",
    get: function get() {
      return {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        'Uppy-Versions': "@uppy/companion-client=" + RequestClient.VERSION
      };
    }
  }]);

  return RequestClient;
}(), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":63,"./../../utils/lib/fetchWithNetworkError":206,"./AuthError":64}],67:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var RequestClient = require('./RequestClient');

var _getName = function _getName(id) {
  return id.split('-').map(function (s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }).join(' ');
};

module.exports = /*#__PURE__*/function (_RequestClient) {
  _inheritsLoose(SearchProvider, _RequestClient);

  function SearchProvider(uppy, opts) {
    var _this;

    _this = _RequestClient.call(this, uppy, opts) || this;
    _this.provider = opts.provider;
    _this.id = _this.provider;
    _this.name = _this.opts.name || _getName(_this.id);
    _this.pluginId = _this.opts.pluginId;
    return _this;
  }

  var _proto = SearchProvider.prototype;

  _proto.fileUrl = function fileUrl(id) {
    return this.hostname + "/search/" + this.id + "/get/" + id;
  };

  _proto.search = function search(text, queries) {
    queries = queries ? "&" + queries : '';
    return this.get("search/" + this.id + "/list?q=" + encodeURIComponent(text) + queries);
  };

  return SearchProvider;
}(RequestClient);

},{"./RequestClient":66}],68:[function(require,module,exports){
var ee = require('namespace-emitter');

module.exports = /*#__PURE__*/function () {
  function UppySocket(opts) {
    this.opts = opts;
    this._queued = [];
    this.isOpen = false;
    this.emitter = ee();
    this._handleMessage = this._handleMessage.bind(this);
    this.close = this.close.bind(this);
    this.emit = this.emit.bind(this);
    this.on = this.on.bind(this);
    this.once = this.once.bind(this);
    this.send = this.send.bind(this);

    if (!opts || opts.autoOpen !== false) {
      this.open();
    }
  }

  var _proto = UppySocket.prototype;

  _proto.open = function open() {
    var _this = this;

    this.socket = new WebSocket(this.opts.target);

    this.socket.onopen = function (e) {
      _this.isOpen = true;

      while (_this._queued.length > 0 && _this.isOpen) {
        var first = _this._queued[0];

        _this.send(first.action, first.payload);

        _this._queued = _this._queued.slice(1);
      }
    };

    this.socket.onclose = function (e) {
      _this.isOpen = false;
    };

    this.socket.onmessage = this._handleMessage;
  };

  _proto.close = function close() {
    if (this.socket) {
      this.socket.close();
    }
  };

  _proto.send = function send(action, payload) {
    // attach uuid
    if (!this.isOpen) {
      this._queued.push({
        action: action,
        payload: payload
      });

      return;
    }

    this.socket.send(JSON.stringify({
      action: action,
      payload: payload
    }));
  };

  _proto.on = function on(action, handler) {
    this.emitter.on(action, handler);
  };

  _proto.emit = function emit(action, payload) {
    this.emitter.emit(action, payload);
  };

  _proto.once = function once(action, handler) {
    this.emitter.once(action, handler);
  };

  _proto._handleMessage = function _handleMessage(e) {
    try {
      var message = JSON.parse(e.data);
      this.emit(message.action, message.payload);
    } catch (err) {
      console.log(err);
    }
  };

  return UppySocket;
}();

},{"namespace-emitter":36}],69:[function(require,module,exports){
'use strict';
/**
 * Manages communications with Companion
 */

var RequestClient = require('./RequestClient');

var Provider = require('./Provider');

var SearchProvider = require('./SearchProvider');

var Socket = require('./Socket');

module.exports = {
  RequestClient: RequestClient,
  Provider: Provider,
  SearchProvider: SearchProvider,
  Socket: Socket
};

},{"./Provider":65,"./RequestClient":66,"./SearchProvider":67,"./Socket":68}],70:[function(require,module,exports){
'use strict';
/**
 * This module serves as an Async wrapper for LocalStorage
 */

module.exports.setItem = function (key, value) {
  return new Promise(function (resolve) {
    localStorage.setItem(key, value);
    resolve();
  });
};

module.exports.getItem = function (key) {
  return Promise.resolve(localStorage.getItem(key));
};

module.exports.removeItem = function (key) {
  return new Promise(function (resolve) {
    localStorage.removeItem(key);
    resolve();
  });
};

},{}],71:[function(require,module,exports){
module.exports={
  "name": "@uppy/core",
  "description": "Core module for the extensible JavaScript file upload widget with support for drag&drop, resumable uploads, previews, restrictions, file processing/encoding, remote providers like Instagram, Dropbox, Google Drive, S3 and more :dog:",
  "version": "1.19.1",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/store-default": "file:../store-default",
    "@uppy/utils": "file:../utils",
    "cuid": "^2.1.1",
    "lodash.throttle": "^4.1.1",
    "mime-match": "^1.0.2",
    "namespace-emitter": "^2.0.1",
    "preact": "8.2.9"
  }
}

},{}],72:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var preact = require('preact');

var findDOMElement = require('./../../utils/lib/findDOMElement');
/**
 * Defer a frequent call to the microtask queue.
 */


function debounce(fn) {
  var calling = null;
  var latestArgs = null;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    latestArgs = args;

    if (!calling) {
      calling = Promise.resolve().then(function () {
        calling = null; // At this point `args` may be different from the most
        // recent state, if multiple calls happened since this task
        // was queued. So we use the `latestArgs`, which definitely
        // is the most recent call.

        return fn.apply(void 0, latestArgs);
      });
    }

    return calling;
  };
}
/**
 * Boilerplate that all Plugins share - and should not be used
 * directly. It also shows which methods final plugins should implement/override,
 * this deciding on structure.
 *
 * @param {object} main Uppy core object
 * @param {object} object with plugin options
 * @returns {Array|string} files or success/fail message
 */


module.exports = /*#__PURE__*/function () {
  function Plugin(uppy, opts) {
    this.uppy = uppy;
    this.opts = opts || {};
    this.update = this.update.bind(this);
    this.mount = this.mount.bind(this);
    this.install = this.install.bind(this);
    this.uninstall = this.uninstall.bind(this);
  }

  var _proto = Plugin.prototype;

  _proto.getPluginState = function getPluginState() {
    var _this$uppy$getState = this.uppy.getState(),
        plugins = _this$uppy$getState.plugins;

    return plugins[this.id] || {};
  };

  _proto.setPluginState = function setPluginState(update) {
    var _extends2;

    var _this$uppy$getState2 = this.uppy.getState(),
        plugins = _this$uppy$getState2.plugins;

    this.uppy.setState({
      plugins: _extends({}, plugins, (_extends2 = {}, _extends2[this.id] = _extends({}, plugins[this.id], update), _extends2))
    });
  };

  _proto.setOptions = function setOptions(newOpts) {
    this.opts = _extends({}, this.opts, newOpts);
    this.setPluginState(); // so that UI re-renders with new options
  };

  _proto.update = function update(state) {
    if (typeof this.el === 'undefined') {
      return;
    }

    if (this._updateUI) {
      this._updateUI(state);
    }
  } // Called after every state update, after everything's mounted. Debounced.
  ;

  _proto.afterUpdate = function afterUpdate() {}
  /**
   * Called when plugin is mounted, whether in DOM or into another plugin.
   * Needed because sometimes plugins are mounted separately/after `install`,
   * so this.el and this.parent might not be available in `install`.
   * This is the case with @uppy/react plugins, for example.
   */
  ;

  _proto.onMount = function onMount() {}
  /**
   * Check if supplied `target` is a DOM element or an `object`.
   * If it’s an object — target is a plugin, and we search `plugins`
   * for a plugin with same name and return its target.
   *
   * @param {string|object} target
   *
   */
  ;

  _proto.mount = function mount(target, plugin) {
    var _this = this;

    var callerPluginName = plugin.id;
    var targetElement = findDOMElement(target);

    if (targetElement) {
      this.isTargetDOMEl = true; // API for plugins that require a synchronous rerender.

      this.rerender = function (state) {
        // plugin could be removed, but this.rerender is debounced below,
        // so it could still be called even after uppy.removePlugin or uppy.close
        // hence the check
        if (!_this.uppy.getPlugin(_this.id)) return;
        _this.el = preact.render(_this.render(state), targetElement, _this.el);

        _this.afterUpdate();
      };

      this._updateUI = debounce(this.rerender);
      this.uppy.log("Installing " + callerPluginName + " to a DOM element '" + target + "'"); // clear everything inside the target container

      if (this.opts.replaceTargetContent) {
        targetElement.innerHTML = '';
      }

      this.el = preact.render(this.render(this.uppy.getState()), targetElement);
      this.onMount();
      return this.el;
    }

    var targetPlugin;

    if (typeof target === 'object' && target instanceof Plugin) {
      // Targeting a plugin *instance*
      targetPlugin = target;
    } else if (typeof target === 'function') {
      // Targeting a plugin type
      var Target = target; // Find the target plugin instance.

      this.uppy.iteratePlugins(function (plugin) {
        if (plugin instanceof Target) {
          targetPlugin = plugin;
          return false;
        }
      });
    }

    if (targetPlugin) {
      this.uppy.log("Installing " + callerPluginName + " to " + targetPlugin.id);
      this.parent = targetPlugin;
      this.el = targetPlugin.addTarget(plugin);
      this.onMount();
      return this.el;
    }

    this.uppy.log("Not installing " + callerPluginName);
    var message = "Invalid target option given to " + callerPluginName + ".";

    if (typeof target === 'function') {
      message += ' The given target is not a Plugin class. ' + 'Please check that you\'re not specifying a React Component instead of a plugin. ' + 'If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: ' + 'run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.';
    } else {
      message += 'If you meant to target an HTML element, please make sure that the element exists. ' + 'Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. ' + '(see https://github.com/transloadit/uppy/issues/1042)\n\n' + 'If you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.';
    }

    throw new Error(message);
  };

  _proto.render = function render(state) {
    throw new Error('Extend the render method to add your plugin to a DOM element');
  };

  _proto.addTarget = function addTarget(plugin) {
    throw new Error('Extend the addTarget method to add your plugin to another plugin\'s target');
  };

  _proto.unmount = function unmount() {
    if (this.isTargetDOMEl && this.el && this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
  };

  _proto.install = function install() {};

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return Plugin;
}();

},{"./../../utils/lib/findDOMElement":208,"preact":37}],73:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* global AggregateError */
var Translator = require('./../../utils/lib/Translator');

var ee = require('namespace-emitter');

var cuid = require('cuid');

var throttle = require('lodash.throttle');

var prettierBytes = require('@transloadit/prettier-bytes');

var match = require('mime-match');

var DefaultStore = require('./../../store-default');

var getFileType = require('./../../utils/lib/getFileType');

var getFileNameAndExtension = require('./../../utils/lib/getFileNameAndExtension');

var generateFileID = require('./../../utils/lib/generateFileID');

var findIndex = require('./../../utils/lib/findIndex');

var supportsUploadProgress = require('./supportsUploadProgress');

var _require = require('./loggers'),
    justErrorsLogger = _require.justErrorsLogger,
    debugLogger = _require.debugLogger;

var Plugin = require('./Plugin');

var _require2 = require('../package.json'),
    version = _require2.version; // Exported from here.


var RestrictionError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RestrictionError, _Error);

  function RestrictionError() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Error.call.apply(_Error, [this].concat(args)) || this;
    _this.isRestriction = true;
    return _this;
  }

  return RestrictionError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Uppy Core module.
 * Manages plugins, state updates, acts as an event bus,
 * adds/removes files and metadata.
 */


var Uppy = /*#__PURE__*/function () {
  /**
   * Instantiate Uppy
   *
   * @param {object} opts — Uppy options
   */
  function Uppy(opts) {
    var _this2 = this;

    this.defaultLocale = {
      strings: {
        addBulkFilesFailed: {
          0: 'Failed to add %{smart_count} file due to an internal error',
          1: 'Failed to add %{smart_count} files due to internal errors'
        },
        youCanOnlyUploadX: {
          0: 'You can only upload %{smart_count} file',
          1: 'You can only upload %{smart_count} files'
        },
        youHaveToAtLeastSelectX: {
          0: 'You have to select at least %{smart_count} file',
          1: 'You have to select at least %{smart_count} files'
        },
        // The default `exceedsSize2` string only combines the `exceedsSize` string (%{backwardsCompat}) with the size.
        // Locales can override `exceedsSize2` to specify a different word order. This is for backwards compat with
        // Uppy 1.9.x and below which did a naive concatenation of `exceedsSize2 + size` instead of using a locale-specific
        // substitution.
        // TODO: In 2.0 `exceedsSize2` should be removed in and `exceedsSize` updated to use substitution.
        exceedsSize2: '%{backwardsCompat} %{size}',
        exceedsSize: '%{file} exceeds maximum allowed size of',
        inferiorSize: 'This file is smaller than the allowed size of %{size}',
        youCanOnlyUploadFileTypes: 'You can only upload: %{types}',
        noNewAlreadyUploading: 'Cannot add new files: already uploading',
        noDuplicates: 'Cannot add the duplicate file \'%{fileName}\', it already exists',
        companionError: 'Connection with Companion failed',
        companionUnauthorizeHint: 'To unauthorize to your %{provider} account, please go to %{url}',
        failedToUpload: 'Failed to upload %{file}',
        noInternetConnection: 'No Internet connection',
        connectedToInternet: 'Connected to the Internet',
        // Strings for remote providers
        noFilesFound: 'You have no files or folders here',
        selectX: {
          0: 'Select %{smart_count}',
          1: 'Select %{smart_count}'
        },
        selectAllFilesFromFolderNamed: 'Select all files from folder %{name}',
        unselectAllFilesFromFolderNamed: 'Unselect all files from folder %{name}',
        selectFileNamed: 'Select file %{name}',
        unselectFileNamed: 'Unselect file %{name}',
        openFolderNamed: 'Open folder %{name}',
        cancel: 'Cancel',
        logOut: 'Log out',
        filter: 'Filter',
        resetFilter: 'Reset filter',
        loading: 'Loading...',
        authenticateWithTitle: 'Please authenticate with %{pluginName} to select files',
        authenticateWith: 'Connect to %{pluginName}',
        searchImages: 'Search for images',
        enterTextToSearch: 'Enter text to search for images',
        backToSearch: 'Back to Search',
        emptyFolderAdded: 'No files were added from empty folder',
        folderAdded: {
          0: 'Added %{smart_count} file from %{folder}',
          1: 'Added %{smart_count} files from %{folder}'
        }
      }
    };
    var defaultOptions = {
      id: 'uppy',
      autoProceed: false,
      allowMultipleUploads: true,
      debug: false,
      restrictions: {
        maxFileSize: null,
        minFileSize: null,
        maxTotalFileSize: null,
        maxNumberOfFiles: null,
        minNumberOfFiles: null,
        allowedFileTypes: null
      },
      meta: {},
      onBeforeFileAdded: function onBeforeFileAdded(currentFile) {
        return currentFile;
      },
      onBeforeUpload: function onBeforeUpload(files) {
        return files;
      },
      store: DefaultStore(),
      logger: justErrorsLogger,
      infoTimeout: 5000
    }; // Merge default options with the ones set by user,
    // making sure to merge restrictions too

    this.opts = _extends({}, defaultOptions, opts, {
      restrictions: _extends({}, defaultOptions.restrictions, opts && opts.restrictions)
    }); // Support debug: true for backwards-compatability, unless logger is set in opts
    // opts instead of this.opts to avoid comparing objects — we set logger: justErrorsLogger in defaultOptions

    if (opts && opts.logger && opts.debug) {
      this.log('You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.', 'warning');
    } else if (opts && opts.debug) {
      this.opts.logger = debugLogger;
    }

    this.log("Using Core v" + this.constructor.VERSION);

    if (this.opts.restrictions.allowedFileTypes && this.opts.restrictions.allowedFileTypes !== null && !Array.isArray(this.opts.restrictions.allowedFileTypes)) {
      throw new TypeError('`restrictions.allowedFileTypes` must be an array');
    }

    this.i18nInit(); // Container for different types of plugins

    this.plugins = {};
    this.getState = this.getState.bind(this);
    this.getPlugin = this.getPlugin.bind(this);
    this.setFileMeta = this.setFileMeta.bind(this);
    this.setFileState = this.setFileState.bind(this);
    this.log = this.log.bind(this);
    this.info = this.info.bind(this);
    this.hideInfo = this.hideInfo.bind(this);
    this.addFile = this.addFile.bind(this);
    this.removeFile = this.removeFile.bind(this);
    this.pauseResume = this.pauseResume.bind(this);
    this.validateRestrictions = this.validateRestrictions.bind(this); // ___Why throttle at 500ms?
    //    - We must throttle at >250ms for superfocus in Dashboard to work well
    //    (because animation takes 0.25s, and we want to wait for all animations to be over before refocusing).
    //    [Practical Check]: if thottle is at 100ms, then if you are uploading a file,
    //    and click 'ADD MORE FILES', - focus won't activate in Firefox.
    //    - We must throttle at around >500ms to avoid performance lags.
    //    [Practical Check] Firefox, try to upload a big file for a prolonged period of time. Laptop will start to heat up.

    this.calculateProgress = throttle(this.calculateProgress.bind(this), 500, {
      leading: true,
      trailing: true
    });
    this.updateOnlineStatus = this.updateOnlineStatus.bind(this);
    this.resetProgress = this.resetProgress.bind(this);
    this.pauseAll = this.pauseAll.bind(this);
    this.resumeAll = this.resumeAll.bind(this);
    this.retryAll = this.retryAll.bind(this);
    this.cancelAll = this.cancelAll.bind(this);
    this.retryUpload = this.retryUpload.bind(this);
    this.upload = this.upload.bind(this);
    this.emitter = ee();
    this.on = this.on.bind(this);
    this.off = this.off.bind(this);
    this.once = this.emitter.once.bind(this.emitter);
    this.emit = this.emitter.emit.bind(this.emitter);
    this.preProcessors = [];
    this.uploaders = [];
    this.postProcessors = [];
    this.store = this.opts.store;
    this.setState({
      plugins: {},
      files: {},
      currentUploads: {},
      allowNewUpload: true,
      capabilities: {
        uploadProgress: supportsUploadProgress(),
        individualCancellation: true,
        resumableUploads: false
      },
      totalProgress: 0,
      meta: _extends({}, this.opts.meta),
      info: {
        isHidden: true,
        type: 'info',
        message: ''
      },
      recoveredState: null
    });
    this.storeUnsubscribe = this.store.subscribe(function (prevState, nextState, patch) {
      _this2.emit('state-update', prevState, nextState, patch);

      _this2.updateAll(nextState);
    }); // Exposing uppy object on window for debugging and testing

    if (this.opts.debug && typeof window !== 'undefined') {
      window[this.opts.id] = this;
    }

    this.addListeners(); // Re-enable if we’ll need some capabilities on boot, like isMobileDevice
    // this._setCapabilities()
  } // _setCapabilities = () => {
  //   const capabilities = {
  //     isMobileDevice: isMobileDevice()
  //   }
  //   this.setState({
  //     ...this.getState().capabilities,
  //     capabilities
  //   })
  // }


  var _proto = Uppy.prototype;

  _proto.on = function on(event, callback) {
    this.emitter.on(event, callback);
    return this;
  };

  _proto.off = function off(event, callback) {
    this.emitter.off(event, callback);
    return this;
  }
  /**
   * Iterate on all plugins and run `update` on them.
   * Called each time state changes.
   *
   */
  ;

  _proto.updateAll = function updateAll(state) {
    this.iteratePlugins(function (plugin) {
      plugin.update(state);
    });
  }
  /**
   * Updates state with a patch
   *
   * @param {object} patch {foo: 'bar'}
   */
  ;

  _proto.setState = function setState(patch) {
    this.store.setState(patch);
  }
  /**
   * Returns current state.
   *
   * @returns {object}
   */
  ;

  _proto.getState = function getState() {
    return this.store.getState();
  }
  /**
   * Back compat for when uppy.state is used instead of uppy.getState().
   */
  ;

  /**
   * Shorthand to set state for a specific file.
   */
  _proto.setFileState = function setFileState(fileID, state) {
    var _extends2;

    if (!this.getState().files[fileID]) {
      throw new Error("Can\u2019t set state for " + fileID + " (the file could have been removed)");
    }

    this.setState({
      files: _extends({}, this.getState().files, (_extends2 = {}, _extends2[fileID] = _extends({}, this.getState().files[fileID], state), _extends2))
    });
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.opts.locale]);
    this.locale = this.translator.locale;
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
  };

  _proto.setOptions = function setOptions(newOpts) {
    this.opts = _extends({}, this.opts, newOpts, {
      restrictions: _extends({}, this.opts.restrictions, newOpts && newOpts.restrictions)
    });

    if (newOpts.meta) {
      this.setMeta(newOpts.meta);
    }

    this.i18nInit();

    if (newOpts.locale) {
      this.iteratePlugins(function (plugin) {
        plugin.setOptions();
      });
    }

    this.setState(); // so that UI re-renders with new options
  };

  _proto.resetProgress = function resetProgress() {
    var defaultProgress = {
      percentage: 0,
      bytesUploaded: 0,
      uploadComplete: false,
      uploadStarted: null
    };

    var files = _extends({}, this.getState().files);

    var updatedFiles = {};
    Object.keys(files).forEach(function (fileID) {
      var updatedFile = _extends({}, files[fileID]);

      updatedFile.progress = _extends({}, updatedFile.progress, defaultProgress);
      updatedFiles[fileID] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      totalProgress: 0
    });
    this.emit('reset-progress');
  };

  _proto.addPreProcessor = function addPreProcessor(fn) {
    this.preProcessors.push(fn);
  };

  _proto.removePreProcessor = function removePreProcessor(fn) {
    var i = this.preProcessors.indexOf(fn);

    if (i !== -1) {
      this.preProcessors.splice(i, 1);
    }
  };

  _proto.addPostProcessor = function addPostProcessor(fn) {
    this.postProcessors.push(fn);
  };

  _proto.removePostProcessor = function removePostProcessor(fn) {
    var i = this.postProcessors.indexOf(fn);

    if (i !== -1) {
      this.postProcessors.splice(i, 1);
    }
  };

  _proto.addUploader = function addUploader(fn) {
    this.uploaders.push(fn);
  };

  _proto.removeUploader = function removeUploader(fn) {
    var i = this.uploaders.indexOf(fn);

    if (i !== -1) {
      this.uploaders.splice(i, 1);
    }
  };

  _proto.setMeta = function setMeta(data) {
    var updatedMeta = _extends({}, this.getState().meta, data);

    var updatedFiles = _extends({}, this.getState().files);

    Object.keys(updatedFiles).forEach(function (fileID) {
      updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
        meta: _extends({}, updatedFiles[fileID].meta, data)
      });
    });
    this.log('Adding metadata:');
    this.log(data);
    this.setState({
      meta: updatedMeta,
      files: updatedFiles
    });
  };

  _proto.setFileMeta = function setFileMeta(fileID, data) {
    var updatedFiles = _extends({}, this.getState().files);

    if (!updatedFiles[fileID]) {
      this.log('Was trying to set metadata for a file that has been removed: ', fileID);
      return;
    }

    var newMeta = _extends({}, updatedFiles[fileID].meta, data);

    updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
      meta: newMeta
    });
    this.setState({
      files: updatedFiles
    });
  }
  /**
   * Get a file object.
   *
   * @param {string} fileID The ID of the file object to return.
   */
  ;

  _proto.getFile = function getFile(fileID) {
    return this.getState().files[fileID];
  }
  /**
   * Get all files in an array.
   */
  ;

  _proto.getFiles = function getFiles() {
    var _this$getState = this.getState(),
        files = _this$getState.files;

    return Object.keys(files).map(function (fileID) {
      return files[fileID];
    });
  }
  /**
   * A public wrapper for _checkRestrictions — checks if a file passes a set of restrictions.
   * For use in UI pluigins (like Providers), to disallow selecting files that won’t pass restrictions.
   *
   * @param {object} file object to check
   * @param {Array} [files] array to check maxNumberOfFiles and maxTotalFileSize
   * @returns {object} { result: true/false, reason: why file didn’t pass restrictions }
   */
  ;

  _proto.validateRestrictions = function validateRestrictions(file, files) {
    try {
      this.checkRestrictions(file, files);
      return {
        result: true
      };
    } catch (err) {
      return {
        result: false,
        reason: err.message
      };
    }
  }
  /**
   * Check if file passes a set of restrictions set in options: maxFileSize, minFileSize,
   * maxNumberOfFiles and allowedFileTypes.
   *
   * @param {object} file object to check
   * @param {Array} [files] array to check maxNumberOfFiles and maxTotalFileSize
   * @private
   */
  ;

  _proto.checkRestrictions = function checkRestrictions(file, files) {
    if (files === void 0) {
      files = this.getFiles();
    }

    var _this$opts$restrictio = this.opts.restrictions,
        maxFileSize = _this$opts$restrictio.maxFileSize,
        minFileSize = _this$opts$restrictio.minFileSize,
        maxTotalFileSize = _this$opts$restrictio.maxTotalFileSize,
        maxNumberOfFiles = _this$opts$restrictio.maxNumberOfFiles,
        allowedFileTypes = _this$opts$restrictio.allowedFileTypes;

    if (maxNumberOfFiles) {
      if (files.length + 1 > maxNumberOfFiles) {
        throw new RestrictionError("" + this.i18n('youCanOnlyUploadX', {
          smart_count: maxNumberOfFiles
        }));
      }
    }

    if (allowedFileTypes) {
      var isCorrectFileType = allowedFileTypes.some(function (type) {
        // check if this is a mime-type
        if (type.indexOf('/') > -1) {
          if (!file.type) return false;
          return match(file.type.replace(/;.*?$/, ''), type);
        } // otherwise this is likely an extension


        if (type[0] === '.' && file.extension) {
          return file.extension.toLowerCase() === type.substr(1).toLowerCase();
        }

        return false;
      });

      if (!isCorrectFileType) {
        var allowedFileTypesString = allowedFileTypes.join(', ');
        throw new RestrictionError(this.i18n('youCanOnlyUploadFileTypes', {
          types: allowedFileTypesString
        }));
      }
    } // We can't check maxTotalFileSize if the size is unknown.


    if (maxTotalFileSize && file.size != null) {
      var totalFilesSize = 0;
      totalFilesSize += file.size;
      files.forEach(function (f) {
        totalFilesSize += f.size;
      });

      if (totalFilesSize > maxTotalFileSize) {
        throw new RestrictionError(this.i18n('exceedsSize2', {
          backwardsCompat: this.i18n('exceedsSize'),
          size: prettierBytes(maxTotalFileSize),
          file: file.name
        }));
      }
    } // We can't check maxFileSize if the size is unknown.


    if (maxFileSize && file.size != null) {
      if (file.size > maxFileSize) {
        throw new RestrictionError(this.i18n('exceedsSize2', {
          backwardsCompat: this.i18n('exceedsSize'),
          size: prettierBytes(maxFileSize),
          file: file.name
        }));
      }
    } // We can't check minFileSize if the size is unknown.


    if (minFileSize && file.size != null) {
      if (file.size < minFileSize) {
        throw new RestrictionError(this.i18n('inferiorSize', {
          size: prettierBytes(minFileSize)
        }));
      }
    }
  }
  /**
   * Check if minNumberOfFiles restriction is reached before uploading.
   *
   * @private
   */
  ;

  _proto.checkMinNumberOfFiles = function checkMinNumberOfFiles(files) {
    var minNumberOfFiles = this.opts.restrictions.minNumberOfFiles;

    if (Object.keys(files).length < minNumberOfFiles) {
      throw new RestrictionError("" + this.i18n('youHaveToAtLeastSelectX', {
        smart_count: minNumberOfFiles
      }));
    }
  }
  /**
   * Logs an error, sets Informer message, then throws the error.
   * Emits a 'restriction-failed' event if it’s a restriction error
   *
   * @param {object | string} err — Error object or plain string message
   * @param {object} [options]
   * @param {boolean} [options.showInformer=true] — Sometimes developer might want to show Informer manually
   * @param {object} [options.file=null] — File object used to emit the restriction error
   * @param {boolean} [options.throwErr=true] — Errors shouldn’t be thrown, for example, in `upload-error` event
   * @private
   */
  ;

  _proto.showOrLogErrorAndThrow = function showOrLogErrorAndThrow(err, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$showInformer = _ref.showInformer,
        showInformer = _ref$showInformer === void 0 ? true : _ref$showInformer,
        _ref$file = _ref.file,
        file = _ref$file === void 0 ? null : _ref$file,
        _ref$throwErr = _ref.throwErr,
        throwErr = _ref$throwErr === void 0 ? true : _ref$throwErr;

    var message = typeof err === 'object' ? err.message : err;
    var details = typeof err === 'object' && err.details ? err.details : ''; // Restriction errors should be logged, but not as errors,
    // as they are expected and shown in the UI.

    var logMessageWithDetails = message;

    if (details) {
      logMessageWithDetails += " " + details;
    }

    if (err.isRestriction) {
      this.log(logMessageWithDetails);
      this.emit('restriction-failed', file, err);
    } else {
      this.log(logMessageWithDetails, 'error');
    } // Sometimes informer has to be shown manually by the developer,
    // for example, in `onBeforeFileAdded`.


    if (showInformer) {
      this.info({
        message: message,
        details: details
      }, 'error', this.opts.infoTimeout);
    }

    if (throwErr) {
      throw typeof err === 'object' ? err : new Error(err);
    }
  };

  _proto.assertNewUploadAllowed = function assertNewUploadAllowed(file) {
    var _this$getState2 = this.getState(),
        allowNewUpload = _this$getState2.allowNewUpload;

    if (allowNewUpload === false) {
      this.showOrLogErrorAndThrow(new RestrictionError(this.i18n('noNewAlreadyUploading')), {
        file: file
      });
    }
  }
  /**
   * Create a file state object based on user-provided `addFile()` options.
   *
   * Note this is extremely side-effectful and should only be done when a file state object will be added to state immediately afterward!
   *
   * The `files` value is passed in because it may be updated by the caller without updating the store.
   */
  ;

  _proto.checkAndCreateFileStateObject = function checkAndCreateFileStateObject(files, f) {
    var fileType = getFileType(f);
    var file = f;
    file.type = fileType;
    var onBeforeFileAddedResult = this.opts.onBeforeFileAdded(file, files);

    if (onBeforeFileAddedResult === false) {
      // Don’t show UI info for this error, as it should be done by the developer
      this.showOrLogErrorAndThrow(new RestrictionError('Cannot add the file because onBeforeFileAdded returned false.'), {
        showInformer: false,
        file: file
      });
    }

    if (typeof onBeforeFileAddedResult === 'object' && onBeforeFileAddedResult) {
      file = onBeforeFileAddedResult;
    }

    var fileName;

    if (file.name) {
      fileName = file.name;
    } else if (fileType.split('/')[0] === 'image') {
      fileName = fileType.split('/')[0] + "." + fileType.split('/')[1];
    } else {
      fileName = 'noname';
    }

    var fileExtension = getFileNameAndExtension(fileName).extension;
    var isRemote = file.isRemote || false;
    var fileID = generateFileID(file);

    if (files[fileID] && !files[fileID].isGhost) {
      this.showOrLogErrorAndThrow(new RestrictionError(this.i18n('noDuplicates', {
        fileName: fileName
      })), {
        file: file
      });
    }

    var meta = file.meta || {};
    meta.name = fileName;
    meta.type = fileType; // `null` means the size is unknown.

    var size = Number.isFinite(file.data.size) ? file.data.size : null;
    var newFile = {
      source: file.source || '',
      id: fileID,
      name: fileName,
      extension: fileExtension || '',
      meta: _extends({}, this.getState().meta, meta),
      type: fileType,
      data: file.data,
      progress: {
        percentage: 0,
        bytesUploaded: 0,
        bytesTotal: size,
        uploadComplete: false,
        uploadStarted: null
      },
      size: size,
      isRemote: isRemote,
      remote: file.remote || '',
      preview: file.preview
    };

    try {
      var filesArray = Object.keys(files).map(function (i) {
        return files[i];
      });
      this.checkRestrictions(newFile, filesArray);
    } catch (err) {
      this.showOrLogErrorAndThrow(err, {
        file: newFile
      });
    }

    return newFile;
  } // Schedule an upload if `autoProceed` is enabled.
  ;

  _proto.startIfAutoProceed = function startIfAutoProceed() {
    var _this3 = this;

    if (this.opts.autoProceed && !this.scheduledAutoProceed) {
      this.scheduledAutoProceed = setTimeout(function () {
        _this3.scheduledAutoProceed = null;

        _this3.upload().catch(function (err) {
          if (!err.isRestriction) {
            _this3.log(err.stack || err.message || err);
          }
        });
      }, 4);
    }
  }
  /**
   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,
   * try to guess file type in a clever way, check file against restrictions,
   * and start an upload if `autoProceed === true`.
   *
   * @param {object} file object to add
   * @returns {string} id for the added file
   */
  ;

  _proto.addFile = function addFile(file) {
    var _extends3;

    this.assertNewUploadAllowed(file);

    var _this$getState3 = this.getState(),
        files = _this$getState3.files;

    var newFile = this.checkAndCreateFileStateObject(files, file); // Users are asked to re-select recovered files without data,
    // and to keep the progress, meta and everthing else, we only replace said data

    if (files[newFile.id] && files[newFile.id].isGhost) {
      newFile = _extends({}, files[newFile.id], {
        data: file.data,
        isGhost: false
      });
      this.log("Replaced the blob in the restored ghost file: " + newFile.name + ", " + newFile.id);
    }

    this.setState({
      files: _extends({}, files, (_extends3 = {}, _extends3[newFile.id] = newFile, _extends3))
    });
    this.emit('file-added', newFile);
    this.emit('files-added', [newFile]);
    this.log("Added file: " + newFile.name + ", " + newFile.id + ", mime type: " + newFile.type);
    this.startIfAutoProceed();
    return newFile.id;
  }
  /**
   * Add multiple files to `state.files`. See the `addFile()` documentation.
   *
   * If an error occurs while adding a file, it is logged and the user is notified.
   * This is good for UI plugins, but not for programmatic use.
   * Programmatic users should usually still use `addFile()` on individual files.
   */
  ;

  _proto.addFiles = function addFiles(fileDescriptors) {
    var _this4 = this;

    this.assertNewUploadAllowed(); // create a copy of the files object only once

    var files = _extends({}, this.getState().files);

    var newFiles = [];
    var errors = [];

    for (var i = 0; i < fileDescriptors.length; i++) {
      try {
        var newFile = this.checkAndCreateFileStateObject(files, fileDescriptors[i]); // Users are asked to re-select recovered files without data,
        // and to keep the progress, meta and everthing else, we only replace said data

        if (files[newFile.id] && files[newFile.id].isGhost) {
          newFile = _extends({}, files[newFile.id], {
            data: fileDescriptors[i].data,
            isGhost: false
          });
          this.log("Replaced blob in a ghost file: " + newFile.name + ", " + newFile.id);
        }

        files[newFile.id] = newFile;
        newFiles.push(newFile);
      } catch (err) {
        if (!err.isRestriction) {
          errors.push(err);
        }
      }
    }

    this.setState({
      files: files
    });
    newFiles.forEach(function (newFile) {
      _this4.emit('file-added', newFile);
    });
    this.emit('files-added', newFiles);

    if (newFiles.length > 5) {
      this.log("Added batch of " + newFiles.length + " files");
    } else {
      Object.keys(newFiles).forEach(function (fileID) {
        _this4.log("Added file: " + newFiles[fileID].name + "\n id: " + newFiles[fileID].id + "\n type: " + newFiles[fileID].type);
      });
    }

    if (newFiles.length > 0) {
      this.startIfAutoProceed();
    }

    if (errors.length > 0) {
      var message = 'Multiple errors occurred while adding files:\n';
      errors.forEach(function (subError) {
        message += "\n * " + subError.message;
      });
      this.info({
        message: this.i18n('addBulkFilesFailed', {
          smart_count: errors.length
        }),
        details: message
      }, 'error', this.opts.infoTimeout);

      if (typeof AggregateError === 'function') {
        throw new AggregateError(errors, message);
      } else {
        var err = new Error(message);
        err.errors = errors;
        throw err;
      }
    }
  };

  _proto.removeFiles = function removeFiles(fileIDs, reason) {
    var _this5 = this;

    var _this$getState4 = this.getState(),
        files = _this$getState4.files,
        currentUploads = _this$getState4.currentUploads;

    var updatedFiles = _extends({}, files);

    var updatedUploads = _extends({}, currentUploads);

    var removedFiles = Object.create(null);
    fileIDs.forEach(function (fileID) {
      if (files[fileID]) {
        removedFiles[fileID] = files[fileID];
        delete updatedFiles[fileID];
      }
    }); // Remove files from the `fileIDs` list in each upload.

    function fileIsNotRemoved(uploadFileID) {
      return removedFiles[uploadFileID] === undefined;
    }

    Object.keys(updatedUploads).forEach(function (uploadID) {
      var newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved); // Remove the upload if no files are associated with it anymore.

      if (newFileIDs.length === 0) {
        delete updatedUploads[uploadID];
        return;
      }

      updatedUploads[uploadID] = _extends({}, currentUploads[uploadID], {
        fileIDs: newFileIDs
      });
    });
    var stateUpdate = {
      currentUploads: updatedUploads,
      files: updatedFiles
    }; // If all files were removed - allow new uploads,
    // and clear recoveredState

    if (Object.keys(updatedFiles).length === 0) {
      stateUpdate.allowNewUpload = true;
      stateUpdate.error = null;
      stateUpdate.recoveredState = null;
    }

    this.setState(stateUpdate);
    this.calculateTotalProgress();
    var removedFileIDs = Object.keys(removedFiles);
    removedFileIDs.forEach(function (fileID) {
      _this5.emit('file-removed', removedFiles[fileID], reason);
    });

    if (removedFileIDs.length > 5) {
      this.log("Removed " + removedFileIDs.length + " files");
    } else {
      this.log("Removed files: " + removedFileIDs.join(', '));
    }
  };

  _proto.removeFile = function removeFile(fileID, reason) {
    if (reason === void 0) {
      reason = null;
    }

    this.removeFiles([fileID], reason);
  };

  _proto.pauseResume = function pauseResume(fileID) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
      return undefined;
    }

    var wasPaused = this.getFile(fileID).isPaused || false;
    var isPaused = !wasPaused;
    this.setFileState(fileID, {
      isPaused: isPaused
    });
    this.emit('upload-pause', fileID, isPaused);
    return isPaused;
  };

  _proto.pauseAll = function pauseAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var inProgressUpdatedFiles = Object.keys(updatedFiles).filter(function (file) {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: true
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('pause-all');
  };

  _proto.resumeAll = function resumeAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var inProgressUpdatedFiles = Object.keys(updatedFiles).filter(function (file) {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: false,
        error: null
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('resume-all');
  };

  _proto.retryAll = function retryAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var filesToRetry = Object.keys(updatedFiles).filter(function (file) {
      return updatedFiles[file].error;
    });
    filesToRetry.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: false,
        error: null
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      error: null
    });
    this.emit('retry-all', filesToRetry);

    if (filesToRetry.length === 0) {
      return Promise.resolve({
        successful: [],
        failed: []
      });
    }

    var uploadID = this.createUpload(filesToRetry, {
      forceAllowNewUpload: true // create new upload even if allowNewUpload: false

    });
    return this.runUpload(uploadID);
  };

  _proto.cancelAll = function cancelAll() {
    this.emit('cancel-all');

    var _this$getState5 = this.getState(),
        files = _this$getState5.files;

    var fileIDs = Object.keys(files);

    if (fileIDs.length) {
      this.removeFiles(fileIDs, 'cancel-all');
    }

    this.setState({
      totalProgress: 0,
      error: null,
      recoveredState: null
    });
  };

  _proto.retryUpload = function retryUpload(fileID) {
    this.setFileState(fileID, {
      error: null,
      isPaused: false
    });
    this.emit('upload-retry', fileID);
    var uploadID = this.createUpload([fileID], {
      forceAllowNewUpload: true // create new upload even if allowNewUpload: false

    });
    return this.runUpload(uploadID);
  };

  _proto.reset = function reset() {
    this.cancelAll();
  };

  _proto.logout = function logout() {
    this.iteratePlugins(function (plugin) {
      if (plugin.provider && plugin.provider.logout) {
        plugin.provider.logout();
      }
    });
  };

  _proto.calculateProgress = function calculateProgress(file, data) {
    if (!this.getFile(file.id)) {
      this.log("Not setting progress for a file that has been removed: " + file.id);
      return;
    } // bytesTotal may be null or zero; in that case we can't divide by it


    var canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;
    this.setFileState(file.id, {
      progress: _extends({}, this.getFile(file.id).progress, {
        bytesUploaded: data.bytesUploaded,
        bytesTotal: data.bytesTotal,
        percentage: canHavePercentage // TODO(goto-bus-stop) flooring this should probably be the choice of the UI?
        // we get more accurate calculations if we don't round this at all.
        ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
      })
    });
    this.calculateTotalProgress();
  };

  _proto.calculateTotalProgress = function calculateTotalProgress() {
    // calculate total progress, using the number of files currently uploading,
    // multiplied by 100 and the summ of individual progress of each file
    var files = this.getFiles();
    var inProgress = files.filter(function (file) {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });

    if (inProgress.length === 0) {
      this.emit('progress', 0);
      this.setState({
        totalProgress: 0
      });
      return;
    }

    var sizedFiles = inProgress.filter(function (file) {
      return file.progress.bytesTotal != null;
    });
    var unsizedFiles = inProgress.filter(function (file) {
      return file.progress.bytesTotal == null;
    });

    if (sizedFiles.length === 0) {
      var progressMax = inProgress.length * 100;
      var currentProgress = unsizedFiles.reduce(function (acc, file) {
        return acc + file.progress.percentage;
      }, 0);

      var _totalProgress = Math.round(currentProgress / progressMax * 100);

      this.setState({
        totalProgress: _totalProgress
      });
      return;
    }

    var totalSize = sizedFiles.reduce(function (acc, file) {
      return acc + file.progress.bytesTotal;
    }, 0);
    var averageSize = totalSize / sizedFiles.length;
    totalSize += averageSize * unsizedFiles.length;
    var uploadedSize = 0;
    sizedFiles.forEach(function (file) {
      uploadedSize += file.progress.bytesUploaded;
    });
    unsizedFiles.forEach(function (file) {
      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
    });
    var totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100); // hot fix, because:
    // uploadedSize ended up larger than totalSize, resulting in 1325% total

    if (totalProgress > 100) {
      totalProgress = 100;
    }

    this.setState({
      totalProgress: totalProgress
    });
    this.emit('progress', totalProgress);
  }
  /**
   * Registers listeners for all global actions, like:
   * `error`, `file-removed`, `upload-progress`
   */
  ;

  _proto.addListeners = function addListeners() {
    var _this6 = this;

    /**
     * @param {Error} error
     * @param {object} [file]
     * @param {object} [response]
     */
    var errorHandler = function errorHandler(error, file, response) {
      var errorMsg = error.message || 'Unknown error';

      if (error.details) {
        errorMsg += " " + error.details;
      }

      _this6.setState({
        error: errorMsg
      });

      if (file != null) {
        _this6.setFileState(file.id, {
          error: errorMsg,
          response: response
        });
      }
    };

    this.on('error', errorHandler);
    this.on('upload-error', function (file, error, response) {
      errorHandler(error, file, response);

      if (typeof error === 'object' && error.message) {
        var newError = new Error(error.message);
        newError.details = error.message;

        if (error.details) {
          newError.details += " " + error.details;
        }

        newError.message = _this6.i18n('failedToUpload', {
          file: file.name
        });

        _this6.showOrLogErrorAndThrow(newError, {
          throwErr: false
        });
      } else {
        _this6.showOrLogErrorAndThrow(error, {
          throwErr: false
        });
      }
    });
    this.on('upload', function () {
      _this6.setState({
        error: null
      });
    });
    this.on('upload-started', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: {
          uploadStarted: Date.now(),
          uploadComplete: false,
          percentage: 0,
          bytesUploaded: 0,
          bytesTotal: file.size
        }
      });
    });
    this.on('upload-progress', this.calculateProgress);
    this.on('upload-success', function (file, uploadResp) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var currentProgress = _this6.getFile(file.id).progress;

      _this6.setFileState(file.id, {
        progress: _extends({}, currentProgress, {
          postprocess: _this6.postProcessors.length > 0 ? {
            mode: 'indeterminate'
          } : null,
          uploadComplete: true,
          percentage: 100,
          bytesUploaded: currentProgress.bytesTotal
        }),
        response: uploadResp,
        uploadURL: uploadResp.uploadURL,
        isPaused: false
      });

      _this6.calculateTotalProgress();
    });
    this.on('preprocess-progress', function (file, progress) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: _extends({}, _this6.getFile(file.id).progress, {
          preprocess: progress
        })
      });
    });
    this.on('preprocess-complete', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var files = _extends({}, _this6.getState().files);

      files[file.id] = _extends({}, files[file.id], {
        progress: _extends({}, files[file.id].progress)
      });
      delete files[file.id].progress.preprocess;

      _this6.setState({
        files: files
      });
    });
    this.on('postprocess-progress', function (file, progress) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: _extends({}, _this6.getState().files[file.id].progress, {
          postprocess: progress
        })
      });
    });
    this.on('postprocess-complete', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var files = _extends({}, _this6.getState().files);

      files[file.id] = _extends({}, files[file.id], {
        progress: _extends({}, files[file.id].progress)
      });
      delete files[file.id].progress.postprocess; // TODO should we set some kind of `fullyComplete` property on the file object
      // so it's easier to see that the file is upload…fully complete…rather than
      // what we have to do now (`uploadComplete && !postprocess`)

      _this6.setState({
        files: files
      });
    });
    this.on('restored', function () {
      // Files may have changed--ensure progress is still accurate.
      _this6.calculateTotalProgress();
    }); // show informer if offline

    if (typeof window !== 'undefined' && window.addEventListener) {
      window.addEventListener('online', function () {
        return _this6.updateOnlineStatus();
      });
      window.addEventListener('offline', function () {
        return _this6.updateOnlineStatus();
      });
      setTimeout(function () {
        return _this6.updateOnlineStatus();
      }, 3000);
    }
  };

  _proto.updateOnlineStatus = function updateOnlineStatus() {
    var online = typeof window.navigator.onLine !== 'undefined' ? window.navigator.onLine : true;

    if (!online) {
      this.emit('is-offline');
      this.info(this.i18n('noInternetConnection'), 'error', 0);
      this.wasOffline = true;
    } else {
      this.emit('is-online');

      if (this.wasOffline) {
        this.emit('back-online');
        this.info(this.i18n('connectedToInternet'), 'success', 3000);
        this.wasOffline = false;
      }
    }
  };

  _proto.getID = function getID() {
    return this.opts.id;
  }
  /**
   * Registers a plugin with Core.
   *
   * @param {object} Plugin object
   * @param {object} [opts] object with options to be passed to Plugin
   * @returns {object} self for chaining
   */
  // eslint-disable-next-line no-shadow
  ;

  _proto.use = function use(Plugin, opts) {
    if (typeof Plugin !== 'function') {
      var msg = "Expected a plugin class, but got " + (Plugin === null ? 'null' : typeof Plugin) + "." + ' Please verify that the plugin was imported and spelled correctly.';
      throw new TypeError(msg);
    } // Instantiate


    var plugin = new Plugin(this, opts);
    var pluginId = plugin.id;
    this.plugins[plugin.type] = this.plugins[plugin.type] || [];

    if (!pluginId) {
      throw new Error('Your plugin must have an id');
    }

    if (!plugin.type) {
      throw new Error('Your plugin must have a type');
    }

    var existsPluginAlready = this.getPlugin(pluginId);

    if (existsPluginAlready) {
      var _msg = "Already found a plugin named '" + existsPluginAlready.id + "'. " + ("Tried to use: '" + pluginId + "'.\n") + 'Uppy plugins must have unique `id` options. See https://uppy.io/docs/plugins/#id.';

      throw new Error(_msg);
    }

    if (Plugin.VERSION) {
      this.log("Using " + pluginId + " v" + Plugin.VERSION);
    }

    this.plugins[plugin.type].push(plugin);
    plugin.install();
    return this;
  }
  /**
   * Find one Plugin by name.
   *
   * @param {string} id plugin id
   * @returns {object|boolean}
   */
  ;

  _proto.getPlugin = function getPlugin(id) {
    var foundPlugin = null;
    this.iteratePlugins(function (plugin) {
      if (plugin.id === id) {
        foundPlugin = plugin;
        return false;
      }
    });
    return foundPlugin;
  }
  /**
   * Iterate through all `use`d plugins.
   *
   * @param {Function} method that will be run on each plugin
   */
  ;

  _proto.iteratePlugins = function iteratePlugins(method) {
    var _this7 = this;

    Object.keys(this.plugins).forEach(function (pluginType) {
      _this7.plugins[pluginType].forEach(method);
    });
  }
  /**
   * Uninstall and remove a plugin.
   *
   * @param {object} instance The plugin instance to remove.
   */
  ;

  _proto.removePlugin = function removePlugin(instance) {
    var _extends4;

    this.log("Removing plugin " + instance.id);
    this.emit('plugin-remove', instance);

    if (instance.uninstall) {
      instance.uninstall();
    }

    var list = this.plugins[instance.type].slice(); // list.indexOf failed here, because Vue3 converted the plugin instance
    // to a Proxy object, which failed the strict comparison test:
    // obj !== objProxy

    var index = findIndex(list, function (item) {
      return item.id === instance.id;
    });

    if (index !== -1) {
      list.splice(index, 1);
      this.plugins[instance.type] = list;
    }

    var state = this.getState();
    var updatedState = {
      plugins: _extends({}, state.plugins, (_extends4 = {}, _extends4[instance.id] = undefined, _extends4))
    };
    this.setState(updatedState);
  }
  /**
   * Uninstall all plugins and close down this Uppy instance.
   */
  ;

  _proto.close = function close() {
    var _this8 = this;

    this.log("Closing Uppy instance " + this.opts.id + ": removing all files and uninstalling plugins");
    this.reset();
    this.storeUnsubscribe();
    this.iteratePlugins(function (plugin) {
      _this8.removePlugin(plugin);
    });
  }
  /**
   * Set info message in `state.info`, so that UI plugins like `Informer`
   * can display the message.
   *
   * @param {string | object} message Message to be displayed by the informer
   * @param {string} [type]
   * @param {number} [duration]
   */
  ;

  _proto.info = function info(message, type, duration) {
    if (type === void 0) {
      type = 'info';
    }

    if (duration === void 0) {
      duration = 3000;
    }

    var isComplexMessage = typeof message === 'object';
    this.setState({
      info: {
        isHidden: false,
        type: type,
        message: isComplexMessage ? message.message : message,
        details: isComplexMessage ? message.details : null
      }
    });
    this.emit('info-visible');
    clearTimeout(this.infoTimeoutID);

    if (duration === 0) {
      this.infoTimeoutID = undefined;
      return;
    } // hide the informer after `duration` milliseconds


    this.infoTimeoutID = setTimeout(this.hideInfo, duration);
  };

  _proto.hideInfo = function hideInfo() {
    var newInfo = _extends({}, this.getState().info, {
      isHidden: true
    });

    this.setState({
      info: newInfo
    });
    this.emit('info-hidden');
  }
  /**
   * Passes messages to a function, provided in `opts.logger`.
   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.
   *
   * @param {string|object} message to log
   * @param {string} [type] optional `error` or `warning`
   */
  ;

  _proto.log = function log(message, type) {
    var logger = this.opts.logger;

    switch (type) {
      case 'error':
        logger.error(message);
        break;

      case 'warning':
        logger.warn(message);
        break;

      default:
        logger.debug(message);
        break;
    }
  }
  /**
   * Obsolete, event listeners are now added in the constructor.
   */
  ;

  _proto.run = function run() {
    this.log('Calling run() is no longer necessary.', 'warning');
    return this;
  }
  /**
   * Restore an upload by its ID.
   */
  ;

  _proto.restore = function restore(uploadID) {
    this.log("Core: attempting to restore upload \"" + uploadID + "\"");

    if (!this.getState().currentUploads[uploadID]) {
      this.removeUpload(uploadID);
      return Promise.reject(new Error('Nonexistent upload'));
    }

    return this.runUpload(uploadID);
  }
  /**
   * Create an upload for a bunch of files.
   *
   * @param {Array<string>} fileIDs File IDs to include in this upload.
   * @returns {string} ID of this upload.
   */
  ;

  _proto.createUpload = function createUpload(fileIDs, opts) {
    var _extends5;

    if (opts === void 0) {
      opts = {};
    }

    // uppy.retryAll sets this to true — when retrying we want to ignore `allowNewUpload: false`
    var _opts = opts,
        _opts$forceAllowNewUp = _opts.forceAllowNewUpload,
        forceAllowNewUpload = _opts$forceAllowNewUp === void 0 ? false : _opts$forceAllowNewUp;

    var _this$getState6 = this.getState(),
        allowNewUpload = _this$getState6.allowNewUpload,
        currentUploads = _this$getState6.currentUploads;

    if (!allowNewUpload && !forceAllowNewUpload) {
      throw new Error('Cannot create a new upload: already uploading.');
    }

    var uploadID = cuid();
    this.emit('upload', {
      id: uploadID,
      fileIDs: fileIDs
    });
    this.setState({
      allowNewUpload: this.opts.allowMultipleUploads !== false,
      currentUploads: _extends({}, currentUploads, (_extends5 = {}, _extends5[uploadID] = {
        fileIDs: fileIDs,
        step: 0,
        result: {}
      }, _extends5))
    });
    return uploadID;
  };

  _proto.getUpload = function getUpload(uploadID) {
    var _this$getState7 = this.getState(),
        currentUploads = _this$getState7.currentUploads;

    return currentUploads[uploadID];
  }
  /**
   * Add data to an upload's result object.
   *
   * @param {string} uploadID The ID of the upload.
   * @param {object} data Data properties to add to the result object.
   */
  ;

  _proto.addResultData = function addResultData(uploadID, data) {
    var _extends6;

    if (!this.getUpload(uploadID)) {
      this.log("Not setting result for an upload that has been removed: " + uploadID);
      return;
    }

    var _this$getState8 = this.getState(),
        currentUploads = _this$getState8.currentUploads;

    var currentUpload = _extends({}, currentUploads[uploadID], {
      result: _extends({}, currentUploads[uploadID].result, data)
    });

    this.setState({
      currentUploads: _extends({}, currentUploads, (_extends6 = {}, _extends6[uploadID] = currentUpload, _extends6))
    });
  }
  /**
   * Remove an upload, eg. if it has been canceled or completed.
   *
   * @param {string} uploadID The ID of the upload.
   */
  ;

  _proto.removeUpload = function removeUpload(uploadID) {
    var currentUploads = _extends({}, this.getState().currentUploads);

    delete currentUploads[uploadID];
    this.setState({
      currentUploads: currentUploads
    });
  }
  /**
   * Run an upload. This picks up where it left off in case the upload is being restored.
   *
   * @private
   */
  ;

  _proto.runUpload = function runUpload(uploadID) {
    var _this9 = this;

    var uploadData = this.getState().currentUploads[uploadID];
    var restoreStep = uploadData.step;
    var steps = [].concat(this.preProcessors, this.uploaders, this.postProcessors);
    var lastStep = Promise.resolve();
    steps.forEach(function (fn, step) {
      // Skip this step if we are restoring and have already completed this step before.
      if (step < restoreStep) {
        return;
      }

      lastStep = lastStep.then(function () {
        var _extends7;

        var _this9$getState = _this9.getState(),
            currentUploads = _this9$getState.currentUploads;

        var currentUpload = currentUploads[uploadID];

        if (!currentUpload) {
          return;
        }

        var updatedUpload = _extends({}, currentUpload, {
          step: step
        });

        _this9.setState({
          currentUploads: _extends({}, currentUploads, (_extends7 = {}, _extends7[uploadID] = updatedUpload, _extends7))
        }); // TODO give this the `updatedUpload` object as its only parameter maybe?
        // Otherwise when more metadata may be added to the upload this would keep getting more parameters
        // eslint-disable-next-line consistent-return


        return fn(updatedUpload.fileIDs, uploadID);
      }).then(function () {
        return null;
      });
    }); // Not returning the `catch`ed promise, because we still want to return a rejected
    // promise from this method if the upload failed.

    lastStep.catch(function (err) {
      _this9.emit('error', err, uploadID);

      _this9.removeUpload(uploadID);
    });
    return lastStep.then(function () {
      // Set result data.
      var _this9$getState2 = _this9.getState(),
          currentUploads = _this9$getState2.currentUploads;

      var currentUpload = currentUploads[uploadID];

      if (!currentUpload) {
        return;
      } // Mark postprocessing step as complete if necessary; this addresses a case where we might get
      // stuck in the postprocessing UI while the upload is fully complete.
      // If the postprocessing steps do not do any work, they may not emit postprocessing events at
      // all, and never mark the postprocessing as complete. This is fine on its own but we
      // introduced code in the @uppy/core upload-success handler to prepare postprocessing progress
      // state if any postprocessors are registered. That is to avoid a "flash of completed state"
      // before the postprocessing plugins can emit events.
      //
      // So, just in case an upload with postprocessing plugins *has* completed *without* emitting
      // postprocessing completion, we do it instead.


      currentUpload.fileIDs.forEach(function (fileID) {
        var file = _this9.getFile(fileID);

        if (file && file.progress.postprocess) {
          _this9.emit('postprocess-complete', file);
        }
      });
      var files = currentUpload.fileIDs.map(function (fileID) {
        return _this9.getFile(fileID);
      });
      var successful = files.filter(function (file) {
        return !file.error;
      });
      var failed = files.filter(function (file) {
        return file.error;
      });

      _this9.addResultData(uploadID, {
        successful: successful,
        failed: failed,
        uploadID: uploadID
      });
    }).then(function () {
      // Emit completion events.
      // This is in a separate function so that the `currentUploads` variable
      // always refers to the latest state. In the handler right above it refers
      // to an outdated object without the `.result` property.
      var _this9$getState3 = _this9.getState(),
          currentUploads = _this9$getState3.currentUploads;

      if (!currentUploads[uploadID]) {
        return;
      }

      var currentUpload = currentUploads[uploadID];
      var result = currentUpload.result;

      _this9.emit('complete', result);

      _this9.removeUpload(uploadID); // eslint-disable-next-line consistent-return


      return result;
    }).then(function (result) {
      if (result == null) {
        _this9.log("Not setting result for an upload that has been removed: " + uploadID);
      }

      return result;
    });
  }
  /**
   * Start an upload for all the files that are not currently being uploaded.
   *
   * @returns {Promise}
   */
  ;

  _proto.upload = function upload() {
    var _this10 = this;

    if (!this.plugins.uploader) {
      this.log('No uploader type plugins are used', 'warning');
    }

    var _this$getState9 = this.getState(),
        files = _this$getState9.files;

    var onBeforeUploadResult = this.opts.onBeforeUpload(files);

    if (onBeforeUploadResult === false) {
      return Promise.reject(new Error('Not starting the upload because onBeforeUpload returned false'));
    }

    if (onBeforeUploadResult && typeof onBeforeUploadResult === 'object') {
      files = onBeforeUploadResult; // Updating files in state, because uploader plugins receive file IDs,
      // and then fetch the actual file object from state

      this.setState({
        files: files
      });
    }

    return Promise.resolve().then(function () {
      return _this10.checkMinNumberOfFiles(files);
    }).catch(function (err) {
      _this10.showOrLogErrorAndThrow(err);
    }).then(function () {
      var _this10$getState = _this10.getState(),
          currentUploads = _this10$getState.currentUploads; // get a list of files that are currently assigned to uploads


      var currentlyUploadingFiles = Object.keys(currentUploads).reduce(function (prev, curr) {
        return prev.concat(currentUploads[curr].fileIDs);
      }, []);
      var waitingFileIDs = [];
      Object.keys(files).forEach(function (fileID) {
        var file = _this10.getFile(fileID); // if the file hasn't started uploading and hasn't already been assigned to an upload..


        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
          waitingFileIDs.push(file.id);
        }
      });

      var uploadID = _this10.createUpload(waitingFileIDs);

      return _this10.runUpload(uploadID);
    }).catch(function (err) {
      _this10.showOrLogErrorAndThrow(err, {
        showInformer: false
      });
    });
  };

  _createClass(Uppy, [{
    key: "state",
    get: function get() {
      return this.getState();
    }
  }]);

  return Uppy;
}();

Uppy.VERSION = version;

module.exports = function core(opts) {
  return new Uppy(opts);
}; // Expose class constructor.


module.exports.Uppy = Uppy;
module.exports.Plugin = Plugin;
module.exports.debugLogger = debugLogger;

},{"../package.json":71,"./../../store-default":156,"./../../utils/lib/Translator":202,"./../../utils/lib/findIndex":209,"./../../utils/lib/generateFileID":210,"./../../utils/lib/getFileNameAndExtension":217,"./../../utils/lib/getFileType":218,"./Plugin":72,"./loggers":74,"./supportsUploadProgress":75,"@transloadit/prettier-bytes":1,"cuid":13,"lodash.throttle":32,"mime-match":35,"namespace-emitter":36}],74:[function(require,module,exports){
var getTimeStamp = require('./../../utils/lib/getTimeStamp'); // Swallow all logs, except errors.
// default if logger is not set or debug: false


var justErrorsLogger = {
  debug: function debug() {},
  warn: function warn() {},
  error: function error() {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  }
}; // Print logs to console with namespace + timestamp,
// set by logger: Uppy.debugLogger or debug: true

var debugLogger = {
  debug: function debug() {
    // IE 10 doesn’t support console.debug
    var debug = console.debug || console.log;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    debug.call.apply(debug, [console, "[Uppy] [" + getTimeStamp() + "]"].concat(args));
  },
  warn: function warn() {
    var _console2;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return (_console2 = console).warn.apply(_console2, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  },
  error: function error() {
    var _console3;

    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return (_console3 = console).error.apply(_console3, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  }
};
module.exports = {
  justErrorsLogger: justErrorsLogger,
  debugLogger: debugLogger
};

},{"./../../utils/lib/getTimeStamp":223}],75:[function(require,module,exports){
// Edge 15.x does not fire 'progress' events on uploads.
// See https://github.com/transloadit/uppy/issues/945
// And https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12224510/
module.exports = function supportsUploadProgress(userAgent) {
  // Allow passing in userAgent for tests
  if (userAgent == null) {
    userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : null;
  } // Assume it works because basically everything supports progress events.


  if (!userAgent) return true;
  var m = /Edge\/(\d+\.\d+)/.exec(userAgent);
  if (!m) return true;
  var edgeVersion = m[1];

  var _edgeVersion$split = edgeVersion.split('.'),
      major = _edgeVersion$split[0],
      minor = _edgeVersion$split[1];

  major = parseInt(major, 10);
  minor = parseInt(minor, 10); // Worked before:
  // Edge 40.15063.0.0
  // Microsoft EdgeHTML 15.15063

  if (major < 15 || major === 15 && minor < 15063) {
    return true;
  } // Fixed in:
  // Microsoft EdgeHTML 18.18218


  if (major > 18 || major === 18 && minor >= 18218) {
    return true;
  } // other versions don't work.


  return false;
};

},{}],76:[function(require,module,exports){
module.exports={
  "name": "@uppy/dashboard",
  "description": "Universal UI plugin for Uppy.",
  "version": "1.20.1",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dashboard",
    "ui"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/informer": "file:../informer",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/status-bar": "file:../status-bar",
    "@uppy/thumbnail-generator": "file:../thumbnail-generator",
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "cuid": "^2.1.1",
    "is-shallow-equal": "^1.0.1",
    "lodash.debounce": "^4.0.8",
    "lodash.throttle": "^4.1.1",
    "memoize-one": "^5.0.4",
    "preact": "8.2.9",
    "resize-observer-polyfill": "^1.5.0"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],77:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var AddFiles = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AddFiles, _Component);

  function AddFiles() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _this.triggerFileInputClick = function () {
      _this.fileInput.click();
    };

    _this.triggerFolderInputClick = function () {
      _this.folderInput.click();
    };

    _this.onFileInputChange = function (event) {
      _this.props.handleInputChange(event); // We clear the input after a file is selected, because otherwise
      // change event is not fired in Chrome and Safari when a file
      // with the same name is selected.
      // ___Why not use value="" on <input/> instead?
      //    Because if we use that method of clearing the input,
      //    Chrome will not trigger change if we drop the same file twice (Issue #768).


      event.target.value = null;
    };

    _this.renderHiddenInput = function (isFolder, refCallback) {
      return h("input", {
        className: "uppy-Dashboard-input",
        hidden: true,
        "aria-hidden": "true",
        tabIndex: -1,
        webkitdirectory: isFolder,
        type: "file",
        name: "files[]",
        multiple: _this.props.maxNumberOfFiles !== 1,
        onChange: _this.onFileInputChange,
        accept: _this.props.allowedFileTypes,
        ref: refCallback
      });
    };

    _this.renderMyDeviceAcquirer = function () {
      return h("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": "MyDevice"
      }, h("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "data-uppy-super-focusable": true,
        onClick: _this.triggerFileInputClick
      }, h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#2275D7"
      }), h("path", {
        d: "M21.973 21.152H9.863l-1.108-5.087h14.464l-1.246 5.087zM9.935 11.37h3.958l.886 1.444a.673.673 0 0 0 .585.316h6.506v1.37H9.935v-3.13zm14.898 3.44a.793.793 0 0 0-.616-.31h-.978v-2.126c0-.379-.275-.613-.653-.613H15.75l-.886-1.445a.673.673 0 0 0-.585-.316H9.232c-.378 0-.667.209-.667.587V14.5h-.782a.793.793 0 0 0-.61.303.795.795 0 0 0-.155.663l1.45 6.633c.078.36.396.618.764.618h13.354c.36 0 .674-.246.76-.595l1.631-6.636a.795.795 0 0 0-.144-.675z",
        fill: "#FFF"
      }))), h("div", {
        className: "uppy-DashboardTab-name"
      }, _this.props.i18n('myDevice'))));
    };

    _this.renderBrowseButton = function (text, onClickFn) {
      var numberOfAcquirers = _this.props.acquirers.length;
      return h("button", {
        type: "button",
        className: "uppy-u-reset uppy-Dashboard-browse",
        onClick: onClickFn,
        "data-uppy-super-focusable": numberOfAcquirers === 0
      }, text);
    };

    _this.renderDropPasteBrowseTagline = function () {
      var numberOfAcquirers = _this.props.acquirers.length; // in order to keep the i18n CamelCase and options lower (as are defaults) we will want to transform a lower
      // to Camel

      var lowerFMSelectionType = _this.props.fileManagerSelectionType;
      var camelFMSelectionType = lowerFMSelectionType.charAt(0).toUpperCase() + lowerFMSelectionType.slice(1); // For backwards compatibility, we need to support both 'browse' and 'browseFiles'/'browseFolders' as strings here.

      var browseText = 'browse';
      var browseFilesText = 'browse';
      var browseFoldersText = 'browse';

      if (lowerFMSelectionType === 'files') {
        try {
          browseText = _this.props.i18n('browse');
          browseFilesText = _this.props.i18n('browse');
          browseFoldersText = _this.props.i18n('browse');
        } catch (_unused) {// Ignore, hopefully we can use the 'browseFiles' / 'browseFolders' strings
        }
      }

      try {
        browseFilesText = _this.props.i18n('browseFiles');
        browseFoldersText = _this.props.i18n('browseFolders');
      } catch (_unused2) {// Ignore, use the 'browse' string
      }

      var browse = _this.renderBrowseButton(browseText, _this.triggerFileInputClick);

      var browseFiles = _this.renderBrowseButton(browseFilesText, _this.triggerFileInputClick);

      var browseFolders = _this.renderBrowseButton(browseFoldersText, _this.triggerFolderInputClick); // Before the `fileManagerSelectionType` feature existed, we had two possible
      // strings here, but now we have six. We use the new-style strings by default:


      var titleText;

      if (numberOfAcquirers > 0) {
        titleText = _this.props.i18nArray("dropPasteImport" + camelFMSelectionType, {
          browseFiles: browseFiles,
          browseFolders: browseFolders,
          browse: browse
        });
      } else {
        titleText = _this.props.i18nArray("dropPaste" + camelFMSelectionType, {
          browseFiles: browseFiles,
          browseFolders: browseFolders,
          browse: browse
        });
      } // We use the old-style strings if available: this implies that the user has
      // manually specified them, so they should take precedence over the new-style
      // defaults.


      if (lowerFMSelectionType === 'files') {
        try {
          if (numberOfAcquirers > 0) {
            titleText = _this.props.i18nArray('dropPasteImport', {
              browse: browse
            });
          } else {
            titleText = _this.props.i18nArray('dropPaste', {
              browse: browse
            });
          }
        } catch (_unused3) {// Ignore, the new-style strings will be used.
        }
      }

      if (_this.props.disableLocalFiles) {
        titleText = _this.props.i18n('importFiles');
      }

      return h("div", {
        className: "uppy-Dashboard-AddFiles-title"
      }, titleText);
    };

    _this.renderAcquirer = function (acquirer) {
      return h("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": acquirer.id
      }, h("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "aria-controls": "uppy-DashboardContent-panel--" + acquirer.id,
        "aria-selected": _this.props.activePickerPanel.id === acquirer.id,
        "data-uppy-super-focusable": true,
        onClick: function onClick() {
          return _this.props.showPanel(acquirer.id);
        }
      }, acquirer.icon(), h("div", {
        className: "uppy-DashboardTab-name"
      }, acquirer.name)));
    };

    _this.renderAcquirers = function (acquirers, disableLocalFiles) {
      // Group last two buttons, so we don’t end up with
      // just one button on a new line
      var acquirersWithoutLastTwo = [].concat(acquirers);
      var lastTwoAcquirers = acquirersWithoutLastTwo.splice(acquirers.length - 2, acquirers.length);
      return h("div", {
        className: "uppy-Dashboard-AddFiles-list",
        role: "tablist"
      }, !disableLocalFiles && _this.renderMyDeviceAcquirer(), acquirersWithoutLastTwo.map(function (acquirer) {
        return _this.renderAcquirer(acquirer);
      }), h("span", {
        role: "presentation",
        style: "white-space: nowrap;"
      }, lastTwoAcquirers.map(function (acquirer) {
        return _this.renderAcquirer(acquirer);
      })));
    };

    return _this;
  }

  var _proto = AddFiles.prototype;

  _proto.renderPoweredByUppy = function renderPoweredByUppy() {
    var uppyBranding = h("span", null, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-poweredByIcon",
      width: "11",
      height: "11",
      viewBox: "0 0 11 11"
    }, h("path", {
      d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
      fillRule: "evenodd"
    })), h("span", {
      className: "uppy-Dashboard-poweredByUppy"
    }, "Uppy")); // Support both the old word-order-insensitive string `poweredBy` and the new word-order-sensitive string `poweredBy2`

    var linkText = this.props.i18nArray('poweredBy2', {
      backwardsCompat: this.props.i18n('poweredBy'),
      uppy: uppyBranding
    });
    return h("a", {
      tabIndex: "-1",
      href: "https://uppy.io",
      rel: "noreferrer noopener",
      target: "_blank",
      className: "uppy-Dashboard-poweredBy"
    }, linkText);
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-Dashboard-AddFiles"
    }, this.renderHiddenInput(false, function (ref) {
      _this2.fileInput = ref;
    }), this.renderHiddenInput(true, function (ref) {
      _this2.folderInput = ref;
    }), this.renderDropPasteBrowseTagline(), this.props.acquirers.length > 0 && this.renderAcquirers(this.props.acquirers, this.props.disableLocalFiles), h("div", {
      className: "uppy-Dashboard-AddFiles-info"
    }, this.props.note && h("div", {
      className: "uppy-Dashboard-note"
    }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props)));
  };

  return AddFiles;
}(Component);

module.exports = AddFiles;

},{"preact":37}],78:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var AddFiles = require('./AddFiles');

var AddFilesPanel = function AddFilesPanel(props) {
  return h("div", {
    className: classNames('uppy-Dashboard-AddFilesPanel', props.className),
    "data-uppy-panelType": "AddFiles",
    "aria-hidden": props.showAddFilesPanel
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n('addingMoreFiles')), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: function onClick(ev) {
      return props.toggleAddFilesPanel(false);
    }
  }, props.i18n('back'))), h(AddFiles, props));
};

module.exports = AddFilesPanel;

},{"./AddFiles":77,"classnames":10,"preact":37}],79:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var FileList = require('./FileList');

var AddFiles = require('./AddFiles');

var AddFilesPanel = require('./AddFilesPanel');

var PickerPanelContent = require('./PickerPanelContent');

var EditorPanel = require('./EditorPanel');

var PanelTopBar = require('./PickerPanelTopBar');

var FileCard = require('./FileCard');

var Slide = require('./Slide');

var isDragDropSupported = require('./../../../utils/lib/isDragDropSupported'); // http://dev.edenspiekermann.com/2016/02/11/introducing-accessible-modal-dialog
// https://github.com/ghosh/micromodal


var WIDTH_XL = 900;
var WIDTH_LG = 700;
var WIDTH_MD = 576;
var HEIGHT_MD = 400;

module.exports = function Dashboard(props) {
  var noFiles = props.totalFileCount === 0;
  var isSizeMD = props.containerWidth > WIDTH_MD;
  var wrapperClassName = classNames({
    'uppy-Root': props.isTargetDOMEl
  });
  var dashboardClassName = classNames({
    'uppy-Dashboard': true,
    'uppy-Dashboard--isDisabled': props.disabled,
    'uppy-Dashboard--animateOpenClose': props.animateOpenClose,
    'uppy-Dashboard--isClosing': props.isClosing,
    'uppy-Dashboard--isDraggingOver': props.isDraggingOver,
    'uppy-Dashboard--modal': !props.inline,
    'uppy-size--md': props.containerWidth > WIDTH_MD,
    'uppy-size--lg': props.containerWidth > WIDTH_LG,
    'uppy-size--xl': props.containerWidth > WIDTH_XL,
    'uppy-size--height-md': props.containerHeight > HEIGHT_MD,
    'uppy-Dashboard--isAddFilesPanelVisible': props.showAddFilesPanel,
    'uppy-Dashboard--isInnerWrapVisible': props.areInsidesReadyToBeVisible
  }); // Important: keep these in sync with the percent width values in `src/components/FileItem/index.scss`.

  var itemsPerRow = 1; // mobile

  if (props.containerWidth > WIDTH_XL) {
    itemsPerRow = 5;
  } else if (props.containerWidth > WIDTH_LG) {
    itemsPerRow = 4;
  } else if (props.containerWidth > WIDTH_MD) {
    itemsPerRow = 3;
  }

  var showFileList = props.showSelectedFiles && !noFiles;
  var numberOfFilesForRecovery = props.recoveredState ? Object.keys(props.recoveredState.files).length : null;
  var numberOfGhosts = props.files ? Object.keys(props.files).filter(function (fileID) {
    return props.files[fileID].isGhost;
  }).length : null;

  var renderRestoredText = function renderRestoredText() {
    if (numberOfGhosts > 0) {
      return props.i18n('recoveredXFiles', {
        smart_count: numberOfGhosts
      });
    }

    return props.i18n('recoveredAllFiles');
  };

  var dashboard = h("div", {
    className: dashboardClassName,
    "data-uppy-theme": props.theme,
    "data-uppy-num-acquirers": props.acquirers.length,
    "data-uppy-drag-drop-supported": !props.disableLocalFiles && isDragDropSupported(),
    "aria-hidden": props.inline ? 'false' : props.isHidden,
    "aria-disabled": props.disabled,
    "aria-label": !props.inline ? props.i18n('dashboardWindowTitle') : props.i18n('dashboardTitle'),
    onPaste: props.handlePaste,
    onDragOver: props.handleDragOver,
    onDragLeave: props.handleDragLeave,
    onDrop: props.handleDrop
  }, h("div", {
    className: "uppy-Dashboard-overlay",
    tabIndex: -1,
    onClick: props.handleClickOutside
  }), h("div", {
    className: "uppy-Dashboard-inner",
    "aria-modal": !props.inline && 'true',
    role: !props.inline && 'dialog',
    style: {
      width: props.inline && props.width ? props.width : '',
      height: props.inline && props.height ? props.height : ''
    }
  }, !props.inline ? h("button", {
    className: "uppy-u-reset uppy-Dashboard-close",
    type: "button",
    "aria-label": props.i18n('closeModal'),
    title: props.i18n('closeModal'),
    onClick: props.closeModal
  }, h("span", {
    "aria-hidden": "true"
  }, "\xD7")) : null, h("div", {
    className: "uppy-Dashboard-innerWrap"
  }, h("div", {
    className: "uppy-Dashboard-dropFilesHereHint"
  }, props.i18n('dropHint')), showFileList && h(PanelTopBar, props), numberOfFilesForRecovery && h("div", {
    className: "uppy-Dashboard-serviceMsg"
  }, h("svg", {
    className: "uppy-Dashboard-serviceMsg-icon",
    "aria-hidden": "true",
    focusable: "false",
    width: "21",
    height: "16",
    viewBox: "0 0 24 19"
  }, h("g", {
    transform: "translate(0 -1)",
    fill: "none",
    fillRule: "evenodd"
  }, h("path", {
    d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z",
    fill: "#FFD300"
  }), h("path", {
    fill: "#000",
    d: "M11 6h2l-.3 8h-1.4z"
  }), h("circle", {
    fill: "#000",
    cx: "12",
    cy: "17",
    r: "1"
  }))), h("strong", {
    className: "uppy-Dashboard-serviceMsg-title"
  }, props.i18n('sessionRestored')), h("div", {
    class: "uppy-Dashboard-serviceMsg-text"
  }, renderRestoredText())), showFileList ? h(FileList, _extends({}, props, {
    itemsPerRow: itemsPerRow
  })) : h(AddFiles, _extends({}, props, {
    isSizeMD: isSizeMD
  })), h(Slide, null, props.showAddFilesPanel ? h(AddFilesPanel, _extends({
    key: "AddFiles"
  }, props, {
    isSizeMD: isSizeMD
  })) : null), h(Slide, null, props.fileCardFor ? h(FileCard, _extends({
    key: "FileCard"
  }, props)) : null), h(Slide, null, props.activePickerPanel ? h(PickerPanelContent, _extends({
    key: "Picker"
  }, props)) : null), h(Slide, null, props.showFileEditor ? h(EditorPanel, _extends({
    key: "Editor"
  }, props)) : null), h("div", {
    className: "uppy-Dashboard-progressindicators"
  }, props.progressindicators.map(function (target) {
    return props.getPlugin(target.id).render(props.state);
  })))));
  return (// Wrap it for RTL language support
    h("div", {
      className: wrapperClassName,
      dir: props.direction
    }, dashboard)
  );
};

},{"./../../../utils/lib/isDragDropSupported":226,"./AddFiles":77,"./AddFilesPanel":78,"./EditorPanel":80,"./FileCard":81,"./FileList":87,"./PickerPanelContent":89,"./PickerPanelTopBar":90,"./Slide":91,"classnames":10,"preact":37}],80:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

function EditorPanel(props) {
  var file = this.props.files[this.props.fileCardFor];
  return h("div", {
    className: classNames('uppy-DashboardContent-panel', props.className),
    role: "tabpanel",
    "data-uppy-panelType": "FileEditor",
    id: "uppy-DashboardContent-panel--editor"
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18nArray('editing', {
    file: h("span", {
      className: "uppy-DashboardContent-titleFile"
    }, file.meta ? file.meta.name : file.name)
  })), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n('done'))), h("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.editors.map(function (target) {
    return props.getPlugin(target.id).render(props.state);
  })));
}

module.exports = EditorPanel;

},{"classnames":10,"preact":37}],81:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var classNames = require('classnames');

var getFileTypeIcon = require('../../utils/getFileTypeIcon');

var ignoreEvent = require('../../utils/ignoreEvent.js');

var FilePreview = require('../FilePreview');

var FileCard = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FileCard, _Component);

  function FileCard(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.saveOnEnter = function (ev) {
      if (ev.keyCode === 13) {
        ev.stopPropagation();
        ev.preventDefault();
        var file = _this.props.files[_this.props.fileCardFor];

        _this.props.saveFileCard(_this.state.formState, file.id);
      }
    };

    _this.updateMeta = function (newVal, name) {
      var _extends2;

      _this.setState({
        formState: _extends({}, _this.state.formState, (_extends2 = {}, _extends2[name] = newVal, _extends2))
      });
    };

    _this.handleSave = function () {
      var fileID = _this.props.fileCardFor;

      _this.props.saveFileCard(_this.state.formState, fileID);
    };

    _this.handleCancel = function () {
      _this.props.toggleFileCard(false);
    };

    _this.renderMetaFields = function () {
      var metaFields = _this.getMetaFields() || [];
      var fieldCSSClasses = {
        text: 'uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input'
      };
      return metaFields.map(function (field) {
        var id = "uppy-Dashboard-FileCard-input-" + field.id;
        return h("fieldset", {
          key: field.id,
          className: "uppy-Dashboard-FileCard-fieldset"
        }, h("label", {
          className: "uppy-Dashboard-FileCard-label",
          htmlFor: id
        }, field.name), field.render !== undefined ? field.render({
          value: _this.state.formState[field.id],
          onChange: function onChange(newVal) {
            return _this.updateMeta(newVal, field.id);
          },
          fieldCSSClasses: fieldCSSClasses
        }, h) : h("input", {
          className: fieldCSSClasses.text,
          id: id,
          type: field.type || 'text',
          value: _this.state.formState[field.id],
          placeholder: field.placeholder,
          onKeyUp: _this.saveOnEnter,
          onKeyDown: _this.saveOnEnter,
          onKeyPress: _this.saveOnEnter,
          onInput: function onInput(ev) {
            return _this.updateMeta(ev.target.value, field.id);
          },
          "data-uppy-super-focusable": true
        }));
      });
    };

    var _file = _this.props.files[_this.props.fileCardFor];

    var _metaFields = _this.getMetaFields() || [];

    var storedMetaData = {};

    _metaFields.forEach(function (field) {
      storedMetaData[field.id] = _file.meta[field.id] || '';
    });

    _this.state = {
      formState: storedMetaData
    };
    return _this;
  }

  var _proto = FileCard.prototype;

  _proto.getMetaFields = function getMetaFields() {
    return typeof this.props.metaFields === 'function' ? this.props.metaFields(this.props.files[this.props.fileCardFor]) : this.props.metaFields;
  };

  _proto.render = function render() {
    var _this2 = this;

    var file = this.props.files[this.props.fileCardFor];
    var showEditButton = this.props.canEditFile(file);
    return h("div", {
      className: classNames('uppy-Dashboard-FileCard', this.props.className),
      "data-uppy-panelType": "FileCard",
      onDragOver: ignoreEvent,
      onDragLeave: ignoreEvent,
      onDrop: ignoreEvent,
      onPaste: ignoreEvent
    }, h("div", {
      className: "uppy-DashboardContent-bar"
    }, h("div", {
      className: "uppy-DashboardContent-title",
      role: "heading",
      "aria-level": "1"
    }, this.props.i18nArray('editing', {
      file: h("span", {
        className: "uppy-DashboardContent-titleFile"
      }, file.meta ? file.meta.name : file.name)
    })), h("button", {
      className: "uppy-DashboardContent-back",
      type: "button",
      title: this.props.i18n('finishEditingFile'),
      onClick: this.handleSave
    }, this.props.i18n('done'))), h("div", {
      className: "uppy-Dashboard-FileCard-inner"
    }, h("div", {
      className: "uppy-Dashboard-FileCard-preview",
      style: {
        backgroundColor: getFileTypeIcon(file.type).color
      }
    }, h(FilePreview, {
      file: file
    }), showEditButton && h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit",
      onClick: function onClick() {
        return _this2.props.openFileEditor(file);
      }
    }, this.props.i18n('editFile'))), h("div", {
      className: "uppy-Dashboard-FileCard-info"
    }, this.renderMetaFields()), h("div", {
      className: "uppy-Dashboard-FileCard-actions"
    }, h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onClick: this.handleSave
    }, this.props.i18n('saveChanges')), h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onClick: this.handleCancel
    }, this.props.i18n('cancel')))));
  };

  return FileCard;
}(Component);

module.exports = FileCard;

},{"../../utils/getFileTypeIcon":97,"../../utils/ignoreEvent.js":98,"../FilePreview":88,"classnames":10,"preact":37}],82:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var copyToClipboard = require('../../../utils/copyToClipboard');

function EditButton(_ref) {
  var file = _ref.file,
      uploadInProgressOrComplete = _ref.uploadInProgressOrComplete,
      metaFields = _ref.metaFields,
      canEditFile = _ref.canEditFile,
      i18n = _ref.i18n,
      _onClick = _ref.onClick;

  if (!uploadInProgressOrComplete && metaFields && metaFields.length > 0 || !uploadInProgressOrComplete && canEditFile(file)) {
    return h("button", {
      className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit",
      type: "button",
      "aria-label": i18n('editFile') + " " + file.meta.name,
      title: i18n('editFile'),
      onClick: function onClick() {
        return _onClick();
      }
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "14",
      height: "14",
      viewBox: "0 0 14 14"
    }, h("g", {
      fillRule: "evenodd"
    }, h("path", {
      d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
      fillRule: "nonzero"
    }), h("rect", {
      x: "1",
      y: "12.293",
      width: "11",
      height: "1",
      rx: ".5"
    }), h("path", {
      fillRule: "nonzero",
      d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
    }))));
  }

  return null;
}

function RemoveButton(_ref2) {
  var i18n = _ref2.i18n,
      _onClick2 = _ref2.onClick;
  return h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove",
    type: "button",
    "aria-label": i18n('removeFile'),
    title: i18n('removeFile'),
    onClick: function onClick() {
      return _onClick2();
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "18",
    height: "18",
    viewBox: "0 0 18 18"
  }, h("path", {
    d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
  }), h("path", {
    fill: "#FFF",
    d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
  })));
}

var copyLinkToClipboard = function copyLinkToClipboard(event, props) {
  copyToClipboard(props.file.uploadURL, props.i18n('copyLinkToClipboardFallback')).then(function () {
    props.log('Link copied to clipboard.');
    props.info(props.i18n('copyLinkToClipboardSuccess'), 'info', 3000);
  }).catch(props.log) // avoid losing focus
  .then(function () {
    return event.target.focus({
      preventScroll: true
    });
  });
};

function CopyLinkButton(props) {
  return h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink",
    type: "button",
    "aria-label": props.i18n('copyLink'),
    title: props.i18n('copyLink'),
    onClick: function onClick(event) {
      return copyLinkToClipboard(event, props);
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 12"
  }, h("path", {
    d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
  })));
}

module.exports = function Buttons(props) {
  var file = props.file,
      uploadInProgressOrComplete = props.uploadInProgressOrComplete,
      canEditFile = props.canEditFile,
      metaFields = props.metaFields,
      showLinkToFileUploadResult = props.showLinkToFileUploadResult,
      showRemoveButton = props.showRemoveButton,
      i18n = props.i18n,
      removeFile = props.removeFile,
      toggleFileCard = props.toggleFileCard,
      openFileEditor = props.openFileEditor,
      log = props.log,
      info = props.info;

  var editAction = function editAction() {
    if (metaFields && metaFields.length > 0) {
      toggleFileCard(true, file.id);
    } else {
      openFileEditor(file);
    }
  };

  return h("div", {
    className: "uppy-Dashboard-Item-actionWrapper"
  }, h(EditButton, {
    i18n: i18n,
    file: file,
    uploadInProgressOrComplete: uploadInProgressOrComplete,
    canEditFile: canEditFile,
    metaFields: metaFields,
    onClick: editAction
  }), showLinkToFileUploadResult && file.uploadURL ? h(CopyLinkButton, {
    file: file,
    i18n: i18n,
    info: info,
    log: log
  }) : null, showRemoveButton ? h(RemoveButton, {
    i18n: i18n,
    info: props.info,
    log: props.log,
    onClick: function onClick() {
      return removeFile(file.id, 'removed-by-user');
    }
  }) : null);
};

},{"../../../utils/copyToClipboard":94,"preact":37}],83:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var prettierBytes = require('@transloadit/prettier-bytes');

var truncateString = require('./../../../../../utils/lib/truncateString');

var renderAcquirerIcon = function renderAcquirerIcon(acquirer, props) {
  return h("span", {
    title: props.i18n('fileSource', {
      name: acquirer.name
    })
  }, acquirer.icon());
};

var renderFileName = function renderFileName(props) {
  // Take up at most 2 lines on any screen
  var maxNameLength; // For very small mobile screens

  if (props.containerWidth <= 352) {
    maxNameLength = 35; // For regular mobile screens
  } else if (props.containerWidth <= 576) {
    maxNameLength = 60; // For desktops
  } else {
    maxNameLength = 30;
  }

  return h("div", {
    className: "uppy-Dashboard-Item-name",
    title: props.file.meta.name
  }, truncateString(props.file.meta.name, maxNameLength));
};

var renderFileSize = function renderFileSize(props) {
  return props.file.size && h("div", {
    className: "uppy-Dashboard-Item-statusSize"
  }, prettierBytes(props.file.size));
};

var ReSelectButton = function ReSelectButton(props) {
  return props.file.isGhost && h("span", null, " \u2022 ", h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect",
    type: "button",
    onClick: props.toggleAddFilesPanel
  }, props.i18n('reSelect')));
};

var ErrorButton = function ErrorButton(_ref) {
  var file = _ref.file,
      onClick = _ref.onClick;

  if (file.error) {
    return h("span", {
      className: "uppy-Dashboard-Item-errorDetails",
      "aria-label": file.error,
      "data-microtip-position": "bottom",
      "data-microtip-size": "medium",
      role: "tooltip",
      onClick: onClick
    }, "?");
  }

  return null;
};

module.exports = function FileInfo(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-fileInfo",
    "data-uppy-file-source": props.file.source
  }, renderFileName(props), h("div", {
    className: "uppy-Dashboard-Item-status"
  }, renderFileSize(props), ReSelectButton(props), h(ErrorButton, {
    file: props.file,
    onClick: function onClick() {
      alert(props.file.error);
    }
  })));
};

},{"./../../../../../utils/lib/truncateString":236,"@transloadit/prettier-bytes":1,"preact":37}],84:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var FilePreview = require('../../FilePreview');

var getFileTypeIcon = require('../../../utils/getFileTypeIcon');

module.exports = function FilePreviewAndLink(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-previewInnerWrap",
    style: {
      backgroundColor: getFileTypeIcon(props.file.type).color
    }
  }, props.showLinkToFileUploadResult && props.file.uploadURL && h("a", {
    className: "uppy-Dashboard-Item-previewLink",
    href: props.file.uploadURL,
    rel: "noreferrer noopener",
    target: "_blank",
    "aria-label": props.file.meta.name
  }), h(FilePreview, {
    file: props.file
  }));
};

},{"../../../utils/getFileTypeIcon":97,"../../FilePreview":88,"preact":37}],85:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function onPauseResumeCancelRetry(props) {
  if (props.isUploaded) return;

  if (props.error && !props.hideRetryButton) {
    props.retryUpload(props.file.id);
    return;
  }

  if (props.resumableUploads && !props.hidePauseResumeButton) {
    props.pauseUpload(props.file.id);
  } else if (props.individualCancellation && !props.hideCancelButton) {
    props.cancelUpload(props.file.id);
  }
}

function progressIndicatorTitle(props) {
  if (props.isUploaded) {
    return props.i18n('uploadComplete');
  }

  if (props.error) {
    return props.i18n('retryUpload');
  }

  if (props.resumableUploads) {
    if (props.file.isPaused) {
      return props.i18n('resumeUpload');
    }

    return props.i18n('pauseUpload');
  }

  if (props.individualCancellation) {
    return props.i18n('cancelUpload');
  }

  return '';
}

function ProgressIndicatorButton(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-progressIndicator",
    type: "button",
    "aria-label": progressIndicatorTitle(props),
    title: progressIndicatorTitle(props),
    onClick: function onClick() {
      return onPauseResumeCancelRetry(props);
    }
  }, props.children));
}

function ProgressCircleContainer(_ref) {
  var children = _ref.children;
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "70",
    height: "70",
    viewBox: "0 0 36 36",
    className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle"
  }, children);
}

function ProgressCircle(_ref2) {
  var progress = _ref2.progress;
  // circle length equals 2 * PI * R
  var circleLength = 2 * Math.PI * 15;
  return h("g", null, h("circle", {
    className: "uppy-Dashboard-Item-progressIcon--bg",
    r: "15",
    cx: "18",
    cy: "18",
    "stroke-width": "2",
    fill: "none"
  }), h("circle", {
    className: "uppy-Dashboard-Item-progressIcon--progress",
    r: "15",
    cx: "18",
    cy: "18",
    transform: "rotate(-90, 18, 18)",
    fill: "none",
    "stroke-width": "2",
    "stroke-dasharray": circleLength,
    "stroke-dashoffset": circleLength - circleLength / 100 * progress
  }));
}

module.exports = function FileProgress(props) {
  // Nothing if upload has not started
  if (!props.file.progress.uploadStarted) {
    return null;
  } // Green checkmark when complete


  if (props.isUploaded) {
    return h("div", {
      className: "uppy-Dashboard-Item-progress"
    }, h("div", {
      className: "uppy-Dashboard-Item-progressIndicator"
    }, h(ProgressCircleContainer, null, h("circle", {
      r: "15",
      cx: "18",
      cy: "18",
      fill: "#1bb240"
    }), h("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--check",
      transform: "translate(2, 3)",
      points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
    }))));
  }

  if (props.recoveredState) {
    return;
  } // Retry button for error


  if (props.error && !props.hideRetryButton) {
    return h(ProgressIndicatorButton, props, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry",
      width: "28",
      height: "31",
      viewBox: "0 0 16 19"
    }, h("path", {
      d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
    }), h("path", {
      d: "M7.9 3H10v2H7.9z"
    }), h("path", {
      d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
    }), h("path", {
      d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
    })));
  } // Pause/resume button for resumable uploads


  if (props.resumableUploads && !props.hidePauseResumeButton) {
    return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
      progress: props.file.progress.percentage
    }), props.file.isPaused ? h("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--play",
      transform: "translate(3, 3)",
      points: "12 20 12 10 20 15"
    }) : h("g", {
      className: "uppy-Dashboard-Item-progressIcon--pause",
      transform: "translate(14.5, 13)"
    }, h("rect", {
      x: "0",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }), h("rect", {
      x: "5",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }))));
  } // Cancel button for non-resumable uploads if individualCancellation is supported (not bundled)


  if (!props.resumableUploads && props.individualCancellation && !props.hideCancelButton) {
    return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
      progress: props.file.progress.percentage
    }), h("polygon", {
      className: "cancel",
      transform: "translate(2, 2)",
      points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
    })));
  } // Just progress when buttons are disabled


  return h("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h("div", {
    className: "uppy-Dashboard-Item-progressIndicator"
  }, h(ProgressCircleContainer, null, h(ProgressCircle, {
    progress: props.file.progress.percentage
  }))));
};

},{"preact":37}],86:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var classNames = require('classnames');

var shallowEqual = require('is-shallow-equal');

var FilePreviewAndLink = require('./FilePreviewAndLink');

var FileProgress = require('./FileProgress');

var FileInfo = require('./FileInfo');

var Buttons = require('./Buttons');

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FileItem, _Component);

  function FileItem() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = FileItem.prototype;

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return !shallowEqual(this.props, nextProps);
  };

  _proto.componentDidMount = function componentDidMount() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  } // VirtualList mounts FileItems again and they emit `thumbnail:request`
  // Otherwise thumbnails are broken or missing after Golden Retriever restores files
  ;

  _proto.componentDidUpdate = function componentDidUpdate() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleCancelThumbnail(file);
    }
  };

  _proto.render = function render() {
    var file = this.props.file;
    var isProcessing = file.progress.preprocess || file.progress.postprocess;
    var isUploaded = file.progress.uploadComplete && !isProcessing && !file.error;
    var uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing;
    var uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
    var error = file.error || false; // File that Golden Retriever was able to partly restore (only meta, not blob),
    // users still need to re-add it, so it’s a ghost

    var isGhost = file.isGhost;
    var showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;

    if (isUploaded && this.props.showRemoveButtonAfterComplete) {
      showRemoveButton = true;
    }

    var dashboardItemClass = classNames({
      'uppy-Dashboard-Item': true,
      'is-inprogress': uploadInProgress && !this.props.recoveredState,
      'is-processing': isProcessing,
      'is-complete': isUploaded,
      'is-error': !!error,
      'is-resumable': this.props.resumableUploads,
      'is-noIndividualCancellation': !this.props.individualCancellation,
      'is-ghost': isGhost
    });
    return h("div", {
      className: dashboardItemClass,
      id: "uppy_" + file.id,
      role: this.props.role
    }, h("div", {
      className: "uppy-Dashboard-Item-preview"
    }, h(FilePreviewAndLink, {
      file: file,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult
    }), h(FileProgress, {
      file: file,
      error: error,
      isUploaded: isUploaded,
      hideRetryButton: this.props.hideRetryButton,
      hideCancelButton: this.props.hideCancelButton,
      hidePauseResumeButton: this.props.hidePauseResumeButton,
      recoveredState: this.props.recoveredState,
      showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete,
      resumableUploads: this.props.resumableUploads,
      individualCancellation: this.props.individualCancellation,
      pauseUpload: this.props.pauseUpload,
      cancelUpload: this.props.cancelUpload,
      retryUpload: this.props.retryUpload,
      i18n: this.props.i18n
    })), h("div", {
      className: "uppy-Dashboard-Item-fileInfoAndButtons"
    }, h(FileInfo, {
      file: file,
      id: this.props.id,
      acquirers: this.props.acquirers,
      containerWidth: this.props.containerWidth,
      i18n: this.props.i18n,
      toggleAddFilesPanel: this.props.toggleAddFilesPanel
    }), h(Buttons, {
      file: file,
      metaFields: this.props.metaFields,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      showRemoveButton: showRemoveButton,
      canEditFile: this.props.canEditFile,
      uploadInProgressOrComplete: uploadInProgressOrComplete,
      removeFile: this.props.removeFile,
      toggleFileCard: this.props.toggleFileCard,
      openFileEditor: this.props.openFileEditor,
      i18n: this.props.i18n,
      log: this.props.log,
      info: this.props.info
    })));
  };

  return FileItem;
}(Component);

},{"./Buttons":82,"./FileInfo":83,"./FilePreviewAndLink":84,"./FileProgress":85,"classnames":10,"is-shallow-equal":29,"preact":37}],87:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var FileItem = require('./FileItem/index.js');

var VirtualList = require('./VirtualList');

var classNames = require('classnames');

var _require = require('preact'),
    h = _require.h;

function chunks(list, size) {
  var chunked = [];
  var currentChunk = [];
  list.forEach(function (item, i) {
    if (currentChunk.length < size) {
      currentChunk.push(item);
    } else {
      chunked.push(currentChunk);
      currentChunk = [item];
    }
  });
  if (currentChunk.length) chunked.push(currentChunk);
  return chunked;
}

module.exports = function (props) {
  var noFiles = props.totalFileCount === 0;
  var dashboardFilesClass = classNames('uppy-Dashboard-files', {
    'uppy-Dashboard-files--noFiles': noFiles
  }); // It's not great that this is hardcoded!
  // It's ESPECIALLY not great that this is checking against `itemsPerRow`!

  var rowHeight = props.itemsPerRow === 1 // Mobile
  ? 71 // 190px height + 2 * 5px margin
  : 200;
  var fileProps = {
    // FIXME This is confusing, it's actually the Dashboard's plugin ID
    id: props.id,
    error: props.error,
    // TODO move this to context
    i18n: props.i18n,
    log: props.log,
    info: props.info,
    // features
    acquirers: props.acquirers,
    resumableUploads: props.resumableUploads,
    individualCancellation: props.individualCancellation,
    // visual options
    hideRetryButton: props.hideRetryButton,
    hidePauseResumeButton: props.hidePauseResumeButton,
    hideCancelButton: props.hideCancelButton,
    showLinkToFileUploadResult: props.showLinkToFileUploadResult,
    showRemoveButtonAfterComplete: props.showRemoveButtonAfterComplete,
    isWide: props.isWide,
    metaFields: props.metaFields,
    recoveredState: props.recoveredState,
    // callbacks
    retryUpload: props.retryUpload,
    pauseUpload: props.pauseUpload,
    cancelUpload: props.cancelUpload,
    toggleFileCard: props.toggleFileCard,
    removeFile: props.removeFile,
    handleRequestThumbnail: props.handleRequestThumbnail,
    handleCancelThumbnail: props.handleCancelThumbnail
  };

  var sortByGhostComesFirst = function sortByGhostComesFirst(file1, file2) {
    return props.files[file2].isGhost - props.files[file1].isGhost;
  }; // Sort files by file.isGhost, ghost files first, only if recoveredState is present


  var files = Object.keys(props.files);
  if (props.recoveredState) files.sort(sortByGhostComesFirst);
  var rows = chunks(files, props.itemsPerRow);

  function renderRow(row) {
    return (// The `role="presentation` attribute ensures that the list items are properly associated with the `VirtualList` element
      // We use the first file ID as the key—this should not change across scroll rerenders
      h("div", {
        role: "presentation",
        key: row[0]
      }, row.map(function (fileID) {
        return h(FileItem, _extends({
          key: fileID
        }, fileProps, {
          role: "listitem",
          openFileEditor: props.openFileEditor,
          canEditFile: props.canEditFile,
          toggleAddFilesPanel: props.toggleAddFilesPanel,
          file: props.files[fileID]
        }));
      }))
    );
  }

  return h(VirtualList, {
    class: dashboardFilesClass,
    role: "list",
    data: rows,
    renderRow: renderRow,
    rowHeight: rowHeight
  });
};

},{"./FileItem/index.js":86,"./VirtualList":92,"classnames":10,"preact":37}],88:[function(require,module,exports){
var getFileTypeIcon = require('../utils/getFileTypeIcon');

var _require = require('preact'),
    h = _require.h;

module.exports = function FilePreview(props) {
  var file = props.file;

  if (file.preview) {
    return h("img", {
      className: "uppy-Dashboard-Item-previewImg",
      alt: file.name,
      src: file.preview
    });
  }

  var _getFileTypeIcon = getFileTypeIcon(file.type),
      color = _getFileTypeIcon.color,
      icon = _getFileTypeIcon.icon;

  return h("div", {
    className: "uppy-Dashboard-Item-previewIconWrap"
  }, h("span", {
    className: "uppy-Dashboard-Item-previewIcon",
    style: {
      color: color
    }
  }, icon), h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-Dashboard-Item-previewIconBg",
    width: "58",
    height: "76",
    viewBox: "0 0 58 76"
  }, h("rect", {
    fill: "#FFF",
    width: "58",
    height: "76",
    rx: "3",
    fillRule: "evenodd"
  })));
};

},{"../utils/getFileTypeIcon":97,"preact":37}],89:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var ignoreEvent = require('../utils/ignoreEvent.js');

function PickerPanelContent(props) {
  return h("div", {
    className: classNames('uppy-DashboardContent-panel', props.className),
    role: "tabpanel",
    "data-uppy-panelType": "PickerPanel",
    id: "uppy-DashboardContent-panel--" + props.activePickerPanel.id,
    onDragOver: ignoreEvent,
    onDragLeave: ignoreEvent,
    onDrop: ignoreEvent,
    onPaste: ignoreEvent
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n('importFrom', {
    name: props.activePickerPanel.name
  })), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n('done'))), h("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.getPlugin(props.activePickerPanel.id).render(props.state)));
}

module.exports = PickerPanelContent;

},{"../utils/ignoreEvent.js":98,"classnames":10,"preact":37}],90:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var uploadStates = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete',
  STATE_PAUSED: 'paused'
};

function getUploadingState(isAllErrored, isAllComplete, isAllPaused, files) {
  if (files === void 0) {
    files = {};
  }

  if (isAllErrored) {
    return uploadStates.STATE_ERROR;
  }

  if (isAllComplete) {
    return uploadStates.STATE_COMPLETE;
  }

  if (isAllPaused) {
    return uploadStates.STATE_PAUSED;
  }

  var state = uploadStates.STATE_WAITING;
  var fileIDs = Object.keys(files);

  for (var i = 0; i < fileIDs.length; i++) {
    var progress = files[fileIDs[i]].progress; // If ANY files are being uploaded right now, show the uploading state.

    if (progress.uploadStarted && !progress.uploadComplete) {
      return uploadStates.STATE_UPLOADING;
    } // If files are being preprocessed AND postprocessed at this time, we show the
    // preprocess state. If any files are being uploaded we show uploading.


    if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) {
      state = uploadStates.STATE_PREPROCESSING;
    } // If NO files are being preprocessed or uploaded right now, but some files are
    // being postprocessed, show the postprocess state.


    if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) {
      state = uploadStates.STATE_POSTPROCESSING;
    }
  }

  return state;
}

function UploadStatus(props) {
  var uploadingState = getUploadingState(props.isAllErrored, props.isAllComplete, props.isAllPaused, props.files);

  switch (uploadingState) {
    case 'uploading':
      return props.i18n('uploadingXFiles', {
        smart_count: props.inProgressNotPausedFiles.length
      });

    case 'preprocessing':
    case 'postprocessing':
      return props.i18n('processingXFiles', {
        smart_count: props.processingFiles.length
      });

    case 'paused':
      return props.i18n('uploadPaused');

    case 'waiting':
      return props.i18n('xFilesSelected', {
        smart_count: props.newFiles.length
      });

    case 'complete':
      return props.i18n('uploadComplete');
  }
}

function PanelTopBar(props) {
  var allowNewUpload = props.allowNewUpload; // TODO maybe this should be done in ../index.js, then just pass that down as `allowNewUpload`

  if (allowNewUpload && props.maxNumberOfFiles) {
    allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
  }

  return h("div", {
    className: "uppy-DashboardContent-bar"
  }, !props.isAllComplete && !props.hideCancelButton ? h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.cancelAll
  }, props.i18n('cancel')) : h("div", null), h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, h(UploadStatus, props)), allowNewUpload ? h("button", {
    className: "uppy-DashboardContent-addMore",
    type: "button",
    "aria-label": props.i18n('addMoreFiles'),
    title: props.i18n('addMoreFiles'),
    onClick: function onClick() {
      return props.toggleAddFilesPanel(true);
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "15",
    height: "15",
    viewBox: "0 0 15 15"
  }, h("path", {
    d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
  })), h("span", {
    className: "uppy-DashboardContent-addMoreCaption"
  }, props.i18n('addMore'))) : h("div", null));
}

module.exports = PanelTopBar;

},{"preact":37}],91:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    cloneElement = _require.cloneElement,
    Component = _require.Component;

var classNames = require('classnames');

var transitionName = 'uppy-transition-slideDownUp';
var duration = 250;
/**
 * Vertical slide transition.
 *
 * This can take a _single_ child component, which _must_ accept a `className` prop.
 *
 * Currently this is specific to the `uppy-transition-slideDownUp` transition,
 * but it should be simple to extend this for any type of single-element
 * transition by setting the CSS name and duration as props.
 */

var Slide = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Slide, _Component);

  function Slide(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.state = {
      cachedChildren: null,
      className: ''
    };
    return _this;
  }

  var _proto = Slide.prototype;

  _proto.componentWillUpdate = function componentWillUpdate(nextProps) {
    var _this2 = this;

    var cachedChildren = this.state.cachedChildren;
    var child = nextProps.children[0];
    if (cachedChildren === child) return;
    var patch = {
      cachedChildren: child
    }; // Enter transition

    if (child && !cachedChildren) {
      patch.className = transitionName + "-enter";
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.leaveTimeout);
      this.leaveTimeout = undefined;
      this.animationFrame = requestAnimationFrame(function () {
        // Force it to render before we add the active class
        _this2.base.getBoundingClientRect();

        _this2.setState({
          className: transitionName + "-enter " + transitionName + "-enter-active"
        });

        _this2.enterTimeout = setTimeout(function () {
          _this2.setState({
            className: ''
          });
        }, duration);
      });
    } // Leave transition


    if (cachedChildren && !child && this.leaveTimeout === undefined) {
      patch.cachedChildren = cachedChildren;
      patch.className = transitionName + "-leave";
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.enterTimeout);
      this.enterTimeout = undefined;
      this.animationFrame = requestAnimationFrame(function () {
        _this2.setState({
          className: transitionName + "-leave " + transitionName + "-leave-active"
        });

        _this2.leaveTimeout = setTimeout(function () {
          _this2.setState({
            cachedChildren: null,
            className: ''
          });
        }, duration);
      });
    }

    this.setState(patch);
  };

  _proto.render = function render() {
    var _this$state = this.state,
        cachedChildren = _this$state.cachedChildren,
        className = _this$state.className;

    if (!cachedChildren) {
      return null;
    }

    return cloneElement(cachedChildren, {
      className: classNames(className, cachedChildren.attributes.className)
    });
  };

  return Slide;
}(Component);

module.exports = Slide;

},{"classnames":10,"preact":37}],92:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Adapted from preact-virtual-list: https://github.com/developit/preact-virtual-list
 *
 * © 2016 Jason Miller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Adaptations:
 * - Added role=presentation to helper elements
 * - Tweaked styles for Uppy's Dashboard use case
 */
var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var STYLE_INNER = {
  position: 'relative',
  // Disabled for our use case: the wrapper elements around FileList already deal with overflow,
  // and this additional property would hide things that we want to show.
  //
  // overflow: 'hidden',
  width: '100%',
  minHeight: '100%'
};
var STYLE_CONTENT = {
  position: 'absolute',
  top: 0,
  left: 0,
  // Because the `top` value gets set to some offset, this `height` being 100% would make the scrollbar
  // stretch far beyond the content. For our use case, the content div actually can get its height from
  // the elements inside it, so we don't need to specify a `height` property at all.
  //
  // height: '100%',
  width: '100%',
  overflow: 'visible'
};

var VirtualList = /*#__PURE__*/function (_Component) {
  _inheritsLoose(VirtualList, _Component);

  function VirtualList(props) {
    var _this;

    _this = _Component.call(this, props) || this; // The currently focused node, used to retain focus when the visible rows change.
    // To avoid update loops, this should not cause state updates, so it's kept as a plain property.

    _this.handleResize = function () {
      _this.resize();
    };

    _this.handleScroll = function () {
      _this.setState({
        offset: _this.base.scrollTop
      });

      if (_this.props.sync) {
        _this.forceUpdate();
      }
    };

    _this.focusElement = null;
    _this.state = {
      offset: 0,
      height: 0
    };
    return _this;
  }

  var _proto = VirtualList.prototype;

  _proto.resize = function resize() {
    if (this.state.height !== this.base.offsetHeight) {
      this.setState({
        height: this.base.offsetHeight
      });
    }
  };

  _proto.componentWillUpdate = function componentWillUpdate() {
    if (this.base.contains(document.activeElement)) {
      this.focusElement = document.activeElement;
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    // Maintain focus when rows are added and removed.
    if (this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement) {
      this.focusElement.focus();
    }

    this.focusElement = null;
    this.resize();
  };

  _proto.componentDidMount = function componentDidMount() {
    this.resize();
    window.addEventListener('resize', this.handleResize);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  };

  _proto.render = function render(_ref) {
    var data = _ref.data,
        rowHeight = _ref.rowHeight,
        renderRow = _ref.renderRow,
        _ref$overscanCount = _ref.overscanCount,
        overscanCount = _ref$overscanCount === void 0 ? 10 : _ref$overscanCount,
        sync = _ref.sync,
        props = _objectWithoutPropertiesLoose(_ref, ["data", "rowHeight", "renderRow", "overscanCount", "sync"]);

    var _this$state = this.state,
        offset = _this$state.offset,
        height = _this$state.height; // first visible row index

    var start = Math.floor(offset / rowHeight); // actual number of visible rows (without overscan)

    var visibleRowCount = Math.floor(height / rowHeight); // Overscan: render blocks of rows modulo an overscan row count
    // This dramatically reduces DOM writes during scrolling

    if (overscanCount) {
      start = Math.max(0, start - start % overscanCount);
      visibleRowCount += overscanCount;
    } // last visible + overscan row index + padding to allow keyboard focus to travel past the visible area


    var end = start + visibleRowCount + 4; // data slice currently in viewport plus overscan items

    var selection = data.slice(start, end);

    var styleInner = _extends({}, STYLE_INNER, {
      height: data.length * rowHeight
    });

    var styleContent = _extends({}, STYLE_CONTENT, {
      top: start * rowHeight
    }); // The `role="presentation"` attributes ensure that these wrapper elements are not treated as list
    // items by accessibility and outline tools.


    return h("div", _extends({
      onScroll: this.handleScroll
    }, props), h("div", {
      role: "presentation",
      style: styleInner
    }, h("div", {
      role: "presentation",
      style: styleContent
    }, selection.map(renderRow))));
  };

  return VirtualList;
}(Component);

module.exports = VirtualList;

},{"preact":37}],93:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h;

var _require2 = require('./../../core'),
    Plugin = _require2.Plugin;

var Translator = require('./../../utils/lib/Translator');

var DashboardUI = require('./components/Dashboard');

var StatusBar = require('./../../status-bar');

var Informer = require('./../../informer');

var ThumbnailGenerator = require('./../../thumbnail-generator');

var findAllDOMElements = require('./../../utils/lib/findAllDOMElements');

var toArray = require('./../../utils/lib/toArray');

var getDroppedFiles = require('./../../utils/lib/getDroppedFiles');

var getTextDirection = require('./../../utils/lib/getTextDirection');

var trapFocus = require('./utils/trapFocus');

var cuid = require('cuid');

var ResizeObserver = require('resize-observer-polyfill').default || require('resize-observer-polyfill');

var createSuperFocus = require('./utils/createSuperFocus');

var memoize = require('memoize-one').default || require('memoize-one');

var FOCUSABLE_ELEMENTS = require('./../../utils/lib/FOCUSABLE_ELEMENTS');

var TAB_KEY = 9;
var ESC_KEY = 27;

function createPromise() {
  var o = {};
  o.promise = new Promise(function (resolve, reject) {
    o.resolve = resolve;
    o.reject = reject;
  });
  return o;
}

function defaultPickerIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "30",
    height: "30",
    viewBox: "0 0 30 30"
  }, h("path", {
    d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
  }));
}
/**
 * Dashboard UI with previews, metadata editing, tabs for various services and more
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Dashboard, _Plugin);

  function Dashboard(uppy, _opts) {
    var _this;

    _this = _Plugin.call(this, uppy, _opts) || this;

    _this.setOptions = function (newOpts) {
      _Plugin.prototype.setOptions.call(_assertThisInitialized(_this), newOpts);

      _this.i18nInit();
    };

    _this.i18nInit = function () {
      _this.translator = new Translator([_this.defaultLocale, _this.uppy.locale, _this.opts.locale]);
      _this.i18n = _this.translator.translate.bind(_this.translator);
      _this.i18nArray = _this.translator.translateArray.bind(_this.translator);

      _this.setPluginState(); // so that UI re-renders and we see the updated locale

    };

    _this.removeTarget = function (plugin) {
      var pluginState = _this.getPluginState(); // filter out the one we want to remove


      var newTargets = pluginState.targets.filter(function (target) {
        return target.id !== plugin.id;
      });

      _this.setPluginState({
        targets: newTargets
      });
    };

    _this.addTarget = function (plugin) {
      var callerPluginId = plugin.id || plugin.constructor.name;
      var callerPluginName = plugin.title || callerPluginId;
      var callerPluginType = plugin.type;

      if (callerPluginType !== 'acquirer' && callerPluginType !== 'progressindicator' && callerPluginType !== 'editor') {
        var msg = 'Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor';

        _this.uppy.log(msg, 'error');

        return;
      }

      var target = {
        id: callerPluginId,
        name: callerPluginName,
        type: callerPluginType
      };

      var state = _this.getPluginState();

      var newTargets = state.targets.slice();
      newTargets.push(target);

      _this.setPluginState({
        targets: newTargets
      });

      return _this.el;
    };

    _this.hideAllPanels = function () {
      var update = {
        activePickerPanel: false,
        showAddFilesPanel: false,
        activeOverlayType: null,
        fileCardFor: null,
        showFileEditor: false
      };

      var current = _this.getPluginState();

      if (current.activePickerPanel === update.activePickerPanel && current.showAddFilesPanel === update.showAddFilesPanel && current.showFileEditor === update.showFileEditor && current.activeOverlayType === update.activeOverlayType) {
        // avoid doing a state update if nothing changed
        return;
      }

      _this.setPluginState(update);
    };

    _this.showPanel = function (id) {
      var _this$getPluginState = _this.getPluginState(),
          targets = _this$getPluginState.targets;

      var activePickerPanel = targets.filter(function (target) {
        return target.type === 'acquirer' && target.id === id;
      })[0];

      _this.setPluginState({
        activePickerPanel: activePickerPanel,
        activeOverlayType: 'PickerPanel'
      });
    };

    _this.canEditFile = function (file) {
      var _this$getPluginState2 = _this.getPluginState(),
          targets = _this$getPluginState2.targets;

      var editors = _this._getEditors(targets);

      return editors.some(function (target) {
        return _this.uppy.getPlugin(target.id).canEditFile(file);
      });
    };

    _this.openFileEditor = function (file) {
      var _this$getPluginState3 = _this.getPluginState(),
          targets = _this$getPluginState3.targets;

      var editors = _this._getEditors(targets);

      _this.setPluginState({
        showFileEditor: true,
        fileCardFor: file.id || null,
        activeOverlayType: 'FileEditor'
      });

      editors.forEach(function (editor) {
        _this.uppy.getPlugin(editor.id).selectFile(file);
      });
    };

    _this.openModal = function () {
      var _createPromise = createPromise(),
          promise = _createPromise.promise,
          resolve = _createPromise.resolve; // save scroll position


      _this.savedScrollPosition = window.pageYOffset; // save active element, so we can restore focus when modal is closed

      _this.savedActiveElement = document.activeElement;

      if (_this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.add('uppy-Dashboard-isFixed');
      }

      if (_this.opts.animateOpenClose && _this.getPluginState().isClosing) {
        var handler = function handler() {
          _this.setPluginState({
            isHidden: false
          });

          _this.el.removeEventListener('animationend', handler, false);

          resolve();
        };

        _this.el.addEventListener('animationend', handler, false);
      } else {
        _this.setPluginState({
          isHidden: false
        });

        resolve();
      }

      if (_this.opts.browserBackButtonClose) {
        _this.updateBrowserHistory();
      } // handle ESC and TAB keys in modal dialog


      document.addEventListener('keydown', _this.handleKeyDownInModal);

      _this.uppy.emit('dashboard:modal-open');

      return promise;
    };

    _this.closeModal = function (opts) {
      if (opts === void 0) {
        opts = {};
      }

      var _opts2 = opts,
          _opts2$manualClose = _opts2.manualClose,
          manualClose = _opts2$manualClose === void 0 ? true : _opts2$manualClose;

      var _this$getPluginState4 = _this.getPluginState(),
          isHidden = _this$getPluginState4.isHidden,
          isClosing = _this$getPluginState4.isClosing;

      if (isHidden || isClosing) {
        // short-circuit if animation is ongoing
        return;
      }

      var _createPromise2 = createPromise(),
          promise = _createPromise2.promise,
          resolve = _createPromise2.resolve;

      if (_this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.remove('uppy-Dashboard-isFixed');
      }

      if (_this.opts.animateOpenClose) {
        _this.setPluginState({
          isClosing: true
        });

        var handler = function handler() {
          _this.setPluginState({
            isHidden: true,
            isClosing: false
          });

          _this.superFocus.cancel();

          _this.savedActiveElement.focus();

          _this.el.removeEventListener('animationend', handler, false);

          resolve();
        };

        _this.el.addEventListener('animationend', handler, false);
      } else {
        _this.setPluginState({
          isHidden: true
        });

        _this.superFocus.cancel();

        _this.savedActiveElement.focus();

        resolve();
      } // handle ESC and TAB keys in modal dialog


      document.removeEventListener('keydown', _this.handleKeyDownInModal);

      if (manualClose) {
        if (_this.opts.browserBackButtonClose) {
          // Make sure that the latest entry in the history state is our modal name
          if (history.state && history.state[_this.modalName]) {
            // Go back in history to clear out the entry we created (ultimately closing the modal)
            history.go(-1);
          }
        }
      }

      _this.uppy.emit('dashboard:modal-closed');

      return promise;
    };

    _this.isModalOpen = function () {
      return !_this.getPluginState().isHidden || false;
    };

    _this.requestCloseModal = function () {
      if (_this.opts.onRequestCloseModal) {
        return _this.opts.onRequestCloseModal();
      }

      return _this.closeModal();
    };

    _this.setDarkModeCapability = function (isDarkModeOn) {
      var _this$uppy$getState = _this.uppy.getState(),
          capabilities = _this$uppy$getState.capabilities;

      _this.uppy.setState({
        capabilities: _extends({}, capabilities, {
          darkMode: isDarkModeOn
        })
      });
    };

    _this.handleSystemDarkModeChange = function (event) {
      var isDarkModeOnNow = event.matches;

      _this.uppy.log("[Dashboard] Dark mode is " + (isDarkModeOnNow ? 'on' : 'off'));

      _this.setDarkModeCapability(isDarkModeOnNow);
    };

    _this.toggleFileCard = function (show, fileID) {
      var file = _this.uppy.getFile(fileID);

      if (show) {
        _this.uppy.emit('dashboard:file-edit-start', file);
      } else {
        _this.uppy.emit('dashboard:file-edit-complete', file);
      }

      _this.setPluginState({
        fileCardFor: show ? fileID : null,
        activeOverlayType: show ? 'FileCard' : null
      });
    };

    _this.toggleAddFilesPanel = function (show) {
      _this.setPluginState({
        showAddFilesPanel: show,
        activeOverlayType: show ? 'AddFiles' : null
      });
    };

    _this.addFiles = function (files) {
      var descriptors = files.map(function (file) {
        return {
          source: _this.id,
          name: file.name,
          type: file.type,
          data: file,
          meta: {
            // path of the file relative to the ancestor directory the user selected.
            // e.g. 'docs/Old Prague/airbnb.pdf'
            relativePath: file.relativePath || null
          }
        };
      });

      try {
        _this.uppy.addFiles(descriptors);
      } catch (err) {
        _this.uppy.log(err);
      }
    };

    _this.startListeningToResize = function () {
      // Watch for Dashboard container (`.uppy-Dashboard-inner`) resize
      // and update containerWidth/containerHeight in plugin state accordingly.
      // Emits first event on initialization.
      _this.resizeObserver = new ResizeObserver(function (entries, observer) {
        var uppyDashboardInnerEl = entries[0];
        var _uppyDashboardInnerEl = uppyDashboardInnerEl.contentRect,
            width = _uppyDashboardInnerEl.width,
            height = _uppyDashboardInnerEl.height;

        _this.uppy.log("[Dashboard] resized: " + width + " / " + height, 'debug');

        _this.setPluginState({
          containerWidth: width,
          containerHeight: height,
          areInsidesReadyToBeVisible: true
        });
      });

      _this.resizeObserver.observe(_this.el.querySelector('.uppy-Dashboard-inner')); // If ResizeObserver fails to emit an event telling us what size to use - default to the mobile view


      _this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(function () {
        var pluginState = _this.getPluginState();

        var isModalAndClosed = !_this.opts.inline && pluginState.isHidden;

        if ( // if ResizeObserver hasn't yet fired,
        !pluginState.areInsidesReadyToBeVisible // and it's not due to the modal being closed
        && !isModalAndClosed) {
          _this.uppy.log("[Dashboard] resize event didn't fire on time: defaulted to mobile layout", 'debug');

          _this.setPluginState({
            areInsidesReadyToBeVisible: true
          });
        }
      }, 1000);
    };

    _this.stopListeningToResize = function () {
      _this.resizeObserver.disconnect();

      clearTimeout(_this.makeDashboardInsidesVisibleAnywayTimeout);
    };

    _this.recordIfFocusedOnUppyRecently = function (event) {
      if (_this.el.contains(event.target)) {
        _this.ifFocusedOnUppyRecently = true;
      } else {
        _this.ifFocusedOnUppyRecently = false; // ___Why run this.superFocus.cancel here when it already runs in superFocusOnEachUpdate?
        //    Because superFocus is debounced, when we move from Uppy to some other element on the page,
        //    previously run superFocus sometimes hits and moves focus back to Uppy.

        _this.superFocus.cancel();
      }
    };

    _this.disableAllFocusableElements = function (disable) {
      var focusableNodes = toArray(_this.el.querySelectorAll(FOCUSABLE_ELEMENTS));

      if (disable) {
        focusableNodes.forEach(function (node) {
          // save previous tabindex in a data-attribute, to restore when enabling
          var currentTabIndex = node.getAttribute('tabindex');

          if (currentTabIndex) {
            node.dataset.inertTabindex = currentTabIndex;
          }

          node.setAttribute('tabindex', '-1');
        });
      } else {
        focusableNodes.forEach(function (node) {
          if ('inertTabindex' in node.dataset) {
            node.setAttribute('tabindex', node.dataset.inertTabindex);
          } else {
            node.removeAttribute('tabindex');
          }
        });
      }

      _this.dashboardIsDisabled = disable;
    };

    _this.updateBrowserHistory = function () {
      // Ensure history state does not already contain our modal name to avoid double-pushing
      if (!history.state || !history.state[_this.modalName]) {
        var _extends2;

        // Push to history so that the page is not lost on browser back button press
        history.pushState(_extends({}, history.state, (_extends2 = {}, _extends2[_this.modalName] = true, _extends2)), '');
      } // Listen for back button presses


      window.addEventListener('popstate', _this.handlePopState, false);
    };

    _this.handlePopState = function (event) {
      // Close the modal if the history state no longer contains our modal name
      if (_this.isModalOpen() && (!event.state || !event.state[_this.modalName])) {
        _this.closeModal({
          manualClose: false
        });
      } // When the browser back button is pressed and uppy is now the latest entry in the history but the modal is closed, fix the history by removing the uppy history entry
      // This occurs when another entry is added into the history state while the modal is open, and then the modal gets manually closed
      // Solves PR #575 (https://github.com/transloadit/uppy/pull/575)


      if (!_this.isModalOpen() && event.state && event.state[_this.modalName]) {
        history.go(-1);
      }
    };

    _this.handleKeyDownInModal = function (event) {
      // close modal on esc key press
      if (event.keyCode === ESC_KEY) _this.requestCloseModal(event); // trap focus on tab key press

      if (event.keyCode === TAB_KEY) trapFocus.forModal(event, _this.getPluginState().activeOverlayType, _this.el);
    };

    _this.handleClickOutside = function () {
      if (_this.opts.closeModalOnClickOutside) _this.requestCloseModal();
    };

    _this.handlePaste = function (event) {
      // 1. Let any acquirer plugin (Url/Webcam/etc.) handle pastes to the root
      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootPaste(event)
          plugin.handleRootPaste && plugin.handleRootPaste(event);
        }
      }); // 2. Add all dropped files


      var files = toArray(event.clipboardData.files);

      _this.addFiles(files);
    };

    _this.handleInputChange = function (event) {
      event.preventDefault();
      var files = toArray(event.target.files);

      _this.addFiles(files);
    };

    _this.handleDragOver = function (event) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      } // 1. Add a small (+) icon on drop
      // (and prevent browsers from interpreting this as files being _moved_ into the browser, https://github.com/transloadit/uppy/issues/1978)


      event.dataTransfer.dropEffect = 'copy';
      clearTimeout(_this.removeDragOverClassTimeout);

      _this.setPluginState({
        isDraggingOver: true
      });
    };

    _this.handleDragLeave = function (event) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      }

      clearTimeout(_this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library. Solution with 'pointer-events: none' didn't work across browsers.

      _this.removeDragOverClassTimeout = setTimeout(function () {
        _this.setPluginState({
          isDraggingOver: false
        });
      }, 50);
    };

    _this.handleDrop = function (event, dropCategory) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      }

      clearTimeout(_this.removeDragOverClassTimeout); // 2. Remove dragover class

      _this.setPluginState({
        isDraggingOver: false
      }); // 3. Let any acquirer plugin (Url/Webcam/etc.) handle drops to the root


      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootDrop(event)
          plugin.handleRootDrop && plugin.handleRootDrop(event);
        }
      }); // 4. Add all dropped files


      var executedDropErrorOnce = false;

      var logDropError = function logDropError(error) {
        _this.uppy.log(error, 'error'); // In practice all drop errors are most likely the same, so let's just show one to avoid overwhelming the user


        if (!executedDropErrorOnce) {
          _this.uppy.info(error.message, 'error');

          executedDropErrorOnce = true;
        }
      };

      getDroppedFiles(event.dataTransfer, {
        logDropError: logDropError
      }).then(function (files) {
        if (files.length > 0) {
          _this.uppy.log('[Dashboard] Files were dropped');

          _this.addFiles(files);
        }
      });
    };

    _this.handleRequestThumbnail = function (file) {
      if (!_this.opts.waitForThumbnailsBeforeUpload) {
        _this.uppy.emit('thumbnail:request', file);
      }
    };

    _this.handleCancelThumbnail = function (file) {
      if (!_this.opts.waitForThumbnailsBeforeUpload) {
        _this.uppy.emit('thumbnail:cancel', file);
      }
    };

    _this.handleKeyDownInInline = function (event) {
      // Trap focus on tab key press.
      if (event.keyCode === TAB_KEY) trapFocus.forInline(event, _this.getPluginState().activeOverlayType, _this.el);
    };

    _this.handlePasteOnBody = function (event) {
      var isFocusInOverlay = _this.el.contains(document.activeElement);

      if (isFocusInOverlay) {
        _this.handlePaste(event);
      }
    };

    _this.handleComplete = function (_ref) {
      var failed = _ref.failed;

      if (_this.opts.closeAfterFinish && failed.length === 0) {
        // All uploads are done
        _this.requestCloseModal();
      }
    };

    _this.handleCancelRestore = function () {
      _this.uppy.emit('restore-canceled');
    };

    _this._openFileEditorWhenFilesAdded = function (files) {
      var firstFile = files[0];

      if (_this.canEditFile(firstFile)) {
        _this.openFileEditor(firstFile);
      }
    };

    _this.initEvents = function () {
      // Modal open button
      if (_this.opts.trigger && !_this.opts.inline) {
        var showModalTrigger = findAllDOMElements(_this.opts.trigger);

        if (showModalTrigger) {
          showModalTrigger.forEach(function (trigger) {
            return trigger.addEventListener('click', _this.openModal);
          });
        } else {
          _this.uppy.log('Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself', 'warning');
        }
      }

      _this.startListeningToResize();

      document.addEventListener('paste', _this.handlePasteOnBody);

      _this.uppy.on('plugin-remove', _this.removeTarget);

      _this.uppy.on('file-added', _this.hideAllPanels);

      _this.uppy.on('dashboard:modal-closed', _this.hideAllPanels);

      _this.uppy.on('file-editor:complete', _this.hideAllPanels);

      _this.uppy.on('complete', _this.handleComplete); // ___Why fire on capture?
      //    Because this.ifFocusedOnUppyRecently needs to change before onUpdate() fires.


      document.addEventListener('focus', _this.recordIfFocusedOnUppyRecently, true);
      document.addEventListener('click', _this.recordIfFocusedOnUppyRecently, true);

      if (_this.opts.inline) {
        _this.el.addEventListener('keydown', _this.handleKeyDownInInline);
      }

      if (_this.opts.autoOpenFileEditor) {
        _this.uppy.on('files-added', _this._openFileEditorWhenFilesAdded);
      }
    };

    _this.removeEvents = function () {
      var showModalTrigger = findAllDOMElements(_this.opts.trigger);

      if (!_this.opts.inline && showModalTrigger) {
        showModalTrigger.forEach(function (trigger) {
          return trigger.removeEventListener('click', _this.openModal);
        });
      }

      _this.stopListeningToResize();

      document.removeEventListener('paste', _this.handlePasteOnBody);
      window.removeEventListener('popstate', _this.handlePopState, false);

      _this.uppy.off('plugin-remove', _this.removeTarget);

      _this.uppy.off('file-added', _this.hideAllPanels);

      _this.uppy.off('dashboard:modal-closed', _this.hideAllPanels);

      _this.uppy.off('file-editor:complete', _this.hideAllPanels);

      _this.uppy.off('complete', _this.handleComplete);

      document.removeEventListener('focus', _this.recordIfFocusedOnUppyRecently);
      document.removeEventListener('click', _this.recordIfFocusedOnUppyRecently);

      if (_this.opts.inline) {
        _this.el.removeEventListener('keydown', _this.handleKeyDownInInline);
      }

      if (_this.opts.autoOpenFileEditor) {
        _this.uppy.off('files-added', _this._openFileEditorWhenFilesAdded);
      }
    };

    _this.superFocusOnEachUpdate = function () {
      var isFocusInUppy = _this.el.contains(document.activeElement); // When focus is lost on the page (== focus is on body for most browsers, or focus is null for IE11)


      var isFocusNowhere = document.activeElement === document.body || document.activeElement === null;

      var isInformerHidden = _this.uppy.getState().info.isHidden;

      var isModal = !_this.opts.inline;

      if ( // If update is connected to showing the Informer - let the screen reader calmly read it.
      isInformerHidden && ( // If we are in a modal - always superfocus without concern for other elements on the page (user is unlikely to want to interact with the rest of the page)
      isModal // If we are already inside of Uppy, or
      || isFocusInUppy // If we are not focused on anything BUT we have already, at least once, focused on uppy
      //   1. We focus when isFocusNowhere, because when the element we were focused on disappears (e.g. an overlay), - focus gets lost. If user is typing something somewhere else on the page, - focus won't be 'nowhere'.
      //   2. We only focus when focus is nowhere AND this.ifFocusedOnUppyRecently, to avoid focus jumps if we do something else on the page.
      //   [Practical check] Without '&& this.ifFocusedOnUppyRecently', in Safari, in inline mode, when file is uploading, - navigate via tab to the checkbox, try to press space multiple times. Focus will jump to Uppy.
      || isFocusNowhere && _this.ifFocusedOnUppyRecently)) {
        _this.superFocus(_this.el, _this.getPluginState().activeOverlayType);
      } else {
        _this.superFocus.cancel();
      }
    };

    _this.afterUpdate = function () {
      if (_this.opts.disabled && !_this.dashboardIsDisabled) {
        _this.disableAllFocusableElements(true);

        return;
      }

      if (!_this.opts.disabled && _this.dashboardIsDisabled) {
        _this.disableAllFocusableElements(false);
      }

      _this.superFocusOnEachUpdate();
    };

    _this.cancelUpload = function (fileID) {
      _this.uppy.removeFile(fileID);
    };

    _this.saveFileCard = function (meta, fileID) {
      _this.uppy.setFileMeta(fileID, meta);

      _this.toggleFileCard(false, fileID);
    };

    _this._attachRenderFunctionToTarget = function (target) {
      var plugin = _this.uppy.getPlugin(target.id);

      return _extends({}, target, {
        icon: plugin.icon || _this.opts.defaultPickerIcon,
        render: plugin.render
      });
    };

    _this._isTargetSupported = function (target) {
      var plugin = _this.uppy.getPlugin(target.id); // If the plugin does not provide a `supported` check, assume the plugin works everywhere.


      if (typeof plugin.isSupported !== 'function') {
        return true;
      }

      return plugin.isSupported();
    };

    _this._getAcquirers = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'acquirer' && _this._isTargetSupported(target);
      }).map(_this._attachRenderFunctionToTarget);
    });
    _this._getProgressIndicators = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'progressindicator';
      }).map(_this._attachRenderFunctionToTarget);
    });
    _this._getEditors = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'editor';
      }).map(_this._attachRenderFunctionToTarget);
    });

    _this.render = function (state) {
      var pluginState = _this.getPluginState();

      var files = state.files,
          capabilities = state.capabilities,
          allowNewUpload = state.allowNewUpload; // TODO: move this to Core, to share between Status Bar and Dashboard
      // (and any other plugin that might need it, too)

      var newFiles = Object.keys(files).filter(function (file) {
        return !files[file].progress.uploadStarted;
      });
      var uploadStartedFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.uploadStarted;
      });
      var pausedFiles = Object.keys(files).filter(function (file) {
        return files[file].isPaused;
      });
      var completeFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.uploadComplete;
      });
      var erroredFiles = Object.keys(files).filter(function (file) {
        return files[file].error;
      });
      var inProgressFiles = Object.keys(files).filter(function (file) {
        return !files[file].progress.uploadComplete && files[file].progress.uploadStarted;
      });
      var inProgressNotPausedFiles = inProgressFiles.filter(function (file) {
        return !files[file].isPaused;
      });
      var processingFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.preprocess || files[file].progress.postprocess;
      });
      var isUploadStarted = uploadStartedFiles.length > 0;
      var isAllComplete = state.totalProgress === 100 && completeFiles.length === Object.keys(files).length && processingFiles.length === 0;
      var isAllErrored = isUploadStarted && erroredFiles.length === uploadStartedFiles.length;
      var isAllPaused = inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length;

      var acquirers = _this._getAcquirers(pluginState.targets);

      var progressindicators = _this._getProgressIndicators(pluginState.targets);

      var editors = _this._getEditors(pluginState.targets);

      var theme;

      if (_this.opts.theme === 'auto') {
        theme = capabilities.darkMode ? 'dark' : 'light';
      } else {
        theme = _this.opts.theme;
      }

      if (['files', 'folders', 'both'].indexOf(_this.opts.fileManagerSelectionType) < 0) {
        _this.opts.fileManagerSelectionType = 'files';
        console.error("Unsupported option for \"fileManagerSelectionType\". Using default of \"" + _this.opts.fileManagerSelectionType + "\".");
      }

      return DashboardUI({
        state: state,
        isHidden: pluginState.isHidden,
        files: files,
        newFiles: newFiles,
        uploadStartedFiles: uploadStartedFiles,
        completeFiles: completeFiles,
        erroredFiles: erroredFiles,
        inProgressFiles: inProgressFiles,
        inProgressNotPausedFiles: inProgressNotPausedFiles,
        processingFiles: processingFiles,
        isUploadStarted: isUploadStarted,
        isAllComplete: isAllComplete,
        isAllErrored: isAllErrored,
        isAllPaused: isAllPaused,
        totalFileCount: Object.keys(files).length,
        totalProgress: state.totalProgress,
        allowNewUpload: allowNewUpload,
        acquirers: acquirers,
        theme: theme,
        disabled: _this.opts.disabled,
        disableLocalFiles: _this.opts.disableLocalFiles,
        direction: _this.opts.direction,
        activePickerPanel: pluginState.activePickerPanel,
        showFileEditor: pluginState.showFileEditor,
        disableAllFocusableElements: _this.disableAllFocusableElements,
        animateOpenClose: _this.opts.animateOpenClose,
        isClosing: pluginState.isClosing,
        getPlugin: _this.uppy.getPlugin,
        progressindicators: progressindicators,
        editors: editors,
        autoProceed: _this.uppy.opts.autoProceed,
        id: _this.id,
        closeModal: _this.requestCloseModal,
        handleClickOutside: _this.handleClickOutside,
        handleInputChange: _this.handleInputChange,
        handlePaste: _this.handlePaste,
        inline: _this.opts.inline,
        showPanel: _this.showPanel,
        hideAllPanels: _this.hideAllPanels,
        log: _this.uppy.log,
        i18n: _this.i18n,
        i18nArray: _this.i18nArray,
        removeFile: _this.uppy.removeFile,
        uppy: _this.uppy,
        info: _this.uppy.info,
        note: _this.opts.note,
        recoveredState: state.recoveredState,
        metaFields: pluginState.metaFields,
        resumableUploads: capabilities.resumableUploads || false,
        individualCancellation: capabilities.individualCancellation,
        isMobileDevice: capabilities.isMobileDevice,
        pauseUpload: _this.uppy.pauseResume,
        retryUpload: _this.uppy.retryUpload,
        cancelUpload: _this.cancelUpload,
        cancelAll: _this.uppy.cancelAll,
        fileCardFor: pluginState.fileCardFor,
        toggleFileCard: _this.toggleFileCard,
        toggleAddFilesPanel: _this.toggleAddFilesPanel,
        showAddFilesPanel: pluginState.showAddFilesPanel,
        saveFileCard: _this.saveFileCard,
        openFileEditor: _this.openFileEditor,
        canEditFile: _this.canEditFile,
        width: _this.opts.width,
        height: _this.opts.height,
        showLinkToFileUploadResult: _this.opts.showLinkToFileUploadResult,
        fileManagerSelectionType: _this.opts.fileManagerSelectionType,
        proudlyDisplayPoweredByUppy: _this.opts.proudlyDisplayPoweredByUppy,
        hideCancelButton: _this.opts.hideCancelButton,
        hideRetryButton: _this.opts.hideRetryButton,
        hidePauseResumeButton: _this.opts.hidePauseResumeButton,
        showRemoveButtonAfterComplete: _this.opts.showRemoveButtonAfterComplete,
        containerWidth: pluginState.containerWidth,
        containerHeight: pluginState.containerHeight,
        areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
        isTargetDOMEl: _this.isTargetDOMEl,
        parentElement: _this.el,
        allowedFileTypes: _this.uppy.opts.restrictions.allowedFileTypes,
        maxNumberOfFiles: _this.uppy.opts.restrictions.maxNumberOfFiles,
        showSelectedFiles: _this.opts.showSelectedFiles,
        handleCancelRestore: _this.handleCancelRestore,
        handleRequestThumbnail: _this.handleRequestThumbnail,
        handleCancelThumbnail: _this.handleCancelThumbnail,
        // drag props
        isDraggingOver: pluginState.isDraggingOver,
        handleDragOver: _this.handleDragOver,
        handleDragLeave: _this.handleDragLeave,
        handleDrop: _this.handleDrop
      });
    };

    _this.discoverProviderPlugins = function () {
      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin && !plugin.target && plugin.opts && plugin.opts.target === _this.constructor) {
          _this.addTarget(plugin);
        }
      });
    };

    _this.install = function () {
      // Set default state for Dashboard
      _this.setPluginState({
        isHidden: true,
        fileCardFor: null,
        activeOverlayType: null,
        showAddFilesPanel: false,
        activePickerPanel: false,
        showFileEditor: false,
        metaFields: _this.opts.metaFields,
        targets: [],
        // We'll make them visible once .containerWidth is determined
        areInsidesReadyToBeVisible: false,
        isDraggingOver: false
      });

      var _this$opts = _this.opts,
          inline = _this$opts.inline,
          closeAfterFinish = _this$opts.closeAfterFinish;

      if (inline && closeAfterFinish) {
        throw new Error('[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.');
      }

      var allowMultipleUploads = _this.uppy.opts.allowMultipleUploads;

      if (allowMultipleUploads && closeAfterFinish) {
        _this.uppy.log('[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploads` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true', 'warning');
      }

      var target = _this.opts.target;

      if (target) {
        _this.mount(target, _assertThisInitialized(_this));
      }

      var plugins = _this.opts.plugins || [];
      plugins.forEach(function (pluginID) {
        var plugin = _this.uppy.getPlugin(pluginID);

        if (plugin) {
          plugin.mount(_assertThisInitialized(_this), plugin);
        }
      });

      if (!_this.opts.disableStatusBar) {
        _this.uppy.use(StatusBar, {
          id: _this.id + ":StatusBar",
          target: _assertThisInitialized(_this),
          hideUploadButton: _this.opts.hideUploadButton,
          hideRetryButton: _this.opts.hideRetryButton,
          hidePauseResumeButton: _this.opts.hidePauseResumeButton,
          hideCancelButton: _this.opts.hideCancelButton,
          showProgressDetails: _this.opts.showProgressDetails,
          hideAfterFinish: _this.opts.hideProgressAfterFinish,
          locale: _this.opts.locale,
          doneButtonHandler: _this.opts.doneButtonHandler
        });
      }

      if (!_this.opts.disableInformer) {
        _this.uppy.use(Informer, {
          id: _this.id + ":Informer",
          target: _assertThisInitialized(_this)
        });
      }

      if (!_this.opts.disableThumbnailGenerator) {
        _this.uppy.use(ThumbnailGenerator, {
          id: _this.id + ":ThumbnailGenerator",
          thumbnailWidth: _this.opts.thumbnailWidth,
          thumbnailType: _this.opts.thumbnailType,
          waitForThumbnailsBeforeUpload: _this.opts.waitForThumbnailsBeforeUpload,
          // If we don't block on thumbnails, we can lazily generate them
          lazy: !_this.opts.waitForThumbnailsBeforeUpload
        });
      } // Dark Mode / theme


      _this.darkModeMediaQuery = typeof window !== 'undefined' && window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
      var isDarkModeOnFromTheStart = _this.darkModeMediaQuery ? _this.darkModeMediaQuery.matches : false;

      _this.uppy.log("[Dashboard] Dark mode is " + (isDarkModeOnFromTheStart ? 'on' : 'off'));

      _this.setDarkModeCapability(isDarkModeOnFromTheStart);

      if (_this.opts.theme === 'auto') {
        _this.darkModeMediaQuery.addListener(_this.handleSystemDarkModeChange);
      }

      _this.discoverProviderPlugins();

      _this.initEvents();
    };

    _this.uninstall = function () {
      if (!_this.opts.disableInformer) {
        var informer = _this.uppy.getPlugin(_this.id + ":Informer"); // Checking if this plugin exists, in case it was removed by uppy-core
        // before the Dashboard was.


        if (informer) _this.uppy.removePlugin(informer);
      }

      if (!_this.opts.disableStatusBar) {
        var statusBar = _this.uppy.getPlugin(_this.id + ":StatusBar");

        if (statusBar) _this.uppy.removePlugin(statusBar);
      }

      if (!_this.opts.disableThumbnailGenerator) {
        var thumbnail = _this.uppy.getPlugin(_this.id + ":ThumbnailGenerator");

        if (thumbnail) _this.uppy.removePlugin(thumbnail);
      }

      var plugins = _this.opts.plugins || [];
      plugins.forEach(function (pluginID) {
        var plugin = _this.uppy.getPlugin(pluginID);

        if (plugin) plugin.unmount();
      });

      if (_this.opts.theme === 'auto') {
        _this.darkModeMediaQuery.removeListener(_this.handleSystemDarkModeChange);
      }

      _this.unmount();

      _this.removeEvents();
    };

    _this.id = _this.opts.id || 'Dashboard';
    _this.title = 'Dashboard';
    _this.type = 'orchestrator';
    _this.modalName = "uppy-Dashboard-" + cuid();
    _this.defaultLocale = {
      strings: {
        closeModal: 'Close Modal',
        importFrom: 'Import from %{name}',
        addingMoreFiles: 'Adding more files',
        addMoreFiles: 'Add more files',
        dashboardWindowTitle: 'File Uploader Window (Press escape to close)',
        dashboardTitle: 'File Uploader',
        copyLinkToClipboardSuccess: 'Link copied to clipboard',
        copyLinkToClipboardFallback: 'Copy the URL below',
        copyLink: 'Copy link',
        fileSource: 'File source: %{name}',
        done: 'Done',
        back: 'Back',
        addMore: 'Add more',
        removeFile: 'Remove file',
        editFile: 'Edit file',
        editing: 'Editing %{file}',
        finishEditingFile: 'Finish editing file',
        saveChanges: 'Save changes',
        cancel: 'Cancel',
        myDevice: 'My Device',
        dropPasteFiles: 'Drop files here or %{browseFiles}',
        dropPasteFolders: 'Drop files here or %{browseFolders}',
        dropPasteBoth: 'Drop files here, %{browseFiles} or %{browseFolders}',
        dropPasteImportFiles: 'Drop files here, %{browseFiles} or import from:',
        dropPasteImportFolders: 'Drop files here, %{browseFolders} or import from:',
        dropPasteImportBoth: 'Drop files here, %{browseFiles}, %{browseFolders} or import from:',
        importFiles: 'Import files from:',
        dropHint: 'Drop your files here',
        browseFiles: 'browse files',
        browseFolders: 'browse folders',
        uploadComplete: 'Upload complete',
        uploadPaused: 'Upload paused',
        resumeUpload: 'Resume upload',
        pauseUpload: 'Pause upload',
        retryUpload: 'Retry upload',
        cancelUpload: 'Cancel upload',
        xFilesSelected: {
          0: '%{smart_count} file selected',
          1: '%{smart_count} files selected'
        },
        uploadingXFiles: {
          0: 'Uploading %{smart_count} file',
          1: 'Uploading %{smart_count} files'
        },
        processingXFiles: {
          0: 'Processing %{smart_count} file',
          1: 'Processing %{smart_count} files'
        },
        recoveredXFiles: {
          0: 'We could not fully recover 1 file. Please re-select it and resume the upload.',
          1: 'We could not fully recover %{smart_count} files. Please re-select them and resume the upload.'
        },
        recoveredAllFiles: 'We restored all files. You can now resume the upload.',
        sessionRestored: 'Session restored',
        reSelect: 'Re-select',
        // The default `poweredBy2` string only combines the `poweredBy` string (%{backwardsCompat}) with the size.
        // Locales can override `poweredBy2` to specify a different word order. This is for backwards compat with
        // Uppy 1.9.x and below which did a naive concatenation of `poweredBy2 + size` instead of using a locale-specific
        // substitution.
        // TODO: In 2.0 `poweredBy2` should be removed in and `poweredBy` updated to use substitution.
        poweredBy2: '%{backwardsCompat} %{uppy}',
        poweredBy: 'Powered by'
      }
    }; // set default options

    var defaultOptions = {
      target: 'body',
      metaFields: [],
      trigger: '#uppy-select-files',
      inline: false,
      width: 750,
      height: 550,
      thumbnailWidth: 280,
      thumbnailType: 'image/jpeg',
      waitForThumbnailsBeforeUpload: false,
      defaultPickerIcon: defaultPickerIcon,
      showLinkToFileUploadResult: true,
      showProgressDetails: false,
      hideUploadButton: false,
      hideCancelButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideProgressAfterFinish: false,
      doneButtonHandler: function doneButtonHandler() {
        _this.uppy.reset();

        _this.requestCloseModal();
      },
      note: null,
      closeModalOnClickOutside: false,
      closeAfterFinish: false,
      disableStatusBar: false,
      disableInformer: false,
      disableThumbnailGenerator: false,
      disablePageScrollWhenModalOpen: true,
      animateOpenClose: true,
      fileManagerSelectionType: 'files',
      proudlyDisplayPoweredByUppy: true,
      onRequestCloseModal: function onRequestCloseModal() {
        return _this.closeModal();
      },
      showSelectedFiles: true,
      showRemoveButtonAfterComplete: false,
      browserBackButtonClose: false,
      theme: 'light',
      autoOpenFileEditor: false,
      disabled: false,
      disableLocalFiles: false
    }; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, _opts);

    _this.i18nInit();

    _this.superFocus = createSuperFocus();
    _this.ifFocusedOnUppyRecently = false; // Timeouts

    _this.makeDashboardInsidesVisibleAnywayTimeout = null;
    _this.removeDragOverClassTimeout = null;
    return _this;
  }

  var _proto = Dashboard.prototype;

  _proto.onMount = function onMount() {
    // Set the text direction if the page has not defined one.
    var element = this.el;
    var direction = getTextDirection(element);

    if (!direction) {
      element.dir = 'ltr';
    }
  };

  return Dashboard;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":76,"./../../core":73,"./../../informer":110,"./../../status-bar":154,"./../../thumbnail-generator":158,"./../../utils/lib/FOCUSABLE_ELEMENTS":199,"./../../utils/lib/Translator":202,"./../../utils/lib/findAllDOMElements":207,"./../../utils/lib/getDroppedFiles":212,"./../../utils/lib/getTextDirection":222,"./../../utils/lib/toArray":235,"./components/Dashboard":79,"./utils/createSuperFocus":95,"./utils/trapFocus":99,"cuid":13,"memoize-one":34,"preact":37,"resize-observer-polyfill":43}],94:[function(require,module,exports){
/**
 * Copies text to clipboard by creating an almost invisible textarea,
 * adding text there, then running execCommand('copy').
 * Falls back to prompt() when the easy way fails (hello, Safari!)
 * From http://stackoverflow.com/a/30810322
 *
 * @param {string} textToCopy
 * @param {string} fallbackString
 * @returns {Promise}
 */
module.exports = function copyToClipboard(textToCopy, fallbackString) {
  fallbackString = fallbackString || 'Copy the URL below';
  return new Promise(function (resolve) {
    var textArea = document.createElement('textarea');
    textArea.setAttribute('style', {
      position: 'fixed',
      top: 0,
      left: 0,
      width: '2em',
      height: '2em',
      padding: 0,
      border: 'none',
      outline: 'none',
      boxShadow: 'none',
      background: 'transparent'
    });
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();

    var magicCopyFailed = function magicCopyFailed() {
      document.body.removeChild(textArea);
      window.prompt(fallbackString, textToCopy);
      resolve();
    };

    try {
      var successful = document.execCommand('copy');

      if (!successful) {
        return magicCopyFailed('copy command unavailable');
      }

      document.body.removeChild(textArea);
      return resolve();
    } catch (err) {
      document.body.removeChild(textArea);
      return magicCopyFailed(err);
    }
  });
};

},{}],95:[function(require,module,exports){
var debounce = require('lodash.debounce');

var FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

var getActiveOverlayEl = require('./getActiveOverlayEl');
/*
  Focuses on some element in the currently topmost overlay.

  1. If there are some [data-uppy-super-focusable] elements rendered already - focuses on the first superfocusable element, and leaves focus up to the control of a user (until currently focused element disappears from the screen [which can happen when overlay changes, or, e.g., when we click on a folder in googledrive]).
  2. If there are no [data-uppy-super-focusable] elements yet (or ever) - focuses on the first focusable element, but switches focus if superfocusable elements appear on next render.
*/


module.exports = function createSuperFocus() {
  var lastFocusWasOnSuperFocusableEl = false;

  var superFocus = function superFocus(dashboardEl, activeOverlayType) {
    var overlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
    var isFocusInOverlay = overlayEl.contains(document.activeElement); // If focus is already in the topmost overlay, AND on last update we focused on the superfocusable element - then leave focus up to the user.
    // [Practical check] without this line, typing in the search input in googledrive overlay won't work.

    if (isFocusInOverlay && lastFocusWasOnSuperFocusableEl) return;
    var superFocusableEl = overlayEl.querySelector('[data-uppy-super-focusable]'); // If we are already in the topmost overlay, AND there are no super focusable elements yet, - leave focus up to the user.
    // [Practical check] without this line, if you are in an empty folder in google drive, and something's uploading in the bg, - focus will be jumping to Done all the time.

    if (isFocusInOverlay && !superFocusableEl) return;

    if (superFocusableEl) {
      superFocusableEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = true;
    } else {
      var firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS);
      firstEl && firstEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = false;
    }
  }; // ___Why do we need to debounce?
  //    1. To deal with animations: overlay changes via animations, which results in the DOM updating AFTER plugin.update() already executed.
  //    [Practical check] without debounce, if we open the Url overlay, and click 'Done', Dashboard won't get focused again.
  //    [Practical check] if we delay 250ms instead of 260ms - IE11 won't get focused in same situation.
  //    2. Performance: there can be many state update()s in a second, and this function is called every time.


  return debounce(superFocus, 260);
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":199,"./getActiveOverlayEl":96,"lodash.debounce":31}],96:[function(require,module,exports){
/**
 * @returns {HTMLElement} - either dashboard element, or the overlay that's most on top
 */
module.exports = function getActiveOverlayEl(dashboardEl, activeOverlayType) {
  if (activeOverlayType) {
    var overlayEl = dashboardEl.querySelector("[data-uppy-paneltype=\"" + activeOverlayType + "\"]"); // if an overlay is already mounted

    if (overlayEl) return overlayEl;
  }

  return dashboardEl;
};

},{}],97:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function iconImage() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#686DE0",
    fillRule: "evenodd"
  }, h("path", {
    d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z",
    fillRule: "nonzero"
  }), h("path", {
    d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z",
    fillRule: "nonzero"
  }), h("circle", {
    cx: "7.5",
    cy: "9.5",
    r: "1.5"
  })));
}

function iconAudio() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
    fill: "#049BCF",
    fillRule: "nonzero"
  }));
}

function iconVideo() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
    fill: "#19AF67",
    fillRule: "nonzero"
  }));
}

function iconPDF() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
    fill: "#E2514A",
    fillRule: "nonzero"
  }));
}

function iconArchive() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z",
    fill: "#00C469",
    fillRule: "nonzero"
  }));
}

function iconFile() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#A7AFB7",
    fillRule: "nonzero"
  }, h("path", {
    d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
  }), h("path", {
    d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
  })));
}

function iconText() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
    fill: "#5A5E69",
    fillRule: "nonzero"
  }));
}

module.exports = function getIconByMime(fileType) {
  var defaultChoice = {
    color: '#838999',
    icon: iconFile()
  };
  if (!fileType) return defaultChoice;
  var fileTypeGeneral = fileType.split('/')[0];
  var fileTypeSpecific = fileType.split('/')[1]; // Text

  if (fileTypeGeneral === 'text') {
    return {
      color: '#5a5e69',
      icon: iconText()
    };
  } // Image


  if (fileTypeGeneral === 'image') {
    return {
      color: '#686de0',
      icon: iconImage()
    };
  } // Audio


  if (fileTypeGeneral === 'audio') {
    return {
      color: '#068dbb',
      icon: iconAudio()
    };
  } // Video


  if (fileTypeGeneral === 'video') {
    return {
      color: '#19af67',
      icon: iconVideo()
    };
  } // PDF


  if (fileTypeGeneral === 'application' && fileTypeSpecific === 'pdf') {
    return {
      color: '#e25149',
      icon: iconPDF()
    };
  } // Archive


  var archiveTypes = ['zip', 'x-7z-compressed', 'x-rar-compressed', 'x-tar', 'x-gzip', 'x-apple-diskimage'];

  if (fileTypeGeneral === 'application' && archiveTypes.indexOf(fileTypeSpecific) !== -1) {
    return {
      color: '#00C469',
      icon: iconArchive()
    };
  }

  return defaultChoice;
};

},{"preact":37}],98:[function(require,module,exports){
// ignore drop/paste events if they are not in input or textarea —
// otherwise when Url plugin adds drop/paste listeners to this.el,
// draging UI elements or pasting anything into any field triggers those events —
// Url treats them as URLs that need to be imported
function ignoreEvent(ev) {
  var tagName = ev.target.tagName;

  if (tagName === 'INPUT' || tagName === 'TEXTAREA') {
    ev.stopPropagation();
    return;
  }

  ev.preventDefault();
  ev.stopPropagation();
}

module.exports = ignoreEvent;

},{}],99:[function(require,module,exports){
var toArray = require('./../../../utils/lib/toArray');

var getActiveOverlayEl = require('./getActiveOverlayEl');

var FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

function focusOnFirstNode(event, nodes) {
  var node = nodes[0];

  if (node) {
    node.focus();
    event.preventDefault();
  }
}

function focusOnLastNode(event, nodes) {
  var node = nodes[nodes.length - 1];

  if (node) {
    node.focus();
    event.preventDefault();
  }
} // ___Why not just use (focusedItemIndex === -1)?
//    Firefox thinks <ul> is focusable, but we don't have <ul>s in our FOCUSABLE_ELEMENTS. Which means that if we tab into the <ul>, code will think that we are not in the active overlay, and we should focusOnFirstNode() of the currently active overlay!
//    [Practical check] if we use (focusedItemIndex === -1), instagram provider in firefox will never get focus on its pics in the <ul>.


function isFocusInOverlay(activeOverlayEl) {
  return activeOverlayEl.contains(document.activeElement);
}

function trapFocus(event, activeOverlayType, dashboardEl) {
  var activeOverlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
  var focusableNodes = toArray(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS));
  var focusedItemIndex = focusableNodes.indexOf(document.activeElement); // If we pressed tab, and focus is not yet within the current overlay - focus on the first element within the current overlay.
  // This is a safety measure (for when user returns from another tab e.g.), most plugins will try to focus on some important element as it loads.

  if (!isFocusInOverlay(activeOverlayEl)) {
    focusOnFirstNode(event, focusableNodes); // If we pressed shift + tab, and we're on the first element of a modal
  } else if (event.shiftKey && focusedItemIndex === 0) {
    focusOnLastNode(event, focusableNodes); // If we pressed tab, and we're on the last element of the modal
  } else if (!event.shiftKey && focusedItemIndex === focusableNodes.length - 1) {
    focusOnFirstNode(event, focusableNodes);
  }
}

module.exports = {
  // Traps focus inside of the currently open overlay (e.g. Dashboard, or e.g. Instagram), never lets focus disappear from the modal.
  forModal: function forModal(event, activeOverlayType, dashboardEl) {
    trapFocus(event, activeOverlayType, dashboardEl);
  },
  // Traps focus inside of the currently open overlay, unless overlay is null - then let the user tab away.
  forInline: function forInline(event, activeOverlayType, dashboardEl) {
    // ___When we're in the bare 'Drop files here, paste, browse or import from' screen
    if (activeOverlayType === null) {// Do nothing and let the browser handle it, user can tab away from Uppy to other elements on the page
      // ___When there is some overlay with 'Done' button
    } else {
      // Trap the focus inside this overlay!
      // User can close the overlay (click 'Done') if they want to travel away from Uppy.
      trapFocus(event, activeOverlayType, dashboardEl);
    }
  }
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":199,"./../../../utils/lib/toArray":235,"./getActiveOverlayEl":96}],100:[function(require,module,exports){
module.exports={
  "name": "@uppy/dropbox",
  "description": "Import files from Dropbox, into Uppy.",
  "version": "1.5.1",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dropbox"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],101:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Dropbox, _Plugin);

  function Dropbox(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Dropbox';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Dropbox';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#0D2481",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M11 8l5 3.185-5 3.186-5-3.186L11 8zm10 0l5 3.185-5 3.186-5-3.186L21 8zM6 17.556l5-3.185 5 3.185-5 3.186-5-3.186zm15-3.185l5 3.185-5 3.186-5-3.186 5-3.185zm-10 7.432l5-3.185 5 3.185-5 3.186-5-3.186z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'dropbox',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Dropbox.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Dropbox;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":100,"./../../companion-client":69,"./../../core":73,"./../../provider-views":137,"preact":37}],102:[function(require,module,exports){
module.exports={
  "name": "@uppy/facebook",
  "description": "Import files from Facebook, into Uppy.",
  "version": "1.2.1",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "facebook"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],103:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Facebook, _Plugin);

  function Facebook(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Facebook';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Facebook';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#3C5A99"
      }), h("path", {
        d: "M17.842 26v-8.667h2.653l.398-3.377h-3.051v-2.157c0-.978.248-1.644 1.527-1.644H21V7.132A19.914 19.914 0 0 0 18.623 7c-2.352 0-3.963 1.574-3.963 4.465v2.49H12v3.378h2.66V26h3.182z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'facebook',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Facebook.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    var viewOptions = {};

    if (this.getPluginState().files.length && !this.getPluginState().folders.length) {
      viewOptions.viewType = 'grid';
      viewOptions.showFilter = false;
      viewOptions.showTitles = false;
    }

    return this.view.render(state, viewOptions);
  };

  return Facebook;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":102,"./../../companion-client":69,"./../../core":73,"./../../provider-views":137,"preact":37}],104:[function(require,module,exports){
module.exports={
  "name": "@uppy/form",
  "description": "Connect Uppy to an existing HTML <form>.",
  "version": "1.3.30",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "form"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "get-form-data": "^2.0.0"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],105:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var findDOMElement = require('./../../utils/lib/findDOMElement');

var toArray = require('./../../utils/lib/toArray'); // Rollup uses get-form-data's ES modules build, and rollup-plugin-commonjs automatically resolves `.default`.
// So, if we are being built using rollup, this require() won't have a `.default` property.


var getFormData = require('get-form-data').default || require('get-form-data');
/**
 * Form
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Form, _Plugin);

  function Form(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'acquirer';
    _this.id = _this.opts.id || 'Form';
    _this.title = 'Form'; // set default options

    var defaultOptions = {
      target: null,
      resultName: 'uppyResult',
      getMetaFromForm: true,
      addResultToForm: true,
      multipleResults: false,
      submitOnSuccess: false,
      triggerUploadOnSubmit: false
    }; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, opts);
    _this.handleFormSubmit = _this.handleFormSubmit.bind(_assertThisInitialized(_this));
    _this.handleUploadStart = _this.handleUploadStart.bind(_assertThisInitialized(_this));
    _this.handleSuccess = _this.handleSuccess.bind(_assertThisInitialized(_this));
    _this.addResultToForm = _this.addResultToForm.bind(_assertThisInitialized(_this));
    _this.getMetaFromForm = _this.getMetaFromForm.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Form.prototype;

  _proto.handleUploadStart = function handleUploadStart() {
    if (this.opts.getMetaFromForm) {
      this.getMetaFromForm();
    }
  };

  _proto.handleSuccess = function handleSuccess(result) {
    if (this.opts.addResultToForm) {
      this.addResultToForm(result);
    }

    if (this.opts.submitOnSuccess) {
      this.form.submit();
    }
  };

  _proto.handleFormSubmit = function handleFormSubmit(ev) {
    var _this2 = this;

    if (this.opts.triggerUploadOnSubmit) {
      ev.preventDefault();
      var elements = toArray(ev.target.elements);
      var disabledByUppy = [];
      elements.forEach(function (el) {
        var isButton = el.tagName === 'BUTTON' || el.tagName === 'INPUT' && el.type === 'submit';

        if (isButton && !el.disabled) {
          el.disabled = true;
          disabledByUppy.push(el);
        }
      });
      this.uppy.upload().then(function () {
        disabledByUppy.forEach(function (button) {
          button.disabled = false;
        });
      }, function (err) {
        disabledByUppy.forEach(function (button) {
          button.disabled = false;
        });
        return Promise.reject(err);
      }).catch(function (err) {
        _this2.uppy.log(err.stack || err.message || err);
      });
    }
  };

  _proto.addResultToForm = function addResultToForm(result) {
    this.uppy.log('[Form] Adding result to the original form:');
    this.uppy.log(result);
    var resultInput = this.form.querySelector("[name=\"" + this.opts.resultName + "\"]");

    if (resultInput) {
      if (this.opts.multipleResults) {
        // Append new result to the previous result array.
        // If the previous result is empty, or not an array,
        // set it to an empty array.
        var updatedResult;

        try {
          updatedResult = JSON.parse(resultInput.value);
        } catch (err) {// Nothing, since we check for array below anyway
        }

        if (!Array.isArray(updatedResult)) {
          updatedResult = [];
        }

        updatedResult.push(result);
        resultInput.value = JSON.stringify(updatedResult);
      } else {
        // Replace existing result with the newer result on `complete` event.
        // This behavior is not ideal, since you most likely want to always keep
        // all results in the input. This is kept for backwards compatability until 2.0.
        resultInput.value = JSON.stringify(result);
      }

      return;
    }

    resultInput = document.createElement('input');
    resultInput.name = this.opts.resultName;
    resultInput.type = 'hidden';

    if (this.opts.multipleResults) {
      // Wrap result in an array so we can have multiple results
      resultInput.value = JSON.stringify([result]);
    } else {
      // Result is an object, kept for backwards compatability until 2.0
      resultInput.value = JSON.stringify(result);
    }

    this.form.appendChild(resultInput);
  };

  _proto.getMetaFromForm = function getMetaFromForm() {
    var formMeta = getFormData(this.form); // We want to exclude meta the the Form plugin itself has added
    // See https://github.com/transloadit/uppy/issues/1637

    delete formMeta[this.opts.resultName];
    this.uppy.setMeta(formMeta);
  };

  _proto.install = function install() {
    this.form = findDOMElement(this.opts.target);

    if (!this.form || this.form.nodeName !== 'FORM') {
      this.uppy.log('Form plugin requires a <form> target element passed in options to operate, none was found', 'error');
      return;
    }

    this.form.addEventListener('submit', this.handleFormSubmit);
    this.uppy.on('upload', this.handleUploadStart);
    this.uppy.on('complete', this.handleSuccess);
  };

  _proto.uninstall = function uninstall() {
    this.form.removeEventListener('submit', this.handleFormSubmit);
    this.uppy.off('upload', this.handleUploadStart);
    this.uppy.off('complete', this.handleSuccess);
  };

  return Form;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":104,"./../../core":73,"./../../utils/lib/findDOMElement":208,"./../../utils/lib/toArray":235,"get-form-data":23}],106:[function(require,module,exports){
module.exports={
  "name": "@uppy/google-drive",
  "description": "The Google Drive plugin for Uppy lets users import files from their Google Drive account",
  "version": "1.7.1",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "google drive",
    "cloud storage",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],107:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../provider-views'),
    ProviderViews = _require.ProviderViews;

module.exports = /*#__PURE__*/function (_ProviderViews) {
  _inheritsLoose(DriveProviderViews, _ProviderViews);

  function DriveProviderViews() {
    return _ProviderViews.apply(this, arguments) || this;
  }

  var _proto = DriveProviderViews.prototype;

  _proto.toggleCheckbox = function toggleCheckbox(e, file) {
    e.stopPropagation();
    e.preventDefault(); // Shared Drives aren't selectable; for all else, defer to the base ProviderView.
    // @todo isTeamDrive is left for backward compatibility. We should remove it in the next
    // major release.

    if (!file.custom.isTeamDrive && !file.custom.isSharedDrive) {
      _ProviderViews.prototype.toggleCheckbox.call(this, e, file);
    }
  };

  return DriveProviderViews;
}(ProviderViews);

},{"./../../provider-views":137}],108:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var DriveProviderViews = require('./DriveProviderViews');

var _require3 = require('preact'),
    h = _require3.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(GoogleDrive, _Plugin);

  function GoogleDrive(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'GoogleDrive';
    _this.title = _this.opts.title || 'Google Drive';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Google Drive';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#4285F4",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M10.324 23.3l3-5.1H25l-3 5.1H10.324zM13 18.2l-3 5.1-3-5.1 5.839-9.924 2.999 5.1L13 18.2zm11.838-.276h-6L13 8h6l5.84 9.924h-.002z",
        fill: "#FFF"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'drive',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = GoogleDrive.prototype;

  _proto.install = function install() {
    this.view = new DriveProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder('root', '/')]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return GoogleDrive;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":106,"./../../companion-client":69,"./../../core":73,"./DriveProviderViews":107,"preact":37}],109:[function(require,module,exports){
module.exports={
  "name": "@uppy/informer",
  "description": "A notification and error pop-up bar for Uppy.",
  "version": "1.6.5",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "notification",
    "bar",
    "ui"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],110:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('preact'),
    h = _require2.h;
/**
 * Informer
 * Shows rad message bubbles
 * used like this: `uppy.info('hello world', 'info', 5000)`
 * or for errors: `uppy.info('Error uploading img.jpg', 'error', 5000)`
 *
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Informer, _Plugin);

  function Informer(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.render = function (state) {
      var _state$info = state.info,
          isHidden = _state$info.isHidden,
          message = _state$info.message,
          details = _state$info.details;

      function displayErrorAlert() {
        var errorMessage = message + " \n\n " + details;
        alert(errorMessage);
      }

      var handleMouseOver = function handleMouseOver() {
        clearTimeout(_this.uppy.infoTimeoutID);
      };

      var handleMouseLeave = function handleMouseLeave() {
        _this.uppy.infoTimeoutID = setTimeout(_this.uppy.hideInfo, 2000);
      };

      return h("div", {
        className: "uppy uppy-Informer",
        "aria-hidden": isHidden
      }, h("p", {
        role: "alert"
      }, message, ' ', details && h("span", {
        "aria-label": details,
        "data-microtip-position": "top-left",
        "data-microtip-size": "medium",
        role: "tooltip",
        onClick: displayErrorAlert,
        onMouseOver: handleMouseOver,
        onMouseLeave: handleMouseLeave
      }, "?")));
    };

    _this.type = 'progressindicator';
    _this.id = _this.opts.id || 'Informer';
    _this.title = 'Informer'; // set default options

    var defaultOptions = {}; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, opts);
    return _this;
  }

  var _proto = Informer.prototype;

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  return Informer;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":109,"./../../core":73,"preact":37}],111:[function(require,module,exports){
module.exports={
  "name": "@uppy/instagram",
  "description": "Import photos and videos from Instagram, into Uppy.",
  "version": "1.5.1",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "instagram",
    "provider",
    "photos",
    "videos"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],112:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Instagram, _Plugin);

  function Instagram(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Instagram';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Instagram';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#E1306C",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M16 8.622c2.403 0 2.688.009 3.637.052.877.04 1.354.187 1.67.31.392.144.745.374 1.036.673.299.29.529.644.673 1.035.123.317.27.794.31 1.671.043.95.052 1.234.052 3.637s-.009 2.688-.052 3.637c-.04.877-.187 1.354-.31 1.671a2.98 2.98 0 0 1-1.708 1.708c-.317.123-.794.27-1.671.31-.95.043-1.234.053-3.637.053s-2.688-.01-3.637-.053c-.877-.04-1.354-.187-1.671-.31a2.788 2.788 0 0 1-1.035-.673 2.788 2.788 0 0 1-.673-1.035c-.123-.317-.27-.794-.31-1.671-.043-.949-.052-1.234-.052-3.637s.009-2.688.052-3.637c.04-.877.187-1.354.31-1.67.144-.392.374-.745.673-1.036.29-.299.644-.529 1.035-.673.317-.123.794-.27 1.671-.31.95-.043 1.234-.052 3.637-.052zM16 7c-2.444 0-2.75.01-3.71.054-.959.044-1.613.196-2.185.419-.6.225-1.145.58-1.594 1.038-.458.45-.813.993-1.039 1.594-.222.572-.374 1.226-.418 2.184C7.01 13.25 7 13.556 7 16s.01 2.75.054 3.71c.044.959.196 1.613.419 2.185.226.6.58 1.145 1.038 1.594.45.458.993.813 1.594 1.038.572.223 1.227.375 2.184.419.96.044 1.267.054 3.711.054s2.75-.01 3.71-.054c.959-.044 1.613-.196 2.185-.419a4.602 4.602 0 0 0 2.632-2.632c.223-.572.375-1.226.419-2.184.044-.96.054-1.267.054-3.711s-.01-2.75-.054-3.71c-.044-.959-.196-1.613-.419-2.185A4.412 4.412 0 0 0 23.49 8.51a4.412 4.412 0 0 0-1.594-1.039c-.572-.222-1.226-.374-2.184-.418C18.75 7.01 18.444 7 16 7zm0 4.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9zm0 7.421a2.921 2.921 0 1 1 0-5.842 2.921 2.921 0 0 1 0 5.842zm4.875-6.671a1.125 1.125 0 1 1 0-2.25 1.125 1.125 0 0 1 0 2.25z",
        fill: "#FFF"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'instagram',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Instagram.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider,
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder('recent')]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Instagram;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":111,"./../../companion-client":69,"./../../core":73,"./../../provider-views":137,"preact":37}],113:[function(require,module,exports){
module.exports={
  "name": "@uppy/onedrive",
  "description": "Import files from OneDrive, into Uppy.",
  "version": "1.2.1",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "onedrive"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],114:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(OneDrive, _Plugin);

  function OneDrive(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'OneDrive';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'OneDrive';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#0262C0"
      }), h("g", {
        fill: "#FFF",
        fillRule: "nonzero"
      }, h("path", {
        d: "M24.157 22s1.492-.205 1.79-1.655a2.624 2.624 0 0 0 .03-.878c-.22-1.64-1.988-2.01-1.988-2.01s.307-1.765-1.312-2.69c-1.62-.925-3.1 0-3.1 0S18.711 13 16.366 13c-3.016 0-3.519 3.448-3.519 3.448S10 16.618 10 19.14c0 2.523 2.597 2.86 2.597 2.86h11.56z"
      }), h("path", {
        d: "M9.421 19.246c0-2.197 1.606-3.159 2.871-3.472.44-1.477 1.654-3.439 4.135-3.439H16.445c1.721 0 2.79.823 3.368 1.476a3.99 3.99 0 0 1 1.147-.171h.01l.03.002C21.017 13.5 20.691 10 16.757 10c-2.69 0-3.639 2.345-3.639 2.345s-1.95-1.482-3.955.567c-1.028 1.052-.79 2.669-.79 2.669S6 15.824 6 18.412C6 20.757 8.452 21 8.452 21h1.372a3.77 3.77 0 0 1-.403-1.754z"
      }))));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'onedrive',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = OneDrive.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return OneDrive;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":113,"./../../companion-client":69,"./../../core":73,"./../../provider-views":137,"preact":37}],115:[function(require,module,exports){
module.exports={
  "name": "@uppy/provider-views",
  "description": "View library for Uppy remote provider plugins.",
  "version": "1.12.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],116:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // TODO use Fragment when upgrading to preact X


var Breadcrumb = function Breadcrumb(props) {
  return h("span", null, h("button", {
    type: "button",
    className: "uppy-u-reset",
    onClick: props.getFolder
  }, props.title), !props.isLast ? ' / ' : '');
};

module.exports = function (props) {
  return h("div", {
    className: "uppy-Provider-breadcrumbs"
  }, h("div", {
    className: "uppy-Provider-breadcrumbsIcon"
  }, props.breadcrumbsIcon), props.directories.map(function (directory, i) {
    return h(Breadcrumb, {
      key: directory.id,
      getFolder: function getFolder() {
        return props.getFolder(directory.id);
      },
      title: i === 0 ? props.title : directory.title,
      isLast: i + 1 === props.directories.length
    });
  }));
};

},{"preact":37}],117:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var classNames = require('classnames');

var Filter = require('./Filter');

var ItemList = require('./ItemList');

var FooterActions = require('./FooterActions');

var _require = require('preact'),
    h = _require.h;

var Browser = function Browser(props) {
  var currentSelection = props.currentSelection,
      folders = props.folders,
      files = props.files,
      uppyFiles = props.uppyFiles,
      filterItems = props.filterItems,
      filterInput = props.filterInput;
  var filteredFolders = folders;
  var filteredFiles = files;

  if (filterInput !== '') {
    filteredFolders = filterItems(folders);
    filteredFiles = filterItems(files);
  }

  var selected = currentSelection.length;
  return h("div", {
    className: classNames('uppy-ProviderBrowser', "uppy-ProviderBrowser-viewType--" + props.viewType)
  }, h("div", {
    className: "uppy-ProviderBrowser-header"
  }, h("div", {
    className: classNames('uppy-ProviderBrowser-headerBar', !props.showBreadcrumbs && 'uppy-ProviderBrowser-headerBar--simple')
  }, props.headerComponent)), props.showFilter && h(Filter, props), h(ItemList, {
    columns: [{
      name: 'Name',
      key: 'title'
    }],
    folders: filteredFolders,
    files: filteredFiles,
    sortByTitle: props.sortByTitle,
    sortByDate: props.sortByDate,
    isChecked: props.isChecked,
    handleFolderClick: props.getNextFolder,
    toggleCheckbox: props.toggleCheckbox,
    handleScroll: props.handleScroll,
    title: props.title,
    showTitles: props.showTitles,
    i18n: props.i18n,
    viewType: props.viewType,
    validateRestrictions: props.validateRestrictions,
    uppyFiles: uppyFiles,
    currentSelection: currentSelection
  }), selected > 0 && h(FooterActions, _extends({
    selected: selected
  }, props)));
};

module.exports = Browser;

},{"./Filter":119,"./FooterActions":120,"./ItemList":125,"classnames":10,"preact":37}],118:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    Component = _require.Component;

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CloseWrapper, _Component);

  function CloseWrapper() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = CloseWrapper.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.onUnmount();
  };

  _proto.render = function render() {
    return this.props.children[0];
  };

  return CloseWrapper;
}(Component);

},{"preact":37}],119:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Filter, _Component);

  function Filter(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.preventEnterPress = _this.preventEnterPress.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Filter.prototype;

  _proto.preventEnterPress = function preventEnterPress(ev) {
    if (ev.keyCode === 13) {
      ev.stopPropagation();
      ev.preventDefault();
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-ProviderBrowser-search"
    }, h("input", {
      className: "uppy-u-reset uppy-ProviderBrowser-searchInput",
      type: "text",
      placeholder: this.props.i18n('filter'),
      "aria-label": this.props.i18n('filter'),
      onKeyUp: this.preventEnterPress,
      onKeyDown: this.preventEnterPress,
      onKeyPress: this.preventEnterPress,
      onInput: function onInput(e) {
        return _this2.props.filterQuery(e);
      },
      value: this.props.filterInput
    }), h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-ProviderBrowser-searchIcon",
      width: "12",
      height: "12",
      viewBox: "0 0 12 12"
    }, h("path", {
      d: "M8.638 7.99l3.172 3.172a.492.492 0 1 1-.697.697L7.91 8.656a4.977 4.977 0 0 1-2.983.983C2.206 9.639 0 7.481 0 4.819 0 2.158 2.206 0 4.927 0c2.721 0 4.927 2.158 4.927 4.82a4.74 4.74 0 0 1-1.216 3.17zm-3.71.685c2.176 0 3.94-1.726 3.94-3.856 0-2.129-1.764-3.855-3.94-3.855C2.75.964.984 2.69.984 4.819c0 2.13 1.765 3.856 3.942 3.856z"
    })), this.props.filterInput && h("button", {
      className: "uppy-u-reset uppy-ProviderBrowser-searchClose",
      type: "button",
      "aria-label": this.props.i18n('resetFilter'),
      title: this.props.i18n('resetFilter'),
      onClick: this.props.filterQuery
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      viewBox: "0 0 19 19"
    }, h("path", {
      d: "M17.318 17.232L9.94 9.854 9.586 9.5l-.354.354-7.378 7.378h.707l-.62-.62v.706L9.318 9.94l.354-.354-.354-.354L1.94 1.854v.707l.62-.62h-.706l7.378 7.378.354.354.354-.354 7.378-7.378h-.707l.622.62v-.706L9.854 9.232l-.354.354.354.354 7.378 7.378.708-.707-7.38-7.378v.708l7.38-7.38.353-.353-.353-.353-.622-.622-.353-.353-.354.352-7.378 7.38h.708L2.56 1.23 2.208.88l-.353.353-.622.62-.353.355.352.353 7.38 7.38v-.708l-7.38 7.38-.353.353.352.353.622.622.353.353.354-.353 7.38-7.38h-.708l7.38 7.38z"
    }))));
  };

  return Filter;
}(Component);

},{"preact":37}],120:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-ProviderBrowser-footer"
  }, h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary",
    onClick: props.done
  }, props.i18n('selectX', {
    smart_count: props.selected
  })), h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-link",
    onClick: props.cancel
  }, props.i18n('cancel')));
};

},{"preact":37}],121:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // it could be a <li><button class="fake-checkbox"/> <button/></li>


module.exports = function (props) {
  return h("li", {
    className: props.className,
    title: props.isDisabled ? props.restrictionReason : null
  }, h("div", {
    "aria-hidden": true,
    className: "uppy-ProviderBrowserItem-fakeCheckbox " + (props.isChecked ? 'uppy-ProviderBrowserItem-fakeCheckbox--is-checked' : '')
  }), h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onClick: props.toggleCheckbox,
    role: "option",
    "aria-label": props.isChecked ? props.i18n('unselectFileNamed', {
      name: props.title
    }) : props.i18n('selectFileNamed', {
      name: props.title
    }),
    "aria-selected": props.isChecked,
    "aria-disabled": props.isDisabled,
    disabled: props.isDisabled,
    "data-uppy-super-focusable": true
  }, props.itemIconEl, props.showTitles && props.title));
};

},{"preact":37}],122:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function FileIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: 11,
    height: 14.5,
    viewBox: "0 0 44 58"
  }, h("path", {
    d: "M27.437.517a1 1 0 0 0-.094.03H4.25C2.037.548.217 2.368.217 4.58v48.405c0 2.212 1.82 4.03 4.03 4.03H39.03c2.21 0 4.03-1.818 4.03-4.03V15.61a1 1 0 0 0-.03-.28 1 1 0 0 0 0-.093 1 1 0 0 0-.03-.032 1 1 0 0 0 0-.03 1 1 0 0 0-.032-.063 1 1 0 0 0-.03-.063 1 1 0 0 0-.032 0 1 1 0 0 0-.03-.063 1 1 0 0 0-.032-.03 1 1 0 0 0-.03-.063 1 1 0 0 0-.063-.062l-14.593-14a1 1 0 0 0-.062-.062A1 1 0 0 0 28 .708a1 1 0 0 0-.374-.157 1 1 0 0 0-.156 0 1 1 0 0 0-.03-.03l-.003-.003zM4.25 2.547h22.218v9.97c0 2.21 1.82 4.03 4.03 4.03h10.564v36.438a2.02 2.02 0 0 1-2.032 2.032H4.25c-1.13 0-2.032-.9-2.032-2.032V4.58c0-1.13.902-2.032 2.03-2.032zm24.218 1.345l10.375 9.937.75.718H30.5c-1.13 0-2.032-.9-2.032-2.03V3.89z"
  }));
}

function FolderIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    style: {
      minWidth: 16,
      marginRight: 3
    },
    viewBox: "0 0 276.157 276.157"
  }, h("path", {
    d: "M273.08 101.378c-3.3-4.65-8.86-7.32-15.254-7.32h-24.34V67.59c0-10.2-8.3-18.5-18.5-18.5h-85.322c-3.63 0-9.295-2.875-11.436-5.805l-6.386-8.735c-4.982-6.814-15.104-11.954-23.546-11.954H58.73c-9.292 0-18.638 6.608-21.737 15.372l-2.033 5.752c-.958 2.71-4.72 5.37-7.596 5.37H18.5C8.3 49.09 0 57.39 0 67.59v167.07c0 .886.16 1.73.443 2.52.152 3.306 1.18 6.424 3.053 9.064 3.3 4.652 8.86 7.32 15.255 7.32h188.487c11.395 0 23.27-8.425 27.035-19.18l40.677-116.188c2.11-6.035 1.43-12.164-1.87-16.816zM18.5 64.088h8.864c9.295 0 18.64-6.607 21.738-15.37l2.032-5.75c.96-2.712 4.722-5.373 7.597-5.373h29.565c3.63 0 9.295 2.876 11.437 5.806l6.386 8.735c4.982 6.815 15.104 11.954 23.546 11.954h85.322c1.898 0 3.5 1.602 3.5 3.5v26.47H69.34c-11.395 0-23.27 8.423-27.035 19.178L15 191.23V67.59c0-1.898 1.603-3.5 3.5-3.5zm242.29 49.15l-40.676 116.188c-1.674 4.78-7.812 9.135-12.877 9.135H18.75c-1.447 0-2.576-.372-3.02-.997-.442-.625-.422-1.814.057-3.18l40.677-116.19c1.674-4.78 7.812-9.134 12.877-9.134h188.487c1.448 0 2.577.372 3.02.997.443.625.423 1.814-.056 3.18z"
  }));
}

function VideoIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    style: {
      width: 16,
      marginRight: 4
    },
    viewBox: "0 0 58 58"
  }, h("path", {
    d: "M36.537 28.156l-11-7a1.005 1.005 0 0 0-1.02-.033C24.2 21.3 24 21.635 24 22v14a1 1 0 0 0 1.537.844l11-7a1.002 1.002 0 0 0 0-1.688zM26 34.18V23.82L34.137 29 26 34.18z"
  }), h("path", {
    d: "M57 6H1a1 1 0 0 0-1 1v44a1 1 0 0 0 1 1h56a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM10 28H2v-9h8v9zm-8 2h8v9H2v-9zm10 10V8h34v42H12V40zm44-12h-8v-9h8v9zm-8 2h8v9h-8v-9zm8-22v9h-8V8h8zM2 8h8v9H2V8zm0 42v-9h8v9H2zm54 0h-8v-9h8v9z"
  }));
}

module.exports = function (props) {
  if (props.itemIconString === null) return;

  switch (props.itemIconString) {
    case 'file':
      return h(FileIcon, null);

    case 'folder':
      return h(FolderIcon, null);

    case 'video':
      return h(VideoIcon, null);

    default:
      return h("img", {
        src: props.itemIconString
      });
  }
};

},{"preact":37}],123:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var getAriaLabelOfCheckbox = function getAriaLabelOfCheckbox(props) {
  if (props.type === 'folder') {
    if (props.isChecked) {
      return props.i18n('unselectAllFilesFromFolderNamed', {
        name: props.title
      });
    }

    return props.i18n('selectAllFilesFromFolderNamed', {
      name: props.title
    });
  }

  if (props.isChecked) {
    return props.i18n('unselectFileNamed', {
      name: props.title
    });
  }

  return props.i18n('selectFileNamed', {
    name: props.title
  });
}; // if folder:
//   + checkbox (selects all files from folder)
//   + folder name (opens folder)
// if file:
//   + checkbox (selects file)
//   + file name (selects file)


module.exports = function (props) {
  return h("li", {
    className: props.className,
    title: props.isDisabled ? props.restrictionReason : null
  }, !props.isCheckboxDisabled ? h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-fakeCheckbox " + (props.isChecked ? 'uppy-ProviderBrowserItem-fakeCheckbox--is-checked' : ''),
    onClick: props.toggleCheckbox // for the <label/>
    ,
    id: props.id,
    role: "option",
    "aria-label": getAriaLabelOfCheckbox(props),
    "aria-selected": props.isChecked,
    "aria-disabled": props.isDisabled,
    disabled: props.isDisabled,
    "data-uppy-super-focusable": true
  }) : null, props.type === 'file' ? // label for a checkbox
  h("label", {
    htmlFor: props.id,
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner"
  }, h("div", {
    className: "uppy-ProviderBrowserItem-iconWrap"
  }, props.itemIconEl), props.showTitles && props.title) : // button to open a folder
  h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onClick: props.handleFolderClick,
    "aria-label": props.i18n('openFolderNamed', {
      name: props.title
    })
  }, h("div", {
    className: "uppy-ProviderBrowserItem-iconWrap"
  }, props.itemIconEl), props.showTitles && h("span", null, props.title)));
};

},{"preact":37}],124:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var ItemIcon = require('./components/ItemIcon');

var GridLi = require('./components/GridLi');

var ListLi = require('./components/ListLi');

module.exports = function (props) {
  var itemIconString = props.getItemIcon();
  var className = classNames('uppy-ProviderBrowserItem', {
    'uppy-ProviderBrowserItem--selected': props.isChecked
  }, {
    'uppy-ProviderBrowserItem--disabled': props.isDisabled
  }, {
    'uppy-ProviderBrowserItem--noPreview': itemIconString === 'video'
  });
  var itemIconEl = h(ItemIcon, {
    itemIconString: itemIconString
  });

  switch (props.viewType) {
    case 'grid':
      return h(GridLi, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    case 'list':
      return h(ListLi, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    default:
      throw new Error("There is no such type " + props.viewType);
  }
};

},{"./components/GridLi":121,"./components/ItemIcon":122,"./components/ListLi":123,"classnames":10,"preact":37}],125:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var remoteFileObjToLocal = require('./../../utils/lib/remoteFileObjToLocal');

var Item = require('./Item/index'); // Hopefully this name will not be used by Google


var VIRTUAL_SHARED_DIR = 'shared-with-me';

var getSharedProps = function getSharedProps(fileOrFolder, props) {
  return {
    id: fileOrFolder.id,
    title: fileOrFolder.name,
    getItemIcon: function getItemIcon() {
      return fileOrFolder.icon;
    },
    isChecked: props.isChecked(fileOrFolder),
    toggleCheckbox: function toggleCheckbox(e) {
      return props.toggleCheckbox(e, fileOrFolder);
    },
    columns: props.columns,
    showTitles: props.showTitles,
    viewType: props.viewType,
    i18n: props.i18n
  };
};

module.exports = function (props) {
  var folders = props.folders,
      files = props.files,
      handleScroll = props.handleScroll,
      isChecked = props.isChecked;

  if (!folders.length && !files.length) {
    return h("div", {
      className: "uppy-Provider-empty"
    }, props.i18n('noFilesFound'));
  }

  return h("div", {
    className: "uppy-ProviderBrowser-body"
  }, h("ul", {
    className: "uppy-ProviderBrowser-list",
    onScroll: handleScroll,
    role: "listbox" // making <ul> not focusable for firefox
    ,
    tabIndex: "-1"
  }, folders.map(function (folder) {
    return Item(_extends({}, getSharedProps(folder, props), {
      type: 'folder',
      isDisabled: isChecked(folder) ? isChecked(folder).loading : false,
      isCheckboxDisabled: folder.id === VIRTUAL_SHARED_DIR,
      handleFolderClick: function handleFolderClick() {
        return props.handleFolderClick(folder);
      }
    }));
  }), files.map(function (file) {
    var validateRestrictions = props.validateRestrictions(remoteFileObjToLocal(file), [].concat(props.uppyFiles, props.currentSelection));
    var sharedProps = getSharedProps(file, props);
    var restrictionReason = validateRestrictions.reason;
    return Item(_extends({}, sharedProps, {
      type: 'file',
      isDisabled: !validateRestrictions.result && !sharedProps.isChecked,
      restrictionReason: restrictionReason
    }));
  })));
};

},{"./../../utils/lib/remoteFileObjToLocal":232,"./Item/index":124,"preact":37}],126:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-Provider-loading"
  }, h("span", null, props.i18n('loading')));
};

},{"preact":37}],127:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var AuthView = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AuthView, _Component);

  function AuthView() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = AuthView.prototype;

  _proto.render = function render() {
    var pluginNameComponent = h("span", {
      className: "uppy-Provider-authTitleName"
    }, this.props.pluginName, h("br", null));
    return h("div", {
      className: "uppy-Provider-auth"
    }, h("div", {
      className: "uppy-Provider-authIcon"
    }, this.props.pluginIcon()), h("div", {
      className: "uppy-Provider-authTitle"
    }, this.props.i18nArray('authenticateWithTitle', {
      pluginName: pluginNameComponent
    })), h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn",
      onClick: this.props.handleAuth,
      "data-uppy-super-focusable": true
    }, this.props.i18nArray('authenticateWith', {
      pluginName: this.props.pluginName
    })));
  };

  return AuthView;
}(Component);

module.exports = AuthView;

},{"preact":37}],128:[function(require,module,exports){
var User = require('./User');

var Breadcrumbs = require('../Breadcrumbs');

module.exports = function (props) {
  var components = [];

  if (props.showBreadcrumbs) {
    components.push(Breadcrumbs({
      getFolder: props.getFolder,
      directories: props.directories,
      breadcrumbsIcon: props.pluginIcon && props.pluginIcon(),
      title: props.title
    }));
  }

  components.push(User({
    logout: props.logout,
    username: props.username,
    i18n: props.i18n
  }));
  return components;
};

},{"../Breadcrumbs":116,"./User":130}],129:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var AuthView = require('./AuthView');

var Header = require('./Header');

var Browser = require('../Browser');

var LoaderView = require('../Loader');

var generateFileID = require('./../../../utils/lib/generateFileID');

var getFileType = require('./../../../utils/lib/getFileType');

var findIndex = require('./../../../utils/lib/findIndex');

var isPreviewSupported = require('./../../../utils/lib/isPreviewSupported');

var SharedHandler = require('../SharedHandler');

var CloseWrapper = require('../CloseWrapper'); // location.origin does not exist in IE


function getOrigin() {
  if ('origin' in location) {
    return location.origin; // eslint-disable-line compat/compat
  }

  return location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : '');
}
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = _class = /*#__PURE__*/function () {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  function ProviderView(plugin, opts) {
    this.plugin = plugin;
    this.provider = opts.provider;
    this._sharedHandler = new SharedHandler(plugin); // set default options

    var defaultOptions = {
      viewType: 'list',
      showTitles: true,
      showFilter: true,
      showBreadcrumbs: true
    }; // merge default options with the ones set by user

    this.opts = _extends({}, defaultOptions, opts); // Logic

    this.addFile = this.addFile.bind(this);
    this.filterQuery = this.filterQuery.bind(this);
    this.getFolder = this.getFolder.bind(this);
    this.getNextFolder = this.getNextFolder.bind(this);
    this.logout = this.logout.bind(this);
    this.preFirstRender = this.preFirstRender.bind(this);
    this.handleAuth = this.handleAuth.bind(this);
    this.sortByTitle = this.sortByTitle.bind(this);
    this.sortByDate = this.sortByDate.bind(this);
    this.handleError = this.handleError.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.listAllFiles = this.listAllFiles.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.cancelPicking = this.cancelPicking.bind(this);
    this.clearSelection = this.clearSelection.bind(this); // Visual

    this.render = this.render.bind(this);
    this.clearSelection(); // Set default state for the plugin

    this.plugin.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      filterInput: '',
      isSearchVisible: false
    });
  }

  var _proto = ProviderView.prototype;

  _proto.tearDown = function tearDown() {// Nothing.
  };

  _proto._updateFilesAndFolders = function _updateFilesAndFolders(res, files, folders) {
    this.nextPagePath = res.nextPagePath;
    res.items.forEach(function (item) {
      if (item.isFolder) {
        folders.push(item);
      } else {
        files.push(item);
      }
    });
    this.plugin.setPluginState({
      folders: folders,
      files: files
    });
  }
  /**
   * Called only the first time the provider view is rendered.
   * Kind of like an init function.
   */
  ;

  _proto.preFirstRender = function preFirstRender() {
    this.plugin.setPluginState({
      didFirstRender: true
    });
    this.plugin.onFirstRender();
  }
  /**
   * Based on folder ID, fetch a new folder and update it to state
   *
   * @param  {string} id Folder id
   * @returns {Promise}   Folders/files in folder
   */
  ;

  _proto.getFolder = function getFolder(id, name) {
    var _this = this;

    return this._sharedHandler.loaderWrapper(this.provider.list(id), function (res) {
      var folders = [];
      var files = [];
      var updatedDirectories;

      var state = _this.plugin.getPluginState();

      var index = findIndex(state.directories, function (dir) {
        return id === dir.id;
      });

      if (index !== -1) {
        updatedDirectories = state.directories.slice(0, index + 1);
      } else {
        updatedDirectories = state.directories.concat([{
          id: id,
          title: name
        }]);
      }

      _this.username = res.username || _this.username;

      _this._updateFilesAndFolders(res, files, folders);

      _this.plugin.setPluginState({
        directories: updatedDirectories
      });
    }, this.handleError);
  }
  /**
   * Fetches new folder
   *
   * @param  {object} folder
   */
  ;

  _proto.getNextFolder = function getNextFolder(folder) {
    this.getFolder(folder.requestPath, folder.name);
    this.lastCheckbox = undefined;
  };

  _proto.addFile = function addFile(file) {
    var tagFile = {
      id: this.providerFileToId(file),
      source: this.plugin.id,
      data: file,
      name: file.name || file.id,
      type: file.mimeType,
      isRemote: true,
      body: {
        fileId: file.id
      },
      remote: {
        companionUrl: this.plugin.opts.companionUrl,
        url: "" + this.provider.fileUrl(file.requestPath),
        body: {
          fileId: file.id
        },
        providerOptions: this.provider.opts
      }
    };
    var fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?

    if (fileType && isPreviewSupported(fileType)) {
      tagFile.preview = file.thumbnail;
    }

    this.plugin.uppy.log('Adding remote file');

    try {
      this.plugin.uppy.addFile(tagFile);
      return true;
    } catch (err) {
      if (!err.isRestriction) {
        this.plugin.uppy.log(err);
      }

      return false;
    }
  }
  /**
   * Removes session token on client side.
   */
  ;

  _proto.logout = function logout() {
    var _this2 = this;

    this.provider.logout().then(function (res) {
      if (res.ok) {
        if (!res.revoked) {
          var message = _this2.plugin.uppy.i18n('companionUnauthorizeHint', {
            provider: _this2.plugin.title,
            url: res.manual_revoke_url
          });

          _this2.plugin.uppy.info(message, 'info', 7000);
        }

        var newState = {
          authenticated: false,
          files: [],
          folders: [],
          directories: []
        };

        _this2.plugin.setPluginState(newState);
      }
    }).catch(this.handleError);
  };

  _proto.filterQuery = function filterQuery(e) {
    var state = this.plugin.getPluginState();
    this.plugin.setPluginState(_extends({}, state, {
      filterInput: e ? e.target.value : ''
    }));
  };

  _proto.sortByTitle = function sortByTitle() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        folders = state.folders,
        sorting = state.sorting;
    var sortedFiles = files.sort(function (fileA, fileB) {
      if (sorting === 'titleDescending') {
        return fileB.name.localeCompare(fileA.name);
      }

      return fileA.name.localeCompare(fileB.name);
    });
    var sortedFolders = folders.sort(function (folderA, folderB) {
      if (sorting === 'titleDescending') {
        return folderB.name.localeCompare(folderA.name);
      }

      return folderA.name.localeCompare(folderB.name);
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      folders: sortedFolders,
      sorting: sorting === 'titleDescending' ? 'titleAscending' : 'titleDescending'
    }));
  };

  _proto.sortByDate = function sortByDate() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        folders = state.folders,
        sorting = state.sorting;
    var sortedFiles = files.sort(function (fileA, fileB) {
      var a = new Date(fileA.modifiedDate);
      var b = new Date(fileB.modifiedDate);

      if (sorting === 'dateDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    var sortedFolders = folders.sort(function (folderA, folderB) {
      var a = new Date(folderA.modifiedDate);
      var b = new Date(folderB.modifiedDate);

      if (sorting === 'dateDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      folders: sortedFolders,
      sorting: sorting === 'dateDescending' ? 'dateAscending' : 'dateDescending'
    }));
  };

  _proto.sortBySize = function sortBySize() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        sorting = state.sorting; // check that plugin supports file sizes

    if (!files.length || !this.plugin.getItemData(files[0]).size) {
      return;
    }

    var sortedFiles = files.sort(function (fileA, fileB) {
      var a = fileA.size;
      var b = fileB.size;

      if (sorting === 'sizeDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      sorting: sorting === 'sizeDescending' ? 'sizeAscending' : 'sizeDescending'
    }));
  }
  /**
   * Adds all files found inside of specified folder.
   *
   * Uses separated state while folder contents are being fetched and
   * mantains list of selected folders, which are separated from files.
   */
  ;

  _proto.addFolder = function addFolder(folder) {
    var _this3 = this;

    var folderId = this.providerFileToId(folder);
    var state = this.plugin.getPluginState();

    var folders = _extends({}, state.selectedFolders);

    if (folderId in folders && folders[folderId].loading) {
      return;
    }

    folders[folderId] = {
      loading: true,
      files: []
    };
    this.plugin.setPluginState({
      selectedFolders: _extends({}, folders)
    });
    return this.listAllFiles(folder.requestPath).then(function (files) {
      var count = 0;
      files.forEach(function (file) {
        var success = _this3.addFile(file);

        if (success) count++;
      });
      var ids = files.map(_this3.providerFileToId);
      folders[folderId] = {
        loading: false,
        files: ids
      };

      _this3.plugin.setPluginState({
        selectedFolders: folders
      });

      var message;

      if (files.length) {
        message = _this3.plugin.uppy.i18n('folderAdded', {
          smart_count: count,
          folder: folder.name
        });
      } else {
        message = _this3.plugin.uppy.i18n('emptyFolderAdded');
      }

      _this3.plugin.uppy.info(message);
    }).catch(function (e) {
      var state = _this3.plugin.getPluginState();

      var selectedFolders = _extends({}, state.selectedFolders);

      delete selectedFolders[folderId];

      _this3.plugin.setPluginState({
        selectedFolders: selectedFolders
      });

      _this3.handleError(e);
    });
  };

  _proto.providerFileToId = function providerFileToId(file) {
    return generateFileID({
      data: file,
      name: file.name || file.id,
      type: file.mimeType
    });
  };

  _proto.handleAuth = function handleAuth() {
    var _this4 = this;

    var authState = btoa(JSON.stringify({
      origin: getOrigin()
    }));
    var clientVersion = "@uppy/provider-views=" + ProviderView.VERSION;
    var link = this.provider.authUrl({
      state: authState,
      uppyVersions: clientVersion
    });
    var authWindow = window.open(link, '_blank');

    var handleToken = function handleToken(e) {
      if (!_this4._isOriginAllowed(e.origin, _this4.plugin.opts.companionAllowedHosts) || e.source !== authWindow) {
        _this4.plugin.uppy.log("rejecting event from " + e.origin + " vs allowed pattern " + _this4.plugin.opts.companionAllowedHosts);

        return;
      } // Check if it's a string before doing the JSON.parse to maintain support
      // for older Companion versions that used object references


      var data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

      if (!data.token) {
        _this4.plugin.uppy.log('did not receive token from auth window');

        return;
      }

      authWindow.close();
      window.removeEventListener('message', handleToken);

      _this4.provider.setAuthToken(data.token);

      _this4.preFirstRender();
    };

    window.addEventListener('message', handleToken);
  };

  _proto._isOriginAllowed = function _isOriginAllowed(origin, allowedOrigin) {
    var getRegex = function getRegex(value) {
      if (typeof value === 'string') {
        return new RegExp("^" + value + "$");
      }

      if (value instanceof RegExp) {
        return value;
      }
    };

    var patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(getRegex) : [getRegex(allowedOrigin)];
    return patterns.filter(function (pattern) {
      return pattern != null;
    }) // loose comparison to catch undefined
    .some(function (pattern) {
      return pattern.test(origin) || pattern.test(origin + "/");
    }); // allowing for trailing '/'
  };

  _proto.handleError = function handleError(error) {
    var uppy = this.plugin.uppy;
    uppy.log(error.toString());

    if (error.isAuthError) {
      return;
    }

    var message = uppy.i18n('companionError');
    uppy.info({
      message: message,
      details: error.toString()
    }, 'error', 5000);
  };

  _proto.handleScroll = function handleScroll(e) {
    var _this5 = this;

    var scrollPos = e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight);
    var path = this.nextPagePath || null;

    if (scrollPos < 50 && path && !this._isHandlingScroll) {
      this.provider.list(path).then(function (res) {
        var _this5$plugin$getPlug = _this5.plugin.getPluginState(),
            files = _this5$plugin$getPlug.files,
            folders = _this5$plugin$getPlug.folders;

        _this5._updateFilesAndFolders(res, files, folders);
      }).catch(this.handleError).then(function () {
        _this5._isHandlingScroll = false;
      }); // always called

      this._isHandlingScroll = true;
    }
  };

  _proto.listAllFiles = function listAllFiles(path, files) {
    var _this6 = this;

    if (files === void 0) {
      files = null;
    }

    files = files || [];
    return new Promise(function (resolve, reject) {
      _this6.provider.list(path).then(function (res) {
        res.items.forEach(function (item) {
          if (!item.isFolder) {
            files.push(item);
          } else {
            _this6.addFolder(item);
          }
        });
        var moreFiles = res.nextPagePath || null;

        if (moreFiles) {
          return _this6.listAllFiles(moreFiles, files).then(function (files) {
            return resolve(files);
          }).catch(function (e) {
            return reject(e);
          });
        }

        return resolve(files);
      }).catch(function (e) {
        return reject(e);
      });
    });
  };

  _proto.donePicking = function donePicking() {
    var _this7 = this;

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi.currentSelection;

    var promises = currentSelection.map(function (file) {
      if (file.isFolder) {
        return _this7.addFolder(file);
      }

      return _this7.addFile(file);
    });

    this._sharedHandler.loaderWrapper(Promise.all(promises), function () {
      _this7.clearSelection();
    }, function () {});
  };

  _proto.cancelPicking = function cancelPicking() {
    this.clearSelection();
    var dashboard = this.plugin.uppy.getPlugin('Dashboard');
    if (dashboard) dashboard.hideAllPanels();
  };

  _proto.clearSelection = function clearSelection() {
    this.plugin.setPluginState({
      currentSelection: []
    });
  };

  _proto.render = function render(state, viewOptions) {
    if (viewOptions === void 0) {
      viewOptions = {};
    }

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        authenticated = _this$plugin$getPlugi2.authenticated,
        didFirstRender = _this$plugin$getPlugi2.didFirstRender;

    if (!didFirstRender) {
      this.preFirstRender();
    } // reload pluginState for "loading" attribute because it might
    // have changed above.


    if (this.plugin.getPluginState().loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (!authenticated) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(AuthView, {
        pluginName: this.plugin.title,
        pluginIcon: this.plugin.icon,
        handleAuth: this.handleAuth,
        i18n: this.plugin.uppy.i18n,
        i18nArray: this.plugin.uppy.i18nArray
      }));
    }

    var targetViewOptions = _extends({}, this.opts, viewOptions);

    var headerProps = {
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      getFolder: this.getFolder,
      directories: this.plugin.getPluginState().directories,
      pluginIcon: this.plugin.icon,
      title: this.plugin.title,
      logout: this.logout,
      username: this.username,
      i18n: this.plugin.uppy.i18n
    };

    var browserProps = _extends({}, this.plugin.getPluginState(), {
      username: this.username,
      getNextFolder: this.getNextFolder,
      getFolder: this.getFolder,
      filterItems: this._sharedHandler.filterItems,
      filterQuery: this.filterQuery,
      sortByTitle: this.sortByTitle,
      sortByDate: this.sortByDate,
      logout: this.logout,
      isChecked: this._sharedHandler.isChecked,
      toggleCheckbox: this._sharedHandler.toggleCheckbox,
      handleScroll: this.handleScroll,
      listAllFiles: this.listAllFiles,
      done: this.donePicking,
      cancel: this.cancelPicking,
      headerComponent: Header(headerProps),
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n,
      uppyFiles: this.plugin.uppy.getFiles(),
      validateRestrictions: this.plugin.uppy.validateRestrictions
    });

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  };

  return ProviderView;
}(), _class.VERSION = require('../../package.json').version, _temp);

},{"../../package.json":115,"../Browser":117,"../CloseWrapper":118,"../Loader":126,"../SharedHandler":136,"./../../../utils/lib/findIndex":209,"./../../../utils/lib/generateFileID":210,"./../../../utils/lib/getFileType":218,"./../../../utils/lib/isPreviewSupported":229,"./AuthView":127,"./Header":128,"preact":37}],130:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return [h("span", {
    className: "uppy-ProviderBrowser-user",
    key: "username"
  }, props.username), h("button", {
    type: "button",
    onClick: props.logout,
    className: "uppy-u-reset uppy-ProviderBrowser-userLogout",
    key: "logout"
  }, props.i18n('logOut'))];
};

},{"preact":37}],131:[function(require,module,exports){
module.exports = require('./ProviderView');

},{"./ProviderView":129}],132:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("button", {
    type: "button",
    onClick: props.triggerSearchInput,
    className: "uppy-u-reset uppy-ProviderBrowser-userLogout"
  }, props.i18n('backToSearch'));
};

},{"preact":37}],133:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  var input;

  var handleKeyPress = function handleKeyPress(ev) {
    if (ev.keyCode === 13) {
      validateAndSearch();
    }
  };

  var validateAndSearch = function validateAndSearch() {
    if (input.value) {
      props.search(input.value);
    }
  };

  return h("div", {
    className: "uppy-SearchProvider"
  }, h("input", {
    className: "uppy-u-reset uppy-c-textInput uppy-SearchProvider-input",
    type: "text",
    "aria-label": props.i18n('enterTextToSearch'),
    placeholder: props.i18n('enterTextToSearch'),
    onKeyUp: handleKeyPress,
    ref: function ref(input_) {
      input = input_;
    },
    "data-uppy-super-focusable": true
  }), h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-SearchProvider-searchButton",
    type: "button",
    onClick: validateAndSearch
  }, props.i18n('searchImages')));
};

},{"preact":37}],134:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var SearchInput = require('./InputView');

var Browser = require('../Browser');

var LoaderView = require('../Loader');

var generateFileID = require('./../../../utils/lib/generateFileID');

var getFileType = require('./../../../utils/lib/getFileType');

var isPreviewSupported = require('./../../../utils/lib/isPreviewSupported');

var Header = require('./Header');

var SharedHandler = require('../SharedHandler');

var CloseWrapper = require('../CloseWrapper');
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = _class = /*#__PURE__*/function () {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  function ProviderView(plugin, opts) {
    this.plugin = plugin;
    this.provider = opts.provider;
    this._sharedHandler = new SharedHandler(plugin); // set default options

    var defaultOptions = {
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    }; // merge default options with the ones set by user

    this.opts = _extends({}, defaultOptions, opts); // Logic

    this.search = this.search.bind(this);
    this.triggerSearchInput = this.triggerSearchInput.bind(this);
    this.addFile = this.addFile.bind(this);
    this.preFirstRender = this.preFirstRender.bind(this);
    this.handleError = this.handleError.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.cancelPicking = this.cancelPicking.bind(this);
    this.clearSelection = this.clearSelection.bind(this); // Visual

    this.render = this.render.bind(this);
    this.clearSelection(); // Set default state for the plugin

    this.plugin.setPluginState({
      isInputMode: true,
      files: [],
      folders: [],
      directories: [],
      filterInput: '',
      isSearchVisible: false
    });
  }

  var _proto = ProviderView.prototype;

  _proto.tearDown = function tearDown() {// Nothing.
  };

  _proto._updateFilesAndInputMode = function _updateFilesAndInputMode(res, files) {
    this.nextPageQuery = res.nextPageQuery;
    this._searchTerm = res.searchedFor;
    res.items.forEach(function (item) {
      files.push(item);
    });
    this.plugin.setPluginState({
      isInputMode: false,
      files: files
    });
  }
  /**
   * Called only the first time the provider view is rendered.
   * Kind of like an init function.
   */
  ;

  _proto.preFirstRender = function preFirstRender() {
    this.plugin.setPluginState({
      didFirstRender: true
    });
    this.plugin.onFirstRender();
  };

  _proto.search = function search(query) {
    var _this = this;

    if (query && query === this._searchTerm) {
      // no need to search again as this is the same as the previous search
      this.plugin.setPluginState({
        isInputMode: false
      });
      return;
    }

    return this._sharedHandler.loaderWrapper(this.provider.search(query), function (res) {
      _this._updateFilesAndInputMode(res, []);
    }, this.handleError);
  };

  _proto.triggerSearchInput = function triggerSearchInput() {
    this.plugin.setPluginState({
      isInputMode: true
    });
  } // @todo this function should really be a function of the plugin and not the view.
  // maybe we should consider creating a base ProviderPlugin class that has this method
  ;

  _proto.addFile = function addFile(file) {
    var tagFile = {
      id: this.providerFileToId(file),
      source: this.plugin.id,
      data: file,
      name: file.name || file.id,
      type: file.mimeType,
      isRemote: true,
      body: {
        fileId: file.id
      },
      remote: {
        companionUrl: this.plugin.opts.companionUrl,
        url: "" + this.provider.fileUrl(file.requestPath),
        body: {
          fileId: file.id
        },
        providerOptions: _extends({}, this.provider.opts, {
          provider: null
        })
      }
    };
    var fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?

    if (fileType && isPreviewSupported(fileType)) {
      tagFile.preview = file.thumbnail;
    }

    this.plugin.uppy.log('Adding remote file');

    try {
      this.plugin.uppy.addFile(tagFile);
    } catch (err) {
      if (!err.isRestriction) {
        this.plugin.uppy.log(err);
      }
    }
  };

  _proto.providerFileToId = function providerFileToId(file) {
    return generateFileID({
      data: file,
      name: file.name || file.id,
      type: file.mimeType
    });
  };

  _proto.handleError = function handleError(error) {
    var uppy = this.plugin.uppy;
    uppy.log(error.toString());
    var message = uppy.i18n('companionError');
    uppy.info({
      message: message,
      details: error.toString()
    }, 'error', 5000);
  };

  _proto.handleScroll = function handleScroll(e) {
    var _this2 = this;

    var scrollPos = e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight);
    var query = this.nextPageQuery || null;

    if (scrollPos < 50 && query && !this._isHandlingScroll) {
      this.provider.search(this._searchTerm, query).then(function (res) {
        var _this2$plugin$getPlug = _this2.plugin.getPluginState(),
            files = _this2$plugin$getPlug.files;

        _this2._updateFilesAndInputMode(res, files);
      }).catch(this.handleError).then(function () {
        _this2._isHandlingScroll = false;
      }); // always called

      this._isHandlingScroll = true;
    }
  };

  _proto.donePicking = function donePicking() {
    var _this3 = this;

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi.currentSelection;

    var promises = currentSelection.map(function (file) {
      return _this3.addFile(file);
    });

    this._sharedHandler.loaderWrapper(Promise.all(promises), function () {
      _this3.clearSelection();
    }, function () {});
  };

  _proto.cancelPicking = function cancelPicking() {
    this.clearSelection();
    var dashboard = this.plugin.uppy.getPlugin('Dashboard');
    if (dashboard) dashboard.hideAllPanels();
  };

  _proto.clearSelection = function clearSelection() {
    this.plugin.setPluginState({
      currentSelection: []
    });
  };

  _proto.render = function render(state, viewOptions) {
    if (viewOptions === void 0) {
      viewOptions = {};
    }

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        didFirstRender = _this$plugin$getPlugi2.didFirstRender,
        isInputMode = _this$plugin$getPlugi2.isInputMode;

    if (!didFirstRender) {
      this.preFirstRender();
    } // reload pluginState for "loading" attribute because it might
    // have changed above.


    if (this.plugin.getPluginState().loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (isInputMode) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(SearchInput, {
        search: this.search,
        i18n: this.plugin.uppy.i18n
      }));
    }

    var targetViewOptions = _extends({}, this.opts, viewOptions);

    var browserProps = _extends({}, this.plugin.getPluginState(), {
      isChecked: this._sharedHandler.isChecked,
      toggleCheckbox: this._sharedHandler.toggleCheckbox,
      handleScroll: this.handleScroll,
      done: this.donePicking,
      cancel: this.cancelPicking,
      headerComponent: Header({
        triggerSearchInput: this.triggerSearchInput,
        i18n: this.plugin.uppy.i18n
      }),
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n,
      uppyFiles: this.plugin.uppy.getFiles(),
      validateRestrictions: this.plugin.uppy.validateRestrictions
    });

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  };

  return ProviderView;
}(), _class.VERSION = require('../../package.json').version, _temp);

},{"../../package.json":115,"../Browser":117,"../CloseWrapper":118,"../Loader":126,"../SharedHandler":136,"./../../../utils/lib/generateFileID":210,"./../../../utils/lib/getFileType":218,"./../../../utils/lib/isPreviewSupported":229,"./Header":132,"./InputView":133,"preact":37}],135:[function(require,module,exports){
module.exports = require('./SearchProviderView');

},{"./SearchProviderView":134}],136:[function(require,module,exports){
var remoteFileObjToLocal = require('./../../utils/lib/remoteFileObjToLocal');

module.exports = /*#__PURE__*/function () {
  function SharedHandler(plugin) {
    this.plugin = plugin;
    this.filterItems = this.filterItems.bind(this);
    this.toggleCheckbox = this.toggleCheckbox.bind(this);
    this.isChecked = this.isChecked.bind(this);
    this.loaderWrapper = this.loaderWrapper.bind(this);
  }

  var _proto = SharedHandler.prototype;

  _proto.filterItems = function filterItems(items) {
    var state = this.plugin.getPluginState();

    if (!state.filterInput || state.filterInput === '') {
      return items;
    }

    return items.filter(function (folder) {
      return folder.name.toLowerCase().indexOf(state.filterInput.toLowerCase()) !== -1;
    });
  }
  /**
   * Toggles file/folder checkbox to on/off state while updating files list.
   *
   * Note that some extra complexity comes from supporting shift+click to
   * toggle multiple checkboxes at once, which is done by getting all files
   * in between last checked file and current one.
   */
  ;

  _proto.toggleCheckbox = function toggleCheckbox(e, file) {
    var _this = this;

    e.stopPropagation();
    e.preventDefault();
    e.currentTarget.focus();

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        folders = _this$plugin$getPlugi.folders,
        files = _this$plugin$getPlugi.files;

    var items = this.filterItems(folders.concat(files)); // Shift-clicking selects a single consecutive list of items
    // starting at the previous click and deselects everything else.

    if (this.lastCheckbox && e.shiftKey) {
      var _currentSelection;

      var prevIndex = items.indexOf(this.lastCheckbox);
      var currentIndex = items.indexOf(file);

      if (prevIndex < currentIndex) {
        _currentSelection = items.slice(prevIndex, currentIndex + 1);
      } else {
        _currentSelection = items.slice(currentIndex, prevIndex + 1);
      } // Check restrictions on each file in currentSelection,
      // reduce it to only contain files that pass restrictions


      _currentSelection = _currentSelection.reduce(function (reducedCurrentSelection, item) {
        var uppy = _this.plugin.uppy;
        var validatedRestrictions = uppy.validateRestrictions(remoteFileObjToLocal(item), [].concat(uppy.getFiles(), reducedCurrentSelection));

        if (!validatedRestrictions.result) {
          uppy.info({
            message: validatedRestrictions.reason
          }, 'error', uppy.opts.infoTimeout);
          return reducedCurrentSelection;
        }

        return [].concat(reducedCurrentSelection, [item]);
      });
      this.plugin.setPluginState({
        currentSelection: _currentSelection
      });
      return;
    }

    this.lastCheckbox = file;

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi2.currentSelection;

    if (this.isChecked(file)) {
      this.plugin.setPluginState({
        currentSelection: currentSelection.filter(function (item) {
          return item.id !== file.id;
        })
      });
    } else {
      this.plugin.setPluginState({
        currentSelection: currentSelection.concat([file])
      });
    }
  };

  _proto.isChecked = function isChecked(file) {
    var _this$plugin$getPlugi3 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi3.currentSelection; // comparing id instead of the file object, because the reference to the object
    // changes when we switch folders, and the file list is updated


    return currentSelection.some(function (item) {
      return item.id === file.id;
    });
  };

  _proto.loaderWrapper = function loaderWrapper(promise, then, catch_) {
    var _this2 = this;

    promise.then(function (result) {
      _this2.plugin.setPluginState({
        loading: false
      });

      then(result);
    }).catch(function (err) {
      _this2.plugin.setPluginState({
        loading: false
      });

      catch_(err);
    });
    this.plugin.setPluginState({
      loading: true
    });
  };

  return SharedHandler;
}();

},{"./../../utils/lib/remoteFileObjToLocal":232}],137:[function(require,module,exports){
var ProviderViews = require('./ProviderView');

var SearchProviderViews = require('./SearchProviderView');

module.exports = {
  ProviderViews: ProviderViews,
  SearchProviderViews: SearchProviderViews
};

},{"./ProviderView":131,"./SearchProviderView":135}],138:[function(require,module,exports){
module.exports={
  "name": "@uppy/robodog",
  "description": "Transloadit SDK for browsers based on Uppy",
  "version": "1.10.11",
  "license": "MIT",
  "main": "lib/index.js",
  "jsnext:main": "src/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "transloadit",
    "file encoding",
    "encoding",
    "file processing",
    "video encoding",
    "crop",
    "resize",
    "watermark",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/core": "file:../core",
    "@uppy/dashboard": "file:../dashboard",
    "@uppy/dropbox": "file:../dropbox",
    "@uppy/facebook": "file:../facebook",
    "@uppy/form": "file:../form",
    "@uppy/google-drive": "file:../google-drive",
    "@uppy/instagram": "file:../instagram",
    "@uppy/onedrive": "file:../onedrive",
    "@uppy/status-bar": "file:../status-bar",
    "@uppy/transloadit": "file:../transloadit",
    "@uppy/url": "file:../url",
    "@uppy/utils": "file:../utils",
    "@uppy/webcam": "file:../webcam",
    "es6-promise": "4.2.5",
    "whatwg-fetch": "3.6.2"
  }
}

},{}],139:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var toArray = require('./../../utils/lib/toArray');

var findDOMElement = require('./../../utils/lib/findDOMElement');
/**
 * Add files from existing file inputs to Uppy.
 */


var AttachFileInputs = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(AttachFileInputs, _Plugin);

  function AttachFileInputs(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'AttachFileInputs';
    _this.type = 'acquirer';
    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));
    _this.inputs = null;
    return _this;
  }

  var _proto = AttachFileInputs.prototype;

  _proto.handleChange = function handleChange(event) {
    this.addFiles(event.target);
  };

  _proto.addFiles = function addFiles(input) {
    var _this2 = this;

    var files = toArray(input.files);
    files.forEach(function (file) {
      try {
        _this2.uppy.addFile({
          source: _this2.id,
          name: file.name,
          type: file.type,
          data: file
        });
      } catch (err) {
        if (!err.isRestriction) {
          _this2.uppy.log(err);
        }
      }
    });
  };

  _proto.install = function install() {
    var _this3 = this;

    this.el = findDOMElement(this.opts.target);

    if (!this.el) {
      throw new Error('[AttachFileInputs] Target form does not exist');
    }

    var restrictions = this.uppy.opts.restrictions;
    this.inputs = this.el.querySelectorAll('input[type="file"]');
    this.inputs.forEach(function (input) {
      input.addEventListener('change', _this3.handleChange);

      if (!input.hasAttribute('multiple')) {
        if (restrictions.maxNumberOfFiles !== 1) {
          input.setAttribute('multiple', 'multiple');
        } else {
          input.removeAttribute('multiple');
        }
      }

      if (!input.hasAttribute('accept') && restrictions.allowedFileTypes) {
        input.setAttribute('accept', restrictions.allowedFileTypes.join(','));
      } // Check if this input already contains files (eg. user selected them before Uppy loaded,
      // or the page was refreshed and the browser kept files selected)


      _this3.addFiles(input);
    });
  };

  _proto.uninstall = function uninstall() {
    var _this4 = this;

    this.inputs.forEach(function (input) {
      input.removeEventListener('change', _this4.handleChange);
    });
    this.inputs = null;
  };

  return AttachFileInputs;
}(Plugin);

module.exports = AttachFileInputs;

},{"./../../core":73,"./../../utils/lib/findDOMElement":208,"./../../utils/lib/toArray":235}],140:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var findDOMElement = require('./../../utils/lib/findDOMElement');
/**
 * After an upload completes, inject result data from Transloadit in a hidden input.
 *
 * Must be added _after_ the Transloadit plugin.
 */


var TransloaditFormResult = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(TransloaditFormResult, _Plugin);

  function TransloaditFormResult(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'TransloaditFormResult';
    _this.type = 'modifier';
    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = TransloaditFormResult.prototype;

  _proto.getAssemblyStatuses = function getAssemblyStatuses(fileIDs) {
    var _this2 = this;

    var assemblyIds = [];
    fileIDs.forEach(function (fileID) {
      var file = _this2.uppy.getFile(fileID);

      var assembly = file.transloadit && file.transloadit.assembly;

      if (assembly && assemblyIds.indexOf(assembly) === -1) {
        assemblyIds.push(assembly);
      }
    });
    var tl = this.uppy.getPlugin(this.opts.transloaditPluginId || 'Transloadit');
    return assemblyIds.map(function (id) {
      return tl.getAssembly(id);
    });
  };

  _proto.handleUpload = function handleUpload(fileIDs) {
    var assemblies = this.getAssemblyStatuses(fileIDs);
    var input = document.createElement('input');
    input.type = 'hidden';
    input.name = this.opts.name;
    input.value = JSON.stringify(assemblies);
    var target = findDOMElement(this.opts.target);
    target.appendChild(input);
  };

  _proto.install = function install() {
    this.uppy.addPostProcessor(this.handleUpload);
  };

  _proto.uninstall = function uninstall() {
    this.uppy.removePostProcessor(this.handleUpload);
  };

  return TransloaditFormResult;
}(Plugin);

module.exports = TransloaditFormResult;

},{"./../../core":73,"./../../utils/lib/findDOMElement":208}],141:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;
/**
 * Add a `results` key to the upload result data, containing all Transloadit Assembly results.
 */


var TransloaditResultsPlugin = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(TransloaditResultsPlugin, _Plugin);

  function TransloaditResultsPlugin(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'modifier';
    _this.id = _this.opts.id || 'TransloaditResultsPlugin';
    _this._afterUpload = _this._afterUpload.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = TransloaditResultsPlugin.prototype;

  _proto.install = function install() {
    this.uppy.addPostProcessor(this._afterUpload);
  };

  _proto._afterUpload = function _afterUpload(fileIDs, uploadID) {
    var _this$uppy$getState = this.uppy.getState(),
        currentUploads = _this$uppy$getState.currentUploads;

    var result = currentUploads[uploadID].result;
    var assemblies = result && Array.isArray(result.transloadit) ? result.transloadit : []; // Merge the assembly.results[*] arrays and add `stepName` and
    // `assemblyId` properties.

    var assemblyResults = [];
    assemblies.forEach(function (assembly) {
      Object.keys(assembly.results).forEach(function (stepName) {
        var results = assembly.results[stepName];
        results.forEach(function (result) {
          assemblyResults.push(_extends({}, result, {
            assemblyId: assembly.assembly_id,
            stepName: stepName
          }));
        });
      });
    });
    this.uppy.addResultData(uploadID, {
      results: assemblyResults
    });
  };

  return TransloaditResultsPlugin;
}(Plugin);

module.exports = TransloaditResultsPlugin;

},{"./../../core":73}],142:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Dashboard = require('./../../dashboard');

var has = require('./../../utils/lib/hasProperty');

var dashboardOptionNames = ['metaFields', 'width', 'height', 'thumbnailWidth', 'showLinkToFileUploadResult', 'showProgressDetails', 'hideRetryButton', 'hideCancelButton', 'hideUploadButton', 'hideProgressAfterFinish', 'note', 'disableStatusBar', 'disableInformer', 'disableThumbnailGenerator', 'showSelectedFiles', 'proudlyDisplayPoweredByUppy', 'theme'];
var modalDashboardOptionNames = ['trigger', 'closeModalOnClickOutside', 'closeAfterFinish', 'disablePageScrollWhenModalOpen', 'animateOpenClose', 'onRequestCloseModal', 'browserBackButtonClose'];

function addDashboardPlugin(uppy, opts, overrideOpts) {
  var dashboardOpts = {};
  dashboardOptionNames.forEach(function (key) {
    if (has(opts, key)) {
      dashboardOpts[key] = opts[key];
    }
  });
  var inline = overrideOpts.inline == null ? dashboardOpts.inline : overrideOpts.inline;

  if (!inline) {
    modalDashboardOptionNames.forEach(function (key) {
      if (has(opts, key)) {
        dashboardOpts[key] = opts[key];
      }
    });
  }

  uppy.use(Dashboard, _extends({}, dashboardOpts, overrideOpts));
}

module.exports = addDashboardPlugin;

},{"./../../dashboard":93,"./../../utils/lib/hasProperty":224}],143:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Transloadit = require('./../../transloadit');

var has = require('./../../utils/lib/hasProperty');

var remoteProviders = {
  dropbox: require('./../../dropbox'),
  'google-drive': require('./../../google-drive'),
  instagram: require('./../../instagram'),
  facebook: require('./../../facebook'),
  onedrive: require('./../../onedrive'),
  url: require('./../../url')
};
var localProviders = {
  webcam: require('./../../webcam')
};
var remoteProviderOptionNames = ['companionUrl', 'companionAllowedHosts', 'companionHeaders', 'serverHeaders', 'target']; // No shared options.

var localProviderOptionNames = ['target'];

function addRemoteProvider(uppy, name, opts) {
  var Provider = remoteProviders[name];
  var providerOptions = {
    // Default to the :tl: Companion servers.
    companionUrl: Transloadit.COMPANION,
    companionAllowedHosts: Transloadit.COMPANION_PATTERN
  };
  remoteProviderOptionNames.forEach(function (name) {
    if (has(opts, name)) providerOptions[name] = opts[name];
  }); // Apply overrides for a specific provider plugin.

  if (typeof opts[name] === 'object') {
    _extends(providerOptions, opts[name]);
  }

  uppy.use(Provider, providerOptions);
}

function addLocalProvider(uppy, name, opts) {
  var Provider = localProviders[name];
  var providerOptions = {};
  localProviderOptionNames.forEach(function (name) {
    if (has(opts, name)) providerOptions[name] = opts[name];
  }); // Apply overrides for a specific provider plugin.

  if (typeof opts[name] === 'object') {
    _extends(providerOptions, opts[name]);
  }

  uppy.use(Provider, providerOptions);
}

function addProviders(uppy, names, opts) {
  if (opts === void 0) {
    opts = {};
  }

  names.forEach(function (name) {
    if (has(remoteProviders, name)) {
      addRemoteProvider(uppy, name, opts);
    } else if (has(localProviders, name)) {
      addLocalProvider(uppy, name, opts);
    } else {
      var validNames = [].concat(Object.keys(remoteProviders), Object.keys(localProviders));
      var expectedNameString = validNames.sort().map(function (validName) {
        return "'" + validName + "'";
      }).join(', ');
      throw new Error("Unexpected provider '" + name + "', expected one of [" + expectedNameString + "]");
    }
  });
}

module.exports = addProviders;

},{"./../../dropbox":101,"./../../facebook":103,"./../../google-drive":108,"./../../instagram":112,"./../../onedrive":114,"./../../transloadit":189,"./../../url":196,"./../../utils/lib/hasProperty":224,"./../../webcam":248}],144:[function(require,module,exports){
var Transloadit = require('./../../transloadit');

var has = require('./../../utils/lib/hasProperty');

var TransloaditResults = require('./TransloaditResultsPlugin');

var transloaditOptionNames = ['service', 'waitForEncoding', 'waitForMetadata', 'alwaysRunAssembly', 'importFromUploadURLs', 'signature', 'params', 'fields', 'limit', 'locale', 'getAssemblyOptions'];

function addTransloaditPlugin(uppy, opts) {
  var transloaditOptions = {};
  transloaditOptionNames.forEach(function (name) {
    if (has(opts, name)) transloaditOptions[name] = opts[name];
  });
  uppy.use(Transloadit, transloaditOptions); // Adds a `results` key to the upload result data containing a flat array of all results from all Assemblies.

  if (transloaditOptions.waitForEncoding) {
    uppy.use(TransloaditResults);
  }
}

module.exports = addTransloaditPlugin;

},{"./../../transloadit":189,"./../../utils/lib/hasProperty":224,"./TransloaditResultsPlugin":141}],145:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Uppy = require('./../../core');

var has = require('./../../utils/lib/hasProperty');

var eventNames = {
  // File management events
  onFileAdded: 'file-added',
  onFileRemoved: 'file-removed',
  // Transloadit events
  onImportError: 'transloadit:import-error',
  onAssemblyCreated: 'transloadit:assembly-created',
  onAssemblyExecuting: 'transloadit:assembly-executing',
  onAssemblyError: 'transloadit:assembly-error',
  onAssemblyComplete: 'transloadit:complete',
  onResult: 'transloadit:result',
  // Upload events
  onStart: 'upload',
  onPause: 'pause-all',
  onFilePause: 'upload-pause',
  onCancel: 'cancel-all',
  onError: 'error',
  // mostly akin to promise rejection
  onFileCancel: 'upload-cancel',
  onFileProgress: 'upload-progress',
  onFileError: 'upload-error',
  onUploaded: 'transloadit:upload',
  onComplete: 'complete' // mostly akin to promise resolution

};
var uppyOptionNames = ['autoProceed', 'restrictions', 'meta', 'onBeforeFileAdded', 'onBeforeUpload', 'debug'];

function createUppy(opts, overrides) {
  if (overrides === void 0) {
    overrides = {};
  }

  var uppyOptions = {};
  uppyOptionNames.forEach(function (name) {
    if (has(opts, name)) uppyOptions[name] = opts[name];
  });

  _extends(uppyOptions, overrides);

  var uppy = new Uppy(uppyOptions); // Builtin event aliases

  Object.keys(eventNames).forEach(function (optionName) {
    var eventName = eventNames[optionName];

    if (typeof opts[optionName] === 'function') {
      uppy.on(eventName, opts[optionName]);
    }
  }); // Custom events (these should probably be added to core)

  if (typeof opts.onProgress === 'function') {
    uppy.on('upload-progress', function () {
      var _uppy$getState = uppy.getState(),
          totalProgress = _uppy$getState.totalProgress;

      opts.onProgress.call(uppy, totalProgress);
    });
  }

  return uppy;
}

module.exports = createUppy;

},{"./../../core":73,"./../../utils/lib/hasProperty":224}],146:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var createUppy = require('./createUppy');

var addDashboardPlugin = require('./addDashboardPlugin');

var addTransloaditPlugin = require('./addTransloaditPlugin');

var addProviders = require('./addProviders');

function dashboard(target, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var inline = opts.inline == null ? true : opts.inline;
  var pluginId = 'Dashboard';
  var uppy = createUppy(opts);
  addTransloaditPlugin(uppy, opts);
  addDashboardPlugin(uppy, opts, {
    id: pluginId,
    inline: inline,
    target: target,
    closeAfterFinish: false
  });

  if (Array.isArray(opts.providers)) {
    addProviders(uppy, opts.providers, _extends({}, opts, {
      // Install providers into the Dashboard.
      target: uppy.getPlugin(pluginId)
    }));
  }

  return uppy;
}

module.exports = dashboard;

},{"./addDashboardPlugin":142,"./addProviders":143,"./addTransloaditPlugin":144,"./createUppy":145}],147:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Uppy = require('./../../core');

var Form = require('./../../form');

var StatusBar = require('./../../status-bar');

var findDOMElement = require('./../../utils/lib/findDOMElement');

var has = require('./../../utils/lib/hasProperty');

var AttachFileInputs = require('./AttachFileInputs');

var TransloaditFormResult = require('./TransloaditFormResult');

var addDashboardPlugin = require('./addDashboardPlugin');

var addTransloaditPlugin = require('./addTransloaditPlugin');

var addProviders = require('./addProviders');

var defaultLocaleStrings = {
  chooseFiles: 'Choose files'
};

function mergeDefaultLocale(defaults, userProvided) {
  if (userProvided === void 0) {
    userProvided = {};
  }

  var strings = userProvided.strings || {};
  return _extends({}, userProvided, {
    strings: _extends({}, defaults, strings)
  });
}

function form(target, opts) {
  if (!opts) throw new TypeError('robodog.form: must provide an options object');
  opts = _extends({}, opts, {
    locale: mergeDefaultLocale(defaultLocaleStrings, opts.locale)
  });
  var uppy = new Uppy(opts);
  addTransloaditPlugin(uppy, opts);
  uppy.use(TransloaditFormResult, {
    target: target,
    transloaditPluginId: 'Transloadit',
    name: 'transloadit'
  });
  var submitOnSuccess = true;

  if (has(opts, 'submitOnSuccess')) {
    submitOnSuccess = !!opts.submitOnSuccess;
  }

  var formOptions = {
    target: target,
    triggerUploadOnSubmit: true,
    submitOnSuccess: submitOnSuccess,
    addResultToForm: false // using custom implementation instead

  };

  if (has(opts, 'triggerUploadOnSubmit')) {
    formOptions.triggerUploadOnSubmit = opts.triggerUploadOnSubmit;
  }

  uppy.use(Form, formOptions);
  var useDashboard = opts.dashboard || opts.modal;

  if (useDashboard) {
    var dashboardTarget = findDOMElement(opts.dashboard) || document.body;
    var dashboardId = 'form:Dashboard';
    var dashboardOpts = {
      id: dashboardId,
      target: dashboardTarget
    };

    if (opts.modal) {
      var trigger = 'input[type="file"]';
      var button = document.createElement('button');
      button.textContent = uppy.i18n('chooseFiles');
      button.type = 'button';
      var old = findDOMElement(trigger, findDOMElement(target));
      old.parentNode.replaceChild(button, old);
      dashboardOpts.inline = false;
      dashboardOpts.trigger = button;
    } else {
      dashboardOpts.inline = true;
      dashboardOpts.hideUploadButton = true;
    }

    addDashboardPlugin(uppy, opts, dashboardOpts);

    if (Array.isArray(opts.providers)) {
      addProviders(uppy, opts.providers, _extends({}, opts, {
        target: uppy.getPlugin(dashboardId)
      }));
    }
  } else {
    uppy.use(AttachFileInputs, {
      target: target
    });
  }

  if (opts.statusBar) {
    uppy.use(StatusBar, {
      target: opts.statusBar,
      // hide most of the things to keep our api simple,
      // we can change this in the future if someone needs it
      hideUploadButton: true,
      hideAfterFinish: true,
      hideRetryButton: true,
      hidePauseResumeButtons: true,
      hideCancelButtons: true
    });
  }

  return uppy;
}

module.exports = form;

},{"./../../core":73,"./../../form":105,"./../../status-bar":154,"./../../utils/lib/findDOMElement":208,"./../../utils/lib/hasProperty":224,"./AttachFileInputs":139,"./TransloaditFormResult":140,"./addDashboardPlugin":142,"./addProviders":143,"./addTransloaditPlugin":144}],148:[function(require,module,exports){
var form = require('./form');

var dashboard = require('./dashboard');

var pick = require('./pick');

var upload = require('./upload');

module.exports = {
  dashboard: dashboard,
  form: form,
  pick: pick,
  upload: upload,
  VERSION: require('../package.json').version
};

},{"../package.json":138,"./dashboard":146,"./form":147,"./pick":149,"./upload":150}],149:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var createUppy = require('./createUppy');

var addDashboardPlugin = require('./addDashboardPlugin');

var addTransloaditPlugin = require('./addTransloaditPlugin');

var addProviders = require('./addProviders');

var CANCEL = {};

function pick(opts) {
  if (opts === void 0) {
    opts = {};
  }

  var target = opts.target || document.body;
  var pluginId = 'pick';
  var uppy = createUppy(opts, {
    allowMultipleUploads: false
  });
  addTransloaditPlugin(uppy, opts);
  addDashboardPlugin(uppy, opts, {
    id: pluginId,
    target: target,
    closeAfterFinish: true
  });

  if (Array.isArray(opts.providers)) {
    addProviders(uppy, opts.providers, _extends({}, opts, {
      // Install providers into the Dashboard.
      target: uppy.getPlugin(pluginId)
    }));
  }

  return new Promise(function (resolve, reject) {
    uppy.on('complete', function (result) {
      if (result.failed.length === 0) {
        resolve(result);
      }
    });
    uppy.on('error', reject);
    uppy.on('cancel-all', function () {
      return reject(CANCEL);
    });
    uppy.getPlugin(pluginId).openModal();
  }).then(function (result) {
    return result;
  }, function (err) {
    if (err === CANCEL) {
      uppy.getPlugin(pluginId).requestCloseModal();
      return null;
    }

    throw err;
  });
}

module.exports = pick;

},{"./addDashboardPlugin":142,"./addProviders":143,"./addTransloaditPlugin":144,"./createUppy":145}],150:[function(require,module,exports){
var toArray = require('./../../utils/lib/toArray');

var createUppy = require('./createUppy');

var addTransloaditPlugin = require('./addTransloaditPlugin');

function upload(files, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (!Array.isArray(files) && typeof files.length === 'number') {
    files = toArray(files);
  }

  var uppy = createUppy(opts, {
    allowMultipleUploads: false
  });
  addTransloaditPlugin(uppy, opts);
  files.forEach(function (file) {
    uppy.addFile({
      data: file,
      type: file.type,
      name: file.name,
      meta: file.meta || {}
    });
  });
  return uppy.upload();
}

module.exports = upload;

},{"./../../utils/lib/toArray":235,"./addTransloaditPlugin":144,"./createUppy":145}],151:[function(require,module,exports){
module.exports={
  "name": "@uppy/status-bar",
  "description": "A progress bar for Uppy, with many bells and whistles.",
  "version": "1.9.5",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "progress bar",
    "status bar",
    "progress",
    "upload",
    "eta",
    "speed"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "lodash.throttle": "^4.1.1",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],152:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var throttle = require('lodash.throttle');

var classNames = require('classnames');

var statusBarStates = require('./StatusBarStates');

var prettierBytes = require('@transloadit/prettier-bytes');

var prettyETA = require('./../../utils/lib/prettyETA');

var _require = require('preact'),
    h = _require.h;

function calculateProcessingProgress(files) {
  // Collect pre or postprocessing progress states.
  var progresses = [];
  Object.keys(files).forEach(function (fileID) {
    var progress = files[fileID].progress;

    if (progress.preprocess) {
      progresses.push(progress.preprocess);
    }

    if (progress.postprocess) {
      progresses.push(progress.postprocess);
    }
  }); // In the future we should probably do this differently. For now we'll take the
  // mode and message from the first file…

  var _progresses$ = progresses[0],
      mode = _progresses$.mode,
      message = _progresses$.message;
  var value = progresses.filter(isDeterminate).reduce(function (total, progress, index, all) {
    return total + progress.value / all.length;
  }, 0);

  function isDeterminate(progress) {
    return progress.mode === 'determinate';
  }

  return {
    mode: mode,
    message: message,
    value: value
  };
}

function togglePauseResume(props) {
  if (props.isAllComplete) return;

  if (!props.resumableUploads) {
    return props.cancelAll();
  }

  if (props.isAllPaused) {
    return props.resumeAll();
  }

  return props.pauseAll();
}

function RenderReSelectGhosts(_ref) {
  var i18n = _ref.i18n;
  return h("div", {
    className: "uppy-StatusBar-serviceMsg"
  }, i18n('reSelectGhosts'), h("svg", {
    className: "uppy-c-icon uppy-StatusBar-serviceMsg-ghostsIcon",
    "aria-hidden": "true",
    width: "15",
    height: "19",
    viewBox: "0 0 35 39"
  }, h("path", {
    d: "M1.708 38.66c1.709 0 3.417-3.417 6.834-3.417 3.416 0 5.125 3.417 8.61 3.417 3.348 0 5.056-3.417 8.473-3.417 4.305 0 5.125 3.417 6.833 3.417.889 0 1.709-.889 1.709-1.709v-19.68C34.167-5.757 0-5.757 0 17.271v19.68c0 .82.888 1.709 1.708 1.709zm8.542-17.084a3.383 3.383 0 01-3.417-3.416 3.383 3.383 0 013.417-3.417 3.383 3.383 0 013.417 3.417 3.383 3.383 0 01-3.417 3.416zm13.667 0A3.383 3.383 0 0120.5 18.16a3.383 3.383 0 013.417-3.417 3.383 3.383 0 013.416 3.417 3.383 3.383 0 01-3.416 3.416z",
    fillRule: "nonzero"
  })));
}

module.exports = function (props) {
  props = props || {};
  var _props = props,
      newFiles = _props.newFiles,
      allowNewUpload = _props.allowNewUpload,
      isUploadInProgress = _props.isUploadInProgress,
      isAllPaused = _props.isAllPaused,
      resumableUploads = _props.resumableUploads,
      error = _props.error,
      hideUploadButton = _props.hideUploadButton,
      hidePauseResumeButton = _props.hidePauseResumeButton,
      hideCancelButton = _props.hideCancelButton,
      hideRetryButton = _props.hideRetryButton,
      recoveredState = _props.recoveredState;
  var uploadState = props.uploadState;
  var progressValue = props.totalProgress;
  var progressMode;
  var progressBarContent;

  if (uploadState === statusBarStates.STATE_PREPROCESSING || uploadState === statusBarStates.STATE_POSTPROCESSING) {
    var progress = calculateProcessingProgress(props.files);
    progressMode = progress.mode;

    if (progressMode === 'determinate') {
      progressValue = progress.value * 100;
    }

    progressBarContent = ProgressBarProcessing(progress);
  } else if (uploadState === statusBarStates.STATE_COMPLETE) {
    progressBarContent = ProgressBarComplete(props);
  } else if (uploadState === statusBarStates.STATE_UPLOADING) {
    if (!props.supportsUploadProgress) {
      progressMode = 'indeterminate';
      progressValue = null;
    }

    progressBarContent = ProgressBarUploading(props);
  } else if (uploadState === statusBarStates.STATE_ERROR) {
    progressValue = undefined;
    progressBarContent = ProgressBarError(props);
  }

  var width = typeof progressValue === 'number' ? progressValue : 100;
  var isHidden = uploadState === statusBarStates.STATE_WAITING && props.hideUploadButton || uploadState === statusBarStates.STATE_WAITING && !props.newFiles > 0 || uploadState === statusBarStates.STATE_COMPLETE && props.hideAfterFinish;
  var showUploadBtn = !error && newFiles && !isUploadInProgress && !isAllPaused && allowNewUpload && !hideUploadButton;

  if (recoveredState) {
    isHidden = false;
    showUploadBtn = true;
  }

  var showCancelBtn = !hideCancelButton && uploadState !== statusBarStates.STATE_WAITING && uploadState !== statusBarStates.STATE_COMPLETE;
  var showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState === statusBarStates.STATE_UPLOADING;
  var showRetryBtn = error && !hideRetryButton;
  var showDoneBtn = props.doneButtonHandler && uploadState === statusBarStates.STATE_COMPLETE;
  var progressClassNames = "uppy-StatusBar-progress\n                           " + (progressMode ? "is-" + progressMode : '');
  var statusBarClassNames = classNames({
    'uppy-Root': props.isTargetDOMEl
  }, 'uppy-StatusBar', "is-" + uploadState, {
    'has-ghosts': props.isSomeGhost
  });
  return h("div", {
    className: statusBarClassNames,
    "aria-hidden": isHidden
  }, h("div", {
    className: progressClassNames,
    style: {
      width: width + "%"
    },
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": progressValue
  }), progressBarContent, h("div", {
    className: "uppy-StatusBar-actions"
  }, showUploadBtn ? h(UploadBtn, _extends({}, props, {
    uploadState: uploadState
  })) : null, showRetryBtn ? h(RetryBtn, props) : null, showPauseResumeBtn ? h(PauseResumeButton, props) : null, showCancelBtn ? h(CancelBtn, props) : null, showDoneBtn ? h(DoneBtn, props) : null));
};

var UploadBtn = function UploadBtn(props) {
  var uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--upload', {
    'uppy-c-btn-primary': props.uploadState === statusBarStates.STATE_WAITING
  }, {
    'uppy-StatusBar-actionBtn--disabled': props.isSomeGhost
  });
  var uploadBtnText = props.newFiles && props.isUploadStarted && !props.recoveredState ? props.i18n('uploadXNewFiles', {
    smart_count: props.newFiles
  }) : props.i18n('uploadXFiles', {
    smart_count: props.newFiles
  });
  return h("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": props.i18n('uploadXFiles', {
      smart_count: props.newFiles
    }),
    onClick: props.startUpload,
    disabled: props.isSomeGhost,
    "data-uppy-super-focusable": true
  }, uploadBtnText);
};

var RetryBtn = function RetryBtn(props) {
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
    "aria-label": props.i18n('retryUpload'),
    onClick: props.retryAll,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "8",
    height: "10",
    viewBox: "0 0 8 10"
  }, h("path", {
    d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
  })), props.i18n('retry'));
};

var CancelBtn = function CancelBtn(props) {
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    title: props.i18n('cancel'),
    "aria-label": props.i18n('cancel'),
    onClick: props.cancelAll,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
  }))));
};

var PauseResumeButton = function PauseResumeButton(props) {
  var isAllPaused = props.isAllPaused,
      i18n = props.i18n;
  var title = isAllPaused ? i18n('resume') : i18n('pause');
  return h("button", {
    title: title,
    "aria-label": title,
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    type: "button",
    onClick: function onClick() {
      return togglePauseResume(props);
    },
    "data-uppy-super-focusable": true
  }, isAllPaused ? h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M6 4.25L11.5 8 6 11.75z"
  }))) : h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    d: "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z",
    fill: "#FFF"
  }))));
};

var DoneBtn = function DoneBtn(props) {
  var i18n = props.i18n;
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done",
    onClick: props.doneButtonHandler,
    "data-uppy-super-focusable": true
  }, i18n('done'));
};

var LoadingSpinner = function LoadingSpinner() {
  return h("svg", {
    className: "uppy-StatusBar-spinner",
    "aria-hidden": "true",
    focusable: "false",
    width: "14",
    height: "14"
  }, h("path", {
    d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
    fillRule: "evenodd"
  }));
};

var ProgressBarProcessing = function ProgressBarProcessing(props) {
  var value = Math.round(props.value * 100);
  return h("div", {
    className: "uppy-StatusBar-content"
  }, h(LoadingSpinner, null), props.mode === 'determinate' ? value + "% \xB7 " : '', props.message);
};

var renderDot = function renderDot() {
  return " \xB7 ";
};

var ProgressDetails = function ProgressDetails(props) {
  var ifShowFilesUploadedOfTotal = props.numUploads > 1;
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, ifShowFilesUploadedOfTotal && props.i18n('filesUploadedOfTotal', {
    complete: props.complete,
    smart_count: props.numUploads
  }), h("span", {
    className: "uppy-StatusBar-additionalInfo"
  }, ifShowFilesUploadedOfTotal && renderDot(), props.i18n('dataUploadedOfTotal', {
    complete: prettierBytes(props.totalUploadedSize),
    total: prettierBytes(props.totalSize)
  }), renderDot(), props.i18n('xTimeLeft', {
    time: prettyETA(props.totalETA)
  })));
};

var UnknownProgressDetails = function UnknownProgressDetails(props) {
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, props.i18n('filesUploadedOfTotal', {
    complete: props.complete,
    smart_count: props.numUploads
  }));
};

var UploadNewlyAddedFiles = function UploadNewlyAddedFiles(props) {
  var uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--uploadNewlyAdded');
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, h("div", {
    className: "uppy-StatusBar-statusSecondaryHint"
  }, props.i18n('xMoreFilesAdded', {
    smart_count: props.newFiles
  })), h("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": props.i18n('uploadXFiles', {
      smart_count: props.newFiles
    }),
    onClick: props.startUpload
  }, props.i18n('upload')));
};

var ThrottledProgressDetails = throttle(ProgressDetails, 500, {
  leading: true,
  trailing: true
});

var ProgressBarUploading = function ProgressBarUploading(props) {
  if (!props.isUploadStarted || props.isAllComplete) {
    return null;
  }

  var title = props.isAllPaused ? props.i18n('paused') : props.i18n('uploading');
  var showUploadNewlyAddedFiles = props.newFiles && props.isUploadStarted;
  return h("div", {
    className: "uppy-StatusBar-content",
    "aria-label": title,
    title: title
  }, !props.isAllPaused ? h(LoadingSpinner, null) : null, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, props.supportsUploadProgress ? title + ": " + props.totalProgress + "%" : title), !props.isAllPaused && !showUploadNewlyAddedFiles && props.showProgressDetails ? props.supportsUploadProgress ? h(ThrottledProgressDetails, props) : h(UnknownProgressDetails, props) : null, showUploadNewlyAddedFiles ? h(UploadNewlyAddedFiles, props) : null));
};

var ProgressBarComplete = function ProgressBarComplete(_ref2) {
  var totalProgress = _ref2.totalProgress,
      i18n = _ref2.i18n;
  return h("div", {
    className: "uppy-StatusBar-content",
    role: "status",
    title: i18n('complete')
  }, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "15",
    height: "11",
    viewBox: "0 0 15 11"
  }, h("path", {
    d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
  })), i18n('complete'))));
};

var ProgressBarError = function ProgressBarError(_ref3) {
  var error = _ref3.error,
      retryAll = _ref3.retryAll,
      hideRetryButton = _ref3.hideRetryButton,
      i18n = _ref3.i18n;

  function displayErrorAlert() {
    var errorMessage = i18n('uploadFailed') + " \n\n " + error;
    alert(errorMessage);
  }

  return h("div", {
    className: "uppy-StatusBar-content",
    role: "alert",
    title: i18n('uploadFailed')
  }, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "11",
    height: "11",
    viewBox: "0 0 11 11"
  }, h("path", {
    d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
  })), i18n('uploadFailed'))), h("span", {
    className: "uppy-StatusBar-details",
    "aria-label": error,
    "data-microtip-position": "top-right",
    "data-microtip-size": "medium",
    role: "tooltip",
    onClick: displayErrorAlert
  }, "?"));
};

},{"./../../utils/lib/prettyETA":231,"./StatusBarStates":153,"@transloadit/prettier-bytes":1,"classnames":10,"lodash.throttle":32,"preact":37}],153:[function(require,module,exports){
module.exports = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete'
};

},{}],154:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var StatusBarUI = require('./StatusBar');

var statusBarStates = require('./StatusBarStates');

var getSpeed = require('./../../utils/lib/getSpeed');

var getBytesRemaining = require('./../../utils/lib/getBytesRemaining');

var getTextDirection = require('./../../utils/lib/getTextDirection');
/**
 * StatusBar: renders a status bar with upload/pause/resume/cancel/retry buttons,
 * progress percentage and time remaining.
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(StatusBar, _Plugin);

  function StatusBar(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.startUpload = function () {
      var _this$uppy$getState = _this.uppy.getState(),
          recoveredState = _this$uppy$getState.recoveredState;

      if (recoveredState) {
        _this.uppy.emit('restore-confirmed');

        return;
      }

      return _this.uppy.upload().catch(function () {// Error logged in Core
      });
    };

    _this.id = _this.opts.id || 'StatusBar';
    _this.title = 'StatusBar';
    _this.type = 'progressindicator';
    _this.defaultLocale = {
      strings: {
        uploading: 'Uploading',
        upload: 'Upload',
        complete: 'Complete',
        uploadFailed: 'Upload failed',
        paused: 'Paused',
        retry: 'Retry',
        retryUpload: 'Retry upload',
        cancel: 'Cancel',
        pause: 'Pause',
        resume: 'Resume',
        done: 'Done',
        filesUploadedOfTotal: {
          0: '%{complete} of %{smart_count} file uploaded',
          1: '%{complete} of %{smart_count} files uploaded'
        },
        dataUploadedOfTotal: '%{complete} of %{total}',
        xTimeLeft: '%{time} left',
        uploadXFiles: {
          0: 'Upload %{smart_count} file',
          1: 'Upload %{smart_count} files'
        },
        uploadXNewFiles: {
          0: 'Upload +%{smart_count} file',
          1: 'Upload +%{smart_count} files'
        },
        xMoreFilesAdded: {
          0: '%{smart_count} more file added',
          1: '%{smart_count} more files added'
        }
      }
    }; // set default options

    var defaultOptions = {
      target: 'body',
      hideUploadButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideCancelButton: false,
      showProgressDetails: false,
      hideAfterFinish: true,
      doneButtonHandler: null
    };
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.render = _this.render.bind(_assertThisInitialized(_this));
    _this.install = _this.install.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = StatusBar.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.getTotalSpeed = function getTotalSpeed(files) {
    var totalSpeed = 0;
    files.forEach(function (file) {
      totalSpeed += getSpeed(file.progress);
    });
    return totalSpeed;
  };

  _proto.getTotalETA = function getTotalETA(files) {
    var totalSpeed = this.getTotalSpeed(files);

    if (totalSpeed === 0) {
      return 0;
    }

    var totalBytesRemaining = files.reduce(function (total, file) {
      return total + getBytesRemaining(file.progress);
    }, 0);
    return Math.round(totalBytesRemaining / totalSpeed * 10) / 10;
  };

  _proto.getUploadingState = function getUploadingState(isAllErrored, isAllComplete, recoveredState, files) {
    if (isAllErrored) {
      return statusBarStates.STATE_ERROR;
    }

    if (isAllComplete) {
      return statusBarStates.STATE_COMPLETE;
    }

    if (recoveredState) {
      return statusBarStates.STATE_WAITING;
    }

    var state = statusBarStates.STATE_WAITING;
    var fileIDs = Object.keys(files);

    for (var i = 0; i < fileIDs.length; i++) {
      var progress = files[fileIDs[i]].progress; // If ANY files are being uploaded right now, show the uploading state.

      if (progress.uploadStarted && !progress.uploadComplete) {
        return statusBarStates.STATE_UPLOADING;
      } // If files are being preprocessed AND postprocessed at this time, we show the
      // preprocess state. If any files are being uploaded we show uploading.


      if (progress.preprocess && state !== statusBarStates.STATE_UPLOADING) {
        state = statusBarStates.STATE_PREPROCESSING;
      } // If NO files are being preprocessed or uploaded right now, but some files are
      // being postprocessed, show the postprocess state.


      if (progress.postprocess && state !== statusBarStates.STATE_UPLOADING && state !== statusBarStates.STATE_PREPROCESSING) {
        state = statusBarStates.STATE_POSTPROCESSING;
      }
    }

    return state;
  };

  _proto.render = function render(state) {
    var capabilities = state.capabilities,
        files = state.files,
        allowNewUpload = state.allowNewUpload,
        totalProgress = state.totalProgress,
        error = state.error,
        recoveredState = state.recoveredState; // TODO: move this to Core, to share between Status Bar and Dashboard
    // (and any other plugin that might need it, too)

    var filesArray = Object.keys(files).map(function (file) {
      return files[file];
    });
    var newFiles = filesArray.filter(function (file) {
      return !file.progress.uploadStarted && !file.progress.preprocess && !file.progress.postprocess;
    }); // If some state was recovered, we want to show Upload button/counter
    // for all the files, because in this case it’s not an Upload button,
    // but “Confirm Restore Button”

    if (recoveredState) {
      newFiles = filesArray;
    }

    var uploadStartedFiles = filesArray.filter(function (file) {
      return file.progress.uploadStarted;
    });
    var pausedFiles = uploadStartedFiles.filter(function (file) {
      return file.isPaused;
    });
    var completeFiles = filesArray.filter(function (file) {
      return file.progress.uploadComplete;
    });
    var erroredFiles = filesArray.filter(function (file) {
      return file.error;
    });
    var inProgressFiles = filesArray.filter(function (file) {
      return !file.progress.uploadComplete && file.progress.uploadStarted;
    });
    var inProgressNotPausedFiles = inProgressFiles.filter(function (file) {
      return !file.isPaused;
    });
    var startedFiles = filesArray.filter(function (file) {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });
    var processingFiles = filesArray.filter(function (file) {
      return file.progress.preprocess || file.progress.postprocess;
    });
    var totalETA = this.getTotalETA(inProgressNotPausedFiles);
    var totalSize = 0;
    var totalUploadedSize = 0;
    startedFiles.forEach(function (file) {
      totalSize += file.progress.bytesTotal || 0;
      totalUploadedSize += file.progress.bytesUploaded || 0;
    });
    var isUploadStarted = startedFiles.length > 0;
    var isAllComplete = totalProgress === 100 && completeFiles.length === Object.keys(files).length && processingFiles.length === 0;
    var isAllErrored = error && erroredFiles.length === filesArray.length;
    var isAllPaused = inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length;
    var isUploadInProgress = inProgressFiles.length > 0;
    var resumableUploads = capabilities.resumableUploads || false;
    var supportsUploadProgress = capabilities.uploadProgress !== false;
    var isSomeGhost = filesArray.some(function (file) {
      return file.isGhost;
    });
    return StatusBarUI({
      error: error,
      uploadState: this.getUploadingState(isAllErrored, isAllComplete, recoveredState, state.files || {}),
      allowNewUpload: allowNewUpload,
      totalProgress: totalProgress,
      totalSize: totalSize,
      totalUploadedSize: totalUploadedSize,
      isAllComplete: isAllComplete,
      isAllPaused: isAllPaused,
      isAllErrored: isAllErrored,
      isUploadStarted: isUploadStarted,
      isUploadInProgress: isUploadInProgress,
      isSomeGhost: isSomeGhost,
      recoveredState: recoveredState,
      complete: completeFiles.length,
      newFiles: newFiles.length,
      numUploads: startedFiles.length,
      totalETA: totalETA,
      files: files,
      i18n: this.i18n,
      pauseAll: this.uppy.pauseAll,
      resumeAll: this.uppy.resumeAll,
      retryAll: this.uppy.retryAll,
      cancelAll: this.uppy.cancelAll,
      startUpload: this.startUpload,
      doneButtonHandler: this.opts.doneButtonHandler,
      resumableUploads: resumableUploads,
      supportsUploadProgress: supportsUploadProgress,
      showProgressDetails: this.opts.showProgressDetails,
      hideUploadButton: this.opts.hideUploadButton,
      hideRetryButton: this.opts.hideRetryButton,
      hidePauseResumeButton: this.opts.hidePauseResumeButton,
      hideCancelButton: this.opts.hideCancelButton,
      hideAfterFinish: this.opts.hideAfterFinish,
      isTargetDOMEl: this.isTargetDOMEl
    });
  };

  _proto.onMount = function onMount() {
    // Set the text direction if the page has not defined one.
    var element = this.el;
    var direction = getTextDirection(element);

    if (!direction) {
      element.dir = 'ltr';
    }
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return StatusBar;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":151,"./../../core":73,"./../../utils/lib/Translator":202,"./../../utils/lib/getBytesRemaining":211,"./../../utils/lib/getSpeed":221,"./../../utils/lib/getTextDirection":222,"./StatusBar":152,"./StatusBarStates":153}],155:[function(require,module,exports){
module.exports={
  "name": "@uppy/store-default",
  "description": "The default simple object-based store for Uppy.",
  "version": "1.2.7",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-store"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  }
}

},{}],156:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * Default store that keeps state in a simple object.
 */
var DefaultStore = /*#__PURE__*/function () {
  function DefaultStore() {
    this.state = {};
    this.callbacks = [];
  }

  var _proto = DefaultStore.prototype;

  _proto.getState = function getState() {
    return this.state;
  };

  _proto.setState = function setState(patch) {
    var prevState = _extends({}, this.state);

    var nextState = _extends({}, this.state, patch);

    this.state = nextState;

    this._publish(prevState, nextState, patch);
  };

  _proto.subscribe = function subscribe(listener) {
    var _this = this;

    this.callbacks.push(listener);
    return function () {
      // Remove the listener.
      _this.callbacks.splice(_this.callbacks.indexOf(listener), 1);
    };
  };

  _proto._publish = function _publish() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.callbacks.forEach(function (listener) {
      listener.apply(void 0, args);
    });
  };

  return DefaultStore;
}();

DefaultStore.VERSION = require('../package.json').version;

module.exports = function defaultStore() {
  return new DefaultStore();
};

},{"../package.json":155}],157:[function(require,module,exports){
module.exports={
  "name": "@uppy/thumbnail-generator",
  "description": "Uppy plugin that generates small previews of images to show on your upload UI.",
  "version": "1.7.10",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "thumbnail",
    "preview",
    "resize"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "exifr": "^6.0.0",
    "math-log2": "^1.0.1"
  },
  "devDependencies": {
    "namespace-emitter": "2.0.1"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],158:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var dataURItoBlob = require('./../../utils/lib/dataURItoBlob');

var isObjectURL = require('./../../utils/lib/isObjectURL');

var isPreviewSupported = require('./../../utils/lib/isPreviewSupported');

var MathLog2 = require('math-log2'); // Polyfill for IE.


var exifr = require('exifr/dist/mini.legacy.umd.js');
/**
 * The Thumbnail Generator plugin
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(ThumbnailGenerator, _Plugin);

  function ThumbnailGenerator(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.onFileAdded = function (file) {
      if (!file.preview && file.data && isPreviewSupported(file.type) && !file.isRemote) {
        _this.addToQueue(file.id);
      }
    };

    _this.onCancelRequest = function (file) {
      var index = _this.queue.indexOf(file.id);

      if (index !== -1) {
        _this.queue.splice(index, 1);
      }
    };

    _this.onFileRemoved = function (file) {
      var index = _this.queue.indexOf(file.id);

      if (index !== -1) {
        _this.queue.splice(index, 1);
      } // Clean up object URLs.


      if (file.preview && isObjectURL(file.preview)) {
        URL.revokeObjectURL(file.preview);
      }
    };

    _this.onRestored = function () {
      var restoredFiles = _this.uppy.getFiles().filter(function (file) {
        return file.isRestored;
      });

      restoredFiles.forEach(function (file) {
        // Only add blob URLs; they are likely invalid after being restored.
        if (!file.preview || isObjectURL(file.preview)) {
          _this.addToQueue(file.id);
        }
      });
    };

    _this.waitUntilAllProcessed = function (fileIDs) {
      fileIDs.forEach(function (fileID) {
        var file = _this.uppy.getFile(fileID);

        _this.uppy.emit('preprocess-progress', file, {
          mode: 'indeterminate',
          message: _this.i18n('generatingThumbnails')
        });
      });

      var emitPreprocessCompleteForAll = function emitPreprocessCompleteForAll() {
        fileIDs.forEach(function (fileID) {
          var file = _this.uppy.getFile(fileID);

          _this.uppy.emit('preprocess-complete', file);
        });
      };

      return new Promise(function (resolve, reject) {
        if (_this.queueProcessing) {
          _this.uppy.once('thumbnail:all-generated', function () {
            emitPreprocessCompleteForAll();
            resolve();
          });
        } else {
          emitPreprocessCompleteForAll();
          resolve();
        }
      });
    };

    _this.type = 'modifier';
    _this.id = _this.opts.id || 'ThumbnailGenerator';
    _this.title = 'Thumbnail Generator';
    _this.queue = [];
    _this.queueProcessing = false;
    _this.defaultThumbnailDimension = 200;
    _this.thumbnailType = _this.opts.thumbnailType || 'image/jpeg';
    _this.defaultLocale = {
      strings: {
        generatingThumbnails: 'Generating thumbnails...'
      }
    };
    var defaultOptions = {
      thumbnailWidth: null,
      thumbnailHeight: null,
      waitForThumbnailsBeforeUpload: false,
      lazy: false
    };
    _this.opts = _extends({}, defaultOptions, opts);

    if (_this.opts.lazy && _this.opts.waitForThumbnailsBeforeUpload) {
      throw new Error('ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.');
    }

    _this.i18nInit();

    return _this;
  }

  var _proto = ThumbnailGenerator.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  }
  /**
   * Create a thumbnail for the given Uppy file object.
   *
   * @param {{data: Blob}} file
   * @param {number} targetWidth
   * @param {number} targetHeight
   * @returns {Promise}
   */
  ;

  _proto.createThumbnail = function createThumbnail(file, targetWidth, targetHeight) {
    var _this2 = this;

    // bug in the compatibility data
    // eslint-disable-next-line compat/compat
    var originalUrl = URL.createObjectURL(file.data);
    var onload = new Promise(function (resolve, reject) {
      var image = new Image();
      image.src = originalUrl;
      image.addEventListener('load', function () {
        // bug in the compatibility data
        // eslint-disable-next-line compat/compat
        URL.revokeObjectURL(originalUrl);
        resolve(image);
      });
      image.addEventListener('error', function (event) {
        // bug in the compatibility data
        // eslint-disable-next-line compat/compat
        URL.revokeObjectURL(originalUrl);
        reject(event.error || new Error('Could not create thumbnail'));
      });
    });
    var orientationPromise = exifr.rotation(file.data).catch(function (_err) {
      return 1;
    });
    return Promise.all([onload, orientationPromise]).then(function (_ref) {
      var image = _ref[0],
          orientation = _ref[1];

      var dimensions = _this2.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);

      var rotatedImage = _this2.rotateImage(image, orientation);

      var resizedImage = _this2.resizeImage(rotatedImage, dimensions.width, dimensions.height);

      return _this2.canvasToBlob(resizedImage, _this2.thumbnailType, 80);
    }).then(function (blob) {
      // bug in the compatibility data
      // eslint-disable-next-line compat/compat
      return URL.createObjectURL(blob);
    });
  }
  /**
   * Get the new calculated dimensions for the given image and a target width
   * or height. If both width and height are given, only width is taken into
   * account. If neither width nor height are given, the default dimension
   * is used.
   */
  ;

  _proto.getProportionalDimensions = function getProportionalDimensions(img, width, height, rotation) {
    var aspect = img.width / img.height;

    if (rotation === 90 || rotation === 270) {
      aspect = img.height / img.width;
    }

    if (width != null) {
      return {
        width: width,
        height: Math.round(width / aspect)
      };
    }

    if (height != null) {
      return {
        width: Math.round(height * aspect),
        height: height
      };
    }

    return {
      width: this.defaultThumbnailDimension,
      height: Math.round(this.defaultThumbnailDimension / aspect)
    };
  }
  /**
   * Make sure the image doesn’t exceed browser/device canvas limits.
   * For ios with 256 RAM and ie
   */
  ;

  _proto.protect = function protect(image) {
    // https://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
    var ratio = image.width / image.height;
    var maxSquare = 5000000; // ios max canvas square

    var maxSize = 4096; // ie max canvas dimensions

    var maxW = Math.floor(Math.sqrt(maxSquare * ratio));
    var maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));

    if (maxW > maxSize) {
      maxW = maxSize;
      maxH = Math.round(maxW / ratio);
    }

    if (maxH > maxSize) {
      maxH = maxSize;
      maxW = Math.round(ratio * maxH);
    }

    if (image.width > maxW) {
      var canvas = document.createElement('canvas');
      canvas.width = maxW;
      canvas.height = maxH;
      canvas.getContext('2d').drawImage(image, 0, 0, maxW, maxH);
      image = canvas;
    }

    return image;
  }
  /**
   * Resize an image to the target `width` and `height`.
   *
   * Returns a Canvas with the resized image on it.
   */
  ;

  _proto.resizeImage = function resizeImage(image, targetWidth, targetHeight) {
    // Resizing in steps refactored to use a solution from
    // https://blog.uploadcare.com/image-resize-in-browsers-is-broken-e38eed08df01
    image = this.protect(image);
    var steps = Math.ceil(MathLog2(image.width / targetWidth));

    if (steps < 1) {
      steps = 1;
    }

    var sW = targetWidth * Math.pow(2, steps - 1);
    var sH = targetHeight * Math.pow(2, steps - 1);
    var x = 2;

    while (steps--) {
      var canvas = document.createElement('canvas');
      canvas.width = sW;
      canvas.height = sH;
      canvas.getContext('2d').drawImage(image, 0, 0, sW, sH);
      image = canvas;
      sW = Math.round(sW / x);
      sH = Math.round(sH / x);
    }

    return image;
  };

  _proto.rotateImage = function rotateImage(image, translate) {
    var w = image.width;
    var h = image.height;

    if (translate.deg === 90 || translate.deg === 270) {
      w = image.height;
      h = image.width;
    }

    var canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    var context = canvas.getContext('2d');
    context.translate(w / 2, h / 2);

    if (translate.canvas) {
      context.rotate(translate.rad);
      context.scale(translate.scaleX, translate.scaleY);
    }

    context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
    return canvas;
  }
  /**
   * Save a <canvas> element's content to a Blob object.
   *
   * @param {HTMLCanvasElement} canvas
   * @returns {Promise}
   */
  ;

  _proto.canvasToBlob = function canvasToBlob(canvas, type, quality) {
    try {
      canvas.getContext('2d').getImageData(0, 0, 1, 1);
    } catch (err) {
      if (err.code === 18) {
        return Promise.reject(new Error('cannot read image, probably an svg with external resources'));
      }
    }

    if (canvas.toBlob) {
      return new Promise(function (resolve) {
        canvas.toBlob(resolve, type, quality);
      }).then(function (blob) {
        if (blob === null) {
          throw new Error('cannot read image, probably an svg with external resources');
        }

        return blob;
      });
    }

    return Promise.resolve().then(function () {
      return dataURItoBlob(canvas.toDataURL(type, quality), {});
    }).then(function (blob) {
      if (blob === null) {
        throw new Error('could not extract blob, probably an old browser');
      }

      return blob;
    });
  }
  /**
   * Set the preview URL for a file.
   */
  ;

  _proto.setPreviewURL = function setPreviewURL(fileID, preview) {
    this.uppy.setFileState(fileID, {
      preview: preview
    });
  };

  _proto.addToQueue = function addToQueue(item) {
    this.queue.push(item);

    if (this.queueProcessing === false) {
      this.processQueue();
    }
  };

  _proto.processQueue = function processQueue() {
    var _this3 = this;

    this.queueProcessing = true;

    if (this.queue.length > 0) {
      var current = this.uppy.getFile(this.queue.shift());

      if (!current) {
        this.uppy.log('[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug', 'error');
        return;
      }

      return this.requestThumbnail(current).catch(function (err) {}) // eslint-disable-line handle-callback-err
      .then(function () {
        return _this3.processQueue();
      });
    }

    this.queueProcessing = false;
    this.uppy.log('[ThumbnailGenerator] Emptied thumbnail queue');
    this.uppy.emit('thumbnail:all-generated');
  };

  _proto.requestThumbnail = function requestThumbnail(file) {
    var _this4 = this;

    if (isPreviewSupported(file.type) && !file.isRemote) {
      return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then(function (preview) {
        _this4.setPreviewURL(file.id, preview);

        _this4.uppy.log("[ThumbnailGenerator] Generated thumbnail for " + file.id);

        _this4.uppy.emit('thumbnail:generated', _this4.uppy.getFile(file.id), preview);
      }).catch(function (err) {
        _this4.uppy.log("[ThumbnailGenerator] Failed thumbnail for " + file.id + ":", 'warning');

        _this4.uppy.log(err, 'warning');

        _this4.uppy.emit('thumbnail:error', _this4.uppy.getFile(file.id), err);
      });
    }

    return Promise.resolve();
  };

  _proto.install = function install() {
    this.uppy.on('file-removed', this.onFileRemoved);

    if (this.opts.lazy) {
      this.uppy.on('thumbnail:request', this.onFileAdded);
      this.uppy.on('thumbnail:cancel', this.onCancelRequest);
    } else {
      this.uppy.on('file-added', this.onFileAdded);
      this.uppy.on('restored', this.onRestored);
    }

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.addPreProcessor(this.waitUntilAllProcessed);
    }
  };

  _proto.uninstall = function uninstall() {
    this.uppy.off('file-removed', this.onFileRemoved);

    if (this.opts.lazy) {
      this.uppy.off('thumbnail:request', this.onFileAdded);
      this.uppy.off('thumbnail:cancel', this.onCancelRequest);
    } else {
      this.uppy.off('file-added', this.onFileAdded);
      this.uppy.off('restored', this.onRestored);
    }

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.removePreProcessor(this.waitUntilAllProcessed);
    }
  };

  return ThumbnailGenerator;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":157,"./../../core":73,"./../../utils/lib/Translator":202,"./../../utils/lib/dataURItoBlob":204,"./../../utils/lib/isObjectURL":228,"./../../utils/lib/isPreviewSupported":229,"exifr/dist/mini.legacy.umd.js":22,"math-log2":33}],159:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],160:[function(require,module,exports){
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

},{"./debug":161,"_process":38}],161:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":172}],162:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":163,"engine.io-parser":19}],163:[function(require,module,exports){
/**
 * Module dependencies.
 */

var transports = require('./transports/index');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports/index');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

},{"./transport":164,"./transports/index":165,"component-emitter":159,"debug":160,"engine.io-parser":19,"indexof":28,"parseqs":173,"parseuri":174}],164:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":159,"engine.io-parser":19}],165:[function(require,module,exports){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

},{"./polling-jsonp":166,"./polling-xhr":167,"./websocket":169,"xmlhttprequest-ssl":170}],166:[function(require,module,exports){
(function (global){(function (){
/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */
function glob () {
  return typeof self !== 'undefined' ? self
      : typeof window !== 'undefined' ? window
      : typeof global !== 'undefined' ? global : {};
}

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = (global.___eio || []);
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":168,"component-inherit":12}],167:[function(require,module,exports){
/* global attachEvent */

/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

},{"./polling":168,"component-emitter":159,"component-inherit":12,"debug":160,"xmlhttprequest-ssl":170}],168:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":164,"component-inherit":12,"debug":160,"engine.io-parser":19,"parseqs":173,"xmlhttprequest-ssl":170,"yeast":62}],169:[function(require,module,exports){
(function (Buffer){(function (){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
} else {
  try {
    NodeWebSocket = require('ws');
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../transport":164,"buffer":9,"component-inherit":12,"debug":160,"engine.io-parser":19,"parseqs":173,"ws":8,"yeast":62}],170:[function(require,module,exports){
// browser shim for xmlhttprequest module

var hasCORS = require('has-cors');

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

},{"has-cors":26}],171:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],172:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],173:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],174:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],175:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":176,"./socket":178,"./url":179,"debug":160,"socket.io-parser":181}],176:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":177,"./socket":178,"backo2":4,"component-bind":11,"component-emitter":159,"debug":160,"engine.io-client":162,"indexof":28,"socket.io-parser":181}],177:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

},{}],178:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var parseqs = require('parseqs');
var hasBin = require('has-binary2');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};

},{"./on":177,"component-bind":11,"component-emitter":159,"debug":160,"has-binary2":24,"parseqs":173,"socket.io-parser":181,"to-array":45}],179:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

},{"debug":160,"parseuri":174}],180:[function(require,module,exports){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

},{"./is-buffer":182,"isarray":171}],181:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var start = i + 1;
    while (str.charAt(++i) !== '-' && i != str.length) {}
    var buf = str.substring(start, i);
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    var start = i + 1;
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      if (i === str.length) break;
    }
    p.nsp = str.substring(start, i);
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    var start = i + 1;
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      if (i === str.length) break;
    }
    p.id = Number(str.substring(start, i + 1));
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}

},{"./binary":180,"./is-buffer":182,"component-emitter":183,"debug":160,"isarray":171}],182:[function(require,module,exports){
(function (Buffer){(function (){

module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":9}],183:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],184:[function(require,module,exports){
module.exports={
  "name": "@uppy/transloadit",
  "description": "The Transloadit plugin can be used to upload files to Transloadit for all kinds of processing, such as transcoding video, resizing images, zipping/unzipping, and more",
  "version": "1.6.25",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "transloadit",
    "file encoding",
    "encoding",
    "file processing",
    "video encoding",
    "crop",
    "resize",
    "watermark",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/tus": "file:../tus",
    "@uppy/utils": "file:../utils",
    "component-emitter": "^1.2.1",
    "socket.io-client": "~2.2.0",
    "url-parse": "^1.4.7"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],185:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var io = requireSocketIo;

var Emitter = require('component-emitter');

var has = require('./../../utils/lib/hasProperty');

var parseUrl = require('./parseUrl');

var NetworkError = require('./../../utils/lib/NetworkError');

var fetchWithNetworkError = require('./../../utils/lib/fetchWithNetworkError'); // Lazy load socket.io to avoid a console error
// in IE 10 when the Transloadit plugin is not used.
// (The console.error call comes from `buffer`. I
// think we actually don't use that part of socket.io
// at all…)


var socketIo;

function requireSocketIo() {
  if (!socketIo) {
    socketIo = require('socket.io-client');
  }

  return socketIo;
}

var ASSEMBLY_UPLOADING = 'ASSEMBLY_UPLOADING';
var ASSEMBLY_EXECUTING = 'ASSEMBLY_EXECUTING';
var ASSEMBLY_COMPLETED = 'ASSEMBLY_COMPLETED';
var statusOrder = [ASSEMBLY_UPLOADING, ASSEMBLY_EXECUTING, ASSEMBLY_COMPLETED];
/**
 * Check that an assembly status is equal to or larger than some desired status.
 * It checks for things that are larger so that a comparison like this works,
 * when the old assembly status is UPLOADING but the new is FINISHED:
 *
 * !isStatus(oldStatus, ASSEMBLY_EXECUTING) && isStatus(newState, ASSEMBLY_EXECUTING)
 *
 * …so that we can emit the 'executing' event even if the execution step was so
 * fast that we missed it.
 */

function isStatus(status, test) {
  return statusOrder.indexOf(status) >= statusOrder.indexOf(test);
}

var TransloaditAssembly = /*#__PURE__*/function (_Emitter) {
  _inheritsLoose(TransloaditAssembly, _Emitter);

  function TransloaditAssembly(assembly) {
    var _this;

    _this = _Emitter.call(this) || this; // The current assembly status.

    _this.status = assembly; // The socket.io connection.

    _this.socket = null; // The interval timer for full status updates.

    _this.pollInterval = null; // Whether this assembly has been closed (finished or errored)

    _this.closed = false;
    return _this;
  }

  var _proto = TransloaditAssembly.prototype;

  _proto.connect = function connect() {
    this._connectSocket();

    this._beginPolling();
  };

  _proto._onFinished = function _onFinished() {
    this.emit('finished');
    this.close();
  };

  _proto._connectSocket = function _connectSocket() {
    var _this2 = this;

    var parsed = parseUrl(this.status.websocket_url);
    var socket = io().connect(parsed.origin, {
      transports: ['websocket'],
      path: parsed.pathname
    });
    socket.on('connect', function () {
      socket.emit('assembly_connect', {
        id: _this2.status.assembly_id
      });

      _this2.emit('connect');
    });
    socket.on('connect_failed', function () {
      _this2._onError(new NetworkError('Transloadit Socket.io connection error'));

      _this2.socket = null;
    });
    socket.on('error', function () {
      socket.disconnect();
      _this2.socket = null;
    });
    socket.on('assembly_finished', function () {
      _this2._onFinished();
    });
    socket.on('assembly_upload_finished', function (file) {
      _this2.emit('upload', file);

      _this2.status.uploads.push(file);
    });
    socket.on('assembly_uploading_finished', function () {
      _this2.emit('executing');
    });
    socket.on('assembly_upload_meta_data_extracted', function () {
      _this2.emit('metadata');

      _this2._fetchStatus({
        diff: false
      });
    });
    socket.on('assembly_result_finished', function (stepName, result) {
      _this2.emit('result', stepName, result);

      if (!_this2.status.results[stepName]) {
        _this2.status.results[stepName] = [];
      }

      _this2.status.results[stepName].push(result);
    });
    socket.on('assembly_error', function (err) {
      _this2._onError(err); // Refetch for updated status code


      _this2._fetchStatus({
        diff: false
      });
    });
    this.socket = socket;
  };

  _proto._onError = function _onError(err) {
    this.emit('error', _extends(new Error(err.message), err));
  }
  /**
   * Begin polling for assembly status changes. This sends a request to the
   * assembly status endpoint every so often, if the socket is not connected.
   * If the socket connection fails or takes a long time, we won't miss any
   * events.
   */
  ;

  _proto._beginPolling = function _beginPolling() {
    var _this3 = this;

    this.pollInterval = setInterval(function () {
      if (!_this3.socket || !_this3.socket.connected) {
        _this3._fetchStatus();
      }
    }, 2000);
  }
  /**
   * Reload assembly status. Useful if the socket doesn't work.
   *
   * Pass `diff: false` to avoid emitting diff events, instead only emitting
   * 'status'.
   */
  ;

  _proto._fetchStatus = function _fetchStatus(_temp) {
    var _this4 = this;

    var _ref = _temp === void 0 ? {} : _temp,
        _ref$diff = _ref.diff,
        diff = _ref$diff === void 0 ? true : _ref$diff;

    return fetchWithNetworkError(this.status.assembly_ssl_url).then(function (response) {
      return response.json();
    }).then(function (status) {
      // Avoid updating if we closed during this request's lifetime.
      if (_this4.closed) return;

      _this4.emit('status', status);

      if (diff) {
        _this4.updateStatus(status);
      } else {
        _this4.status = status;
      }
    }).catch(function (err) {
      return _this4._onError(err);
    });
  };

  _proto.update = function update() {
    return this._fetchStatus({
      diff: true
    });
  }
  /**
   * Update this assembly's status with a full new object. Events will be
   * emitted for status changes, new files, and new results.
   *
   * @param {object} next The new assembly status object.
   */
  ;

  _proto.updateStatus = function updateStatus(next) {
    this._diffStatus(this.status, next);

    this.status = next;
  }
  /**
   * Diff two assembly statuses, and emit the events necessary to go from `prev`
   * to `next`.
   *
   * @param {object} prev The previous assembly status.
   * @param {object} next The new assembly status.
   */
  ;

  _proto._diffStatus = function _diffStatus(prev, next) {
    var _this5 = this;

    var prevStatus = prev.ok;
    var nextStatus = next.ok;

    if (next.error && !prev.error) {
      return this._onError(next);
    } // Desired emit order:
    //  - executing
    //  - (n × upload)
    //  - metadata
    //  - (m × result)
    //  - finished
    // The below checks run in this order, that way even if we jump from
    // UPLOADING straight to FINISHED all the events are emitted as expected.


    var nowExecuting = isStatus(nextStatus, ASSEMBLY_EXECUTING) && !isStatus(prevStatus, ASSEMBLY_EXECUTING);

    if (nowExecuting) {
      // Without WebSockets, this is our only way to tell if uploading finished.
      // Hence, we emit this just before the 'upload's and before the 'metadata'
      // event for the most intuitive ordering, corresponding to the _usual_
      // ordering (if not guaranteed) that you'd get on the WebSocket.
      this.emit('executing');
    } // Find new uploaded files.


    Object.keys(next.uploads).filter(function (upload) {
      return !has(prev.uploads, upload);
    }).map(function (upload) {
      return next.uploads[upload];
    }).forEach(function (upload) {
      _this5.emit('upload', upload);
    });

    if (nowExecuting) {
      this.emit('metadata');
    } // Find new results.


    Object.keys(next.results).forEach(function (stepName) {
      var nextResults = next.results[stepName];
      var prevResults = prev.results[stepName];
      nextResults.filter(function (n) {
        return !prevResults || !prevResults.some(function (p) {
          return p.id === n.id;
        });
      }).forEach(function (result) {
        _this5.emit('result', stepName, result);
      });
    });

    if (isStatus(nextStatus, ASSEMBLY_COMPLETED) && !isStatus(prevStatus, ASSEMBLY_COMPLETED)) {
      this.emit('finished');
    }
  }
  /**
   * Stop updating this assembly.
   */
  ;

  _proto.close = function close() {
    this.closed = true;

    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }

    clearInterval(this.pollInterval);
  };

  return TransloaditAssembly;
}(Emitter);

module.exports = TransloaditAssembly;

},{"./../../utils/lib/NetworkError":200,"./../../utils/lib/fetchWithNetworkError":206,"./../../utils/lib/hasProperty":224,"./parseUrl":190,"component-emitter":159,"socket.io-client":175}],186:[function(require,module,exports){
/**
 * Check that Assembly parameters are present and include all required fields.
 */
function validateParams(params) {
  if (!params) {
    throw new Error('Transloadit: The `params` option is required.');
  }

  if (typeof params === 'string') {
    try {
      params = JSON.parse(params);
    } catch (err) {
      // Tell the user that this is not an Uppy bug!
      err.message = "Transloadit: The `params` option is a malformed JSON string: " + err.message;
      throw err;
    }
  }

  if (!params.auth || !params.auth.key) {
    throw new Error('Transloadit: The `params.auth.key` option is required. ' + 'You can find your Transloadit API key at https://transloadit.com/account/api-settings.');
  }
}
/**
 * Turn Transloadit plugin options and a list of files into a list of Assembly
 * options.
 */


var AssemblyOptions = /*#__PURE__*/function () {
  function AssemblyOptions(files, opts) {
    this.files = files;
    this.opts = opts;
  }
  /**
   * Normalize Uppy-specific Assembly option features to a Transloadit-
   * compatible object.
   */


  var _proto = AssemblyOptions.prototype;

  _proto._normalizeAssemblyOptions = function _normalizeAssemblyOptions(file, assemblyOptions) {
    if (Array.isArray(assemblyOptions.fields)) {
      var fieldNames = assemblyOptions.fields;
      assemblyOptions.fields = {};
      fieldNames.forEach(function (fieldName) {
        assemblyOptions.fields[fieldName] = file.meta[fieldName];
      });
    }

    if (!assemblyOptions.fields) {
      assemblyOptions.fields = {};
    }

    return assemblyOptions;
  }
  /**
   * Get Assembly options for a file.
   */
  ;

  _proto._getAssemblyOptions = function _getAssemblyOptions(file) {
    var _this = this;

    var options = this.opts;
    return Promise.resolve().then(function () {
      return options.getAssemblyOptions(file, options);
    }).then(function (assemblyOptions) {
      return _this._normalizeAssemblyOptions(file, assemblyOptions);
    }).then(function (assemblyOptions) {
      validateParams(assemblyOptions.params);
      return {
        fileIDs: [file.id],
        options: assemblyOptions
      };
    });
  }
  /**
   * Combine Assemblies with the same options into a single Assembly for all the
   * relevant files.
   */
  ;

  _proto._dedupe = function _dedupe(list) {
    var dedupeMap = Object.create(null);
    list.forEach(function (_ref) {
      var fileIDs = _ref.fileIDs,
          options = _ref.options;
      var id = JSON.stringify(options);

      if (dedupeMap[id]) {
        var _dedupeMap$id$fileIDs;

        (_dedupeMap$id$fileIDs = dedupeMap[id].fileIDs).push.apply(_dedupeMap$id$fileIDs, fileIDs);
      } else {
        dedupeMap[id] = {
          options: options,
          fileIDs: [].concat(fileIDs)
        };
      }
    });
    return Object.keys(dedupeMap).map(function (id) {
      return dedupeMap[id];
    });
  }
  /**
   * Generate a set of Assemblies that will handle the upload.
   * Returns a Promise for an object with keys:
   *  - fileIDs - an array of file IDs to add to this Assembly
   *  - options - Assembly options
   */
  ;

  _proto.build = function build() {
    var _this2 = this;

    var options = this.opts;

    if (this.files.length > 0) {
      return Promise.all(this.files.map(function (file) {
        return _this2._getAssemblyOptions(file);
      })).then(function (list) {
        return _this2._dedupe(list);
      });
    }

    if (options.alwaysRunAssembly) {
      // No files, just generate one Assembly
      return Promise.resolve(options.getAssemblyOptions(null, options)).then(function (assemblyOptions) {
        validateParams(assemblyOptions.params);
        return [{
          fileIDs: _this2.files.map(function (file) {
            return file.id;
          }),
          options: assemblyOptions
        }];
      });
    } // If there are no files and we do not `alwaysRunAssembly`,
    // don't do anything.


    return Promise.resolve([]);
  };

  return AssemblyOptions;
}();

module.exports = AssemblyOptions;
module.exports.validateParams = validateParams;

},{}],187:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Emitter = require('component-emitter');
/**
 * Track completion of multiple assemblies.
 *
 * Emits 'assembly-complete' when an assembly completes.
 * Emits 'assembly-error' when an assembly fails.
 * Exposes a `.promise` property that resolves when all assemblies have
 * completed (or failed).
 */


var TransloaditAssemblyWatcher = /*#__PURE__*/function (_Emitter) {
  _inheritsLoose(TransloaditAssemblyWatcher, _Emitter);

  function TransloaditAssemblyWatcher(uppy, assemblyIDs) {
    var _this;

    _this = _Emitter.call(this) || this;
    _this._uppy = uppy;
    _this._assemblyIDs = assemblyIDs;
    _this._remaining = assemblyIDs.length;
    _this.promise = new Promise(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
    _this._onAssemblyComplete = _this._onAssemblyComplete.bind(_assertThisInitialized(_this));
    _this._onAssemblyCancel = _this._onAssemblyCancel.bind(_assertThisInitialized(_this));
    _this._onAssemblyError = _this._onAssemblyError.bind(_assertThisInitialized(_this));
    _this._onImportError = _this._onImportError.bind(_assertThisInitialized(_this));

    _this._addListeners();

    return _this;
  }
  /**
   * Are we watching this assembly ID?
   */


  var _proto = TransloaditAssemblyWatcher.prototype;

  _proto._watching = function _watching(id) {
    return this._assemblyIDs.indexOf(id) !== -1;
  };

  _proto._onAssemblyComplete = function _onAssemblyComplete(assembly) {
    if (!this._watching(assembly.assembly_id)) {
      return;
    }

    this._uppy.log("[Transloadit] AssemblyWatcher: Got Assembly finish " + assembly.assembly_id);

    this.emit('assembly-complete', assembly.assembly_id);

    this._checkAllComplete();
  };

  _proto._onAssemblyCancel = function _onAssemblyCancel(assembly) {
    if (!this._watching(assembly.assembly_id)) {
      return;
    }

    this._checkAllComplete();
  };

  _proto._onAssemblyError = function _onAssemblyError(assembly, error) {
    if (!this._watching(assembly.assembly_id)) {
      return;
    }

    this._uppy.log("[Transloadit] AssemblyWatcher: Got Assembly error " + assembly.assembly_id);

    this._uppy.log(error);

    this.emit('assembly-error', assembly.assembly_id, error);

    this._checkAllComplete();
  };

  _proto._onImportError = function _onImportError(assembly, fileID, error) {
    if (!this._watching(assembly.assembly_id)) {
      return;
    } // Not sure if we should be doing something when it's just one file failing.
    // ATM, the only options are 1) ignoring or 2) failing the entire upload.
    // I think failing the upload is better than silently ignoring.
    // In the future we should maybe have a way to resolve uploads with some failures,
    // like returning an object with `{ successful, failed }` uploads.


    this._onAssemblyError(assembly, error);
  };

  _proto._checkAllComplete = function _checkAllComplete() {
    this._remaining -= 1;

    if (this._remaining === 0) {
      // We're done, these listeners can be removed
      this._removeListeners();

      this._resolve();
    }
  };

  _proto._removeListeners = function _removeListeners() {
    this._uppy.off('transloadit:complete', this._onAssemblyComplete);

    this._uppy.off('transloadit:assembly-cancel', this._onAssemblyCancel);

    this._uppy.off('transloadit:assembly-error', this._onAssemblyError);

    this._uppy.off('transloadit:import-error', this._onImportError);
  };

  _proto._addListeners = function _addListeners() {
    this._uppy.on('transloadit:complete', this._onAssemblyComplete);

    this._uppy.on('transloadit:assembly-cancel', this._onAssemblyCancel);

    this._uppy.on('transloadit:assembly-error', this._onAssemblyError);

    this._uppy.on('transloadit:import-error', this._onImportError);
  };

  return TransloaditAssemblyWatcher;
}(Emitter);

module.exports = TransloaditAssemblyWatcher;

},{"component-emitter":159}],188:[function(require,module,exports){
var fetchWithNetworkError = require('./../../utils/lib/fetchWithNetworkError');

var URL = require('url-parse');
/**
 * A Barebones HTTP API client for Transloadit.
 */


module.exports = /*#__PURE__*/function () {
  function Client(opts) {
    if (opts === void 0) {
      opts = {};
    }

    this.opts = opts;
    this._reportError = this._reportError.bind(this);
    this._headers = {
      'Transloadit-Client': this.opts.client
    };
  }
  /**
   * Create a new assembly.
   *
   * @param {object} options
   * @param {string|object} options.params
   * @param {object} options.fields
   * @param {string} options.signature
   * @param {number} options.expectedFiles
   */


  var _proto = Client.prototype;

  _proto.createAssembly = function createAssembly(_ref) {
    var _this = this;

    var params = _ref.params,
        fields = _ref.fields,
        signature = _ref.signature,
        expectedFiles = _ref.expectedFiles;
    var data = new FormData();
    data.append('params', typeof params === 'string' ? params : JSON.stringify(params));

    if (signature) {
      data.append('signature', signature);
    }

    Object.keys(fields).forEach(function (key) {
      data.append(key, fields[key]);
    });
    data.append('num_expected_upload_files', expectedFiles);
    var url = new URL('/assemblies', "" + this.opts.service).href;
    return fetchWithNetworkError(url, {
      method: 'post',
      headers: this._headers,
      body: data
    }).then(function (response) {
      return response.json();
    }).then(function (assembly) {
      if (assembly.error) {
        var error = new Error(assembly.error);
        error.details = assembly.message;
        error.assembly = assembly;

        if (assembly.assembly_id) {
          error.details += ' ' + ("Assembly ID: " + assembly.assembly_id);
        }

        throw error;
      }

      return assembly;
    }).catch(function (err) {
      return _this._reportError(err, {
        url: url,
        type: 'API_ERROR'
      });
    });
  }
  /**
   * Reserve resources for a file in an Assembly. Then addFile can be used later.
   *
   * @param {object} assembly
   * @param {UppyFile} file
   */
  ;

  _proto.reserveFile = function reserveFile(assembly, file) {
    var _this2 = this;

    var size = encodeURIComponent(file.size);
    var url = assembly.assembly_ssl_url + "/reserve_file?size=" + size;
    return fetchWithNetworkError(url, {
      method: 'post',
      headers: this._headers
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      return _this2._reportError(err, {
        assembly: assembly,
        file: file,
        url: url,
        type: 'API_ERROR'
      });
    });
  }
  /**
   * Import a remote file to an Assembly.
   *
   * @param {object} assembly
   * @param {UppyFile} file
   */
  ;

  _proto.addFile = function addFile(assembly, file) {
    var _this3 = this;

    if (!file.uploadURL) {
      return Promise.reject(new Error('File does not have an `uploadURL`.'));
    }

    var size = encodeURIComponent(file.size);
    var uploadUrl = encodeURIComponent(file.uploadURL);
    var filename = encodeURIComponent(file.name);
    var fieldname = 'file';
    var qs = "size=" + size + "&filename=" + filename + "&fieldname=" + fieldname + "&s3Url=" + uploadUrl;
    var url = assembly.assembly_ssl_url + "/add_file?" + qs;
    return fetchWithNetworkError(url, {
      method: 'post',
      headers: this._headers
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      return _this3._reportError(err, {
        assembly: assembly,
        file: file,
        url: url,
        type: 'API_ERROR'
      });
    });
  }
  /**
   * Cancel a running Assembly.
   *
   * @param {object} assembly
   */
  ;

  _proto.cancelAssembly = function cancelAssembly(assembly) {
    var _this4 = this;

    var url = assembly.assembly_ssl_url;
    return fetchWithNetworkError(url, {
      method: 'delete',
      headers: this._headers
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      return _this4._reportError(err, {
        url: url,
        type: 'API_ERROR'
      });
    });
  }
  /**
   * Get the current status for an assembly.
   *
   * @param {string} url The status endpoint of the assembly.
   */
  ;

  _proto.getAssemblyStatus = function getAssemblyStatus(url) {
    var _this5 = this;

    return fetchWithNetworkError(url, {
      headers: this._headers
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      return _this5._reportError(err, {
        url: url,
        type: 'STATUS_ERROR'
      });
    });
  };

  _proto.submitError = function submitError(err, _ref2) {
    var endpoint = _ref2.endpoint,
        instance = _ref2.instance,
        assembly = _ref2.assembly;
    var message = err.details ? err.message + " (" + err.details + ")" : err.message;
    return fetchWithNetworkError('https://transloaditstatus.com/client_error', {
      method: 'post',
      body: JSON.stringify({
        endpoint: endpoint,
        instance: instance,
        assembly_id: assembly,
        agent: typeof navigator !== 'undefined' ? navigator.userAgent : '',
        client: this.opts.client,
        error: message
      })
    }).then(function (response) {
      return response.json();
    });
  };

  _proto._reportError = function _reportError(err, params) {
    if (this.opts.errorReporting === false) {
      throw err;
    }

    var opts = {
      type: params.type
    };

    if (params.assembly) {
      opts.assembly = params.assembly.assembly_id;
      opts.instance = params.assembly.instance;
    }

    if (params.url) {
      opts.endpoint = params.url;
    }

    this.submitError(err, opts).catch(function (_) {// not much we can do then is there
    });
    throw err;
  };

  return Client;
}();

},{"./../../utils/lib/fetchWithNetworkError":206,"url-parse":60}],189:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Translator = require('./../../utils/lib/Translator');

var hasProperty = require('./../../utils/lib/hasProperty');

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Tus = require('./../../tus');

var Assembly = require('./Assembly');

var Client = require('./Client');

var AssemblyOptions = require('./AssemblyOptions');

var AssemblyWatcher = require('./AssemblyWatcher');

function defaultGetAssemblyOptions(file, options) {
  return {
    params: options.params,
    signature: options.signature,
    fields: options.fields
  };
}

var COMPANION = 'https://api2.transloadit.com/companion'; // Regex matching acceptable postMessage() origins for authentication feedback from companion.

var ALLOWED_COMPANION_PATTERN = /\.transloadit\.com$/; // Regex used to check if a Companion address is run by Transloadit.

var TL_COMPANION = /https?:\/\/api2(?:-\w+)?\.transloadit\.com\/companion/;
var TL_UPPY_SERVER = /https?:\/\/api2(?:-\w+)?\.transloadit\.com\/uppy-server/;
/**
 * Upload files to Transloadit using Tus.
 */

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Transloadit, _Plugin);

  function Transloadit(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'uploader';
    _this.id = _this.opts.id || 'Transloadit';
    _this.title = 'Transloadit';
    _this.defaultLocale = {
      strings: {
        creatingAssembly: 'Preparing upload...',
        creatingAssemblyFailed: 'Transloadit: Could not create Assembly',
        encoding: 'Encoding...'
      }
    };
    var defaultOptions = {
      service: 'https://api2.transloadit.com',
      errorReporting: true,
      waitForEncoding: false,
      waitForMetadata: false,
      alwaysRunAssembly: false,
      importFromUploadURLs: false,
      signature: null,
      params: null,
      fields: {},
      getAssemblyOptions: defaultGetAssemblyOptions,
      limit: 0
    };
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this._prepareUpload = _this._prepareUpload.bind(_assertThisInitialized(_this));
    _this._afterUpload = _this._afterUpload.bind(_assertThisInitialized(_this));
    _this._onError = _this._onError.bind(_assertThisInitialized(_this));
    _this._onTusError = _this._onTusError.bind(_assertThisInitialized(_this));
    _this._onCancelAll = _this._onCancelAll.bind(_assertThisInitialized(_this));
    _this._onFileUploadURLAvailable = _this._onFileUploadURLAvailable.bind(_assertThisInitialized(_this));
    _this._onRestored = _this._onRestored.bind(_assertThisInitialized(_this));
    _this._getPersistentData = _this._getPersistentData.bind(_assertThisInitialized(_this));
    var hasCustomAssemblyOptions = _this.opts.getAssemblyOptions !== defaultOptions.getAssemblyOptions;

    if (_this.opts.params) {
      AssemblyOptions.validateParams(_this.opts.params);
    } else if (!hasCustomAssemblyOptions) {
      // Throw the same error that we'd throw if the `params` returned from a
      // `getAssemblyOptions()` function is null.
      AssemblyOptions.validateParams(null);
    }

    _this.client = new Client({
      service: _this.opts.service,
      client: _this._getClientVersion(),
      errorReporting: _this.opts.errorReporting
    }); // Contains Assembly instances for in-progress Assemblies.

    _this.activeAssemblies = {}; // Contains a mapping of uploadID to AssemblyWatcher

    _this.assemblyWatchers = {}; // Contains a file IDs that have completed postprocessing before the upload they belong to has entered the postprocess stage.

    _this.completedFiles = Object.create(null);
    return _this;
  }

  var _proto = Transloadit.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto._getClientVersion = function _getClientVersion() {
    var _this2 = this;

    var list = ["uppy-core:" + this.uppy.constructor.VERSION, "uppy-transloadit:" + this.constructor.VERSION, "uppy-tus:" + Tus.VERSION];

    var addPluginVersion = function addPluginVersion(pluginName, versionName) {
      var plugin = _this2.uppy.getPlugin(pluginName);

      if (plugin) {
        list.push(versionName + ":" + plugin.constructor.VERSION);
      }
    };

    if (this.opts.importFromUploadURLs) {
      addPluginVersion('XHRUpload', 'uppy-xhr-upload');
      addPluginVersion('AwsS3', 'uppy-aws-s3');
      addPluginVersion('AwsS3Multipart', 'uppy-aws-s3-multipart');
    }

    addPluginVersion('Dropbox', 'uppy-dropbox');
    addPluginVersion('Box', 'uppy-box');
    addPluginVersion('Facebook', 'uppy-facebook');
    addPluginVersion('GoogleDrive', 'uppy-google-drive');
    addPluginVersion('Instagram', 'uppy-instagram');
    addPluginVersion('OneDrive', 'uppy-onedrive');
    addPluginVersion('Zoom', 'uppy-zoom');
    addPluginVersion('Url', 'uppy-url');
    return list.join(',');
  }
  /**
   * Attach metadata to files to configure the Tus plugin to upload to Transloadit.
   * Also use Transloadit's Companion
   *
   * See: https://github.com/tus/tusd/wiki/Uploading-to-Transloadit-using-tus#uploading-using-tus
   *
   * @param {object} file
   * @param {object} status
   */
  ;

  _proto._attachAssemblyMetadata = function _attachAssemblyMetadata(file, status) {
    // Add the metadata parameters Transloadit needs.
    var meta = _extends({}, file.meta, {
      assembly_url: status.assembly_url,
      filename: file.name,
      fieldname: 'file'
    }); // Add Assembly-specific Tus endpoint.


    var tus = _extends({}, file.tus, {
      endpoint: status.tus_url,
      // Include X-Request-ID headers for better debugging.
      addRequestId: true
    }); // Set Companion location. We only add this, if 'file' has the attribute
    // remote, because this is the criteria to identify remote files.
    // We only replace the hostname for Transloadit's companions, so that
    // people can also self-host them while still using Transloadit for encoding.


    var remote = file.remote;

    if (file.remote && TL_UPPY_SERVER.test(file.remote.companionUrl)) {
      var err = new Error('The https://api2.transloadit.com/uppy-server endpoint was renamed to ' + 'https://api2.transloadit.com/companion, please update your `companionUrl` ' + 'options accordingly.'); // Explicitly log this error here because it is caught by the `createAssembly`
      // Promise further along.
      // That's fine, but createAssembly only shows the informer, we need something a
      // little more noisy.

      this.uppy.log(err);
      throw err;
    }

    if (file.remote && TL_COMPANION.test(file.remote.companionUrl)) {
      var newHost = status.companion_url.replace(/\/$/, '');
      var path = file.remote.url.replace(file.remote.companionUrl, '').replace(/^\//, '');
      remote = _extends({}, file.remote, {
        companionUrl: newHost,
        url: newHost + "/" + path
      });
    } // Store the Assembly ID this file is in on the file under the `transloadit` key.


    var newFile = _extends({}, file, {
      transloadit: {
        assembly: status.assembly_id
      }
    }); // Only configure the Tus plugin if we are uploading straight to Transloadit (the default).


    if (!this.opts.importFromUploadURLs) {
      _extends(newFile, {
        meta: meta,
        tus: tus,
        remote: remote
      });
    }

    return newFile;
  };

  _proto._createAssembly = function _createAssembly(fileIDs, uploadID, options) {
    var _this3 = this;

    this.uppy.log('[Transloadit] Create Assembly');
    return this.client.createAssembly({
      params: options.params,
      fields: options.fields,
      expectedFiles: fileIDs.length,
      signature: options.signature
    }).then(function (newAssembly) {
      var _extends2, _extends3;

      var assembly = new Assembly(newAssembly);
      var status = assembly.status;
      var assemblyID = status.assembly_id;

      var _this3$getPluginState = _this3.getPluginState(),
          assemblies = _this3$getPluginState.assemblies,
          uploadsAssemblies = _this3$getPluginState.uploadsAssemblies;

      _this3.setPluginState({
        // Store the Assembly status.
        assemblies: _extends({}, assemblies, (_extends2 = {}, _extends2[assemblyID] = status, _extends2)),
        // Store the list of Assemblies related to this upload.
        uploadsAssemblies: _extends({}, uploadsAssemblies, (_extends3 = {}, _extends3[uploadID] = [].concat(uploadsAssemblies[uploadID], [assemblyID]), _extends3))
      });

      var _this3$uppy$getState = _this3.uppy.getState(),
          files = _this3$uppy$getState.files;

      var updatedFiles = {};
      fileIDs.forEach(function (id) {
        updatedFiles[id] = _this3._attachAssemblyMetadata(_this3.uppy.getFile(id), status);
      });

      _this3.uppy.setState({
        files: _extends({}, files, updatedFiles)
      });

      _this3.uppy.emit('transloadit:assembly-created', status, fileIDs);

      _this3.uppy.log("[Transloadit] Created Assembly " + assemblyID);

      return assembly;
    }).catch(function (err) {
      err.message = _this3.i18n('creatingAssemblyFailed') + ": " + err.message; // Reject the promise.

      throw err;
    });
  };

  _proto._createAssemblyWatcher = function _createAssemblyWatcher(assemblyID, fileIDs, uploadID) {
    var _this4 = this;

    // AssemblyWatcher tracks completion states of all Assemblies in this upload.
    var watcher = new AssemblyWatcher(this.uppy, assemblyID);
    watcher.on('assembly-complete', function (id) {
      var files = _this4.getAssemblyFiles(id);

      files.forEach(function (file) {
        _this4.completedFiles[file.id] = true;

        _this4.uppy.emit('postprocess-complete', file);
      });
    });
    watcher.on('assembly-error', function (id, error) {
      // Clear postprocessing state for all our files.
      var files = _this4.getAssemblyFiles(id);

      files.forEach(function (file) {
        // TODO Maybe make a postprocess-error event here?
        _this4.uppy.emit('upload-error', file, error);

        _this4.uppy.emit('postprocess-complete', file);
      });
    });
    this.assemblyWatchers[uploadID] = watcher;
  };

  _proto._shouldWaitAfterUpload = function _shouldWaitAfterUpload() {
    return this.opts.waitForEncoding || this.opts.waitForMetadata;
  }
  /**
   * Used when `importFromUploadURLs` is enabled: reserves all files in
   * the Assembly.
   */
  ;

  _proto._reserveFiles = function _reserveFiles(assembly, fileIDs) {
    var _this5 = this;

    return Promise.all(fileIDs.map(function (fileID) {
      var file = _this5.uppy.getFile(fileID);

      return _this5.client.reserveFile(assembly.status, file);
    }));
  }
  /**
   * Used when `importFromUploadURLs` is enabled: adds files to the Assembly
   * once they have been fully uploaded.
   */
  ;

  _proto._onFileUploadURLAvailable = function _onFileUploadURLAvailable(rawFile) {
    var _this6 = this;

    var file = this.uppy.getFile(rawFile.id);

    if (!file || !file.transloadit || !file.transloadit.assembly) {
      return;
    }

    var _this$getPluginState = this.getPluginState(),
        assemblies = _this$getPluginState.assemblies;

    var assembly = assemblies[file.transloadit.assembly];
    this.client.addFile(assembly, file).catch(function (err) {
      _this6.uppy.log(err);

      _this6.uppy.emit('transloadit:import-error', assembly, file.id, err);
    });
  };

  _proto._findFile = function _findFile(uploadedFile) {
    var files = this.uppy.getFiles();

    for (var i = 0; i < files.length; i++) {
      var file = files[i]; // Completed file upload.

      if (file.uploadURL === uploadedFile.tus_upload_url) {
        return file;
      } // In-progress file upload.


      if (file.tus && file.tus.uploadUrl === uploadedFile.tus_upload_url) {
        return file;
      }

      if (!uploadedFile.is_tus_file) {
        // Fingers-crossed check for non-tus uploads, eg imported from S3.
        if (file.name === uploadedFile.name && file.size === uploadedFile.size) {
          return file;
        }
      }
    }
  };

  _proto._onFileUploadComplete = function _onFileUploadComplete(assemblyId, uploadedFile) {
    var _extends4;

    var state = this.getPluginState();

    var file = this._findFile(uploadedFile);

    if (!file) {
      this.uppy.log('[Transloadit] Couldn’t file the file, it was likely removed in the process');
      return;
    }

    this.setPluginState({
      files: _extends({}, state.files, (_extends4 = {}, _extends4[uploadedFile.id] = {
        assembly: assemblyId,
        id: file.id,
        uploadedFile: uploadedFile
      }, _extends4))
    });
    this.uppy.emit('transloadit:upload', uploadedFile, this.getAssembly(assemblyId));
  }
  /**
   * Callback when a new Assembly result comes in.
   *
   * @param {string} assemblyId
   * @param {string} stepName
   * @param {object} result
   */
  ;

  _proto._onResult = function _onResult(assemblyId, stepName, result) {
    var state = this.getPluginState();
    var file = state.files[result.original_id]; // The `file` may not exist if an import robot was used instead of a file upload.

    result.localId = file ? file.id : null;
    var entry = {
      result: result,
      stepName: stepName,
      id: result.id,
      assembly: assemblyId
    };
    this.setPluginState({
      results: [].concat(state.results, [entry])
    });
    this.uppy.emit('transloadit:result', stepName, result, this.getAssembly(assemblyId));
  }
  /**
   * When an Assembly has finished processing, get the final state
   * and emit it.
   *
   * @param {object} status
   */
  ;

  _proto._onAssemblyFinished = function _onAssemblyFinished(status) {
    var _this7 = this;

    var url = status.assembly_ssl_url;
    this.client.getAssemblyStatus(url).then(function (finalStatus) {
      var _extends5;

      var assemblyId = finalStatus.assembly_id;

      var state = _this7.getPluginState();

      _this7.setPluginState({
        assemblies: _extends({}, state.assemblies, (_extends5 = {}, _extends5[assemblyId] = finalStatus, _extends5))
      });

      _this7.uppy.emit('transloadit:complete', finalStatus);
    });
  };

  _proto._cancelAssembly = function _cancelAssembly(assembly) {
    var _this8 = this;

    return this.client.cancelAssembly(assembly).then(function () {
      // TODO bubble this through AssemblyWatcher so its event handlers can clean up correctly
      _this8.uppy.emit('transloadit:assembly-cancelled', assembly);
    });
  }
  /**
   * When all files are removed, cancel in-progress Assemblies.
   */
  ;

  _proto._onCancelAll = function _onCancelAll() {
    var _this9 = this;

    var _this$getPluginState2 = this.getPluginState(),
        uploadsAssemblies = _this$getPluginState2.uploadsAssemblies;

    var assemblyIDs = Object.keys(uploadsAssemblies).reduce(function (acc, uploadID) {
      acc.push.apply(acc, uploadsAssemblies[uploadID]);
      return acc;
    }, []);
    var cancelPromises = assemblyIDs.map(function (assemblyID) {
      var assembly = _this9.getAssembly(assemblyID);

      return _this9._cancelAssembly(assembly);
    });
    Promise.all(cancelPromises).catch(function (err) {
      _this9.uppy.log(err);
    });
  }
  /**
   * Custom state serialization for the Golden Retriever plugin.
   * It will pass this back to the `_onRestored` function.
   *
   * @param {Function} setData
   */
  ;

  _proto._getPersistentData = function _getPersistentData(setData) {
    var _setData;

    var state = this.getPluginState();
    var assemblies = state.assemblies;
    var uploadsAssemblies = state.uploadsAssemblies;
    setData((_setData = {}, _setData[this.id] = {
      assemblies: assemblies,
      uploadsAssemblies: uploadsAssemblies
    }, _setData));
  };

  _proto._onRestored = function _onRestored(pluginData) {
    var _this10 = this;

    var savedState = pluginData && pluginData[this.id] ? pluginData[this.id] : {};
    var previousAssemblies = savedState.assemblies || {};
    var uploadsAssemblies = savedState.uploadsAssemblies || {};

    if (Object.keys(uploadsAssemblies).length === 0) {
      // Nothing to restore.
      return;
    } // Convert loaded Assembly statuses to a Transloadit plugin state object.


    var restoreState = function restoreState(assemblies) {
      var files = {};
      var results = [];
      Object.keys(assemblies).forEach(function (id) {
        var status = assemblies[id];
        status.uploads.forEach(function (uploadedFile) {
          var file = _this10._findFile(uploadedFile);

          files[uploadedFile.id] = {
            id: file.id,
            assembly: id,
            uploadedFile: uploadedFile
          };
        });

        var state = _this10.getPluginState();

        Object.keys(status.results).forEach(function (stepName) {
          status.results[stepName].forEach(function (result) {
            var file = state.files[result.original_id];
            result.localId = file ? file.id : null;
            results.push({
              id: result.id,
              result: result,
              stepName: stepName,
              assembly: id
            });
          });
        });
      });

      _this10.setPluginState({
        assemblies: assemblies,
        files: files,
        results: results,
        uploadsAssemblies: uploadsAssemblies
      });
    }; // Set up the Assembly instances and AssemblyWatchers for existing Assemblies.


    var restoreAssemblies = function restoreAssemblies() {
      var _this10$getPluginStat = _this10.getPluginState(),
          assemblies = _this10$getPluginStat.assemblies,
          uploadsAssemblies = _this10$getPluginStat.uploadsAssemblies; // Set up the assembly watchers again for all the ongoing uploads.


      Object.keys(uploadsAssemblies).forEach(function (uploadID) {
        var assemblyIDs = uploadsAssemblies[uploadID];
        var fileIDsInUpload = assemblyIDs.reduce(function (acc, assemblyID) {
          var fileIDsInAssembly = _this10.getAssemblyFiles(assemblyID).map(function (file) {
            return file.id;
          });

          acc.push.apply(acc, fileIDsInAssembly);
          return acc;
        }, []);

        _this10._createAssemblyWatcher(assemblyIDs, fileIDsInUpload, uploadID);
      });
      var allAssemblyIDs = Object.keys(assemblies);
      allAssemblyIDs.forEach(function (id) {
        var assembly = new Assembly(assemblies[id]);

        _this10._connectAssembly(assembly);
      });
    }; // Force-update all Assemblies to check for missed events.


    var updateAssemblies = function updateAssemblies() {
      var _this10$getPluginStat2 = _this10.getPluginState(),
          assemblies = _this10$getPluginStat2.assemblies;

      return Promise.all(Object.keys(assemblies).map(function (id) {
        return _this10.activeAssemblies[id].update();
      }));
    }; // Restore all Assembly state.


    this.restored = Promise.resolve().then(function () {
      restoreState(previousAssemblies);
      restoreAssemblies();
      return updateAssemblies();
    });
    this.restored.then(function () {
      _this10.restored = null;
    });
  };

  _proto._connectAssembly = function _connectAssembly(assembly) {
    var _this11 = this;

    var status = assembly.status;
    var id = status.assembly_id;
    this.activeAssemblies[id] = assembly; // Sync local `assemblies` state

    assembly.on('status', function (newStatus) {
      var _extends6;

      var _this11$getPluginStat = _this11.getPluginState(),
          assemblies = _this11$getPluginStat.assemblies;

      _this11.setPluginState({
        assemblies: _extends({}, assemblies, (_extends6 = {}, _extends6[id] = newStatus, _extends6))
      });
    });
    assembly.on('upload', function (file) {
      _this11._onFileUploadComplete(id, file);
    });
    assembly.on('error', function (error) {
      error.assembly = assembly.status;

      _this11.uppy.emit('transloadit:assembly-error', assembly.status, error);
    });
    assembly.on('executing', function () {
      _this11.uppy.emit('transloadit:assembly-executing', assembly.status);
    });

    if (this.opts.waitForEncoding) {
      assembly.on('result', function (stepName, result) {
        _this11._onResult(id, stepName, result);
      });
    }

    if (this.opts.waitForEncoding) {
      assembly.on('finished', function () {
        _this11._onAssemblyFinished(assembly.status);
      });
    } else if (this.opts.waitForMetadata) {
      assembly.on('metadata', function () {
        _this11._onAssemblyFinished(assembly.status);
      });
    } // No need to connect to the socket if the Assembly has completed by now.


    if (assembly.ok === 'ASSEMBLY_COMPLETE') {
      return assembly;
    } // TODO Do we still need this for anything…?
    // eslint-disable-next-line no-unused-vars


    var connected = new Promise(function (resolve, reject) {
      assembly.once('connect', resolve);
      assembly.once('status', resolve);
      assembly.once('error', reject);
    }).then(function () {
      _this11.uppy.log('[Transloadit] Socket is ready');
    });
    assembly.connect();
    return assembly;
  };

  _proto._prepareUpload = function _prepareUpload(fileIDs, uploadID) {
    var _this12 = this,
        _extends7;

    // Only use files without errors
    fileIDs = fileIDs.filter(function (file) {
      return !file.error;
    });
    fileIDs.forEach(function (fileID) {
      var file = _this12.uppy.getFile(fileID);

      _this12.uppy.emit('preprocess-progress', file, {
        mode: 'indeterminate',
        message: _this12.i18n('creatingAssembly')
      });
    });

    var createAssembly = function createAssembly(_ref) {
      var fileIDs = _ref.fileIDs,
          options = _ref.options;
      var createdAssembly;
      return _this12._createAssembly(fileIDs, uploadID, options).then(function (assembly) {
        createdAssembly = assembly;

        if (_this12.opts.importFromUploadURLs) {
          return _this12._reserveFiles(assembly, fileIDs);
        }
      }).then(function () {
        fileIDs.forEach(function (fileID) {
          var file = _this12.uppy.getFile(fileID);

          _this12.uppy.emit('preprocess-complete', file);
        });
        return createdAssembly;
      }).catch(function (err) {
        fileIDs.forEach(function (fileID) {
          var file = _this12.uppy.getFile(fileID); // Clear preprocessing state when the Assembly could not be created,
          // otherwise the UI gets confused about the lingering progress keys


          _this12.uppy.emit('preprocess-complete', file);

          _this12.uppy.emit('upload-error', file, err);
        });
        throw err;
      });
    };

    var _this$getPluginState3 = this.getPluginState(),
        uploadsAssemblies = _this$getPluginState3.uploadsAssemblies;

    this.setPluginState({
      uploadsAssemblies: _extends({}, uploadsAssemblies, (_extends7 = {}, _extends7[uploadID] = [], _extends7))
    });
    var files = fileIDs.map(function (id) {
      return _this12.uppy.getFile(id);
    });
    var assemblyOptions = new AssemblyOptions(files, this.opts);
    return assemblyOptions.build().then(function (assemblies) {
      return Promise.all(assemblies.map(createAssembly)).then(function (createdAssemblies) {
        var assemblyIDs = createdAssemblies.map(function (assembly) {
          return assembly.status.assembly_id;
        });

        _this12._createAssemblyWatcher(assemblyIDs, fileIDs, uploadID);

        createdAssemblies.map(function (assembly) {
          return _this12._connectAssembly(assembly);
        });
      });
    }, // If something went wrong before any Assemblies could be created,
    // clear all processing state.
    function (err) {
      fileIDs.forEach(function (fileID) {
        var file = _this12.uppy.getFile(fileID);

        _this12.uppy.emit('preprocess-complete', file);

        _this12.uppy.emit('upload-error', file, err);
      });
      throw err;
    });
  };

  _proto._afterUpload = function _afterUpload(fileIDs, uploadID) {
    var _this13 = this;

    var files = fileIDs.map(function (fileID) {
      return _this13.uppy.getFile(fileID);
    }); // Only use files without errors

    fileIDs = files.filter(function (file) {
      return !file.error;
    }).map(function (file) {
      return file.id;
    });
    var state = this.getPluginState(); // If we're still restoring state, wait for that to be done.

    if (this.restored) {
      return this.restored.then(function () {
        return _this13._afterUpload(fileIDs, uploadID);
      });
    }

    var assemblyIDs = state.uploadsAssemblies[uploadID];

    var closeSocketConnections = function closeSocketConnections() {
      assemblyIDs.forEach(function (assemblyID) {
        var assembly = _this13.activeAssemblies[assemblyID];
        assembly.close();
        delete _this13.activeAssemblies[assemblyID];
      });
    }; // If we don't have to wait for encoding metadata or results, we can close
    // the socket immediately and finish the upload.


    if (!this._shouldWaitAfterUpload()) {
      closeSocketConnections();
      var assemblies = assemblyIDs.map(function (id) {
        return _this13.getAssembly(id);
      });
      this.uppy.addResultData(uploadID, {
        transloadit: assemblies
      });
      return Promise.resolve();
    } // If no Assemblies were created for this upload, we also do not have to wait.
    // There's also no sockets or anything to close, so just return immediately.


    if (assemblyIDs.length === 0) {
      this.uppy.addResultData(uploadID, {
        transloadit: []
      });
      return Promise.resolve();
    }

    var incompleteFiles = files.filter(function (file) {
      return !hasProperty(_this13.completedFiles, file.id);
    });
    incompleteFiles.forEach(function (file) {
      _this13.uppy.emit('postprocess-progress', file, {
        mode: 'indeterminate',
        message: _this13.i18n('encoding')
      });
    });
    var watcher = this.assemblyWatchers[uploadID];
    return watcher.promise.then(function () {
      closeSocketConnections();
      var assemblies = assemblyIDs.map(function (id) {
        return _this13.getAssembly(id);
      }); // Remove the Assembly ID list for this upload,
      // it's no longer going to be used anywhere.

      var state = _this13.getPluginState();

      var uploadsAssemblies = _extends({}, state.uploadsAssemblies);

      delete uploadsAssemblies[uploadID];

      _this13.setPluginState({
        uploadsAssemblies: uploadsAssemblies
      });

      _this13.uppy.addResultData(uploadID, {
        transloadit: assemblies
      });
    });
  };

  _proto._onError = function _onError(err, uploadID) {
    var _this14 = this;

    if (err === void 0) {
      err = null;
    }

    var state = this.getPluginState();
    var assemblyIDs = state.uploadsAssemblies[uploadID];
    assemblyIDs.forEach(function (assemblyID) {
      if (_this14.activeAssemblies[assemblyID]) {
        _this14.activeAssemblies[assemblyID].close();
      }
    });
  };

  _proto._onTusError = function _onTusError(err) {
    if (err && /^tus: /.test(err.message)) {
      var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;
      var url = xhr && xhr.responseURL ? xhr.responseURL : null;
      this.client.submitError(err, {
        url: url,
        type: 'TUS_ERROR'
      }).then(function (_) {// if we can't report the error that sucks
      });
    }
  };

  _proto.install = function install() {
    this.uppy.addPreProcessor(this._prepareUpload);
    this.uppy.addPostProcessor(this._afterUpload); // We may need to close socket.io connections on error.

    this.uppy.on('error', this._onError); // Handle cancellation.

    this.uppy.on('cancel-all', this._onCancelAll); // For error reporting.

    this.uppy.on('upload-error', this._onTusError);

    if (this.opts.importFromUploadURLs) {
      // No uploader needed when importing; instead we take the upload URL from an existing uploader.
      this.uppy.on('upload-success', this._onFileUploadURLAvailable);
    } else {
      this.uppy.use(Tus, {
        // Disable tus-js-client fingerprinting, otherwise uploading the same file at different times
        // will upload to an outdated Assembly, and we won't get socket events for it.
        //
        // To resume a Transloadit upload, we need to reconnect to the websocket, and the state that's
        // required to do that is not saved by tus-js-client's fingerprinting. We need the tus URL,
        // the Assembly URL, and the WebSocket URL, at least. We also need to know _all_ the files that
        // were added to the Assembly, so we can properly complete it. All that state is handled by
        // Golden Retriever. So, Golden Retriever is required to do resumability with the Transloadit plugin,
        // and we disable Tus's default resume implementation to prevent bad behaviours.
        storeFingerprintForResuming: false,
        resume: false,
        // Disable Companion's retry optimisation; we need to change the endpoint on retry
        // so it can't just reuse the same tus.Upload instance server-side.
        useFastRemoteRetry: false,
        // Only send Assembly metadata to the tus endpoint.
        metaFields: ['assembly_url', 'filename', 'fieldname'],
        // Pass the limit option to @uppy/tus
        limit: this.opts.limit
      });
    }

    this.uppy.on('restore:get-data', this._getPersistentData);
    this.uppy.on('restored', this._onRestored);
    this.setPluginState({
      // Contains Assembly status objects, indexed by their ID.
      assemblies: {},
      // Contains arrays of Assembly IDs, indexed by the upload ID that they belong to.
      uploadsAssemblies: {},
      // Contains file data from Transloadit, indexed by their Transloadit-assigned ID.
      files: {},
      // Contains result data from Transloadit.
      results: []
    }); // We cannot cancel individual files because Assemblies tend to contain many files.

    var _this$uppy$getState = this.uppy.getState(),
        capabilities = _this$uppy$getState.capabilities;

    this.uppy.setState({
      capabilities: _extends({}, capabilities, {
        individualCancellation: false
      })
    });
  };

  _proto.uninstall = function uninstall() {
    this.uppy.removePreProcessor(this._prepareUpload);
    this.uppy.removePostProcessor(this._afterUpload);
    this.uppy.off('error', this._onError);

    if (this.opts.importFromUploadURLs) {
      this.uppy.off('upload-success', this._onFileUploadURLAvailable);
    }

    var _this$uppy$getState2 = this.uppy.getState(),
        capabilities = _this$uppy$getState2.capabilities;

    this.uppy.setState({
      capabilities: _extends({}, capabilities, {
        individualCancellation: true
      })
    });
  };

  _proto.getAssembly = function getAssembly(id) {
    var _this$getPluginState4 = this.getPluginState(),
        assemblies = _this$getPluginState4.assemblies;

    return assemblies[id];
  };

  _proto.getAssemblyFiles = function getAssemblyFiles(assemblyID) {
    return this.uppy.getFiles().filter(function (file) {
      return file && file.transloadit && file.transloadit.assembly === assemblyID;
    });
  };

  return Transloadit;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);
module.exports.COMPANION = COMPANION;
module.exports.UPPY_SERVER = COMPANION;
module.exports.COMPANION_PATTERN = ALLOWED_COMPANION_PATTERN;

},{"../package.json":184,"./../../core":73,"./../../tus":193,"./../../utils/lib/Translator":202,"./../../utils/lib/hasProperty":224,"./Assembly":185,"./AssemblyOptions":186,"./AssemblyWatcher":187,"./Client":188}],190:[function(require,module,exports){
module.exports = function parseUrl(url) {
  var scheme = /^\w+:\/\//.exec(url);
  var i = 0;

  if (scheme) {
    i = scheme[0].length + 1;
  }

  var slashIndex = url.indexOf('/', i);

  if (slashIndex === -1) {
    return {
      origin: url,
      pathname: '/'
    };
  }

  return {
    origin: url.slice(0, slashIndex),
    pathname: url.slice(slashIndex)
  };
};

},{}],191:[function(require,module,exports){
module.exports={
  "name": "@uppy/tus",
  "description": "Resumable uploads for Uppy using Tus.io",
  "version": "1.9.1",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "upload",
    "resumable",
    "tus"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/utils": "file:../utils",
    "tus-js-client": "^2.1.1"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],192:[function(require,module,exports){
var tus = require('tus-js-client');

function isCordova() {
  return typeof window !== 'undefined' && (typeof window.PhoneGap !== 'undefined' || typeof window.Cordova !== 'undefined' || typeof window.cordova !== 'undefined');
}

function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
} // We override tus fingerprint to uppy’s `file.id`, since the `file.id`
// now also includes `relativePath` for files added from folders.
// This means you can add 2 identical files, if one is in folder a,
// the other in folder b — `a/file.jpg` and `b/file.jpg`, when added
// together with a folder, will be treated as 2 separate files.
//
// For React Native and Cordova, we let tus-js-client’s default
// fingerprint handling take charge.


module.exports = function getFingerprint(uppyFileObj) {
  return function (file, options) {
    if (isCordova() || isReactNative()) {
      return tus.defaultOptions.fingerprint(file, options);
    }

    var uppyFingerprint = ['tus', uppyFileObj.id, options.endpoint].join('-');
    return Promise.resolve(uppyFingerprint);
  };
};

},{"tus-js-client":49}],193:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var tus = require('tus-js-client');

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider,
    RequestClient = _require2.RequestClient,
    Socket = _require2.Socket;

var emitSocketProgress = require('./../../utils/lib/emitSocketProgress');

var getSocketHost = require('./../../utils/lib/getSocketHost');

var settle = require('./../../utils/lib/settle');

var EventTracker = require('./../../utils/lib/EventTracker');

var NetworkError = require('./../../utils/lib/NetworkError');

var isNetworkError = require('./../../utils/lib/isNetworkError');

var RateLimitedQueue = require('./../../utils/lib/RateLimitedQueue');

var hasProperty = require('./../../utils/lib/hasProperty');

var getFingerprint = require('./getFingerprint');
/** @typedef {import('..').TusOptions} TusOptions */

/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */

/** @typedef {import('@uppy/core').Uppy} Uppy */

/** @typedef {import('@uppy/core').UppyFile} UppyFile */

/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */

/**
 * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13
 * excepted we removed 'fingerprint' key to avoid adding more dependencies
 *
 * @type {RawTusOptions}
 */


var tusDefaultOptions = {
  endpoint: '',
  uploadUrl: null,
  metadata: {},
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false
};
/**
 * Tus resumable file uploader
 */

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Tus, _Plugin);

  /**
   * @param {Uppy} uppy
   * @param {TusOptions} opts
   */
  function Tus(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'uploader';
    _this.id = _this.opts.id || 'Tus';
    _this.title = 'Tus'; // set default options

    var defaultOptions = {
      autoRetry: true,
      resume: true,
      useFastRemoteRetry: true,
      limit: 0,
      retryDelays: [0, 1000, 3000, 5000],
      withCredentials: false
    }; // merge default options with the ones set by user

    /** @type {import("..").TusOptions} */

    _this.opts = _extends({}, defaultOptions, opts);
    /**
     * Simultaneous upload limiting is shared across all uploads with this plugin.
     *
     * @type {RateLimitedQueue}
     */

    _this.requests = new RateLimitedQueue(_this.opts.limit);
    _this.uploaders = Object.create(null);
    _this.uploaderEvents = Object.create(null);
    _this.uploaderSockets = Object.create(null);
    _this.handleResetProgress = _this.handleResetProgress.bind(_assertThisInitialized(_this));
    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Tus.prototype;

  _proto.handleResetProgress = function handleResetProgress() {
    var files = _extends({}, this.uppy.getState().files);

    Object.keys(files).forEach(function (fileID) {
      // Only clone the file object if it has a Tus `uploadUrl` attached.
      if (files[fileID].tus && files[fileID].tus.uploadUrl) {
        var tusState = _extends({}, files[fileID].tus);

        delete tusState.uploadUrl;
        files[fileID] = _extends({}, files[fileID], {
          tus: tusState
        });
      }
    });
    this.uppy.setState({
      files: files
    });
  }
  /**
   * Clean up all references for a file's upload: the tus.Upload instance,
   * any events related to the file, and the Companion WebSocket connection.
   *
   * @param {string} fileID
   */
  ;

  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.uploaders[fileID]) {
      var uploader = this.uploaders[fileID];
      uploader.abort();

      if (opts.abort) {
        // to avoid 423 error from tus server, we wait
        // to be sure the previous request has been aborted before terminating the upload
        // @todo remove the timeout when this "wait" is handled in tus-js-client internally
        setTimeout(function () {
          return uploader.abort(true);
        }, 1000);
      }

      this.uploaders[fileID] = null;
    }

    if (this.uploaderEvents[fileID]) {
      this.uploaderEvents[fileID].remove();
      this.uploaderEvents[fileID] = null;
    }

    if (this.uploaderSockets[fileID]) {
      this.uploaderSockets[fileID].close();
      this.uploaderSockets[fileID] = null;
    }
  }
  /**
   * Create a new Tus upload.
   *
   * A lot can happen during an upload, so this is quite hard to follow!
   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.
   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.
   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners
   *   for pausing, cancellation, removal, etc.
   * - While the upload is in progress, it may be paused or cancelled.
   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is
   *   maintained.
   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload--the tus.Upload instance
   *   is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).
   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from
   *   bypassing the limit.
   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done
   *   in the `this.requests` queue.
   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is rejected.
   *
   * When working on this function, keep in mind:
   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned up using this.resetUploaderReferences().
   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using `queuedRequest.abort()`.
   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using `queuedRequest.done()`.
   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable must be updated so the other uses of it are valid.
   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking up a spot in the queue.
   *
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */
  ;

  _proto.upload = function upload(file, current, total) {
    var _this2 = this;

    this.resetUploaderReferences(file.id); // Create a new tus upload

    return new Promise(function (resolve, reject) {
      _this2.uppy.emit('upload-started', file);

      var opts = _extends({}, _this2.opts, file.tus || {});
      /** @type {RawTusOptions} */


      var uploadOptions = _extends({}, tusDefaultOptions, opts);

      delete uploadOptions.resume; // Make `resume: true` work like it did in tus-js-client v1.
      // TODO: Remove in @uppy/tus v2

      if (opts.resume) {
        uploadOptions.storeFingerprintForResuming = true;
      } // We override tus fingerprint to uppy’s `file.id`, since the `file.id`
      // now also includes `relativePath` for files added from folders.
      // This means you can add 2 identical files, if one is in folder a,
      // the other in folder b.


      uploadOptions.fingerprint = getFingerprint(file);

      uploadOptions.onBeforeRequest = function (req) {
        var xhr = req.getUnderlyingObject();
        xhr.withCredentials = !!opts.withCredentials;

        if (typeof opts.onBeforeRequest === 'function') {
          opts.onBeforeRequest(req);
        }
      };

      uploadOptions.onError = function (err) {
        _this2.uppy.log(err);

        var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;

        if (isNetworkError(xhr)) {
          err = new NetworkError(err, xhr);
        }

        _this2.resetUploaderReferences(file.id);

        queuedRequest.done();

        _this2.uppy.emit('upload-error', file, err);

        reject(err);
      };

      uploadOptions.onProgress = function (bytesUploaded, bytesTotal) {
        _this2.onReceiveUploadUrl(file, upload.url);

        _this2.uppy.emit('upload-progress', file, {
          uploader: _this2,
          bytesUploaded: bytesUploaded,
          bytesTotal: bytesTotal
        });
      };

      uploadOptions.onSuccess = function () {
        var uploadResp = {
          uploadURL: upload.url
        };

        _this2.resetUploaderReferences(file.id);

        queuedRequest.done();

        _this2.uppy.emit('upload-success', file, uploadResp);

        if (upload.url) {
          _this2.uppy.log("Download " + upload.file.name + " from " + upload.url);
        }

        resolve(upload);
      };

      var copyProp = function copyProp(obj, srcProp, destProp) {
        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {
          obj[destProp] = obj[srcProp];
        }
      };
      /** @type {Record<string, string>} */


      var meta = {};
      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.
      : Object.keys(file.meta);
      metaFields.forEach(function (item) {
        meta[item] = file.meta[item];
      }); // tusd uses metadata fields 'filetype' and 'filename'

      copyProp(meta, 'type', 'filetype');
      copyProp(meta, 'name', 'filename');
      uploadOptions.metadata = meta;
      var upload = new tus.Upload(file.data, uploadOptions);
      _this2.uploaders[file.id] = upload;
      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy); // Make `resume: true` work like it did in tus-js-client v1.
      // TODO: Remove in @uppy/tus v2.

      if (opts.resume) {
        upload.findPreviousUploads().then(function (previousUploads) {
          var previousUpload = previousUploads[0];

          if (previousUpload) {
            _this2.uppy.log("[Tus] Resuming upload of " + file.id + " started at " + previousUpload.creationTime);

            upload.resumeFromPreviousUpload(previousUpload);
          }
        });
      }

      var queuedRequest = _this2.requests.run(function () {
        if (!file.isPaused) {
          // Ensure this gets scheduled to run _after_ `findPreviousUploads()` returns.
          // TODO: Remove in @uppy/tus v2.
          Promise.resolve().then(function () {
            upload.start();
          });
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return function () {};
      });

      _this2.onFileRemove(file.id, function (targetFileID) {
        queuedRequest.abort();

        _this2.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });

        resolve("upload " + targetFileID + " was removed");
      });

      _this2.onPause(file.id, function (isPaused) {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          upload.abort();
        } else {
          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = _this2.requests.run(function () {
            upload.start();
            return function () {};
          });
        }
      });

      _this2.onPauseAll(file.id, function () {
        queuedRequest.abort();
        upload.abort();
      });

      _this2.onCancelAll(file.id, function () {
        queuedRequest.abort();

        _this2.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });

        resolve("upload " + file.id + " was canceled");
      });

      _this2.onResumeAll(file.id, function () {
        queuedRequest.abort();

        if (file.error) {
          upload.abort();
        }

        queuedRequest = _this2.requests.run(function () {
          upload.start();
          return function () {};
        });
      });
    }).catch(function (err) {
      _this2.uppy.emit('upload-error', file, err);

      throw err;
    });
  }
  /**
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */
  ;

  _proto.uploadRemote = function uploadRemote(file, current, total) {
    var _this3 = this;

    this.resetUploaderReferences(file.id);

    var opts = _extends({}, this.opts);

    if (file.tus) {
      // Install file-specific upload overrides.
      _extends(opts, file.tus);
    }

    this.uppy.emit('upload-started', file);
    this.uppy.log(file.remote.url);

    if (file.serverToken) {
      return this.connectToServerSocket(file);
    }

    return new Promise(function (resolve, reject) {
      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;
      var client = new Client(_this3.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet

      client.post(file.remote.url, _extends({}, file.remote.body, {
        endpoint: opts.endpoint,
        uploadUrl: opts.uploadUrl,
        protocol: 'tus',
        size: file.data.size,
        headers: opts.headers,
        metadata: file.meta
      })).then(function (res) {
        _this3.uppy.setFileState(file.id, {
          serverToken: res.token
        });

        file = _this3.uppy.getFile(file.id);
        return _this3.connectToServerSocket(file);
      }).then(function () {
        resolve();
      }).catch(function (err) {
        _this3.uppy.emit('upload-error', file, err);

        reject(err);
      });
    });
  }
  /**
   * See the comment on the upload() method.
   *
   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().
   *
   * @param {UppyFile} file
   */
  ;

  _proto.connectToServerSocket = function connectToServerSocket(file) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      var token = file.serverToken;
      var host = getSocketHost(file.remote.companionUrl);
      var socket = new Socket({
        target: host + "/api/" + token,
        autoOpen: false
      });
      _this4.uploaderSockets[file.id] = socket;
      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);

      _this4.onFileRemove(file.id, function () {
        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion
        // @todo don't send pause event in the next major release.

        socket.send('pause', {});
        socket.send('cancel', {});

        _this4.resetUploaderReferences(file.id);

        resolve("upload " + file.id + " was removed");
      });

      _this4.onPause(file.id, function (isPaused) {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          socket.send('pause', {});
        } else {
          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = _this4.requests.run(function () {
            socket.send('resume', {});
            return function () {};
          });
        }
      });

      _this4.onPauseAll(file.id, function () {
        queuedRequest.abort();
        socket.send('pause', {});
      });

      _this4.onCancelAll(file.id, function () {
        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion
        // @todo don't send pause event in the next major release.

        socket.send('pause', {});
        socket.send('cancel', {});

        _this4.resetUploaderReferences(file.id);

        resolve("upload " + file.id + " was canceled");
      });

      _this4.onResumeAll(file.id, function () {
        queuedRequest.abort();

        if (file.error) {
          socket.send('pause', {});
        }

        queuedRequest = _this4.requests.run(function () {
          socket.send('resume', {});
          return function () {};
        });
      });

      _this4.onRetry(file.id, function () {
        // Only do the retry if the upload is actually in progress;
        // else we could try to send these messages when the upload is still queued.
        // We may need a better check for this since the socket may also be closed
        // for other reasons, like network failures.
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });

      _this4.onRetryAll(file.id, function () {
        // See the comment in the onRetry() call
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });

      socket.on('progress', function (progressData) {
        return emitSocketProgress(_this4, progressData, file);
      });
      socket.on('error', function (errData) {
        var message = errData.error.message;

        var error = _extends(new Error(message), {
          cause: errData.error
        }); // If the remote retry optimisation should not be used,
        // close the socket—this will tell companion to clear state and delete the file.


        if (!_this4.opts.useFastRemoteRetry) {
          _this4.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.


          _this4.uppy.setFileState(file.id, {
            serverToken: null
          });
        } else {
          socket.close();
        }

        _this4.uppy.emit('upload-error', file, error);

        queuedRequest.done();
        reject(error);
      });
      socket.on('success', function (data) {
        var uploadResp = {
          uploadURL: data.url
        };

        _this4.uppy.emit('upload-success', file, uploadResp);

        _this4.resetUploaderReferences(file.id);

        queuedRequest.done();
        resolve();
      });

      var queuedRequest = _this4.requests.run(function () {
        socket.open();

        if (file.isPaused) {
          socket.send('pause', {});
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return function () {};
      });
    });
  }
  /**
   * Store the uploadUrl on the file options, so that when Golden Retriever
   * restores state, we will continue uploading to the correct URL.
   *
   * @param {UppyFile} file
   * @param {string} uploadURL
   */
  ;

  _proto.onReceiveUploadUrl = function onReceiveUploadUrl(file, uploadURL) {
    var currentFile = this.uppy.getFile(file.id);
    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.

    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {
      this.uppy.log('[Tus] Storing upload url');
      this.uppy.setFileState(currentFile.id, {
        tus: _extends({}, currentFile.tus, {
          uploadUrl: uploadURL
        })
      });
    }
  }
  /**
   * @param {string} fileID
   * @param {function(string): void} cb
   */
  ;

  _proto.onFileRemove = function onFileRemove(fileID, cb) {
    this.uploaderEvents[fileID].on('file-removed', function (file) {
      if (fileID === file.id) cb(file.id);
    });
  }
  /**
   * @param {string} fileID
   * @param {function(boolean): void} cb
   */
  ;

  _proto.onPause = function onPause(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {
      if (fileID === targetFileID) {
        // const isPaused = this.uppy.pauseResume(fileID)
        cb(isPaused);
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onRetry = function onRetry(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onRetryAll = function onRetryAll(fileID, cb) {
    var _this5 = this;

    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {
      if (!_this5.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onPauseAll = function onPauseAll(fileID, cb) {
    var _this6 = this;

    this.uploaderEvents[fileID].on('pause-all', function () {
      if (!_this6.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onCancelAll = function onCancelAll(fileID, cb) {
    var _this7 = this;

    this.uploaderEvents[fileID].on('cancel-all', function () {
      if (!_this7.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onResumeAll = function onResumeAll(fileID, cb) {
    var _this8 = this;

    this.uploaderEvents[fileID].on('resume-all', function () {
      if (!_this8.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {(UppyFile | FailedUppyFile)[]} files
   */
  ;

  _proto.uploadFiles = function uploadFiles(files) {
    var _this9 = this;

    var promises = files.map(function (file, i) {
      var current = i + 1;
      var total = files.length;

      if ('error' in file && file.error) {
        return Promise.reject(new Error(file.error));
      }

      if (file.isRemote) {
        // We emit upload-started here, so that it's also emitted for files
        // that have to wait due to the `limit` option.
        // Don't double-emit upload-started for Golden Retriever-restored files that were already started
        if (!file.progress.uploadStarted || !file.isRestored) {
          _this9.uppy.emit('upload-started', file);
        }

        return _this9.uploadRemote(file, current, total);
      } // Don't double-emit upload-started for Golden Retriever-restored files that were already started


      if (!file.progress.uploadStarted || !file.isRestored) {
        _this9.uppy.emit('upload-started', file);
      }

      return _this9.upload(file, current, total);
    });
    return settle(promises);
  }
  /**
   * @param {string[]} fileIDs
   */
  ;

  _proto.handleUpload = function handleUpload(fileIDs) {
    var _this10 = this;

    if (fileIDs.length === 0) {
      this.uppy.log('[Tus] No files to upload');
      return Promise.resolve();
    }

    if (this.opts.limit === 0) {
      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');
    }

    this.uppy.log('[Tus] Uploading...');
    var filesToUpload = fileIDs.map(function (fileID) {
      return _this10.uppy.getFile(fileID);
    });
    return this.uploadFiles(filesToUpload).then(function () {
      return null;
    });
  };

  _proto.install = function install() {
    this.uppy.setState({
      capabilities: _extends({}, this.uppy.getState().capabilities, {
        resumableUploads: true
      })
    });
    this.uppy.addUploader(this.handleUpload);
    this.uppy.on('reset-progress', this.handleResetProgress);

    if (this.opts.autoRetry) {
      this.uppy.on('back-online', this.uppy.retryAll);
    }
  };

  _proto.uninstall = function uninstall() {
    this.uppy.setState({
      capabilities: _extends({}, this.uppy.getState().capabilities, {
        resumableUploads: false
      })
    });
    this.uppy.removeUploader(this.handleUpload);

    if (this.opts.autoRetry) {
      this.uppy.off('back-online', this.uppy.retryAll);
    }
  };

  return Tus;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":191,"./../../companion-client":69,"./../../core":73,"./../../utils/lib/EventTracker":198,"./../../utils/lib/NetworkError":200,"./../../utils/lib/RateLimitedQueue":201,"./../../utils/lib/emitSocketProgress":205,"./../../utils/lib/getSocketHost":220,"./../../utils/lib/hasProperty":224,"./../../utils/lib/isNetworkError":227,"./../../utils/lib/settle":234,"./getFingerprint":192,"tus-js-client":49}],194:[function(require,module,exports){
module.exports={
  "name": "@uppy/url",
  "description": "The Url plugin lets users import files from the Internet. Paste any URL and it’ll be added!",
  "version": "1.5.22",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "url",
    "import from url",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],195:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var UrlUI = /*#__PURE__*/function (_Component) {
  _inheritsLoose(UrlUI, _Component);

  function UrlUI(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.handleKeyPress = _this.handleKeyPress.bind(_assertThisInitialized(_this));
    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = UrlUI.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.input.value = '';
  };

  _proto.handleKeyPress = function handleKeyPress(ev) {
    if (ev.keyCode === 13) {
      this.props.addFile(this.input.value);
    }
  };

  _proto.handleClick = function handleClick() {
    this.props.addFile(this.input.value);
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-Url"
    }, h("input", {
      className: "uppy-u-reset uppy-c-textInput uppy-Url-input",
      type: "text",
      "aria-label": this.props.i18n('enterUrlToImport'),
      placeholder: this.props.i18n('enterUrlToImport'),
      onKeyUp: this.handleKeyPress,
      ref: function ref(input) {
        _this2.input = input;
      },
      "data-uppy-super-focusable": true
    }), h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Url-importButton",
      type: "button",
      onClick: this.handleClick
    }, this.props.i18n('import')));
  };

  return UrlUI;
}(Component);

module.exports = UrlUI;

},{"preact":37}],196:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var _require2 = require('preact'),
    h = _require2.h;

var _require3 = require('./../../companion-client'),
    RequestClient = _require3.RequestClient;

var UrlUI = require('./UrlUI.js');

var forEachDroppedOrPastedUrl = require('./utils/forEachDroppedOrPastedUrl');

function UrlIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("rect", {
    className: "uppy-ProviderIconBg",
    fill: "#FF753E",
    width: "32",
    height: "32",
    rx: "16"
  }), h("path", {
    d: "M22.788 15.389l-2.199 2.19a3.184 3.184 0 0 1-.513.437c-.806.584-1.686.876-2.638.876a4.378 4.378 0 0 1-3.519-1.752c-.22-.292-.146-.802.147-1.021.293-.22.806-.146 1.026.146.953 1.313 2.785 1.532 4.105.583a.571.571 0 0 0 .293-.292l2.199-2.189c1.1-1.167 1.1-2.992-.073-4.086a2.976 2.976 0 0 0-4.105 0l-1.246 1.24a.71.71 0 0 1-1.026 0 .703.703 0 0 1 0-1.022l1.246-1.24a4.305 4.305 0 0 1 6.083 0c1.833 1.605 1.906 4.451.22 6.13zm-7.183 5.035l-1.246 1.24a2.976 2.976 0 0 1-4.105 0c-1.172-1.094-1.172-2.991-.073-4.086l2.2-2.19.292-.291c.66-.438 1.393-.657 2.2-.584.805.146 1.465.51 1.905 1.168.22.292.733.365 1.026.146.293-.22.367-.73.147-1.022-.733-.949-1.76-1.532-2.859-1.678-1.1-.22-2.272.073-3.225.802l-.44.438-2.199 2.19c-1.686 1.75-1.612 4.524.074 6.202.88.803 1.979 1.241 3.078 1.241 1.1 0 2.199-.438 3.079-1.24l1.246-1.241a.703.703 0 0 0 0-1.022c-.294-.292-.807-.365-1.1-.073z",
    fill: "#FFF",
    fillRule: "nonzero"
  })));
}
/**
 * Url
 *
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Url, _Plugin);

  function Url(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Url';
    _this.title = _this.opts.title || 'Link';
    _this.type = 'acquirer';

    _this.icon = function () {
      return h(UrlIcon, null);
    }; // Set default options and locale


    _this.defaultLocale = {
      strings: {
        import: 'Import',
        enterUrlToImport: 'Enter URL to import a file',
        failedToFetch: 'Companion failed to fetch this URL, please make sure it’s correct',
        enterCorrectUrl: 'Incorrect URL: Please make sure you are entering a direct link to a file'
      }
    };
    var defaultOptions = {};
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.hostname = _this.opts.companionUrl;

    if (!_this.hostname) {
      throw new Error('Companion hostname is required, please consult https://uppy.io/docs/companion');
    } // Bind all event handlers for referencability


    _this.getMeta = _this.getMeta.bind(_assertThisInitialized(_this));
    _this.addFile = _this.addFile.bind(_assertThisInitialized(_this));
    _this.handleRootDrop = _this.handleRootDrop.bind(_assertThisInitialized(_this));
    _this.handleRootPaste = _this.handleRootPaste.bind(_assertThisInitialized(_this));
    _this.client = new RequestClient(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionCookiesRule: _this.opts.companionCookiesRule
    });
    return _this;
  }

  var _proto = Url.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.getFileNameFromUrl = function getFileNameFromUrl(url) {
    return url.substring(url.lastIndexOf('/') + 1);
  };

  _proto.checkIfCorrectURL = function checkIfCorrectURL(url) {
    if (!url) return false;
    var protocol = url.match(/^([a-z0-9]+):\/\//)[1];

    if (protocol !== 'http' && protocol !== 'https') {
      return false;
    }

    return true;
  };

  _proto.addProtocolToURL = function addProtocolToURL(url) {
    var protocolRegex = /^[a-z0-9]+:\/\//;
    var defaultProtocol = 'http://';

    if (protocolRegex.test(url)) {
      return url;
    }

    return defaultProtocol + url;
  };

  _proto.getMeta = function getMeta(url) {
    var _this2 = this;

    return this.client.post('url/meta', {
      url: url
    }).then(function (res) {
      if (res.error) {
        _this2.uppy.log('[URL] Error:');

        _this2.uppy.log(res.error);

        throw new Error('Failed to fetch the file');
      }

      return res;
    });
  };

  _proto.addFile = function addFile(url) {
    var _this3 = this;

    url = this.addProtocolToURL(url);

    if (!this.checkIfCorrectURL(url)) {
      this.uppy.log("[URL] Incorrect URL entered: " + url);
      this.uppy.info(this.i18n('enterCorrectUrl'), 'error', 4000);
      return;
    }

    return this.getMeta(url).then(function (meta) {
      var tagFile = {
        source: _this3.id,
        name: _this3.getFileNameFromUrl(url),
        type: meta.type,
        data: {
          size: meta.size
        },
        isRemote: true,
        body: {
          url: url
        },
        remote: {
          companionUrl: _this3.opts.companionUrl,
          url: _this3.hostname + "/url/get",
          body: {
            fileId: url,
            url: url
          },
          providerOptions: _this3.client.opts
        }
      };
      return tagFile;
    }).then(function (tagFile) {
      _this3.uppy.log('[Url] Adding remote file');

      try {
        return _this3.uppy.addFile(tagFile);
      } catch (err) {
        if (!err.isRestriction) {
          _this3.uppy.log(err);
        }

        return err;
      }
    }).catch(function (err) {
      _this3.uppy.log(err);

      _this3.uppy.info({
        message: _this3.i18n('failedToFetch'),
        details: err
      }, 'error', 4000);

      return err;
    });
  };

  _proto.handleRootDrop = function handleRootDrop(e) {
    var _this4 = this;

    forEachDroppedOrPastedUrl(e.dataTransfer, 'drop', function (url) {
      _this4.uppy.log("[URL] Adding file from dropped url: " + url);

      _this4.addFile(url);
    });
  };

  _proto.handleRootPaste = function handleRootPaste(e) {
    var _this5 = this;

    forEachDroppedOrPastedUrl(e.clipboardData, 'paste', function (url) {
      _this5.uppy.log("[URL] Adding file from pasted url: " + url);

      _this5.addFile(url);
    });
  };

  _proto.render = function render(state) {
    return h(UrlUI, {
      i18n: this.i18n,
      addFile: this.addFile
    });
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return Url;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":194,"./../../companion-client":69,"./../../core":73,"./../../utils/lib/Translator":202,"./UrlUI.js":195,"./utils/forEachDroppedOrPastedUrl":197,"preact":37}],197:[function(require,module,exports){
var toArray = require('./../../../utils/lib/toArray');
/*
  SITUATION

    1. Cross-browser dataTransfer.items

      paste in chrome [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      paste in safari [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "string", type: "text/plain"}
      3: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}

      paste in chrome [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      paste in safari [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      1: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}

      drop in chrome [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      drop in safari [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "file", type: "image/png"}
      drop in firefox [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/x-moz-url"}
      2: {kind: "string", type: "text/plain"}

    2. We can determine if it's a 'copypaste' or a 'drop', but we can't discern between [Copy Image] and [Copy Image Address].

  CONCLUSION

    1. 'paste' ([Copy Image] or [Copy Image Address], we can't discern between these two)
      Don't do anything if there is 'file' item. .handlePaste in the DashboardPlugin will deal with all 'file' items.
      If there are no 'file' items - handle 'text/plain' items.

    2. 'drop'
      Take 'text/uri-list' items. Safari has an additional item of .kind === 'file', and you may worry about the item being duplicated (first by DashboardPlugin, and then by UrlPlugin, now), but don't. Directory handling code won't pay attention to this particular item of kind 'file'.
*/

/**
 * Finds all links dropped/pasted from one browser window to another.
 *
 * @param {object} dataTransfer - DataTransfer instance, e.g. e.clipboardData, or e.dataTransfer
 * @param {string} isDropOrPaste - either 'drop' or 'paste'
 * @param {Function} callback - (urlString) => {}
 */


module.exports = function forEachDroppedOrPastedUrl(dataTransfer, isDropOrPaste, callback) {
  var items = toArray(dataTransfer.items);
  var urlItems;

  switch (isDropOrPaste) {
    case 'paste':
      {
        var atLeastOneFileIsDragged = items.some(function (item) {
          return item.kind === 'file';
        });

        if (atLeastOneFileIsDragged) {
          return;
        }

        urlItems = items.filter(function (item) {
          return item.kind === 'string' && item.type === 'text/plain';
        });
        break;
      }

    case 'drop':
      {
        urlItems = items.filter(function (item) {
          return item.kind === 'string' && item.type === 'text/uri-list';
        });
        break;
      }

    default:
      {
        throw new Error("isDropOrPaste must be either 'drop' or 'paste', but it's " + isDropOrPaste);
      }
  }

  urlItems.forEach(function (item) {
    item.getAsString(function (urlString) {
      return callback(urlString);
    });
  });
};

},{"./../../../utils/lib/toArray":235}],198:[function(require,module,exports){
/**
 * Create a wrapper around an event emitter with a `remove` method to remove
 * all events that were added using the wrapped emitter.
 */
module.exports = /*#__PURE__*/function () {
  function EventTracker(emitter) {
    this._events = [];
    this._emitter = emitter;
  }

  var _proto = EventTracker.prototype;

  _proto.on = function on(event, fn) {
    this._events.push([event, fn]);

    return this._emitter.on(event, fn);
  };

  _proto.remove = function remove() {
    var _this = this;

    this._events.forEach(function (_ref) {
      var event = _ref[0],
          fn = _ref[1];

      _this._emitter.off(event, fn);
    });
  };

  return EventTracker;
}();

},{}],199:[function(require,module,exports){
module.exports = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'input:not([disabled]):not([inert]):not([aria-hidden])', 'select:not([disabled]):not([inert]):not([aria-hidden])', 'textarea:not([disabled]):not([inert]):not([aria-hidden])', 'button:not([disabled]):not([inert]):not([aria-hidden])', 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'];

},{}],200:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var NetworkError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(NetworkError, _Error);

  function NetworkError(error, xhr) {
    var _this;

    if (xhr === void 0) {
      xhr = null;
    }

    _this = _Error.call(this, "This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.\n\nSource error: [" + error + "]") || this;
    _this.isNetworkError = true;
    _this.request = xhr;
    return _this;
  }

  return NetworkError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

module.exports = NetworkError;

},{}],201:[function(require,module,exports){
var findIndex = require('./findIndex');

function createCancelError() {
  return new Error('Cancelled');
}

module.exports = /*#__PURE__*/function () {
  function RateLimitedQueue(limit) {
    if (typeof limit !== 'number' || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }

    this.activeRequests = 0;
    this.queuedHandlers = [];
  }

  var _proto = RateLimitedQueue.prototype;

  _proto._call = function _call(fn) {
    var _this = this;

    this.activeRequests += 1;
    var _done = false;
    var cancelActive;

    try {
      cancelActive = fn();
    } catch (err) {
      this.activeRequests -= 1;
      throw err;
    }

    return {
      abort: function abort() {
        if (_done) return;
        _done = true;
        _this.activeRequests -= 1;
        cancelActive();

        _this._queueNext();
      },
      done: function done() {
        if (_done) return;
        _done = true;
        _this.activeRequests -= 1;

        _this._queueNext();
      }
    };
  };

  _proto._queueNext = function _queueNext() {
    var _this2 = this;

    // Do it soon but not immediately, this allows clearing out the entire queue synchronously
    // one by one without continuously _advancing_ it (and starting new tasks before immediately
    // aborting them)
    Promise.resolve().then(function () {
      _this2._next();
    });
  };

  _proto._next = function _next() {
    if (this.activeRequests >= this.limit) {
      return;
    }

    if (this.queuedHandlers.length === 0) {
      return;
    } // Dispatch the next request, and update the abort/done handlers
    // so that cancelling it does the Right Thing (and doesn't just try
    // to dequeue an already-running request).


    var next = this.queuedHandlers.shift();

    var handler = this._call(next.fn);

    next.abort = handler.abort;
    next.done = handler.done;
  };

  _proto._queue = function _queue(fn, options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    var handler = {
      fn: fn,
      priority: options.priority || 0,
      abort: function abort() {
        _this3._dequeue(handler);
      },
      done: function done() {
        throw new Error('Cannot mark a queued request as done: this indicates a bug');
      }
    };
    var index = findIndex(this.queuedHandlers, function (other) {
      return handler.priority > other.priority;
    });

    if (index === -1) {
      this.queuedHandlers.push(handler);
    } else {
      this.queuedHandlers.splice(index, 0, handler);
    }

    return handler;
  };

  _proto._dequeue = function _dequeue(handler) {
    var index = this.queuedHandlers.indexOf(handler);

    if (index !== -1) {
      this.queuedHandlers.splice(index, 1);
    }
  };

  _proto.run = function run(fn, queueOptions) {
    if (this.activeRequests < this.limit) {
      return this._call(fn);
    }

    return this._queue(fn, queueOptions);
  };

  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {
    var _this4 = this;

    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var queuedRequest;
      var outerPromise = new Promise(function (resolve, reject) {
        queuedRequest = _this4.run(function () {
          var cancelError;
          var innerPromise;

          try {
            innerPromise = Promise.resolve(fn.apply(void 0, args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }

          innerPromise.then(function (result) {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, function (err) {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return function () {
            cancelError = createCancelError();
          };
        }, queueOptions);
      });

      outerPromise.abort = function () {
        queuedRequest.abort();
      };

      return outerPromise;
    };
  };

  return RateLimitedQueue;
}();

},{"./findIndex":209}],202:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var has = require('./hasProperty');
/**
 * Translates strings with interpolation & pluralization support.
 * Extensible with custom dictionaries and pluralization functions.
 *
 * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,
 * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded
 * and can be easily added among with dictionaries, nested objects are used for pluralization
 * as opposed to `||||` delimeter
 *
 * Usage example: `translator.translate('files_chosen', {smart_count: 3})`
 */


module.exports = /*#__PURE__*/function () {
  /**
   * @param {object|Array<object>} locales - locale or list of locales.
   */
  function Translator(locales) {
    var _this = this;

    this.locale = {
      strings: {},
      pluralize: function pluralize(n) {
        if (n === 1) {
          return 0;
        }

        return 1;
      }
    };

    if (Array.isArray(locales)) {
      locales.forEach(function (locale) {
        return _this._apply(locale);
      });
    } else {
      this._apply(locales);
    }
  }

  var _proto = Translator.prototype;

  _proto._apply = function _apply(locale) {
    if (!locale || !locale.strings) {
      return;
    }

    var prevLocale = this.locale;
    this.locale = _extends({}, prevLocale, {
      strings: _extends({}, prevLocale.strings, locale.strings)
    });
    this.locale.pluralize = locale.pluralize || prevLocale.pluralize;
  }
  /**
   * Takes a string with placeholder variables like `%{smart_count} file selected`
   * and replaces it with values from options `{smart_count: 5}`
   *
   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
   *
   * @param {string} phrase that needs interpolation, with placeholders
   * @param {object} options with values that will be used to replace placeholders
   * @returns {any[]} interpolated
   */
  ;

  _proto.interpolate = function interpolate(phrase, options) {
    var _String$prototype = String.prototype,
        split = _String$prototype.split,
        replace = _String$prototype.replace;
    var dollarRegex = /\$/g;
    var dollarBillsYall = '$$$$';
    var interpolated = [phrase];

    for (var arg in options) {
      if (arg !== '_' && has(options, arg)) {
        // Ensure replacement value is escaped to prevent special $-prefixed
        // regex replace tokens. the "$$$$" is needed because each "$" needs to
        // be escaped with "$" itself, and we need two in the resulting output.
        var replacement = options[arg];

        if (typeof replacement === 'string') {
          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall);
        } // We create a new `RegExp` each time instead of using a more-efficient
        // string replace so that the same argument can be replaced multiple times
        // in the same phrase.


        interpolated = insertReplacement(interpolated, new RegExp("%\\{" + arg + "\\}", 'g'), replacement);
      }
    }

    return interpolated;

    function insertReplacement(source, rx, replacement) {
      var newParts = [];
      source.forEach(function (chunk) {
        // When the source contains multiple placeholders for interpolation,
        // we should ignore chunks that are not strings, because those
        // can be JSX objects and will be otherwise incorrectly turned into strings.
        // Without this condition we’d get this: [object Object] hello [object Object] my <button>
        if (typeof chunk !== 'string') {
          return newParts.push(chunk);
        }

        split.call(chunk, rx).forEach(function (raw, i, list) {
          if (raw !== '') {
            newParts.push(raw);
          } // Interlace with the `replacement` value


          if (i < list.length - 1) {
            newParts.push(replacement);
          }
        });
      });
      return newParts;
    }
  }
  /**
   * Public translate method
   *
   * @param {string} key
   * @param {object} options with values that will be used later to replace placeholders in string
   * @returns {string} translated (and interpolated)
   */
  ;

  _proto.translate = function translate(key, options) {
    return this.translateArray(key, options).join('');
  }
  /**
   * Get a translation and return the translated and interpolated parts as an array.
   *
   * @param {string} key
   * @param {object} options with values that will be used to replace placeholders
   * @returns {Array} The translated and interpolated parts, in order.
   */
  ;

  _proto.translateArray = function translateArray(key, options) {
    if (!has(this.locale.strings, key)) {
      throw new Error("missing string: " + key);
    }

    var string = this.locale.strings[key];
    var hasPluralForms = typeof string === 'object';

    if (hasPluralForms) {
      if (options && typeof options.smart_count !== 'undefined') {
        var plural = this.locale.pluralize(options.smart_count);
        return this.interpolate(string[plural], options);
      }

      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');
    }

    return this.interpolate(string, options);
  };

  return Translator;
}();

},{"./hasProperty":224}],203:[function(require,module,exports){
var dataURItoBlob = require('./dataURItoBlob');
/**
 * Save a <canvas> element's content to a Blob object.
 *
 * @param {HTMLCanvasElement} canvas
 * @returns {Promise}
 */


module.exports = function canvasToBlob(canvas, type, quality) {
  if (canvas.toBlob) {
    return new Promise(function (resolve) {
      canvas.toBlob(resolve, type, quality);
    });
  }

  return Promise.resolve().then(function () {
    return dataURItoBlob(canvas.toDataURL(type, quality), {});
  });
};

},{"./dataURItoBlob":204}],204:[function(require,module,exports){
module.exports = function dataURItoBlob(dataURI, opts, toFile) {
  // get the base64 data
  var data = dataURI.split(',')[1]; // user may provide mime type, if not get it from data URI

  var mimeType = opts.mimeType || dataURI.split(',')[0].split(':')[1].split(';')[0]; // default to plain/text if data URI has no mimeType

  if (mimeType == null) {
    mimeType = 'plain/text';
  }

  var binary = atob(data);
  var array = [];

  for (var i = 0; i < binary.length; i++) {
    array.push(binary.charCodeAt(i));
  }

  var bytes;

  try {
    bytes = new Uint8Array(array); // eslint-disable-line compat/compat
  } catch (err) {
    return null;
  } // Convert to a File?


  if (toFile) {
    return new File([bytes], opts.name || '', {
      type: mimeType
    });
  }

  return new Blob([bytes], {
    type: mimeType
  });
};

},{}],205:[function(require,module,exports){
var throttle = require('lodash.throttle');

function _emitSocketProgress(uploader, progressData, file) {
  var progress = progressData.progress,
      bytesUploaded = progressData.bytesUploaded,
      bytesTotal = progressData.bytesTotal;

  if (progress) {
    uploader.uppy.log("Upload progress: " + progress);
    uploader.uppy.emit('upload-progress', file, {
      uploader: uploader,
      bytesUploaded: bytesUploaded,
      bytesTotal: bytesTotal
    });
  }
}

module.exports = throttle(_emitSocketProgress, 300, {
  leading: true,
  trailing: true
});

},{"lodash.throttle":32}],206:[function(require,module,exports){
var NetworkError = require('./NetworkError');
/**
 * Wrapper around window.fetch that throws a NetworkError when appropriate
 */


module.exports = function fetchWithNetworkError() {
  return fetch.apply(void 0, arguments).catch(function (err) {
    if (err.name === 'AbortError') {
      throw err;
    } else {
      throw new NetworkError(err);
    }
  });
};

},{"./NetworkError":200}],207:[function(require,module,exports){
var isDOMElement = require('./isDOMElement');
/**
 * Find one or more DOM elements.
 *
 * @param {string} element
 * @returns {Array|null}
 */


module.exports = function findAllDOMElements(element) {
  if (typeof element === 'string') {
    var elements = [].slice.call(document.querySelectorAll(element));
    return elements.length > 0 ? elements : null;
  }

  if (typeof element === 'object' && isDOMElement(element)) {
    return [element];
  }
};

},{"./isDOMElement":225}],208:[function(require,module,exports){
var isDOMElement = require('./isDOMElement');
/**
 * Find a DOM element.
 *
 * @param {Node|string} element
 * @returns {Node|null}
 */


module.exports = function findDOMElement(element, context) {
  if (context === void 0) {
    context = document;
  }

  if (typeof element === 'string') {
    return context.querySelector(element);
  }

  if (isDOMElement(element)) {
    return element;
  }
};

},{"./isDOMElement":225}],209:[function(require,module,exports){
/**
 * Array.prototype.findIndex ponyfill for old browsers.
 *
 * @param {Array} array
 * @param {Function} predicate
 * @returns {number}
 */
module.exports = function findIndex(array, predicate) {
  for (var i = 0; i < array.length; i++) {
    if (predicate(array[i])) return i;
  }

  return -1;
};

},{}],210:[function(require,module,exports){
/**
 * Takes a file object and turns it into fileID, by converting file.name to lowercase,
 * removing extra characters and adding type, size and lastModified
 *
 * @param {object} file
 * @returns {string} the fileID
 */
module.exports = function generateFileID(file) {
  // It's tempting to do `[items].filter(Boolean).join('-')` here, but that
  // is slower! simple string concatenation is fast
  var id = 'uppy';

  if (typeof file.name === 'string') {
    id += "-" + encodeFilename(file.name.toLowerCase());
  }

  if (file.type !== undefined) {
    id += "-" + file.type;
  }

  if (file.meta && typeof file.meta.relativePath === 'string') {
    id += "-" + encodeFilename(file.meta.relativePath.toLowerCase());
  }

  if (file.data.size !== undefined) {
    id += "-" + file.data.size;
  }

  if (file.data.lastModified !== undefined) {
    id += "-" + file.data.lastModified;
  }

  return id;
};

function encodeFilename(name) {
  var suffix = '';
  return name.replace(/[^A-Z0-9]/ig, function (character) {
    suffix += "-" + encodeCharacter(character);
    return '/';
  }) + suffix;
}

function encodeCharacter(character) {
  return character.charCodeAt(0).toString(32);
}

},{}],211:[function(require,module,exports){
module.exports = function getBytesRemaining(fileProgress) {
  return fileProgress.bytesTotal - fileProgress.bytesUploaded;
};

},{}],212:[function(require,module,exports){
var webkitGetAsEntryApi = require('./utils/webkitGetAsEntryApi/index');

var fallbackApi = require('./utils/fallbackApi');
/**
 * Returns a promise that resolves to the array of dropped files (if a folder is dropped, and browser supports folder parsing - promise resolves to the flat array of all files in all directories).
 * Each file has .relativePath prop appended to it (e.g. "/docs/Prague/ticket_from_prague_to_ufa.pdf") if browser supports it. Otherwise it's undefined.
 *
 * @param {DataTransfer} dataTransfer
 * @param {Function} logDropError - a function that's called every time some folder or some file error out (e.g. because of the folder name being too long on Windows). Notice that resulting promise will always be resolved anyway.
 *
 * @returns {Promise} - Array<File>
 */


module.exports = function getDroppedFiles(dataTransfer, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$logDropError = _ref.logDropError,
      logDropError = _ref$logDropError === void 0 ? function () {} : _ref$logDropError;

  // Get all files from all subdirs. Works (at least) in Chrome, Mozilla, and Safari
  if (dataTransfer.items && dataTransfer.items[0] && 'webkitGetAsEntry' in dataTransfer.items[0]) {
    return webkitGetAsEntryApi(dataTransfer, logDropError); // Otherwise just return all first-order files
  }

  return fallbackApi(dataTransfer);
};

},{"./utils/fallbackApi":213,"./utils/webkitGetAsEntryApi/index":216}],213:[function(require,module,exports){
var toArray = require('../../toArray'); // .files fallback, should be implemented in any browser


module.exports = function fallbackApi(dataTransfer) {
  var files = toArray(dataTransfer.files);
  return Promise.resolve(files);
};

},{"../../toArray":235}],214:[function(require,module,exports){
/**
 * Recursive function, calls the original callback() when the directory is entirely parsed.
 *
 * @param {FileSystemDirectoryReader} directoryReader
 * @param {Array} oldEntries
 * @param {Function} logDropError
 * @param {Function} callback - called with ([ all files and directories in that directoryReader ])
 */
module.exports = function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, _ref) {
  var onSuccess = _ref.onSuccess;
  directoryReader.readEntries(function (entries) {
    var newEntries = [].concat(oldEntries, entries); // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory() must be called until it calls the onSuccess with an empty array.

    if (entries.length) {
      setTimeout(function () {
        getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {
          onSuccess: onSuccess
        });
      }, 0); // Done iterating this particular directory
    } else {
      onSuccess(newEntries);
    }
  }, // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
  function (error) {
    logDropError(error);
    onSuccess(oldEntries);
  });
};

},{}],215:[function(require,module,exports){
/**
 * Get the relative path from the FileEntry#fullPath, because File#webkitRelativePath is always '', at least onDrop.
 *
 * @param {FileEntry} fileEntry
 *
 * @returns {string|null} - if file is not in a folder - return null (this is to be consistent with .relativePath-s of files selected from My Device). If file is in a folder - return its fullPath, e.g. '/simpsons/hi.jpeg'.
 */
module.exports = function getRelativePath(fileEntry) {
  // fileEntry.fullPath - "/simpsons/hi.jpeg" or undefined (for browsers that don't support it)
  // fileEntry.name - "hi.jpeg"
  if (!fileEntry.fullPath || fileEntry.fullPath === "/" + fileEntry.name) {
    return null;
  }

  return fileEntry.fullPath;
};

},{}],216:[function(require,module,exports){
var toArray = require('../../../toArray');

var getRelativePath = require('./getRelativePath');

var getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');

module.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {
  var files = [];
  var rootPromises = [];
  /**
   * Returns a resolved promise, when :files array is enhanced
   *
   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry
   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file
   */

  var createPromiseToAddFileOrParseDirectory = function createPromiseToAddFileOrParseDirectory(entry) {
    return new Promise(function (resolve) {
      // This is a base call
      if (entry.isFile) {
        // Creates a new File object which can be used to read the file.
        entry.file(function (file) {
          file.relativePath = getRelativePath(entry);
          files.push(file);
          resolve();
        }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!
        function (error) {
          logDropError(error);
          resolve();
        }); // This is a recursive call
      } else if (entry.isDirectory) {
        var directoryReader = entry.createReader();
        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {
          onSuccess: function onSuccess(entries) {
            var promises = entries.map(function (entry) {
              return createPromiseToAddFileOrParseDirectory(entry);
            });
            Promise.all(promises).then(function () {
              return resolve();
            });
          }
        });
      }
    });
  }; // For each dropped item, - make sure it's a file/directory, and start deepening in!


  toArray(dataTransfer.items).forEach(function (item) {
    var entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.

    if (entry) {
      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));
    }
  });
  return Promise.all(rootPromises).then(function () {
    return files;
  });
};

},{"../../../toArray":235,"./getFilesAndDirectoriesFromDirectory":214,"./getRelativePath":215}],217:[function(require,module,exports){
/**
 * Takes a full filename string and returns an object {name, extension}
 *
 * @param {string} fullFileName
 * @returns {object} {name, extension}
 */
module.exports = function getFileNameAndExtension(fullFileName) {
  var lastDot = fullFileName.lastIndexOf('.'); // these count as no extension: "no-dot", "trailing-dot."

  if (lastDot === -1 || lastDot === fullFileName.length - 1) {
    return {
      name: fullFileName,
      extension: undefined
    };
  }

  return {
    name: fullFileName.slice(0, lastDot),
    extension: fullFileName.slice(lastDot + 1)
  };
};

},{}],218:[function(require,module,exports){
var getFileNameAndExtension = require('./getFileNameAndExtension');

var mimeTypes = require('./mimeTypes');

module.exports = function getFileType(file) {
  var fileExtension = file.name ? getFileNameAndExtension(file.name).extension : null;
  fileExtension = fileExtension ? fileExtension.toLowerCase() : null;

  if (file.type) {
    // if mime type is set in the file object already, use that
    return file.type;
  }

  if (fileExtension && mimeTypes[fileExtension]) {
    // else, see if we can map extension to a mime type
    return mimeTypes[fileExtension];
  } // if all fails, fall back to a generic byte stream type


  return 'application/octet-stream';
};

},{"./getFileNameAndExtension":217,"./mimeTypes":230}],219:[function(require,module,exports){
// TODO Check which types are actually supported in browsers. Chrome likes webm
// from my testing, but we may need more.
// We could use a library but they tend to contain dozens of KBs of mappings,
// most of which will go unused, so not sure if that's worth it.
var mimeToExtensions = {
  'audio/mp3': 'mp3',
  'audio/mp4': 'mp4',
  'audio/ogg': 'ogg',
  'audio/webm': 'webm',
  'image/gif': 'gif',
  'image/heic': 'heic',
  'image/heif': 'heif',
  'image/jpeg': 'jpg',
  'image/png': 'png',
  'image/svg+xml': 'svg',
  'video/mp4': 'mp4',
  'video/ogg': 'ogv',
  'video/quicktime': 'mov',
  'video/webm': 'webm',
  'video/x-matroska': 'mkv',
  'video/x-msvideo': 'avi'
};

module.exports = function getFileTypeExtension(mimeType) {
  // Remove the ; bit in 'video/x-matroska;codecs=avc1'
  mimeType = mimeType.replace(/;.*$/, '');
  return mimeToExtensions[mimeType] || null;
};

},{}],220:[function(require,module,exports){
module.exports = function getSocketHost(url) {
  // get the host domain
  var regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
  var host = regex.exec(url)[1];
  var socketProtocol = /^http:\/\//i.test(url) ? 'ws' : 'wss';
  return socketProtocol + "://" + host;
};

},{}],221:[function(require,module,exports){
module.exports = function getSpeed(fileProgress) {
  if (!fileProgress.bytesUploaded) return 0;
  var timeElapsed = new Date() - fileProgress.uploadStarted;
  var uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1000);
  return uploadSpeed;
};

},{}],222:[function(require,module,exports){
/**
 * Get the declared text direction for an element.
 *
 * @param {Node} element
 * @returns {string|undefined}
 */
function getTextDirection(element) {
  // There is another way to determine text direction using getComputedStyle(), as done here:
  // https://github.com/pencil-js/text-direction/blob/2a235ce95089b3185acec3b51313cbba921b3811/text-direction.js
  //
  // We do not use that approach because we are interested specifically in the _declared_ text direction.
  // If no text direction is declared, we have to provide our own explicit text direction so our
  // bidirectional CSS style sheets work.
  while (element && !element.dir) {
    element = element.parentNode;
  }

  return element ? element.dir : undefined;
}

module.exports = getTextDirection;

},{}],223:[function(require,module,exports){
/**
 * Returns a timestamp in the format of `hours:minutes:seconds`
 */
module.exports = function getTimeStamp() {
  var date = new Date();
  var hours = pad(date.getHours().toString());
  var minutes = pad(date.getMinutes().toString());
  var seconds = pad(date.getSeconds().toString());
  return hours + ":" + minutes + ":" + seconds;
};
/**
 * Adds zero to strings shorter than two characters
 */


function pad(str) {
  return str.length !== 2 ? 0 + str : str;
}

},{}],224:[function(require,module,exports){
module.exports = function has(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
};

},{}],225:[function(require,module,exports){
/**
 * Check if an object is a DOM element. Duck-typing based on `nodeType`.
 *
 * @param {*} obj
 */
module.exports = function isDOMElement(obj) {
  return obj && typeof obj === 'object' && obj.nodeType === Node.ELEMENT_NODE;
};

},{}],226:[function(require,module,exports){
/**
 * Checks if the browser supports Drag & Drop (not supported on mobile devices, for example).
 *
 * @returns {boolean}
 */
module.exports = function isDragDropSupported() {
  var div = document.createElement('div');

  if (!('draggable' in div) || !('ondragstart' in div && 'ondrop' in div)) {
    return false;
  }

  if (!('FormData' in window)) {
    return false;
  }

  if (!('FileReader' in window)) {
    return false;
  }

  return true;
};

},{}],227:[function(require,module,exports){
function isNetworkError(xhr) {
  if (!xhr) {
    return false;
  }

  return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
}

module.exports = isNetworkError;

},{}],228:[function(require,module,exports){
/**
 * Check if a URL string is an object URL from `URL.createObjectURL`.
 *
 * @param {string} url
 * @returns {boolean}
 */
module.exports = function isObjectURL(url) {
  return url.indexOf('blob:') === 0;
};

},{}],229:[function(require,module,exports){
module.exports = function isPreviewSupported(fileType) {
  if (!fileType) return false;
  var fileTypeSpecific = fileType.split('/')[1]; // list of images that browsers can preview

  if (/^(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileTypeSpecific)) {
    return true;
  }

  return false;
};

},{}],230:[function(require,module,exports){
// ___Why not add the mime-types package?
//    It's 19.7kB gzipped, and we only need mime types for well-known extensions (for file previews).
// ___Where to take new extensions from?
//    https://github.com/jshttp/mime-db/blob/master/db.json
module.exports = {
  md: 'text/markdown',
  markdown: 'text/markdown',
  mp4: 'video/mp4',
  mp3: 'audio/mp3',
  svg: 'image/svg+xml',
  jpg: 'image/jpeg',
  png: 'image/png',
  gif: 'image/gif',
  heic: 'image/heic',
  heif: 'image/heif',
  yaml: 'text/yaml',
  yml: 'text/yaml',
  csv: 'text/csv',
  tsv: 'text/tab-separated-values',
  tab: 'text/tab-separated-values',
  avi: 'video/x-msvideo',
  mks: 'video/x-matroska',
  mkv: 'video/x-matroska',
  mov: 'video/quicktime',
  doc: 'application/msword',
  docm: 'application/vnd.ms-word.document.macroenabled.12',
  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  dot: 'application/msword',
  dotm: 'application/vnd.ms-word.template.macroenabled.12',
  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
  xla: 'application/vnd.ms-excel',
  xlam: 'application/vnd.ms-excel.addin.macroenabled.12',
  xlc: 'application/vnd.ms-excel',
  xlf: 'application/x-xliff+xml',
  xlm: 'application/vnd.ms-excel',
  xls: 'application/vnd.ms-excel',
  xlsb: 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
  xlsm: 'application/vnd.ms-excel.sheet.macroenabled.12',
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  xlt: 'application/vnd.ms-excel',
  xltm: 'application/vnd.ms-excel.template.macroenabled.12',
  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
  xlw: 'application/vnd.ms-excel',
  txt: 'text/plain',
  text: 'text/plain',
  conf: 'text/plain',
  log: 'text/plain',
  pdf: 'application/pdf',
  zip: 'application/zip',
  '7z': 'application/x-7z-compressed',
  rar: 'application/x-rar-compressed',
  tar: 'application/x-tar',
  gz: 'application/gzip',
  dmg: 'application/x-apple-diskimage'
};

},{}],231:[function(require,module,exports){
var secondsToTime = require('./secondsToTime');

module.exports = function prettyETA(seconds) {
  var time = secondsToTime(seconds); // Only display hours and minutes if they are greater than 0 but always
  // display minutes if hours is being displayed
  // Display a leading zero if the there is a preceding unit: 1m 05s, but 5s

  var hoursStr = time.hours ? time.hours + "h " : '';
  var minutesVal = time.hours ? ("0" + time.minutes).substr(-2) : time.minutes;
  var minutesStr = minutesVal ? minutesVal + "m" : '';
  var secondsVal = minutesVal ? ("0" + time.seconds).substr(-2) : time.seconds;
  var secondsStr = time.hours ? '' : minutesVal ? " " + secondsVal + "s" : secondsVal + "s";
  return "" + hoursStr + minutesStr + secondsStr;
};

},{"./secondsToTime":233}],232:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var getFileNameAndExtension = require('./getFileNameAndExtension');

module.exports = function remoteFileObjToLocal(file) {
  return _extends({}, file, {
    type: file.mimeType,
    extension: file.name ? getFileNameAndExtension(file.name).extension : null
  });
};

},{"./getFileNameAndExtension":217}],233:[function(require,module,exports){
module.exports = function secondsToTime(rawSeconds) {
  var hours = Math.floor(rawSeconds / 3600) % 24;
  var minutes = Math.floor(rawSeconds / 60) % 60;
  var seconds = Math.floor(rawSeconds % 60);
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds
  };
};

},{}],234:[function(require,module,exports){
module.exports = function settle(promises) {
  var resolutions = [];
  var rejections = [];

  function resolved(value) {
    resolutions.push(value);
  }

  function rejected(error) {
    rejections.push(error);
  }

  var wait = Promise.all(promises.map(function (promise) {
    return promise.then(resolved, rejected);
  }));
  return wait.then(function () {
    return {
      successful: resolutions,
      failed: rejections
    };
  });
};

},{}],235:[function(require,module,exports){
/**
 * Converts list into array
 */
module.exports = function toArray(list) {
  return Array.prototype.slice.call(list || [], 0);
};

},{}],236:[function(require,module,exports){
/**
 * Truncates a string to the given number of chars (maxLength) by inserting '...' in the middle of that string.
 * Partially taken from https://stackoverflow.com/a/5723274/3192470.
 *
 * @param {string} string - string to be truncated
 * @param {number} maxLength - maximum size of the resulting string
 * @returns {string}
 */
module.exports = function truncateString(string, maxLength) {
  var separator = '...'; // Return original string if it's already shorter than maxLength

  if (string.length <= maxLength) {
    return string; // Return truncated substring without '...' if string can't be meaningfully truncated
  }

  if (maxLength <= separator.length) {
    return string.substr(0, maxLength); // Return truncated string divided in half by '...'
  }

  var charsToShow = maxLength - separator.length;
  var frontChars = Math.ceil(charsToShow / 2);
  var backChars = Math.floor(charsToShow / 2);
  return string.substr(0, frontChars) + separator + string.substr(string.length - backChars);
};

},{}],237:[function(require,module,exports){
module.exports={
  "name": "@uppy/webcam",
  "description": "Uppy plugin that takes photos or records videos using the device's camera.",
  "version": "1.8.11",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "webcam",
    "picture",
    "photo",
    "video",
    "record",
    "mediarecorder"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],238:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    fill: "#0097DC",
    width: "66",
    height: "55",
    viewBox: "0 0 66 55"
  }, h("path", {
    d: "M57.3 8.433c4.59 0 8.1 3.51 8.1 8.1v29.7c0 4.59-3.51 8.1-8.1 8.1H8.7c-4.59 0-8.1-3.51-8.1-8.1v-29.7c0-4.59 3.51-8.1 8.1-8.1h9.45l4.59-7.02c.54-.54 1.35-1.08 2.16-1.08h16.2c.81 0 1.62.54 2.16 1.08l4.59 7.02h9.45zM33 14.64c-8.62 0-15.393 6.773-15.393 15.393 0 8.62 6.773 15.393 15.393 15.393 8.62 0 15.393-6.773 15.393-15.393 0-8.62-6.773-15.393-15.393-15.393zM33 40c-5.648 0-9.966-4.319-9.966-9.967 0-5.647 4.318-9.966 9.966-9.966s9.966 4.319 9.966 9.966C42.966 35.681 38.648 40 33 40z",
    fillRule: "evenodd"
  }));
};

},{"preact":37}],239:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/* eslint-disable jsx-a11y/media-has-caption */
var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var SnapshotButton = require('./SnapshotButton');

var RecordButton = require('./RecordButton');

var RecordingLength = require('./RecordingLength');

var VideoSourceSelect = require('./VideoSourceSelect');

var SubmitButton = require('./SubmitButton');

var DiscardButton = require('./DiscardButton');

function isModeAvailable(modes, mode) {
  return modes.indexOf(mode) !== -1;
}

var CameraScreen = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CameraScreen, _Component);

  function CameraScreen() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = CameraScreen.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var onFocus = this.props.onFocus;
    onFocus();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var onStop = this.props.onStop;
    onStop();
  };

  _proto.render = function render() {
    var _this = this;

    var _this$props = this.props,
        src = _this$props.src,
        recordedVideo = _this$props.recordedVideo,
        recording = _this$props.recording,
        modes = _this$props.modes,
        supportsRecording = _this$props.supportsRecording,
        videoSources = _this$props.videoSources,
        showVideoSourceDropdown = _this$props.showVideoSourceDropdown,
        showRecordingLength = _this$props.showRecordingLength,
        onSubmit = _this$props.onSubmit,
        i18n = _this$props.i18n,
        mirror = _this$props.mirror,
        onSnapshot = _this$props.onSnapshot,
        onStartRecording = _this$props.onStartRecording,
        onStopRecording = _this$props.onStopRecording,
        onDiscardRecordedVideo = _this$props.onDiscardRecordedVideo,
        recordingLengthSeconds = _this$props.recordingLengthSeconds;
    var hasRecordedVideo = !!recordedVideo;
    var shouldShowRecordButton = !hasRecordedVideo && supportsRecording && (isModeAvailable(modes, 'video-only') || isModeAvailable(modes, 'audio-only') || isModeAvailable(modes, 'video-audio'));
    var shouldShowSnapshotButton = !hasRecordedVideo && isModeAvailable(modes, 'picture');
    var shouldShowRecordingLength = supportsRecording && showRecordingLength;
    var shouldShowVideoSourceDropdown = showVideoSourceDropdown && videoSources && videoSources.length > 1;
    var videoProps = {
      playsinline: true
    };

    if (recordedVideo) {
      videoProps.muted = false;
      videoProps.controls = true;
      videoProps.src = recordedVideo; // reset srcObject in dom. If not resetted, stream sticks in element

      if (this.videoElement) {
        this.videoElement.srcObject = undefined;
      }
    } else {
      videoProps.muted = true;
      videoProps.autoplay = true;
      videoProps.srcObject = src;
    }

    return h("div", {
      className: "uppy uppy-Webcam-container"
    }, h("div", {
      className: "uppy-Webcam-videoContainer"
    }, h("video", _extends({
      /* eslint-disable-next-line no-return-assign */
      ref: function ref(videoElement) {
        return _this.videoElement = videoElement;
      },
      className: "uppy-Webcam-video  " + (mirror ? 'uppy-Webcam-video--mirrored' : '')
      /* eslint-disable-next-line react/jsx-props-no-spreading */

    }, videoProps))), h("div", {
      className: "uppy-Webcam-footer"
    }, h("div", {
      className: "uppy-Webcam-videoSourceContainer"
    }, shouldShowVideoSourceDropdown ? VideoSourceSelect(this.props) : null), h("div", {
      className: "uppy-Webcam-buttonContainer"
    }, shouldShowSnapshotButton && h(SnapshotButton, {
      onSnapshot: onSnapshot,
      i18n: i18n
    }), shouldShowRecordButton && h(RecordButton, {
      recording: recording,
      onStartRecording: onStartRecording,
      onStopRecording: onStopRecording,
      i18n: i18n
    }), hasRecordedVideo && h(SubmitButton, {
      onSubmit: onSubmit,
      i18n: i18n
    }), hasRecordedVideo && h(DiscardButton, {
      onDiscard: onDiscardRecordedVideo,
      i18n: i18n
    })), shouldShowRecordingLength && h("div", {
      className: "uppy-Webcam-recordingLength"
    }, h(RecordingLength, {
      recordingLengthSeconds: recordingLengthSeconds,
      i18n: i18n
    }))));
  };

  return CameraScreen;
}(Component);

module.exports = CameraScreen;

},{"./DiscardButton":240,"./RecordButton":242,"./RecordingLength":243,"./SnapshotButton":244,"./SubmitButton":245,"./VideoSourceSelect":246,"preact":37}],240:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function DiscardButton(_ref) {
  var onDiscard = _ref.onDiscard,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
    type: "button",
    title: i18n('discardRecordedFile'),
    "aria-label": i18n('discardRecordedFile'),
    onClick: onDiscard,
    "data-uppy-super-focusable": true
  }, h("svg", {
    width: "13",
    height: "13",
    viewBox: "0 0 13 13",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon"
  }, h("g", {
    fill: "#FFF",
    fillRule: "evenodd"
  }, h("path", {
    d: "M.496 11.367L11.103.76l1.414 1.414L1.911 12.781z"
  }), h("path", {
    d: "M11.104 12.782L.497 2.175 1.911.76l10.607 10.606z"
  }))));
}

module.exports = DiscardButton;

},{"preact":37}],241:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-Webcam-permissons"
  }, h("div", {
    className: "uppy-Webcam-permissonsIcon"
  }, props.icon()), h("h1", {
    className: "uppy-Webcam-title"
  }, props.hasCamera ? props.i18n('allowAccessTitle') : props.i18n('noCameraTitle')), h("p", null, props.hasCamera ? props.i18n('allowAccessDescription') : props.i18n('noCameraDescription')));
};

},{"preact":37}],242:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function RecordButton(_ref) {
  var recording = _ref.recording,
      onStartRecording = _ref.onStartRecording,
      onStopRecording = _ref.onStopRecording,
      i18n = _ref.i18n;

  if (recording) {
    return h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
      type: "button",
      title: i18n('stopRecording'),
      "aria-label": i18n('stopRecording'),
      onClick: onStopRecording,
      "data-uppy-super-focusable": true
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "100",
      height: "100",
      viewBox: "0 0 100 100"
    }, h("rect", {
      x: "15",
      y: "15",
      width: "70",
      height: "70"
    })));
  }

  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
    type: "button",
    title: i18n('startRecording'),
    "aria-label": i18n('startRecording'),
    onClick: onStartRecording,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "100",
    height: "100",
    viewBox: "0 0 100 100"
  }, h("circle", {
    cx: "50",
    cy: "50",
    r: "40"
  })));
};

},{"preact":37}],243:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var formatSeconds = require('./formatSeconds');

module.exports = function RecordingLength(_ref) {
  var recordingLengthSeconds = _ref.recordingLengthSeconds,
      i18n = _ref.i18n;
  var formattedRecordingLengthSeconds = formatSeconds(recordingLengthSeconds);
  return h("span", {
    "aria-label": i18n('recordingLength', {
      recording_length: formattedRecordingLengthSeconds
    })
  }, formattedRecordingLengthSeconds);
};

},{"./formatSeconds":247,"preact":37}],244:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var CameraIcon = require('./CameraIcon');

module.exports = function (_ref) {
  var onSnapshot = _ref.onSnapshot,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--picture",
    type: "button",
    title: i18n('takePicture'),
    "aria-label": i18n('takePicture'),
    onClick: onSnapshot,
    "data-uppy-super-focusable": true
  }, CameraIcon());
};

},{"./CameraIcon":238,"preact":37}],245:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function SubmitButton(_ref) {
  var onSubmit = _ref.onSubmit,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--submit",
    type: "button",
    title: i18n('submitRecordedFile'),
    "aria-label": i18n('submitRecordedFile'),
    onClick: onSubmit,
    "data-uppy-super-focusable": true
  }, h("svg", {
    width: "12",
    height: "9",
    viewBox: "0 0 12 9",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon"
  }, h("path", {
    fill: "#fff",
    fillRule: "nonzero",
    d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z"
  })));
}

module.exports = SubmitButton;

},{"preact":37}],246:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (_ref) {
  var currentDeviceId = _ref.currentDeviceId,
      videoSources = _ref.videoSources,
      onChangeVideoSource = _ref.onChangeVideoSource;
  return h("div", {
    className: "uppy-Webcam-videoSource"
  }, h("select", {
    className: "uppy-u-reset uppy-Webcam-videoSource-select",
    onChange: function onChange(event) {
      onChangeVideoSource(event.target.value);
    }
  }, videoSources.map(function (videoSource) {
    return h("option", {
      key: videoSource.deviceId,
      value: videoSource.deviceId,
      selected: videoSource.deviceId === currentDeviceId
    }, videoSource.label);
  })));
};

},{"preact":37}],247:[function(require,module,exports){
/**
 * Takes an Integer value of seconds (e.g. 83) and converts it into a human-readable formatted string (e.g. '1:23').
 *
 * @param {Integer} seconds
 * @returns {string} the formatted seconds (e.g. '1:23' for 1 minute and 23 seconds)
 *
 */
module.exports = function formatSeconds(seconds) {
  return Math.floor(seconds / 60) + ":" + String(seconds % 60).padStart(2, 0);
};

},{}],248:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h;

var _require2 = require('./../../core'),
    Plugin = _require2.Plugin;

var Translator = require('./../../utils/lib/Translator');

var getFileTypeExtension = require('./../../utils/lib/getFileTypeExtension');

var mimeTypes = require('./../../utils/lib/mimeTypes');

var canvasToBlob = require('./../../utils/lib/canvasToBlob');

var supportsMediaRecorder = require('./supportsMediaRecorder');

var CameraIcon = require('./CameraIcon');

var CameraScreen = require('./CameraScreen');

var PermissionsScreen = require('./PermissionsScreen');

var packageJsonVersion = require('../package.json').version;
/**
 * Normalize a MIME type or file extension into a MIME type.
 *
 * @param {string} fileType - MIME type or a file extension prefixed with `.`.
 * @returns {string|undefined} The MIME type or `undefined` if the fileType is an extension and is not known.
 */


function toMimeType(fileType) {
  if (fileType[0] === '.') {
    return mimeTypes[fileType.slice(1)];
  }

  return fileType;
}
/**
 * Is this MIME type a video?
 *
 * @param {string} mimeType - MIME type.
 * @returns {boolean}
 */


function isVideoMimeType(mimeType) {
  return /^video\/[^*]+$/.test(mimeType);
}
/**
 * Is this MIME type an image?
 *
 * @param {string} mimeType - MIME type.
 * @returns {boolean}
 */


function isImageMimeType(mimeType) {
  return /^image\/[^*]+$/.test(mimeType);
}
/**
 * Setup getUserMedia, with polyfill for older browsers
 * Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
 */


function getMediaDevices() {
  // eslint-disable-next-line compat/compat
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // eslint-disable-next-line compat/compat
    return navigator.mediaDevices;
  }

  var _getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;

  if (!_getUserMedia) {
    return null;
  }

  return {
    getUserMedia: function getUserMedia(opts) {
      return new Promise(function (resolve, reject) {
        _getUserMedia.call(navigator, opts, resolve, reject);
      });
    }
  };
}
/**
 * Webcam
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Webcam, _Plugin);

  function Webcam(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.mediaDevices = getMediaDevices();
    _this.supportsUserMedia = !!_this.mediaDevices; // eslint-disable-next-line no-restricted-globals

    _this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';
    _this.id = _this.opts.id || 'Webcam';
    _this.title = _this.opts.title || 'Camera';
    _this.type = 'acquirer';
    _this.capturedMediaFile = null;

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#03BFEF",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M22 11c1.133 0 2 .867 2 2v7.333c0 1.134-.867 2-2 2H10c-1.133 0-2-.866-2-2V13c0-1.133.867-2 2-2h2.333l1.134-1.733C13.6 9.133 13.8 9 14 9h4c.2 0 .4.133.533.267L19.667 11H22zm-6 1.533a3.764 3.764 0 0 0-3.8 3.8c0 2.129 1.672 3.801 3.8 3.801s3.8-1.672 3.8-3.8c0-2.13-1.672-3.801-3.8-3.801zm0 6.261c-1.395 0-2.46-1.066-2.46-2.46 0-1.395 1.065-2.461 2.46-2.461s2.46 1.066 2.46 2.46c0 1.395-1.065 2.461-2.46 2.461z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.defaultLocale = {
      strings: {
        smile: 'Smile!',
        takePicture: 'Take a picture',
        startRecording: 'Begin video recording',
        stopRecording: 'Stop video recording',
        allowAccessTitle: 'Please allow access to your camera',
        allowAccessDescription: 'In order to take pictures or record video with your camera, please allow camera access for this site.',
        noCameraTitle: 'Camera Not Available',
        noCameraDescription: 'In order to take pictures or record video, please connect a camera device',
        recordingStoppedMaxSize: 'Recording stopped because the file size is about to exceed the limit',
        recordingLength: 'Recording length %{recording_length}',
        submitRecordedFile: 'Submit recorded file',
        discardRecordedFile: 'Discard recorded file'
      }
    }; // set default options

    var defaultOptions = {
      onBeforeSnapshot: function onBeforeSnapshot() {
        return Promise.resolve();
      },
      countdown: false,
      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],
      mirror: true,
      showVideoSourceDropdown: false,
      facingMode: 'user',
      preferredImageMimeType: null,
      preferredVideoMimeType: null,
      showRecordingLength: false
    };
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.install = _this.install.bind(_assertThisInitialized(_this));
    _this.setPluginState = _this.setPluginState.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this)); // Camera controls

    _this.start = _this.start.bind(_assertThisInitialized(_this));
    _this.stop = _this.stop.bind(_assertThisInitialized(_this));
    _this.takeSnapshot = _this.takeSnapshot.bind(_assertThisInitialized(_this));
    _this.startRecording = _this.startRecording.bind(_assertThisInitialized(_this));
    _this.stopRecording = _this.stopRecording.bind(_assertThisInitialized(_this));
    _this.discardRecordedVideo = _this.discardRecordedVideo.bind(_assertThisInitialized(_this));
    _this.submit = _this.submit.bind(_assertThisInitialized(_this));
    _this.oneTwoThreeSmile = _this.oneTwoThreeSmile.bind(_assertThisInitialized(_this));
    _this.focus = _this.focus.bind(_assertThisInitialized(_this));
    _this.changeVideoSource = _this.changeVideoSource.bind(_assertThisInitialized(_this));
    _this.webcamActive = false;

    if (_this.opts.countdown) {
      _this.opts.onBeforeSnapshot = _this.oneTwoThreeSmile;
    }

    _this.setPluginState({
      hasCamera: false,
      cameraReady: false,
      cameraError: null,
      recordingLengthSeconds: 0,
      videoSources: [],
      currentDeviceId: null
    });

    return _this;
  }

  var _proto = Webcam.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, _extends({}, newOpts, {
      videoConstraints: _extends({}, this.opts.videoConstraints, newOpts == null ? void 0 : newOpts.videoConstraints)
    }));

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.hasCameraCheck = function hasCameraCheck() {
    if (!this.mediaDevices) {
      return Promise.resolve(false);
    }

    return this.mediaDevices.enumerateDevices().then(function (devices) {
      return devices.some(function (device) {
        return device.kind === 'videoinput';
      });
    });
  };

  _proto.isAudioOnly = function isAudioOnly() {
    return this.opts.modes.length === 1 && this.opts.modes[0] === 'audio-only';
  };

  _proto.getConstraints = function getConstraints(deviceId) {
    var _this$opts$videoConst;

    if (deviceId === void 0) {
      deviceId = null;
    }

    var acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;
    var acceptsVideo = !this.isAudioOnly() && (this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1);

    var videoConstraints = _extends({}, (_this$opts$videoConst = this.opts.videoConstraints) != null ? _this$opts$videoConst : {
      facingMode: this.opts.facingMode
    }, deviceId ? {
      deviceId: deviceId,
      facingMode: null
    } : {});

    return {
      audio: acceptsAudio,
      video: acceptsVideo ? videoConstraints : false
    };
  } // eslint-disable-next-line consistent-return
  ;

  _proto.start = function start(options) {
    var _this2 = this;

    if (options === void 0) {
      options = null;
    }

    if (!this.supportsUserMedia) {
      return Promise.reject(new Error('Webcam access not supported'));
    }

    this.webcamActive = true;
    this.opts.mirror = true;
    var constraints = this.getConstraints(options && options.deviceId ? options.deviceId : null);
    this.hasCameraCheck().then(function (hasCamera) {
      _this2.setPluginState({
        hasCamera: hasCamera
      }); // ask user for access to their camera


      return _this2.mediaDevices.getUserMedia(constraints).then(function (stream) {
        _this2.stream = stream;
        var currentDeviceId = null;
        var tracks = _this2.isAudioOnly() ? stream.getAudioTracks() : stream.getVideoTracks();

        if (!options || !options.deviceId) {
          currentDeviceId = tracks[0].getSettings().deviceId;
        } else {
          tracks.forEach(function (track) {
            if (track.getSettings().deviceId === options.deviceId) {
              currentDeviceId = track.getSettings().deviceId;
            }
          });
        } // Update the sources now, so we can access the names.


        _this2.updateVideoSources();

        _this2.setPluginState({
          currentDeviceId: currentDeviceId,
          cameraReady: true
        });
      }).catch(function (err) {
        _this2.setPluginState({
          cameraReady: false,
          cameraError: err
        });

        _this2.uppy.info(err.message, 'error');
      });
    });
  }
  /**
   * @returns {object}
   */
  ;

  _proto.getMediaRecorderOptions = function getMediaRecorderOptions() {
    var options = {}; // Try to use the `opts.preferredVideoMimeType` or one of the `allowedFileTypes` for the recording.
    // If the browser doesn't support it, we'll fall back to the browser default instead.
    // Safari doesn't have the `isTypeSupported` API.

    if (MediaRecorder.isTypeSupported) {
      var restrictions = this.uppy.opts.restrictions;
      var preferredVideoMimeTypes = [];

      if (this.opts.preferredVideoMimeType) {
        preferredVideoMimeTypes = [this.opts.preferredVideoMimeType];
      } else if (restrictions.allowedFileTypes) {
        preferredVideoMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isVideoMimeType);
      }

      var filterSupportedTypes = function filterSupportedTypes(candidateType) {
        return MediaRecorder.isTypeSupported(candidateType) && getFileTypeExtension(candidateType);
      };

      var acceptableMimeTypes = preferredVideoMimeTypes.filter(filterSupportedTypes);

      if (acceptableMimeTypes.length > 0) {
        // eslint-disable-next-line prefer-destructuring
        options.mimeType = acceptableMimeTypes[0];
      }
    }

    return options;
  };

  _proto.startRecording = function startRecording() {
    var _this3 = this;

    // only used if supportsMediaRecorder() returned true
    // eslint-disable-next-line compat/compat
    this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions());
    this.recordingChunks = [];
    var stoppingBecauseOfMaxSize = false;
    this.recorder.addEventListener('dataavailable', function (event) {
      _this3.recordingChunks.push(event.data);

      var restrictions = _this3.uppy.opts.restrictions;

      if (_this3.recordingChunks.length > 1 && restrictions.maxFileSize != null && !stoppingBecauseOfMaxSize) {
        var totalSize = _this3.recordingChunks.reduce(function (acc, chunk) {
          return acc + chunk.size;
        }, 0); // Exclude the initial chunk from the average size calculation because it is likely to be a very small outlier


        var averageChunkSize = (totalSize - _this3.recordingChunks[0].size) / (_this3.recordingChunks.length - 1);
        var expectedEndChunkSize = averageChunkSize * 3;
        var maxSize = Math.max(0, restrictions.maxFileSize - expectedEndChunkSize);

        if (totalSize > maxSize) {
          stoppingBecauseOfMaxSize = true;

          _this3.uppy.info(_this3.i18n('recordingStoppedMaxSize'), 'warning', 4000);

          _this3.stopRecording();
        }
      }
    }); // use a "time slice" of 500ms: ondataavailable will be called each 500ms
    // smaller time slices mean we can more accurately check the max file size restriction

    this.recorder.start(500);

    if (this.opts.showRecordingLength) {
      // Start the recordingLengthTimer if we are showing the recording length.
      this.recordingLengthTimer = setInterval(function () {
        var currentRecordingLength = _this3.getPluginState().recordingLengthSeconds;

        _this3.setPluginState({
          recordingLengthSeconds: currentRecordingLength + 1
        });
      }, 1000);
    }

    this.setPluginState({
      isRecording: true
    });
  };

  _proto.stopRecording = function stopRecording() {
    var _this4 = this;

    var stopped = new Promise(function (resolve) {
      _this4.recorder.addEventListener('stop', function () {
        resolve();
      });

      _this4.recorder.stop();

      if (_this4.opts.showRecordingLength) {
        // Stop the recordingLengthTimer if we are showing the recording length.
        clearInterval(_this4.recordingLengthTimer);

        _this4.setPluginState({
          recordingLengthSeconds: 0
        });
      }
    });
    return stopped.then(function () {
      _this4.setPluginState({
        isRecording: false
      });

      return _this4.getVideo();
    }).then(function (file) {
      try {
        _this4.capturedMediaFile = file; // create object url for capture result preview

        _this4.setPluginState({
          // eslint-disable-next-line compat/compat
          recordedVideo: URL.createObjectURL(file.data)
        });

        _this4.opts.mirror = false;
      } catch (err) {
        // Logging the error, exept restrictions, which is handled in Core
        if (!err.isRestriction) {
          _this4.uppy.log(err);
        }
      }
    }).then(function () {
      _this4.recordingChunks = null;
      _this4.recorder = null;
    }, function (error) {
      _this4.recordingChunks = null;
      _this4.recorder = null;
      throw error;
    });
  };

  _proto.discardRecordedVideo = function discardRecordedVideo() {
    this.setPluginState({
      recordedVideo: null
    });
    this.opts.mirror = true;
    this.capturedMediaFile = null;
  };

  _proto.submit = function submit() {
    try {
      if (this.capturedMediaFile) {
        this.uppy.addFile(this.capturedMediaFile);
      }
    } catch (err) {
      // Logging the error, exept restrictions, which is handled in Core
      if (!err.isRestriction) {
        this.uppy.log(err, 'error');
      }
    }
  };

  _proto.stop = function stop() {
    if (this.stream) {
      this.stream.getAudioTracks().forEach(function (track) {
        track.stop();
      });
      this.stream.getVideoTracks().forEach(function (track) {
        track.stop();
      });
    }

    this.webcamActive = false;
    this.stream = null;
    this.setPluginState({
      recordedVideo: null
    });
  };

  _proto.getVideoElement = function getVideoElement() {
    return this.el.querySelector('.uppy-Webcam-video');
  };

  _proto.oneTwoThreeSmile = function oneTwoThreeSmile() {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
      var count = _this5.opts.countdown; // eslint-disable-next-line consistent-return

      var countDown = setInterval(function () {
        if (!_this5.webcamActive) {
          clearInterval(countDown);
          _this5.captureInProgress = false;
          return reject(new Error('Webcam is not active'));
        }

        if (count > 0) {
          _this5.uppy.info(count + "...", 'warning', 800);

          count--;
        } else {
          clearInterval(countDown);

          _this5.uppy.info(_this5.i18n('smile'), 'success', 1500);

          setTimeout(function () {
            return resolve();
          }, 1500);
        }
      }, 1000);
    });
  };

  _proto.takeSnapshot = function takeSnapshot() {
    var _this6 = this;

    if (this.captureInProgress) return;
    this.captureInProgress = true;
    this.opts.onBeforeSnapshot().catch(function (err) {
      var message = typeof err === 'object' ? err.message : err;

      _this6.uppy.info(message, 'error', 5000);

      return Promise.reject(new Error("onBeforeSnapshot: " + message));
    }).then(function () {
      return _this6.getImage();
    }).then(function (tagFile) {
      _this6.captureInProgress = false;

      try {
        _this6.uppy.addFile(tagFile);
      } catch (err) {
        // Logging the error, except restrictions, which is handled in Core
        if (!err.isRestriction) {
          _this6.uppy.log(err);
        }
      }
    }, function (error) {
      _this6.captureInProgress = false;
      throw error;
    });
  };

  _proto.getImage = function getImage() {
    var _this7 = this;

    var video = this.getVideoElement();

    if (!video) {
      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));
    }

    var width = video.videoWidth;
    var height = video.videoHeight;
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    var restrictions = this.uppy.opts.restrictions;
    var preferredImageMimeTypes = [];

    if (this.opts.preferredImageMimeType) {
      preferredImageMimeTypes = [this.opts.preferredImageMimeType];
    } else if (restrictions.allowedFileTypes) {
      preferredImageMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isImageMimeType);
    }

    var mimeType = preferredImageMimeTypes[0] || 'image/jpeg';
    var ext = getFileTypeExtension(mimeType) || 'jpg';
    var name = "cam-" + Date.now() + "." + ext;
    return canvasToBlob(canvas, mimeType).then(function (blob) {
      return {
        source: _this7.id,
        name: name,
        data: new Blob([blob], {
          type: mimeType
        }),
        type: mimeType
      };
    });
  };

  _proto.getVideo = function getVideo() {
    // Sometimes in iOS Safari, Blobs (especially the first Blob in the recordingChunks Array)
    // have empty 'type' attributes (e.g. '') so we need to find a Blob that has a defined 'type'
    // attribute in order to determine the correct MIME type.
    var mimeType = this.recordingChunks.find(function (blob) {
      var _blob$type;

      return ((_blob$type = blob.type) == null ? void 0 : _blob$type.length) > 0;
    }).type;
    var fileExtension = getFileTypeExtension(mimeType);

    if (!fileExtension) {
      return Promise.reject(new Error("Could not retrieve recording: Unsupported media type \"" + mimeType + "\""));
    }

    var name = "webcam-" + Date.now() + "." + fileExtension;
    var blob = new Blob(this.recordingChunks, {
      type: mimeType
    });
    var file = {
      source: this.id,
      name: name,
      data: new Blob([blob], {
        type: mimeType
      }),
      type: mimeType
    };
    return Promise.resolve(file);
  };

  _proto.focus = function focus() {
    var _this8 = this;

    if (!this.opts.countdown) return;
    setTimeout(function () {
      _this8.uppy.info(_this8.i18n('smile'), 'success', 1500);
    }, 1000);
  };

  _proto.changeVideoSource = function changeVideoSource(deviceId) {
    this.stop();
    this.start({
      deviceId: deviceId
    });
  };

  _proto.updateVideoSources = function updateVideoSources() {
    var _this9 = this;

    this.mediaDevices.enumerateDevices().then(function (devices) {
      _this9.setPluginState({
        videoSources: devices.filter(function (device) {
          return device.kind === 'videoinput';
        })
      });
    });
  };

  _proto.render = function render() {
    if (!this.webcamActive) {
      this.start();
    }

    var webcamState = this.getPluginState();

    if (!webcamState.cameraReady || !webcamState.hasCamera) {
      return h(PermissionsScreen, {
        icon: CameraIcon,
        i18n: this.i18n,
        hasCamera: webcamState.hasCamera
      });
    }

    return h(CameraScreen // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, webcamState, {
      onChangeVideoSource: this.changeVideoSource,
      onSnapshot: this.takeSnapshot,
      onStartRecording: this.startRecording,
      onStopRecording: this.stopRecording,
      onDiscardRecordedVideo: this.discardRecordedVideo,
      onSubmit: this.submit,
      onFocus: this.focus,
      onStop: this.stop,
      i18n: this.i18n,
      modes: this.opts.modes,
      showRecordingLength: this.opts.showRecordingLength,
      showVideoSourceDropdown: this.opts.showVideoSourceDropdown,
      supportsRecording: supportsMediaRecorder(),
      recording: webcamState.isRecording,
      mirror: this.opts.mirror,
      src: this.stream
    }));
  };

  _proto.install = function install() {
    var _this10 = this;

    this.setPluginState({
      cameraReady: false,
      recordingLengthSeconds: 0
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }

    if (this.mediaDevices) {
      this.updateVideoSources();

      this.mediaDevices.ondevicechange = function () {
        _this10.updateVideoSources();

        if (_this10.stream) {
          var restartStream = true;

          var _this10$getPluginStat = _this10.getPluginState(),
              videoSources = _this10$getPluginStat.videoSources,
              currentDeviceId = _this10$getPluginStat.currentDeviceId;

          videoSources.forEach(function (videoSource) {
            if (currentDeviceId === videoSource.deviceId) {
              restartStream = false;
            }
          });

          if (restartStream) {
            _this10.stop();

            _this10.start();
          }
        }
      };
    }
  };

  _proto.uninstall = function uninstall() {
    if (this.stream) {
      this.stop();
    }

    this.unmount();
  };

  return Webcam;
}(Plugin), _class.VERSION = packageJsonVersion, _temp);

},{"../package.json":237,"./../../core":73,"./../../utils/lib/Translator":202,"./../../utils/lib/canvasToBlob":203,"./../../utils/lib/getFileTypeExtension":219,"./../../utils/lib/mimeTypes":230,"./CameraIcon":238,"./CameraScreen":239,"./PermissionsScreen":241,"./supportsMediaRecorder":249,"preact":37}],249:[function(require,module,exports){
module.exports = function supportsMediaRecorder() {
  /* eslint-disable compat/compat */
  return typeof MediaRecorder === 'function' && !!MediaRecorder.prototype && typeof MediaRecorder.prototype.start === 'function';
  /* eslint-enable compat/compat */
};

},{}],250:[function(require,module,exports){
(function (global){(function (){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

;(function(root) {
'use strict';

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
    + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  nptable: noop,
  table: noop,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
  text: /^[^\n]+/
};

block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d{1,9}\.)/;
block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
  + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?-->/;
block.html = edit(block.html, 'i')
  .replace('comment', block._comment)
  .replace('tag', block._tag)
  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
  .getRegex();

block.paragraph = edit(block._paragraph)
  .replace('hr', block.hr)
  .replace('heading', ' {0,3}#{1,6} +')
  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('blockquote', ' {0,3}>')
  .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\n]*\\n')
  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
  table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
});

/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */

block.pedantic = merge({}, block.normal, {
  html: edit(
    '^ *(?:comment *(?:\\n|\\s*$)'
    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
    .replace('comment', block._comment)
    .replace(/tag/g, '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
  fences: noop, // fences not supported
  paragraph: edit(block.normal._paragraph)
    .replace('hr', block.hr)
    .replace('heading', ' *#{1,6} *[^\n]')
    .replace('lheading', block.lheading)
    .replace('blockquote', ' {0,3}>')
    .replace('|fences', '')
    .replace('|list', '')
    .replace('|html', '')
    .getRegex()
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = Object.create(null);
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.pedantic) {
    this.rules = block.pedantic;
  } else if (this.options.gfm) {
    this.rules = block.gfm;
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  src = src.replace(/^ +$/gm, '');
  var next,
      loose,
      cap,
      bull,
      b,
      item,
      listStart,
      listItems,
      t,
      space,
      i,
      tag,
      l,
      isordered,
      istask,
      ischecked;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      var lastToken = this.tokens[this.tokens.length - 1];
      src = src.substring(cap[0].length);
      // An indented code block cannot interrupt a paragraph.
      if (lastToken && lastToken.type === 'paragraph') {
        lastToken.text += '\n' + cap[0].trimRight();
      } else {
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          type: 'code',
          codeBlockStyle: 'indented',
          text: !this.options.pedantic
            ? rtrim(cap, '\n')
            : cap
        });
      }
      continue;
    }

    // fences
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2] ? cap[2].trim() : cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (cap = this.rules.nptable.exec(src)) {
      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        src = src.substring(cap[0].length);

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = splitCells(item.cells[i], item.header.length);
        }

        this.tokens.push(item);

        continue;
      }
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];
      isordered = bull.length > 1;

      listStart = {
        type: 'list_start',
        ordered: isordered,
        start: isordered ? +bull : '',
        loose: false
      };

      this.tokens.push(listStart);

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      listItems = [];
      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) */, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull.length > 1 ? b.length === 1
            : (b.length > 1 || (this.options.smartLists && b !== bull))) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        if (loose) {
          listStart.loose = true;
        }

        // Check for task list items
        istask = /^\[[ xX]\] /.test(item);
        ischecked = undefined;
        if (istask) {
          ischecked = item[1] !== ' ';
          item = item.replace(/^\[[ xX]\] +/, '');
        }

        t = {
          type: 'list_item_start',
          task: istask,
          checked: ischecked,
          loose: loose
        };

        listItems.push(t);
        this.tokens.push(t);

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      if (listStart.loose) {
        l = listItems.length;
        i = 0;
        for (; i < l; i++) {
          listItems[i].loose = true;
        }
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      if (!this.tokens.links[tag]) {
        this.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      continue;
    }

    // table (gfm)
    if (cap = this.rules.table.exec(src)) {
      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        src = src.substring(cap[0].length);

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = splitCells(
            item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
            item.header.length);
        }

        this.tokens.push(item);

        continue;
      }
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  tag: '^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
  nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
  strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
  em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noop,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
};

// list of punctuation marks from common mark spec
// without ` and ] to workaround Rule 17 (inline code blocks/links)
inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();

inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex();

inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

inline.tag = edit(inline.tag)
  .replace('comment', block._comment)
  .replace('attribute', inline._attribute)
  .getRegex();

inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

inline.link = edit(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('label', inline._label)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
  link: edit(/^!?\[(label)\]\((.*?)\)/)
    .replace('label', inline._label)
    .getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace('label', inline._label)
    .getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^~+(?=\S)([\s\S]*?\S)~+/,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
});

inline.gfm.url = edit(inline.gfm.url, 'i')
  .replace('email', inline.gfm._extended_email)
  .getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text)
    .replace('\\b_', '\\b_| {2,}\\n')
    .replace(/\{2,\}/g, '*')
    .getRegex()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer();
  this.renderer.options = this.options;

  if (!this.links) {
    throw new Error('Tokens array requires a `links` property.');
  }

  if (this.options.pedantic) {
    this.rules = inline.pedantic;
  } else if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = '',
      link,
      text,
      href,
      title,
      cap,
      prevCapZero;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(cap[1]);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.inRawBlock = true;
      } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.inRawBlock = false;
      }

      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      var lastParenIndex = findClosingBracket(cap[2], '()');
      if (lastParenIndex > -1) {
        var linkLen = 4 + cap[1].length + lastParenIndex;
        cap[2] = cap[2].substring(0, lastParenIndex);
        cap[0] = cap[0].substring(0, linkLen).trim();
        cap[3] = '';
      }
      src = src.substring(cap[0].length);
      this.inLink = true;
      href = cap[2];
      if (this.options.pedantic) {
        link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

        if (link) {
          href = link[1];
          title = link[3];
        } else {
          title = '';
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }
      href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
      out += this.outputLink(cap, {
        href: InlineLexer.escapes(href),
        title: InlineLexer.escapes(title)
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2].trim(), true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(this.mangle(cap[1]));
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      if (cap[2] === '@') {
        text = escape(cap[0]);
        href = 'mailto:' + text;
      } else {
        // do extended autolink path validation
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      src = src.substring(cap[0].length);
      out += this.renderer.link(href, null, text);
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      if (this.inRawBlock) {
        out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);
      } else {
        out += this.renderer.text(escape(this.smartypants(cap[0])));
      }
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

InlineLexer.escapes = function(text) {
  return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = link.href,
      title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = '',
      l = text.length,
      i = 0,
      ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || marked.defaults;
}

Renderer.prototype.code = function(code, infostring, escaped) {
  var lang = (infostring || '').match(/\S*/)[0];
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw, slugger) {
  if (this.options.headerIds) {
    return '<h'
      + level
      + ' id="'
      + this.options.headerPrefix
      + slugger.slug(raw)
      + '">'
      + text
      + '</h'
      + level
      + '>\n';
  }
  // ignore IDs
  return '<h' + level + '>' + text + '</h' + level + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered, start) {
  var type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.checkbox = function(checked) {
  return '<input '
    + (checked ? 'checked="" ' : '')
    + 'disabled="" type="checkbox"'
    + (this.options.xhtml ? ' /' : '')
    + '> ';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  if (body) body = '<tbody>' + body + '</tbody>';

  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + body
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' align="' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
  if (href === null) {
    return text;
  }
  var out = '<a href="' + escape(href) + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
  if (href === null) {
    return text;
  }

  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */

function TextRenderer() {}

// no need for block level renderers

TextRenderer.prototype.strong =
TextRenderer.prototype.em =
TextRenderer.prototype.codespan =
TextRenderer.prototype.del =
TextRenderer.prototype.text = function(text) {
  return text;
};

TextRenderer.prototype.link =
TextRenderer.prototype.image = function(href, title, text) {
  return '' + text;
};

TextRenderer.prototype.br = function() {
  return '';
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer();
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
  this.slugger = new Slugger();
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  // use an InlineLexer with a TextRenderer to extract pure text
  this.inlineText = new InlineLexer(
    src.links,
    merge({}, this.options, { renderer: new TextRenderer() })
  );
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  this.token = this.tokens.pop();
  return this.token;
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        unescape(this.inlineText.output(this.token.text)),
        this.slugger);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = '',
          body = '',
          i,
          row,
          cell,
          j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      body = '';
      var ordered = this.token.ordered,
          start = this.token.start;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered, start);
    }
    case 'list_item_start': {
      body = '';
      var loose = this.token.loose;
      var checked = this.token.checked;
      var task = this.token.task;

      if (this.token.task) {
        body += this.renderer.checkbox(checked);
      }

      while (this.next().type !== 'list_item_end') {
        body += !loose && this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }
      return this.renderer.listitem(body, task, checked);
    }
    case 'html': {
      // TODO parse inline content if parameter markdown=1
      return this.renderer.html(this.token.text);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
    default: {
      var errMsg = 'Token with "' + this.token.type + '" type was not found.';
      if (this.options.silent) {
        console.log(errMsg);
      } else {
        throw new Error(errMsg);
      }
    }
  }
};

/**
 * Slugger generates header id
 */

function Slugger() {
  this.seen = {};
}

/**
 * Convert string to unique id
 */

Slugger.prototype.slug = function(value) {
  var slug = value
    .toLowerCase()
    .trim()
    .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
    .replace(/\s/g, '-');

  if (this.seen.hasOwnProperty(slug)) {
    var originalSlug = slug;
    do {
      this.seen[originalSlug]++;
      slug = originalSlug + '-' + this.seen[originalSlug];
    } while (this.seen.hasOwnProperty(slug));
  }
  this.seen[slug] = 0;

  return slug;
};

/**
 * Helpers
 */

function escape(html, encode) {
  if (encode) {
    if (escape.escapeTest.test(html)) {
      return html.replace(escape.escapeReplace, function(ch) { return escape.replacements[ch]; });
    }
  } else {
    if (escape.escapeTestNoEncode.test(html)) {
      return html.replace(escape.escapeReplaceNoEncode, function(ch) { return escape.replacements[ch]; });
    }
  }

  return html;
}

escape.escapeTest = /[&<>"']/;
escape.escapeReplace = /[&<>"']/g;
escape.replacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || '';
  return {
    replace: function(name, val) {
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return this;
    },
    getRegex: function() {
      return new RegExp(regex, opt);
    }
  };
}

function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return null;
  }
  return href;
}

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (/^[^:]+:\/*[^/]*$/.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = rtrim(base, '/', true);
    }
  }
  base = baseUrls[' ' + base];

  if (href.slice(0, 2) === '//') {
    return base.replace(/:[\s\S]*/, ':') + href;
  } else if (href.charAt(0) === '/') {
    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
  } else {
    return base + href;
  }
}
var baseUrls = {};
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1,
      target,
      key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

function splitCells(tableRow, count) {
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  var row = tableRow.replace(/\|/g, function(match, offset, str) {
        var escaped = false,
            curr = offset;
        while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
        if (escaped) {
          // odd number of slashes means | is escaped
          // so we leave it alone
          return '|';
        } else {
          // add space before unescaped |
          return ' |';
        }
      }),
      cells = row.split(/ \|/),
      i = 0;

  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) cells.push('');
  }

  for (; i < cells.length; i++) {
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
  }
  return cells;
}

// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
// /c*$/ is vulnerable to REDOS.
// invert: Remove suffix of non-c chars instead. Default falsey.
function rtrim(str, c, invert) {
  if (str.length === 0) {
    return '';
  }

  // Length of suffix matching the invert condition.
  var suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < str.length) {
    var currChar = str.charAt(str.length - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }

  return str.substr(0, str.length - suffLen);
}

function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  var level = 0;
  for (var i = 0; i < str.length; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}

function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
  }
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    var highlight = opt.highlight,
        tokens,
        pending,
        i = 0;

    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    checkSanitizeDeprecation(opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.getDefaults = function() {
  return {
    baseUrl: null,
    breaks: false,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: new Renderer(),
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    xhtml: false
  };
};

marked.defaults = marked.getDefaults();

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.Slugger = Slugger;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  root.marked = marked;
}
})(this || (typeof window !== 'undefined' ? window : global));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],251:[function(require,module,exports){
/* eslint-env browser */
var marked = require('marked');

var dragdrop = require('drag-drop'); // Add Robodog JS. It is advisable to install Robodog from npm/yarn.
// But for experimenting, you can use also Transloadit’s CDN, Edgly:
// <script src="https://releases.transloadit.com/uppy/robodog/v1.10.11/robodog.min.js"></script>


var robodog = require('./../../../../packages/@uppy/robodog');

var TRANSLOADIT_EXAMPLE_KEY = '35c1aed03f5011e982b6afe82599b6a0';
var TRANSLOADIT_EXAMPLE_TEMPLATE = '0b2ee2bc25dc43619700c2ce0a75164a';
/**
 * A textarea for markdown text, with support for file attachments.
 *
 * ## Usage
 *
 * ```js
 * const element = document.querySelector('textarea')
 * const mdtxt = new MarkdownTextarea(element)
 * mdtxt.install()
 * ```
 */

var MarkdownTextarea = /*#__PURE__*/function () {
  function MarkdownTextarea(element) {
    this.element = element;
    this.controls = document.createElement('div');
    this.controls.classList.add('mdtxt-controls');
    this.uploadLine = document.createElement('button');
    this.uploadLine.setAttribute('type', 'button');
    this.uploadLine.classList.add('form-upload');
    this.uploadLine.appendChild(document.createTextNode('Tap here to upload an attachment'));
  }

  var _proto = MarkdownTextarea.prototype;

  _proto.install = function install() {
    var element = this.element;
    var wrapper = document.createElement('div');
    wrapper.classList.add('mdtxt');
    element.parentNode.replaceChild(wrapper, element);
    wrapper.appendChild(this.controls);
    wrapper.appendChild(element);
    wrapper.appendChild(this.uploadLine);
    this.setupUploadLine();
    this.setupTextareaDrop();
  };

  _proto.setupTextareaDrop = function setupTextareaDrop() {
    var _this = this;

    dragdrop(this.element, function (files) {
      _this.uploadFiles(files);
    });
  };

  _proto.setupUploadLine = function setupUploadLine() {
    var _this2 = this;

    this.uploadLine.addEventListener('click', function () {
      _this2.pickFiles();
    });
  };

  _proto.reportUploadError = function reportUploadError(err) {
    this.uploadLine.classList.add('error');
    var message = document.createElement('span');
    message.appendChild(document.createTextNode(err.message));
    this.uploadLine.insertChild(message, this.uploadLine.firstChild);
  };

  _proto.unreportUploadError = function unreportUploadError() {
    this.uploadLine.classList.remove('error');
    var message = this.uploadLine.querySelector('message');

    if (message) {
      this.uploadLine.removeChild(message);
    }
  };

  _proto.insertAttachments = function insertAttachments(attachments) {
    var _this3 = this;

    attachments.forEach(function (attachment) {
      var file = attachment.file,
          thumb = attachment.thumb;
      var link = "\n[LABEL](" + file.ssl_url + ")\n";
      var labelText = "View File " + file.basename;

      if (thumb) {
        _this3.element.value += link.replace('LABEL', "![" + labelText + "](" + thumb.ssl_url + ")");
      } else {
        _this3.element.value += link.replace('LABEL', labelText);
      }
    });
  };

  _proto.matchFilesAndThumbs = function matchFilesAndThumbs(results) {
    var filesById = {};
    var thumbsById = {};
    results.forEach(function (result) {
      if (result.stepName === 'thumbnails') {
        thumbsById[result.original_id] = result;
      } else {
        filesById[result.original_id] = result;
      }
    });
    return Object.keys(filesById).reduce(function (acc, key) {
      var file = filesById[key];
      var thumb = thumbsById[key];
      acc.push({
        file: file,
        thumb: thumb
      });
      return acc;
    }, []);
  };

  _proto.uploadFiles = function uploadFiles(files) {
    var _this4 = this;

    robodog.upload(files, {
      waitForEncoding: true,
      params: {
        auth: {
          key: TRANSLOADIT_EXAMPLE_KEY
        },
        template_id: TRANSLOADIT_EXAMPLE_TEMPLATE
      }
    }).then(function (result) {
      if (result === null) return;

      _this4.insertAttachments(_this4.matchFilesAndThumbs(result.results));
    }).catch(function (err) {
      console.error(err);

      _this4.reportUploadError(err);
    });
  };

  _proto.pickFiles = function pickFiles() {
    var _this5 = this;

    robodog.pick({
      waitForEncoding: true,
      params: {
        auth: {
          key: TRANSLOADIT_EXAMPLE_KEY
        },
        template_id: TRANSLOADIT_EXAMPLE_TEMPLATE
      },
      providers: ['webcam', 'url', 'instagram', 'google-drive', 'dropbox']
    }).then(function (result) {
      if (result === null) return;

      _this5.insertAttachments(_this5.matchFilesAndThumbs(result.results));
    }).catch(function (err) {
      console.error(err);

      _this5.reportUploadError(err);
    });
  };

  return MarkdownTextarea;
}();

var textarea = new MarkdownTextarea(document.querySelector('#new textarea'));
textarea.install();

function renderSnippet(title, text) {
  var template = document.querySelector('#snippet');
  var newSnippet = document.importNode(template.content, true);
  var titleEl = newSnippet.querySelector('.snippet-title');
  var contentEl = newSnippet.querySelector('.snippet-content');
  titleEl.appendChild(document.createTextNode(title));
  contentEl.innerHTML = marked(text);
  var list = document.querySelector('#snippets');
  list.insertBefore(newSnippet, list.firstChild);
}

function saveSnippet(title, text) {
  var id = parseInt(localStorage.numSnippets || 0, 10);
  localStorage["snippet_" + id] = JSON.stringify({
    title: title,
    text: text
  });
  localStorage.numSnippets = id + 1;
}

function loadSnippets() {
  for (var id = 0; localStorage["snippet_" + id] != null; id += 1) {
    var _JSON$parse = JSON.parse(localStorage["snippet_" + id]),
        title = _JSON$parse.title,
        text = _JSON$parse.text;

    renderSnippet(title, text);
  }
}

document.querySelector('#new').addEventListener('submit', function (event) {
  event.preventDefault();
  var title = event.target.querySelector('input[name="title"]').value || 'Unnamed Snippet';
  var text = textarea.element.value;
  saveSnippet(title, text);
  renderSnippet(title, text);
  event.target.querySelector('input').value = '';
  event.target.querySelector('textarea').value = '';
});
window.addEventListener('DOMContentLoaded', function () {
  loadSnippets();
});

},{"./../../../../packages/@uppy/robodog":148,"drag-drop":17,"marked":250}]},{},[251])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzL3ByZXR0aWVyQnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWZ0ZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ibG9iL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jdWlkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2N1aWQvbGliL2ZpbmdlcnByaW50LmJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvY3VpZC9saWIvZ2V0UmFuZG9tVmFsdWUuYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jdWlkL2xpYi9wYWQuanMiLCIuLi9ub2RlX21vZHVsZXMvZHJhZy1kcm9wL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2RyYWctZHJvcC9ub2RlX21vZHVsZXMvZmxhdHRlbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvdXRmOC5qcyIsIi4uL25vZGVfbW9kdWxlcy9leGlmci9kaXN0L21pbmkubGVnYWN5LnVtZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtZm9ybS1kYXRhL2xpYi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvaXMtc2hhbGxvdy1lcXVhbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9qcy1iYXNlNjQvYmFzZTY0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gudGhyb3R0bGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbWF0aC1sb2cyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21lbW9pemUtb25lL2Rpc3QvbWVtb2l6ZS1vbmUuY2pzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21pbWUtbWF0Y2gvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbmFtZXNwYWNlLWVtaXR0ZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9xcy1zdHJpbmdpZnkvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdpZnkvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcXVldWUtbWljcm90YXNrL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcmVzaXplLW9ic2VydmVyLXBvbHlmaWxsL2Rpc3QvUmVzaXplT2JzZXJ2ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcnVuLXBhcmFsbGVsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RvLWFycmF5L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL2ZpbGVSZWFkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvZmluZ2VycHJpbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvaHR0cFN0YWNrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL2lzQ29yZG92YS5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9pc1JlYWN0TmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL3JlYWRBc0J5dGVBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci91cmlUb0Jsb2IuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvdXJsU3RvcmFnZS5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvZXJyb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2xvZ2dlci5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvbm9vcFVybFN0b3JhZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L3VwbG9hZC5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvdXVpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy91cmwtcGFyc2UvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvd2lsZGNhcmQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMveWVhc3QvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL0F1dGhFcnJvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL1Byb3ZpZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvUmVxdWVzdENsaWVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL1NlYXJjaFByb3ZpZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvU29ja2V0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy90b2tlblN0b3JhZ2UuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb3JlL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvc3JjL1BsdWdpbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvbG9nZ2Vycy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvc3JjL3N1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0FkZEZpbGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0FkZEZpbGVzUGFuZWwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRGFzaGJvYXJkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0VkaXRvclBhbmVsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVDYXJkL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVJdGVtL0J1dHRvbnMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vRmlsZUluZm8vaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vRmlsZVByZXZpZXdBbmRMaW5rL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVJdGVtL0ZpbGVQcm9ncmVzcy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlTGlzdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlUHJldmlldy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9QaWNrZXJQYW5lbENvbnRlbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvUGlja2VyUGFuZWxUb3BCYXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvU2xpZGUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvVmlydHVhbExpc3QuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy9jb3B5VG9DbGlwYm9hcmQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL2NyZWF0ZVN1cGVyRm9jdXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL2dldEFjdGl2ZU92ZXJsYXlFbC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvZ2V0RmlsZVR5cGVJY29uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy9pZ25vcmVFdmVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvdHJhcEZvY3VzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZHJvcGJveC9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9kcm9wYm94L3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2ZhY2Vib29rL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2ZhY2Vib29rL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Zvcm0vcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvZm9ybS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9nb29nbGUtZHJpdmUvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvZ29vZ2xlLWRyaXZlL3NyYy9Ecml2ZVByb3ZpZGVyVmlld3MuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9nb29nbGUtZHJpdmUvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5mb3JtZXIvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5mb3JtZXIvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5zdGFncmFtL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2luc3RhZ3JhbS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9vbmVkcml2ZS9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9vbmVkcml2ZS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvQnJlYWRjcnVtYnMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvQnJvd3Nlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9DbG9zZVdyYXBwZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvRmlsdGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0Zvb3RlckFjdGlvbnMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvSXRlbS9jb21wb25lbnRzL0dyaWRMaS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2NvbXBvbmVudHMvSXRlbUljb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvSXRlbS9jb21wb25lbnRzL0xpc3RMaS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0l0ZW1MaXN0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0xvYWRlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9Qcm92aWRlclZpZXcvQXV0aFZpZXcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvUHJvdmlkZXJWaWV3L0hlYWRlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9Qcm92aWRlclZpZXcvUHJvdmlkZXJWaWV3LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1Byb3ZpZGVyVmlldy9Vc2VyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1Byb3ZpZGVyVmlldy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9TZWFyY2hQcm92aWRlclZpZXcvSGVhZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1NlYXJjaFByb3ZpZGVyVmlldy9JbnB1dFZpZXcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvU2VhcmNoUHJvdmlkZXJWaWV3L1NlYXJjaFByb3ZpZGVyVmlldy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9TZWFyY2hQcm92aWRlclZpZXcvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvU2hhcmVkSGFuZGxlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvQXR0YWNoRmlsZUlucHV0cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL1RyYW5zbG9hZGl0Rm9ybVJlc3VsdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL1RyYW5zbG9hZGl0UmVzdWx0c1BsdWdpbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL2FkZERhc2hib2FyZFBsdWdpbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL2FkZFByb3ZpZGVycy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL2FkZFRyYW5zbG9hZGl0UGx1Z2luLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvY3JlYXRlVXBweS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL2Rhc2hib2FyZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL2Zvcm0uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9yb2JvZG9nL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL3BpY2suanMiLCIuLi9wYWNrYWdlcy9AdXBweS9yb2JvZG9nL3NyYy91cGxvYWQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zdGF0dXMtYmFyL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3N0YXR1cy1iYXIvc3JjL1N0YXR1c0Jhci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3N0YXR1cy1iYXIvc3JjL1N0YXR1c0JhclN0YXRlcy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3N0YXR1cy1iYXIvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RvcmUtZGVmYXVsdC9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9zdG9yZS1kZWZhdWx0L3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RodW1ibmFpbC1nZW5lcmF0b3IvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvci9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9wYXJzZXVyaS9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L3NyYy9Bc3NlbWJseS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L3NyYy9Bc3NlbWJseU9wdGlvbnMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9zcmMvQXNzZW1ibHlXYXRjaGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvc3JjL0NsaWVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L3NyYy9wYXJzZVVybC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3R1cy9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS90dXMvc3JjL2dldEZpbmdlcnByaW50LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHVzL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3VybC9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS91cmwvc3JjL1VybFVJLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXJsL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3VybC9zcmMvdXRpbHMvZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9FdmVudFRyYWNrZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvRk9DVVNBQkxFX0VMRU1FTlRTLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL05ldHdvcmtFcnJvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9SYXRlTGltaXRlZFF1ZXVlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL1RyYW5zbGF0b3IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvY2FudmFzVG9CbG9iLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2RhdGFVUkl0b0Jsb2IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZW1pdFNvY2tldFByb2dyZXNzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2ZldGNoV2l0aE5ldHdvcmtFcnJvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9maW5kQWxsRE9NRWxlbWVudHMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZmluZERPTUVsZW1lbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZmluZEluZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dlbmVyYXRlRmlsZUlELmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldEJ5dGVzUmVtYWluaW5nLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldERyb3BwZWRGaWxlcy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvdXRpbHMvZmFsbGJhY2tBcGkuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RHJvcHBlZEZpbGVzL3V0aWxzL3dlYmtpdEdldEFzRW50cnlBcGkvZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RHJvcHBlZEZpbGVzL3V0aWxzL3dlYmtpdEdldEFzRW50cnlBcGkvZ2V0UmVsYXRpdmVQYXRoLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldERyb3BwZWRGaWxlcy91dGlscy93ZWJraXRHZXRBc0VudHJ5QXBpL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldEZpbGVOYW1lQW5kRXh0ZW5zaW9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldEZpbGVUeXBlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldEZpbGVUeXBlRXh0ZW5zaW9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldFNvY2tldEhvc3QuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0U3BlZWQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0VGV4dERpcmVjdGlvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRUaW1lU3RhbXAuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaGFzUHJvcGVydHkuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaXNET01FbGVtZW50LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2lzRHJhZ0Ryb3BTdXBwb3J0ZWQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaXNOZXR3b3JrRXJyb3IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaXNPYmplY3RVUkwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaXNQcmV2aWV3U3VwcG9ydGVkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL21pbWVUeXBlcy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9wcmV0dHlFVEEuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvcmVtb3RlRmlsZU9ialRvTG9jYWwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvc2Vjb25kc1RvVGltZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9zZXR0bGUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvdG9BcnJheS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy90cnVuY2F0ZVN0cmluZy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL0NhbWVyYUljb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL0NhbWVyYVNjcmVlbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvRGlzY2FyZEJ1dHRvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvUGVybWlzc2lvbnNTY3JlZW4uanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL1JlY29yZEJ1dHRvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvUmVjb3JkaW5nTGVuZ3RoLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9TbmFwc2hvdEJ1dHRvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvU3VibWl0QnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9WaWRlb1NvdXJjZVNlbGVjdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvZm9ybWF0U2Vjb25kcy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL3N1cHBvcnRzTWVkaWFSZWNvcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5qcyIsInNyYy9leGFtcGxlcy9tYXJrZG93bi1zbmlwcGV0cy9hcHAuZXM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbE5BO0FBQ0E7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3g2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqb0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzljQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6Q0EsSUFBTSxFQUFFLEdBQUcsZUFBWDs7QUFDQSxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsbUJBQUQsQ0FBdkI7O0FBQ0EsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLDZCQUFELENBQW5COztBQUNBLElBQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxZQUFELENBQXhCOztBQUNBLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyw4QkFBRCxDQUE1Qjs7QUFDQSxJQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyx1Q0FBRCxDQUFyQyxDLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsSUFBSSxRQUFKOztBQUNBLFNBQVMsZUFBVCxHQUE0QjtBQUMxQixNQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2IsSUFBQSxRQUFRLEdBQUcsT0FBTyxDQUFDLGtCQUFELENBQWxCO0FBQ0Q7O0FBQ0QsU0FBTyxRQUFQO0FBQ0Q7O0FBRUQsSUFBTSxrQkFBa0IsR0FBRyxvQkFBM0I7QUFDQSxJQUFNLGtCQUFrQixHQUFHLG9CQUEzQjtBQUNBLElBQU0sa0JBQWtCLEdBQUcsb0JBQTNCO0FBRUEsSUFBTSxXQUFXLEdBQUcsQ0FDbEIsa0JBRGtCLEVBRWxCLGtCQUZrQixFQUdsQixrQkFIa0IsQ0FBcEI7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTLFFBQVQsQ0FBbUIsTUFBbkIsRUFBMkIsSUFBM0IsRUFBaUM7QUFDL0IsU0FBTyxXQUFXLENBQUMsT0FBWixDQUFvQixNQUFwQixLQUErQixXQUFXLENBQUMsT0FBWixDQUFvQixJQUFwQixDQUF0QztBQUNEOztJQUVLLG1COzs7QUFDSiwrQkFBYSxRQUFiLEVBQXVCO0FBQUE7O0FBQ3JCLHdDQURxQixDQUdyQjs7QUFDQSxVQUFLLE1BQUwsR0FBYyxRQUFkLENBSnFCLENBS3JCOztBQUNBLFVBQUssTUFBTCxHQUFjLElBQWQsQ0FOcUIsQ0FPckI7O0FBQ0EsVUFBSyxZQUFMLEdBQW9CLElBQXBCLENBUnFCLENBU3JCOztBQUNBLFVBQUssTUFBTCxHQUFjLEtBQWQ7QUFWcUI7QUFXdEI7Ozs7U0FFRCxPLEdBQUEsbUJBQVc7QUFDVCxTQUFLLGNBQUw7O0FBQ0EsU0FBSyxhQUFMO0FBQ0QsRzs7U0FFRCxXLEdBQUEsdUJBQWU7QUFDYixTQUFLLElBQUwsQ0FBVSxVQUFWO0FBQ0EsU0FBSyxLQUFMO0FBQ0QsRzs7U0FFRCxjLEdBQUEsMEJBQWtCO0FBQUE7O0FBQ2hCLFFBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxLQUFLLE1BQUwsQ0FBWSxhQUFiLENBQXZCO0FBQ0EsUUFBTSxNQUFNLEdBQUcsRUFBRSxHQUFHLE9BQUwsQ0FBYSxNQUFNLENBQUMsTUFBcEIsRUFBNEI7QUFDekMsTUFBQSxVQUFVLEVBQUUsQ0FBQyxXQUFELENBRDZCO0FBRXpDLE1BQUEsSUFBSSxFQUFFLE1BQU0sQ0FBQztBQUY0QixLQUE1QixDQUFmO0FBS0EsSUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLFNBQVYsRUFBcUIsWUFBTTtBQUN6QixNQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksa0JBQVosRUFBZ0M7QUFDOUIsUUFBQSxFQUFFLEVBQUUsTUFBSSxDQUFDLE1BQUwsQ0FBWTtBQURjLE9BQWhDOztBQUlBLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxTQUFWO0FBQ0QsS0FORDtBQVFBLElBQUEsTUFBTSxDQUFDLEVBQVAsQ0FBVSxnQkFBVixFQUE0QixZQUFNO0FBQ2hDLE1BQUEsTUFBSSxDQUFDLFFBQUwsQ0FBYyxJQUFJLFlBQUosQ0FBaUIsd0NBQWpCLENBQWQ7O0FBQ0EsTUFBQSxNQUFJLENBQUMsTUFBTCxHQUFjLElBQWQ7QUFDRCxLQUhEO0FBS0EsSUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLE9BQVYsRUFBbUIsWUFBTTtBQUN2QixNQUFBLE1BQU0sQ0FBQyxVQUFQO0FBQ0EsTUFBQSxNQUFJLENBQUMsTUFBTCxHQUFjLElBQWQ7QUFDRCxLQUhEO0FBS0EsSUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLG1CQUFWLEVBQStCLFlBQU07QUFDbkMsTUFBQSxNQUFJLENBQUMsV0FBTDtBQUNELEtBRkQ7QUFJQSxJQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsMEJBQVYsRUFBc0MsVUFBQyxJQUFELEVBQVU7QUFDOUMsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFFBQVYsRUFBb0IsSUFBcEI7O0FBQ0EsTUFBQSxNQUFJLENBQUMsTUFBTCxDQUFZLE9BQVosQ0FBb0IsSUFBcEIsQ0FBeUIsSUFBekI7QUFDRCxLQUhEO0FBS0EsSUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLDZCQUFWLEVBQXlDLFlBQU07QUFDN0MsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFdBQVY7QUFDRCxLQUZEO0FBSUEsSUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLHFDQUFWLEVBQWlELFlBQU07QUFDckQsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFVBQVY7O0FBQ0EsTUFBQSxNQUFJLENBQUMsWUFBTCxDQUFrQjtBQUFFLFFBQUEsSUFBSSxFQUFFO0FBQVIsT0FBbEI7QUFDRCxLQUhEO0FBS0EsSUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLDBCQUFWLEVBQXNDLFVBQUMsUUFBRCxFQUFXLE1BQVgsRUFBc0I7QUFDMUQsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFFBQVYsRUFBb0IsUUFBcEIsRUFBOEIsTUFBOUI7O0FBQ0EsVUFBSSxDQUFDLE1BQUksQ0FBQyxNQUFMLENBQVksT0FBWixDQUFvQixRQUFwQixDQUFMLEVBQW9DO0FBQ2xDLFFBQUEsTUFBSSxDQUFDLE1BQUwsQ0FBWSxPQUFaLENBQW9CLFFBQXBCLElBQWdDLEVBQWhDO0FBQ0Q7O0FBQ0QsTUFBQSxNQUFJLENBQUMsTUFBTCxDQUFZLE9BQVosQ0FBb0IsUUFBcEIsRUFBOEIsSUFBOUIsQ0FBbUMsTUFBbkM7QUFDRCxLQU5EO0FBUUEsSUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLGdCQUFWLEVBQTRCLFVBQUMsR0FBRCxFQUFTO0FBQ25DLE1BQUEsTUFBSSxDQUFDLFFBQUwsQ0FBYyxHQUFkLEVBRG1DLENBRW5DOzs7QUFDQSxNQUFBLE1BQUksQ0FBQyxZQUFMLENBQWtCO0FBQUUsUUFBQSxJQUFJLEVBQUU7QUFBUixPQUFsQjtBQUNELEtBSkQ7QUFNQSxTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0QsRzs7U0FFRCxRLEdBQUEsa0JBQVUsR0FBVixFQUFlO0FBQ2IsU0FBSyxJQUFMLENBQVUsT0FBVixFQUFtQixTQUFjLElBQUksS0FBSixDQUFVLEdBQUcsQ0FBQyxPQUFkLENBQWQsRUFBc0MsR0FBdEMsQ0FBbkI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1NBQ0UsYSxHQUFBLHlCQUFpQjtBQUFBOztBQUNmLFNBQUssWUFBTCxHQUFvQixXQUFXLENBQUMsWUFBTTtBQUNwQyxVQUFJLENBQUMsTUFBSSxDQUFDLE1BQU4sSUFBZ0IsQ0FBQyxNQUFJLENBQUMsTUFBTCxDQUFZLFNBQWpDLEVBQTRDO0FBQzFDLFFBQUEsTUFBSSxDQUFDLFlBQUw7QUFDRDtBQUNGLEtBSjhCLEVBSTVCLElBSjRCLENBQS9CO0FBS0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztTQUNFLFksR0FBQSw2QkFBb0M7QUFBQTs7QUFBQSxrQ0FBSixFQUFJO0FBQUEseUJBQXBCLElBQW9CO0FBQUEsUUFBcEIsSUFBb0IsMEJBQWIsSUFBYTs7QUFDbEMsV0FBTyxxQkFBcUIsQ0FBQyxLQUFLLE1BQUwsQ0FBWSxnQkFBYixDQUFyQixDQUNKLElBREksQ0FDQyxVQUFDLFFBQUQ7QUFBQSxhQUFjLFFBQVEsQ0FBQyxJQUFULEVBQWQ7QUFBQSxLQURELEVBRUosSUFGSSxDQUVDLFVBQUMsTUFBRCxFQUFZO0FBQ2hCO0FBQ0EsVUFBSSxNQUFJLENBQUMsTUFBVCxFQUFpQjs7QUFDakIsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFFBQVYsRUFBb0IsTUFBcEI7O0FBRUEsVUFBSSxJQUFKLEVBQVU7QUFDUixRQUFBLE1BQUksQ0FBQyxZQUFMLENBQWtCLE1BQWxCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsUUFBQSxNQUFJLENBQUMsTUFBTCxHQUFjLE1BQWQ7QUFDRDtBQUNGLEtBWkksRUFhSixLQWJJLENBYUUsVUFBQyxHQUFEO0FBQUEsYUFBUyxNQUFJLENBQUMsUUFBTCxDQUFjLEdBQWQsQ0FBVDtBQUFBLEtBYkYsQ0FBUDtBQWNELEc7O1NBRUQsTSxHQUFBLGtCQUFVO0FBQ1IsV0FBTyxLQUFLLFlBQUwsQ0FBa0I7QUFBRSxNQUFBLElBQUksRUFBRTtBQUFSLEtBQWxCLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1NBQ0UsWSxHQUFBLHNCQUFjLElBQWQsRUFBb0I7QUFDbEIsU0FBSyxXQUFMLENBQWlCLEtBQUssTUFBdEIsRUFBOEIsSUFBOUI7O0FBQ0EsU0FBSyxNQUFMLEdBQWMsSUFBZDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztTQUNFLFcsR0FBQSxxQkFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCO0FBQUE7O0FBQ3ZCLFFBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxFQUF4QjtBQUNBLFFBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxFQUF4Qjs7QUFFQSxRQUFJLElBQUksQ0FBQyxLQUFMLElBQWMsQ0FBQyxJQUFJLENBQUMsS0FBeEIsRUFBK0I7QUFDN0IsYUFBTyxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQVA7QUFDRCxLQU5zQixDQVF2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQSxRQUFNLFlBQVksR0FDZCxRQUFRLENBQUMsVUFBRCxFQUFhLGtCQUFiLENBQVIsSUFDQyxDQUFDLFFBQVEsQ0FBQyxVQUFELEVBQWEsa0JBQWIsQ0FGZDs7QUFHQSxRQUFJLFlBQUosRUFBa0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFLLElBQUwsQ0FBVSxXQUFWO0FBQ0QsS0ExQnNCLENBNEJ2Qjs7O0FBQ0EsSUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLElBQUksQ0FBQyxPQUFqQixFQUNHLE1BREgsQ0FDVSxVQUFDLE1BQUQ7QUFBQSxhQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFOLEVBQWUsTUFBZixDQUFoQjtBQUFBLEtBRFYsRUFFRyxHQUZILENBRU8sVUFBQyxNQUFEO0FBQUEsYUFBWSxJQUFJLENBQUMsT0FBTCxDQUFhLE1BQWIsQ0FBWjtBQUFBLEtBRlAsRUFHRyxPQUhILENBR1csVUFBQyxNQUFELEVBQVk7QUFDbkIsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFFBQVYsRUFBb0IsTUFBcEI7QUFDRCxLQUxIOztBQU9BLFFBQUksWUFBSixFQUFrQjtBQUNoQixXQUFLLElBQUwsQ0FBVSxVQUFWO0FBQ0QsS0F0Q3NCLENBd0N2Qjs7O0FBQ0EsSUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLElBQUksQ0FBQyxPQUFqQixFQUEwQixPQUExQixDQUFrQyxVQUFDLFFBQUQsRUFBYztBQUM5QyxVQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTCxDQUFhLFFBQWIsQ0FBcEI7QUFDQSxVQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTCxDQUFhLFFBQWIsQ0FBcEI7QUFFQSxNQUFBLFdBQVcsQ0FDUixNQURILENBQ1UsVUFBQyxDQUFEO0FBQUEsZUFBTyxDQUFDLFdBQUQsSUFBZ0IsQ0FBQyxXQUFXLENBQUMsSUFBWixDQUFpQixVQUFDLENBQUQ7QUFBQSxpQkFBTyxDQUFDLENBQUMsRUFBRixLQUFTLENBQUMsQ0FBQyxFQUFsQjtBQUFBLFNBQWpCLENBQXhCO0FBQUEsT0FEVixFQUVHLE9BRkgsQ0FFVyxVQUFDLE1BQUQsRUFBWTtBQUNuQixRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsUUFBVixFQUFvQixRQUFwQixFQUE4QixNQUE5QjtBQUNELE9BSkg7QUFLRCxLQVREOztBQVdBLFFBQUksUUFBUSxDQUFDLFVBQUQsRUFBYSxrQkFBYixDQUFSLElBQ0csQ0FBQyxRQUFRLENBQUMsVUFBRCxFQUFhLGtCQUFiLENBRGhCLEVBQ2tEO0FBQ2hELFdBQUssSUFBTCxDQUFVLFVBQVY7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBOzs7U0FDRSxLLEdBQUEsaUJBQVM7QUFDUCxTQUFLLE1BQUwsR0FBYyxJQUFkOztBQUNBLFFBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2YsV0FBSyxNQUFMLENBQVksVUFBWjtBQUNBLFdBQUssTUFBTCxHQUFjLElBQWQ7QUFDRDs7QUFDRCxJQUFBLGFBQWEsQ0FBQyxLQUFLLFlBQU4sQ0FBYjtBQUNELEc7OztFQXZOK0IsTzs7QUEwTmxDLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLG1CQUFqQjs7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBVCxDQUF5QixNQUF6QixFQUFpQztBQUMvQixNQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1gsVUFBTSxJQUFJLEtBQUosQ0FBVSwrQ0FBVixDQUFOO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUIsUUFBSTtBQUNGLE1BQUEsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsTUFBWCxDQUFUO0FBQ0QsS0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1o7QUFDQSxNQUFBLEdBQUcsQ0FBQyxPQUFKLHFFQUNFLEdBQUcsQ0FBQyxPQUROO0FBRUEsWUFBTSxHQUFOO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLENBQUMsTUFBTSxDQUFDLElBQVIsSUFBZ0IsQ0FBQyxNQUFNLENBQUMsSUFBUCxDQUFZLEdBQWpDLEVBQXNDO0FBQ3BDLFVBQU0sSUFBSSxLQUFKLENBQVUsNERBQ1osd0ZBREUsQ0FBTjtBQUVEO0FBQ0Y7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0lBQ00sZTtBQUNKLDJCQUFhLEtBQWIsRUFBb0IsSUFBcEIsRUFBMEI7QUFDeEIsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLFNBQUssSUFBTCxHQUFZLElBQVo7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBOzs7OztTQUNFLHlCLEdBQUEsbUNBQTJCLElBQTNCLEVBQWlDLGVBQWpDLEVBQWtEO0FBQ2hELFFBQUksS0FBSyxDQUFDLE9BQU4sQ0FBYyxlQUFlLENBQUMsTUFBOUIsQ0FBSixFQUEyQztBQUN6QyxVQUFNLFVBQVUsR0FBRyxlQUFlLENBQUMsTUFBbkM7QUFDQSxNQUFBLGVBQWUsQ0FBQyxNQUFoQixHQUF5QixFQUF6QjtBQUNBLE1BQUEsVUFBVSxDQUFDLE9BQVgsQ0FBbUIsVUFBQyxTQUFELEVBQWU7QUFDaEMsUUFBQSxlQUFlLENBQUMsTUFBaEIsQ0FBdUIsU0FBdkIsSUFBb0MsSUFBSSxDQUFDLElBQUwsQ0FBVSxTQUFWLENBQXBDO0FBQ0QsT0FGRDtBQUdEOztBQUVELFFBQUksQ0FBQyxlQUFlLENBQUMsTUFBckIsRUFBNkI7QUFDM0IsTUFBQSxlQUFlLENBQUMsTUFBaEIsR0FBeUIsRUFBekI7QUFDRDs7QUFFRCxXQUFPLGVBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O1NBQ0UsbUIsR0FBQSw2QkFBcUIsSUFBckIsRUFBMkI7QUFBQTs7QUFDekIsUUFBTSxPQUFPLEdBQUcsS0FBSyxJQUFyQjtBQUVBLFdBQU8sT0FBTyxDQUFDLE9BQVIsR0FDSixJQURJLENBQ0MsWUFBTTtBQUNWLGFBQU8sT0FBTyxDQUFDLGtCQUFSLENBQTJCLElBQTNCLEVBQWlDLE9BQWpDLENBQVA7QUFDRCxLQUhJLEVBSUosSUFKSSxDQUlDLFVBQUMsZUFBRCxFQUFxQjtBQUN6QixhQUFPLEtBQUksQ0FBQyx5QkFBTCxDQUErQixJQUEvQixFQUFxQyxlQUFyQyxDQUFQO0FBQ0QsS0FOSSxFQU9KLElBUEksQ0FPQyxVQUFDLGVBQUQsRUFBcUI7QUFDekIsTUFBQSxjQUFjLENBQUMsZUFBZSxDQUFDLE1BQWpCLENBQWQ7QUFFQSxhQUFPO0FBQ0wsUUFBQSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBTixDQURKO0FBRUwsUUFBQSxPQUFPLEVBQUU7QUFGSixPQUFQO0FBSUQsS0FkSSxDQUFQO0FBZUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7O1NBQ0UsTyxHQUFBLGlCQUFTLElBQVQsRUFBZTtBQUNiLFFBQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxNQUFQLENBQWMsSUFBZCxDQUFsQjtBQUNBLElBQUEsSUFBSSxDQUFDLE9BQUwsQ0FBYSxnQkFBMEI7QUFBQSxVQUF2QixPQUF1QixRQUF2QixPQUF1QjtBQUFBLFVBQWQsT0FBYyxRQUFkLE9BQWM7QUFDckMsVUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQUwsQ0FBZSxPQUFmLENBQVg7O0FBQ0EsVUFBSSxTQUFTLENBQUMsRUFBRCxDQUFiLEVBQW1CO0FBQUE7O0FBQ2pCLGlDQUFBLFNBQVMsQ0FBQyxFQUFELENBQVQsQ0FBYyxPQUFkLEVBQXNCLElBQXRCLDhCQUE4QixPQUE5QjtBQUNELE9BRkQsTUFFTztBQUNMLFFBQUEsU0FBUyxDQUFDLEVBQUQsQ0FBVCxHQUFnQjtBQUNkLFVBQUEsT0FBTyxFQUFQLE9BRGM7QUFFZCxVQUFBLE9BQU8sWUFBTSxPQUFOO0FBRk8sU0FBaEI7QUFJRDtBQUNGLEtBVkQ7QUFZQSxXQUFPLE1BQU0sQ0FBQyxJQUFQLENBQVksU0FBWixFQUF1QixHQUF2QixDQUEyQixVQUFDLEVBQUQ7QUFBQSxhQUFRLFNBQVMsQ0FBQyxFQUFELENBQWpCO0FBQUEsS0FBM0IsQ0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7U0FDRSxLLEdBQUEsaUJBQVM7QUFBQTs7QUFDUCxRQUFNLE9BQU8sR0FBRyxLQUFLLElBQXJCOztBQUVBLFFBQUksS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUF4QixFQUEyQjtBQUN6QixhQUFPLE9BQU8sQ0FBQyxHQUFSLENBQ0wsS0FBSyxLQUFMLENBQVcsR0FBWCxDQUFlLFVBQUMsSUFBRDtBQUFBLGVBQVUsTUFBSSxDQUFDLG1CQUFMLENBQXlCLElBQXpCLENBQVY7QUFBQSxPQUFmLENBREssRUFFTCxJQUZLLENBRUEsVUFBQyxJQUFELEVBQVU7QUFDZixlQUFPLE1BQUksQ0FBQyxPQUFMLENBQWEsSUFBYixDQUFQO0FBQ0QsT0FKTSxDQUFQO0FBS0Q7O0FBRUQsUUFBSSxPQUFPLENBQUMsaUJBQVosRUFBK0I7QUFDN0I7QUFDQSxhQUFPLE9BQU8sQ0FBQyxPQUFSLENBQ0wsT0FBTyxDQUFDLGtCQUFSLENBQTJCLElBQTNCLEVBQWlDLE9BQWpDLENBREssRUFFTCxJQUZLLENBRUEsVUFBQyxlQUFELEVBQXFCO0FBQzFCLFFBQUEsY0FBYyxDQUFDLGVBQWUsQ0FBQyxNQUFqQixDQUFkO0FBQ0EsZUFBTyxDQUFDO0FBQ04sVUFBQSxPQUFPLEVBQUUsTUFBSSxDQUFDLEtBQUwsQ0FBVyxHQUFYLENBQWUsVUFBQyxJQUFEO0FBQUEsbUJBQVUsSUFBSSxDQUFDLEVBQWY7QUFBQSxXQUFmLENBREg7QUFFTixVQUFBLE9BQU8sRUFBRTtBQUZILFNBQUQsQ0FBUDtBQUlELE9BUk0sQ0FBUDtBQVNELEtBdEJNLENBd0JQO0FBQ0E7OztBQUNBLFdBQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsRUFBaEIsQ0FBUDtBQUNELEc7Ozs7O0FBR0gsTUFBTSxDQUFDLE9BQVAsR0FBaUIsZUFBakI7QUFDQSxNQUFNLENBQUMsT0FBUCxDQUFlLGNBQWYsR0FBZ0MsY0FBaEM7Ozs7Ozs7OztBQ3hJQSxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsbUJBQUQsQ0FBdkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7SUFDTSwwQjs7O0FBQ0osc0NBQWEsSUFBYixFQUFtQixXQUFuQixFQUFnQztBQUFBOztBQUM5QjtBQUVBLFVBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxVQUFLLFlBQUwsR0FBb0IsV0FBcEI7QUFDQSxVQUFLLFVBQUwsR0FBa0IsV0FBVyxDQUFDLE1BQTlCO0FBRUEsVUFBSyxPQUFMLEdBQWUsSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUM5QyxZQUFLLFFBQUwsR0FBZ0IsT0FBaEI7QUFDQSxZQUFLLE9BQUwsR0FBZSxNQUFmO0FBQ0QsS0FIYyxDQUFmO0FBS0EsVUFBSyxtQkFBTCxHQUEyQixNQUFLLG1CQUFMLENBQXlCLElBQXpCLCtCQUEzQjtBQUNBLFVBQUssaUJBQUwsR0FBeUIsTUFBSyxpQkFBTCxDQUF1QixJQUF2QiwrQkFBekI7QUFDQSxVQUFLLGdCQUFMLEdBQXdCLE1BQUssZ0JBQUwsQ0FBc0IsSUFBdEIsK0JBQXhCO0FBQ0EsVUFBSyxjQUFMLEdBQXNCLE1BQUssY0FBTCxDQUFvQixJQUFwQiwrQkFBdEI7O0FBRUEsVUFBSyxhQUFMOztBQWpCOEI7QUFrQi9CO0FBRUQ7QUFDRjtBQUNBOzs7OztTQUNFLFMsR0FBQSxtQkFBVyxFQUFYLEVBQWU7QUFDYixXQUFPLEtBQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQixFQUExQixNQUFrQyxDQUFDLENBQTFDO0FBQ0QsRzs7U0FFRCxtQixHQUFBLDZCQUFxQixRQUFyQixFQUErQjtBQUM3QixRQUFJLENBQUMsS0FBSyxTQUFMLENBQWUsUUFBUSxDQUFDLFdBQXhCLENBQUwsRUFBMkM7QUFDekM7QUFDRDs7QUFFRCxTQUFLLEtBQUwsQ0FBVyxHQUFYLHlEQUFxRSxRQUFRLENBQUMsV0FBOUU7O0FBRUEsU0FBSyxJQUFMLENBQVUsbUJBQVYsRUFBK0IsUUFBUSxDQUFDLFdBQXhDOztBQUVBLFNBQUssaUJBQUw7QUFDRCxHOztTQUVELGlCLEdBQUEsMkJBQW1CLFFBQW5CLEVBQTZCO0FBQzNCLFFBQUksQ0FBQyxLQUFLLFNBQUwsQ0FBZSxRQUFRLENBQUMsV0FBeEIsQ0FBTCxFQUEyQztBQUN6QztBQUNEOztBQUVELFNBQUssaUJBQUw7QUFDRCxHOztTQUVELGdCLEdBQUEsMEJBQWtCLFFBQWxCLEVBQTRCLEtBQTVCLEVBQW1DO0FBQ2pDLFFBQUksQ0FBQyxLQUFLLFNBQUwsQ0FBZSxRQUFRLENBQUMsV0FBeEIsQ0FBTCxFQUEyQztBQUN6QztBQUNEOztBQUVELFNBQUssS0FBTCxDQUFXLEdBQVgsd0RBQW9FLFFBQVEsQ0FBQyxXQUE3RTs7QUFDQSxTQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsS0FBZjs7QUFFQSxTQUFLLElBQUwsQ0FBVSxnQkFBVixFQUE0QixRQUFRLENBQUMsV0FBckMsRUFBa0QsS0FBbEQ7O0FBRUEsU0FBSyxpQkFBTDtBQUNELEc7O1NBRUQsYyxHQUFBLHdCQUFnQixRQUFoQixFQUEwQixNQUExQixFQUFrQyxLQUFsQyxFQUF5QztBQUN2QyxRQUFJLENBQUMsS0FBSyxTQUFMLENBQWUsUUFBUSxDQUFDLFdBQXhCLENBQUwsRUFBMkM7QUFDekM7QUFDRCxLQUhzQyxDQUt2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFLLGdCQUFMLENBQXNCLFFBQXRCLEVBQWdDLEtBQWhDO0FBQ0QsRzs7U0FFRCxpQixHQUFBLDZCQUFxQjtBQUNuQixTQUFLLFVBQUwsSUFBbUIsQ0FBbkI7O0FBQ0EsUUFBSSxLQUFLLFVBQUwsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekI7QUFDQSxXQUFLLGdCQUFMOztBQUNBLFdBQUssUUFBTDtBQUNEO0FBQ0YsRzs7U0FFRCxnQixHQUFBLDRCQUFvQjtBQUNsQixTQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsc0JBQWYsRUFBdUMsS0FBSyxtQkFBNUM7O0FBQ0EsU0FBSyxLQUFMLENBQVcsR0FBWCxDQUFlLDZCQUFmLEVBQThDLEtBQUssaUJBQW5EOztBQUNBLFNBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSw0QkFBZixFQUE2QyxLQUFLLGdCQUFsRDs7QUFDQSxTQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsMEJBQWYsRUFBMkMsS0FBSyxjQUFoRDtBQUNELEc7O1NBRUQsYSxHQUFBLHlCQUFpQjtBQUNmLFNBQUssS0FBTCxDQUFXLEVBQVgsQ0FBYyxzQkFBZCxFQUFzQyxLQUFLLG1CQUEzQzs7QUFDQSxTQUFLLEtBQUwsQ0FBVyxFQUFYLENBQWMsNkJBQWQsRUFBNkMsS0FBSyxpQkFBbEQ7O0FBQ0EsU0FBSyxLQUFMLENBQVcsRUFBWCxDQUFjLDRCQUFkLEVBQTRDLEtBQUssZ0JBQWpEOztBQUNBLFNBQUssS0FBTCxDQUFXLEVBQVgsQ0FBYywwQkFBZCxFQUEwQyxLQUFLLGNBQS9DO0FBQ0QsRzs7O0VBL0ZzQyxPOztBQWtHekMsTUFBTSxDQUFDLE9BQVAsR0FBaUIsMEJBQWpCOzs7QUM1R0EsSUFBTSxxQkFBcUIsR0FBRyxPQUFPLENBQUMsdUNBQUQsQ0FBckM7O0FBQ0EsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLFdBQUQsQ0FBbkI7QUFFQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxPQUFQO0FBQ0Usa0JBQWEsSUFBYixFQUF3QjtBQUFBLFFBQVgsSUFBVztBQUFYLE1BQUEsSUFBVyxHQUFKLEVBQUk7QUFBQTs7QUFDdEIsU0FBSyxJQUFMLEdBQVksSUFBWjtBQUVBLFNBQUssWUFBTCxHQUFvQixLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBcEI7QUFFQSxTQUFLLFFBQUwsR0FBZ0I7QUFDZCw0QkFBc0IsS0FBSyxJQUFMLENBQVU7QUFEbEIsS0FBaEI7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBbkJBOztBQUFBLFNBb0JFLGNBcEJGLEdBb0JFLDhCQUtHO0FBQUE7O0FBQUEsUUFKRCxNQUlDLFFBSkQsTUFJQztBQUFBLFFBSEQsTUFHQyxRQUhELE1BR0M7QUFBQSxRQUZELFNBRUMsUUFGRCxTQUVDO0FBQUEsUUFERCxhQUNDLFFBREQsYUFDQztBQUNELFFBQU0sSUFBSSxHQUFHLElBQUksUUFBSixFQUFiO0FBQ0EsSUFBQSxJQUFJLENBQUMsTUFBTCxDQUFZLFFBQVosRUFBc0IsT0FBTyxNQUFQLEtBQWtCLFFBQWxCLEdBQ2xCLE1BRGtCLEdBRWxCLElBQUksQ0FBQyxTQUFMLENBQWUsTUFBZixDQUZKOztBQUdBLFFBQUksU0FBSixFQUFlO0FBQ2IsTUFBQSxJQUFJLENBQUMsTUFBTCxDQUFZLFdBQVosRUFBeUIsU0FBekI7QUFDRDs7QUFFRCxJQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksTUFBWixFQUFvQixPQUFwQixDQUE0QixVQUFDLEdBQUQsRUFBUztBQUNuQyxNQUFBLElBQUksQ0FBQyxNQUFMLENBQVksR0FBWixFQUFpQixNQUFNLENBQUMsR0FBRCxDQUF2QjtBQUNELEtBRkQ7QUFHQSxJQUFBLElBQUksQ0FBQyxNQUFMLENBQVksMkJBQVosRUFBeUMsYUFBekM7QUFFQSxRQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUosQ0FBUSxhQUFSLE9BQTBCLEtBQUssSUFBTCxDQUFVLE9BQXBDLEVBQStDLElBQTNEO0FBQ0EsV0FBTyxxQkFBcUIsQ0FBQyxHQUFELEVBQU07QUFDaEMsTUFBQSxNQUFNLEVBQUUsTUFEd0I7QUFFaEMsTUFBQSxPQUFPLEVBQUUsS0FBSyxRQUZrQjtBQUdoQyxNQUFBLElBQUksRUFBRTtBQUgwQixLQUFOLENBQXJCLENBS0osSUFMSSxDQUtDLFVBQUMsUUFBRDtBQUFBLGFBQWMsUUFBUSxDQUFDLElBQVQsRUFBZDtBQUFBLEtBTEQsRUFLZ0MsSUFMaEMsQ0FLcUMsVUFBQyxRQUFELEVBQWM7QUFDdEQsVUFBSSxRQUFRLENBQUMsS0FBYixFQUFvQjtBQUNsQixZQUFNLEtBQUssR0FBRyxJQUFJLEtBQUosQ0FBVSxRQUFRLENBQUMsS0FBbkIsQ0FBZDtBQUNBLFFBQUEsS0FBSyxDQUFDLE9BQU4sR0FBZ0IsUUFBUSxDQUFDLE9BQXpCO0FBQ0EsUUFBQSxLQUFLLENBQUMsUUFBTixHQUFpQixRQUFqQjs7QUFDQSxZQUFJLFFBQVEsQ0FBQyxXQUFiLEVBQTBCO0FBQ3hCLFVBQUEsS0FBSyxDQUFDLE9BQU4sSUFBaUIseUJBQXNCLFFBQVEsQ0FBQyxXQUEvQixDQUFqQjtBQUNEOztBQUNELGNBQU0sS0FBTjtBQUNEOztBQUVELGFBQU8sUUFBUDtBQUNELEtBakJJLEVBa0JKLEtBbEJJLENBa0JFLFVBQUMsR0FBRDtBQUFBLGFBQVMsS0FBSSxDQUFDLFlBQUwsQ0FBa0IsR0FBbEIsRUFBdUI7QUFBRSxRQUFBLEdBQUcsRUFBSCxHQUFGO0FBQU8sUUFBQSxJQUFJLEVBQUU7QUFBYixPQUF2QixDQUFUO0FBQUEsS0FsQkYsQ0FBUDtBQW1CRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxFQTs7QUFBQSxTQW1FRSxXQW5FRixHQW1FRSxxQkFBYSxRQUFiLEVBQXVCLElBQXZCLEVBQTZCO0FBQUE7O0FBQzNCLFFBQU0sSUFBSSxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFOLENBQS9CO0FBQ0EsUUFBTSxHQUFHLEdBQU0sUUFBUSxDQUFDLGdCQUFmLDJCQUFxRCxJQUE5RDtBQUNBLFdBQU8scUJBQXFCLENBQUMsR0FBRCxFQUFNO0FBQUUsTUFBQSxNQUFNLEVBQUUsTUFBVjtBQUFrQixNQUFBLE9BQU8sRUFBRSxLQUFLO0FBQWhDLEtBQU4sQ0FBckIsQ0FDSixJQURJLENBQ0MsVUFBQyxRQUFEO0FBQUEsYUFBYyxRQUFRLENBQUMsSUFBVCxFQUFkO0FBQUEsS0FERCxFQUVKLEtBRkksQ0FFRSxVQUFDLEdBQUQ7QUFBQSxhQUFTLE1BQUksQ0FBQyxZQUFMLENBQWtCLEdBQWxCLEVBQXVCO0FBQUUsUUFBQSxRQUFRLEVBQVIsUUFBRjtBQUFZLFFBQUEsSUFBSSxFQUFKLElBQVo7QUFBa0IsUUFBQSxHQUFHLEVBQUgsR0FBbEI7QUFBdUIsUUFBQSxJQUFJLEVBQUU7QUFBN0IsT0FBdkIsQ0FBVDtBQUFBLEtBRkYsQ0FBUDtBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEZBOztBQUFBLFNBaUZFLE9BakZGLEdBaUZFLGlCQUFTLFFBQVQsRUFBbUIsSUFBbkIsRUFBeUI7QUFBQTs7QUFDdkIsUUFBSSxDQUFDLElBQUksQ0FBQyxTQUFWLEVBQXFCO0FBQ25CLGFBQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxJQUFJLEtBQUosQ0FBVSxvQ0FBVixDQUFmLENBQVA7QUFDRDs7QUFDRCxRQUFNLElBQUksR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBTixDQUEvQjtBQUNBLFFBQU0sU0FBUyxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxTQUFOLENBQXBDO0FBQ0EsUUFBTSxRQUFRLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQU4sQ0FBbkM7QUFDQSxRQUFNLFNBQVMsR0FBRyxNQUFsQjtBQUVBLFFBQU0sRUFBRSxhQUFXLElBQVgsa0JBQTRCLFFBQTVCLG1CQUFrRCxTQUFsRCxlQUFxRSxTQUE3RTtBQUNBLFFBQU0sR0FBRyxHQUFNLFFBQVEsQ0FBQyxnQkFBZixrQkFBNEMsRUFBckQ7QUFDQSxXQUFPLHFCQUFxQixDQUFDLEdBQUQsRUFBTTtBQUFFLE1BQUEsTUFBTSxFQUFFLE1BQVY7QUFBa0IsTUFBQSxPQUFPLEVBQUUsS0FBSztBQUFoQyxLQUFOLENBQXJCLENBQ0osSUFESSxDQUNDLFVBQUMsUUFBRDtBQUFBLGFBQWMsUUFBUSxDQUFDLElBQVQsRUFBZDtBQUFBLEtBREQsRUFFSixLQUZJLENBRUUsVUFBQyxHQUFEO0FBQUEsYUFBUyxNQUFJLENBQUMsWUFBTCxDQUFrQixHQUFsQixFQUF1QjtBQUFFLFFBQUEsUUFBUSxFQUFSLFFBQUY7QUFBWSxRQUFBLElBQUksRUFBSixJQUFaO0FBQWtCLFFBQUEsR0FBRyxFQUFILEdBQWxCO0FBQXVCLFFBQUEsSUFBSSxFQUFFO0FBQTdCLE9BQXZCLENBQVQ7QUFBQSxLQUZGLENBQVA7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFyR0E7O0FBQUEsU0FzR0UsY0F0R0YsR0FzR0Usd0JBQWdCLFFBQWhCLEVBQTBCO0FBQUE7O0FBQ3hCLFFBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxnQkFBckI7QUFDQSxXQUFPLHFCQUFxQixDQUFDLEdBQUQsRUFBTTtBQUFFLE1BQUEsTUFBTSxFQUFFLFFBQVY7QUFBb0IsTUFBQSxPQUFPLEVBQUUsS0FBSztBQUFsQyxLQUFOLENBQXJCLENBQ0osSUFESSxDQUNDLFVBQUMsUUFBRDtBQUFBLGFBQWMsUUFBUSxDQUFDLElBQVQsRUFBZDtBQUFBLEtBREQsRUFFSixLQUZJLENBRUUsVUFBQyxHQUFEO0FBQUEsYUFBUyxNQUFJLENBQUMsWUFBTCxDQUFrQixHQUFsQixFQUF1QjtBQUFFLFFBQUEsR0FBRyxFQUFILEdBQUY7QUFBTyxRQUFBLElBQUksRUFBRTtBQUFiLE9BQXZCLENBQVQ7QUFBQSxLQUZGLENBQVA7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFqSEE7O0FBQUEsU0FrSEUsaUJBbEhGLEdBa0hFLDJCQUFtQixHQUFuQixFQUF3QjtBQUFBOztBQUN0QixXQUFPLHFCQUFxQixDQUFDLEdBQUQsRUFBTTtBQUFFLE1BQUEsT0FBTyxFQUFFLEtBQUs7QUFBaEIsS0FBTixDQUFyQixDQUNKLElBREksQ0FDQyxVQUFDLFFBQUQ7QUFBQSxhQUFjLFFBQVEsQ0FBQyxJQUFULEVBQWQ7QUFBQSxLQURELEVBRUosS0FGSSxDQUVFLFVBQUMsR0FBRDtBQUFBLGFBQVMsTUFBSSxDQUFDLFlBQUwsQ0FBa0IsR0FBbEIsRUFBdUI7QUFBRSxRQUFBLEdBQUcsRUFBSCxHQUFGO0FBQU8sUUFBQSxJQUFJLEVBQUU7QUFBYixPQUF2QixDQUFUO0FBQUEsS0FGRixDQUFQO0FBR0QsR0F0SEg7O0FBQUEsU0F3SEUsV0F4SEYsR0F3SEUscUJBQWEsR0FBYixTQUFvRDtBQUFBLFFBQWhDLFFBQWdDLFNBQWhDLFFBQWdDO0FBQUEsUUFBdEIsUUFBc0IsU0FBdEIsUUFBc0I7QUFBQSxRQUFaLFFBQVksU0FBWixRQUFZO0FBQ2xELFFBQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxPQUFKLEdBQ1QsR0FBRyxDQUFDLE9BREssVUFDTyxHQUFHLENBQUMsT0FEWCxTQUVaLEdBQUcsQ0FBQyxPQUZSO0FBSUEsV0FBTyxxQkFBcUIsQ0FBQyw0Q0FBRCxFQUErQztBQUN6RSxNQUFBLE1BQU0sRUFBRSxNQURpRTtBQUV6RSxNQUFBLElBQUksRUFBRSxJQUFJLENBQUMsU0FBTCxDQUFlO0FBQ25CLFFBQUEsUUFBUSxFQUFSLFFBRG1CO0FBRW5CLFFBQUEsUUFBUSxFQUFSLFFBRm1CO0FBR25CLFFBQUEsV0FBVyxFQUFFLFFBSE07QUFJbkIsUUFBQSxLQUFLLEVBQUUsT0FBTyxTQUFQLEtBQXFCLFdBQXJCLEdBQW1DLFNBQVMsQ0FBQyxTQUE3QyxHQUF5RCxFQUo3QztBQUtuQixRQUFBLE1BQU0sRUFBRSxLQUFLLElBQUwsQ0FBVSxNQUxDO0FBTW5CLFFBQUEsS0FBSyxFQUFFO0FBTlksT0FBZjtBQUZtRSxLQUEvQyxDQUFyQixDQVdKLElBWEksQ0FXQyxVQUFDLFFBQUQ7QUFBQSxhQUFjLFFBQVEsQ0FBQyxJQUFULEVBQWQ7QUFBQSxLQVhELENBQVA7QUFZRCxHQXpJSDs7QUFBQSxTQTJJRSxZQTNJRixHQTJJRSxzQkFBYyxHQUFkLEVBQW1CLE1BQW5CLEVBQTJCO0FBQ3pCLFFBQUksS0FBSyxJQUFMLENBQVUsY0FBVixLQUE2QixLQUFqQyxFQUF3QztBQUN0QyxZQUFNLEdBQU47QUFDRDs7QUFFRCxRQUFNLElBQUksR0FBRztBQUNYLE1BQUEsSUFBSSxFQUFFLE1BQU0sQ0FBQztBQURGLEtBQWI7O0FBR0EsUUFBSSxNQUFNLENBQUMsUUFBWCxFQUFxQjtBQUNuQixNQUFBLElBQUksQ0FBQyxRQUFMLEdBQWdCLE1BQU0sQ0FBQyxRQUFQLENBQWdCLFdBQWhDO0FBQ0EsTUFBQSxJQUFJLENBQUMsUUFBTCxHQUFnQixNQUFNLENBQUMsUUFBUCxDQUFnQixRQUFoQztBQUNEOztBQUNELFFBQUksTUFBTSxDQUFDLEdBQVgsRUFBZ0I7QUFDZCxNQUFBLElBQUksQ0FBQyxRQUFMLEdBQWdCLE1BQU0sQ0FBQyxHQUF2QjtBQUNEOztBQUVELFNBQUssV0FBTCxDQUFpQixHQUFqQixFQUFzQixJQUF0QixFQUE0QixLQUE1QixDQUFrQyxVQUFDLENBQUQsRUFBTyxDQUN2QztBQUNELEtBRkQ7QUFJQSxVQUFNLEdBQU47QUFDRCxHQWhLSDs7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDTkEsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLDRCQUFELENBQTFCOztBQUNBLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyw2QkFBRCxDQUEzQjs7ZUFDbUIsT0FBTyxDQUFDLFlBQUQsQztJQUFsQixNLFlBQUEsTTs7QUFDUixJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsV0FBRCxDQUFuQjs7QUFDQSxJQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsWUFBRCxDQUF4Qjs7QUFDQSxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBRCxDQUF0Qjs7QUFDQSxJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsbUJBQUQsQ0FBL0I7O0FBQ0EsSUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLG1CQUFELENBQS9COztBQUVBLFNBQVMseUJBQVQsQ0FBb0MsSUFBcEMsRUFBMEMsT0FBMUMsRUFBbUQ7QUFDakQsU0FBTztBQUNMLElBQUEsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQURYO0FBRUwsSUFBQSxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBRmQ7QUFHTCxJQUFBLE1BQU0sRUFBRSxPQUFPLENBQUM7QUFIWCxHQUFQO0FBS0Q7O0FBRUQsSUFBTSxTQUFTLEdBQUcsd0NBQWxCLEMsQ0FDQTs7QUFDQSxJQUFNLHlCQUF5QixHQUFHLHFCQUFsQyxDLENBQ0E7O0FBQ0EsSUFBTSxZQUFZLEdBQUcsdURBQXJCO0FBQ0EsSUFBTSxjQUFjLEdBQUcseURBQXZCO0FBRUE7QUFDQTtBQUNBOztBQUNBLE1BQU0sQ0FBQyxPQUFQO0FBQUE7O0FBR0UsdUJBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QjtBQUFBOztBQUN2QiwrQkFBTSxJQUFOLEVBQVksSUFBWjtBQUNBLFVBQUssSUFBTCxHQUFZLFVBQVo7QUFDQSxVQUFLLEVBQUwsR0FBVSxNQUFLLElBQUwsQ0FBVSxFQUFWLElBQWdCLGFBQTFCO0FBQ0EsVUFBSyxLQUFMLEdBQWEsYUFBYjtBQUVBLFVBQUssYUFBTCxHQUFxQjtBQUNuQixNQUFBLE9BQU8sRUFBRTtBQUNQLFFBQUEsZ0JBQWdCLEVBQUUscUJBRFg7QUFFUCxRQUFBLHNCQUFzQixFQUFFLHdDQUZqQjtBQUdQLFFBQUEsUUFBUSxFQUFFO0FBSEg7QUFEVSxLQUFyQjtBQVFBLFFBQU0sY0FBYyxHQUFHO0FBQ3JCLE1BQUEsT0FBTyxFQUFFLDhCQURZO0FBRXJCLE1BQUEsY0FBYyxFQUFFLElBRks7QUFHckIsTUFBQSxlQUFlLEVBQUUsS0FISTtBQUlyQixNQUFBLGVBQWUsRUFBRSxLQUpJO0FBS3JCLE1BQUEsaUJBQWlCLEVBQUUsS0FMRTtBQU1yQixNQUFBLG9CQUFvQixFQUFFLEtBTkQ7QUFPckIsTUFBQSxTQUFTLEVBQUUsSUFQVTtBQVFyQixNQUFBLE1BQU0sRUFBRSxJQVJhO0FBU3JCLE1BQUEsTUFBTSxFQUFFLEVBVGE7QUFVckIsTUFBQSxrQkFBa0IsRUFBRSx5QkFWQztBQVdyQixNQUFBLEtBQUssRUFBRTtBQVhjLEtBQXZCO0FBY0EsVUFBSyxJQUFMLGdCQUFpQixjQUFqQixFQUFvQyxJQUFwQzs7QUFFQSxVQUFLLFFBQUw7O0FBRUEsVUFBSyxjQUFMLEdBQXNCLE1BQUssY0FBTCxDQUFvQixJQUFwQiwrQkFBdEI7QUFDQSxVQUFLLFlBQUwsR0FBb0IsTUFBSyxZQUFMLENBQWtCLElBQWxCLCtCQUFwQjtBQUNBLFVBQUssUUFBTCxHQUFnQixNQUFLLFFBQUwsQ0FBYyxJQUFkLCtCQUFoQjtBQUNBLFVBQUssV0FBTCxHQUFtQixNQUFLLFdBQUwsQ0FBaUIsSUFBakIsK0JBQW5CO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLE1BQUssWUFBTCxDQUFrQixJQUFsQiwrQkFBcEI7QUFDQSxVQUFLLHlCQUFMLEdBQWlDLE1BQUsseUJBQUwsQ0FBK0IsSUFBL0IsK0JBQWpDO0FBQ0EsVUFBSyxXQUFMLEdBQW1CLE1BQUssV0FBTCxDQUFpQixJQUFqQiwrQkFBbkI7QUFDQSxVQUFLLGtCQUFMLEdBQTBCLE1BQUssa0JBQUwsQ0FBd0IsSUFBeEIsK0JBQTFCO0FBRUEsUUFBTSx3QkFBd0IsR0FBRyxNQUFLLElBQUwsQ0FBVSxrQkFBVixLQUFpQyxjQUFjLENBQUMsa0JBQWpGOztBQUNBLFFBQUksTUFBSyxJQUFMLENBQVUsTUFBZCxFQUFzQjtBQUNwQixNQUFBLGVBQWUsQ0FBQyxjQUFoQixDQUErQixNQUFLLElBQUwsQ0FBVSxNQUF6QztBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMsd0JBQUwsRUFBK0I7QUFDcEM7QUFDQTtBQUNBLE1BQUEsZUFBZSxDQUFDLGNBQWhCLENBQStCLElBQS9CO0FBQ0Q7O0FBRUQsVUFBSyxNQUFMLEdBQWMsSUFBSSxNQUFKLENBQVc7QUFDdkIsTUFBQSxPQUFPLEVBQUUsTUFBSyxJQUFMLENBQVUsT0FESTtBQUV2QixNQUFBLE1BQU0sRUFBRSxNQUFLLGlCQUFMLEVBRmU7QUFHdkIsTUFBQSxjQUFjLEVBQUUsTUFBSyxJQUFMLENBQVU7QUFISCxLQUFYLENBQWQsQ0FsRHVCLENBdUR2Qjs7QUFDQSxVQUFLLGdCQUFMLEdBQXdCLEVBQXhCLENBeER1QixDQXlEdkI7O0FBQ0EsVUFBSyxnQkFBTCxHQUF3QixFQUF4QixDQTFEdUIsQ0EyRHZCOztBQUNBLFVBQUssY0FBTCxHQUFzQixNQUFNLENBQUMsTUFBUCxDQUFjLElBQWQsQ0FBdEI7QUE1RHVCO0FBNkR4Qjs7QUFoRUg7O0FBQUEsU0FrRUUsVUFsRUYsR0FrRUUsb0JBQVksT0FBWixFQUFxQjtBQUNuQixzQkFBTSxVQUFOLFlBQWlCLE9BQWpCOztBQUNBLFNBQUssUUFBTDtBQUNELEdBckVIOztBQUFBLFNBdUVFLFFBdkVGLEdBdUVFLG9CQUFZO0FBQ1YsU0FBSyxVQUFMLEdBQWtCLElBQUksVUFBSixDQUFlLENBQUMsS0FBSyxhQUFOLEVBQXFCLEtBQUssSUFBTCxDQUFVLE1BQS9CLEVBQXVDLEtBQUssSUFBTCxDQUFVLE1BQWpELENBQWYsQ0FBbEI7QUFDQSxTQUFLLElBQUwsR0FBWSxLQUFLLFVBQUwsQ0FBZ0IsU0FBaEIsQ0FBMEIsSUFBMUIsQ0FBK0IsS0FBSyxVQUFwQyxDQUFaO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLEtBQUssVUFBTCxDQUFnQixjQUFoQixDQUErQixJQUEvQixDQUFvQyxLQUFLLFVBQXpDLENBQWpCO0FBQ0EsU0FBSyxjQUFMLEdBSlUsQ0FJWTtBQUN2QixHQTVFSDs7QUFBQSxTQThFRSxpQkE5RUYsR0E4RUUsNkJBQXFCO0FBQUE7O0FBQ25CLFFBQU0sSUFBSSxHQUFHLGdCQUNFLEtBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsT0FEeEIsd0JBRVMsS0FBSyxXQUFMLENBQWlCLE9BRjFCLGdCQUdDLEdBQUcsQ0FBQyxPQUhMLENBQWI7O0FBTUEsUUFBTSxnQkFBZ0IsR0FBRyxTQUFuQixnQkFBbUIsQ0FBQyxVQUFELEVBQWEsV0FBYixFQUE2QjtBQUNwRCxVQUFNLE1BQU0sR0FBRyxNQUFJLENBQUMsSUFBTCxDQUFVLFNBQVYsQ0FBb0IsVUFBcEIsQ0FBZjs7QUFDQSxVQUFJLE1BQUosRUFBWTtBQUNWLFFBQUEsSUFBSSxDQUFDLElBQUwsQ0FBYSxXQUFiLFNBQTRCLE1BQU0sQ0FBQyxXQUFQLENBQW1CLE9BQS9DO0FBQ0Q7QUFDRixLQUxEOztBQU9BLFFBQUksS0FBSyxJQUFMLENBQVUsb0JBQWQsRUFBb0M7QUFDbEMsTUFBQSxnQkFBZ0IsQ0FBQyxXQUFELEVBQWMsaUJBQWQsQ0FBaEI7QUFDQSxNQUFBLGdCQUFnQixDQUFDLE9BQUQsRUFBVSxhQUFWLENBQWhCO0FBQ0EsTUFBQSxnQkFBZ0IsQ0FBQyxnQkFBRCxFQUFtQix1QkFBbkIsQ0FBaEI7QUFDRDs7QUFFRCxJQUFBLGdCQUFnQixDQUFDLFNBQUQsRUFBWSxjQUFaLENBQWhCO0FBQ0EsSUFBQSxnQkFBZ0IsQ0FBQyxLQUFELEVBQVEsVUFBUixDQUFoQjtBQUNBLElBQUEsZ0JBQWdCLENBQUMsVUFBRCxFQUFhLGVBQWIsQ0FBaEI7QUFDQSxJQUFBLGdCQUFnQixDQUFDLGFBQUQsRUFBZ0IsbUJBQWhCLENBQWhCO0FBQ0EsSUFBQSxnQkFBZ0IsQ0FBQyxXQUFELEVBQWMsZ0JBQWQsQ0FBaEI7QUFDQSxJQUFBLGdCQUFnQixDQUFDLFVBQUQsRUFBYSxlQUFiLENBQWhCO0FBQ0EsSUFBQSxnQkFBZ0IsQ0FBQyxNQUFELEVBQVMsV0FBVCxDQUFoQjtBQUNBLElBQUEsZ0JBQWdCLENBQUMsS0FBRCxFQUFRLFVBQVIsQ0FBaEI7QUFFQSxXQUFPLElBQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0SEE7O0FBQUEsU0F1SEUsdUJBdkhGLEdBdUhFLGlDQUF5QixJQUF6QixFQUErQixNQUEvQixFQUF1QztBQUNyQztBQUNBLFFBQU0sSUFBSSxnQkFDTCxJQUFJLENBQUMsSUFEQTtBQUVSLE1BQUEsWUFBWSxFQUFFLE1BQU0sQ0FBQyxZQUZiO0FBR1IsTUFBQSxRQUFRLEVBQUUsSUFBSSxDQUFDLElBSFA7QUFJUixNQUFBLFNBQVMsRUFBRTtBQUpILE1BQVYsQ0FGcUMsQ0FRckM7OztBQUNBLFFBQU0sR0FBRyxnQkFDSixJQUFJLENBQUMsR0FERDtBQUVQLE1BQUEsUUFBUSxFQUFFLE1BQU0sQ0FBQyxPQUZWO0FBR1A7QUFDQSxNQUFBLFlBQVksRUFBRTtBQUpQLE1BQVQsQ0FUcUMsQ0FnQnJDO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxRQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBbEI7O0FBQ0EsUUFBSSxJQUFJLENBQUMsTUFBTCxJQUFlLGNBQWMsQ0FBQyxJQUFmLENBQW9CLElBQUksQ0FBQyxNQUFMLENBQVksWUFBaEMsQ0FBbkIsRUFBa0U7QUFDaEUsVUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFKLENBQ1YsMEVBQ0UsNEVBREYsR0FFRSxzQkFIUSxDQUFaLENBRGdFLENBTWhFO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFdBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkO0FBQ0EsWUFBTSxHQUFOO0FBQ0Q7O0FBRUQsUUFBSSxJQUFJLENBQUMsTUFBTCxJQUFlLFlBQVksQ0FBQyxJQUFiLENBQWtCLElBQUksQ0FBQyxNQUFMLENBQVksWUFBOUIsQ0FBbkIsRUFBZ0U7QUFDOUQsVUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLGFBQVAsQ0FDYixPQURhLENBQ0wsS0FESyxFQUNFLEVBREYsQ0FBaEI7QUFFQSxVQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFZLEdBQVosQ0FDVixPQURVLENBQ0YsSUFBSSxDQUFDLE1BQUwsQ0FBWSxZQURWLEVBQ3dCLEVBRHhCLEVBRVYsT0FGVSxDQUVGLEtBRkUsRUFFSyxFQUZMLENBQWI7QUFJQSxNQUFBLE1BQU0sZ0JBQ0QsSUFBSSxDQUFDLE1BREo7QUFFSixRQUFBLFlBQVksRUFBRSxPQUZWO0FBR0osUUFBQSxHQUFHLEVBQUssT0FBTCxTQUFnQjtBQUhmLFFBQU47QUFLRCxLQS9Db0MsQ0FpRHJDOzs7QUFDQSxRQUFNLE9BQU8sZ0JBQ1IsSUFEUTtBQUVYLE1BQUEsV0FBVyxFQUFFO0FBQ1gsUUFBQSxRQUFRLEVBQUUsTUFBTSxDQUFDO0FBRE47QUFGRixNQUFiLENBbERxQyxDQXdEckM7OztBQUNBLFFBQUksQ0FBQyxLQUFLLElBQUwsQ0FBVSxvQkFBZixFQUFxQztBQUNuQyxlQUFjLE9BQWQsRUFBdUI7QUFBRSxRQUFBLElBQUksRUFBSixJQUFGO0FBQVEsUUFBQSxHQUFHLEVBQUgsR0FBUjtBQUFhLFFBQUEsTUFBTSxFQUFOO0FBQWIsT0FBdkI7QUFDRDs7QUFDRCxXQUFPLE9BQVA7QUFDRCxHQXBMSDs7QUFBQSxTQXNMRSxlQXRMRixHQXNMRSx5QkFBaUIsT0FBakIsRUFBMEIsUUFBMUIsRUFBb0MsT0FBcEMsRUFBNkM7QUFBQTs7QUFDM0MsU0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLCtCQUFkO0FBRUEsV0FBTyxLQUFLLE1BQUwsQ0FBWSxjQUFaLENBQTJCO0FBQ2hDLE1BQUEsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQURnQjtBQUVoQyxNQUFBLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFGZ0I7QUFHaEMsTUFBQSxhQUFhLEVBQUUsT0FBTyxDQUFDLE1BSFM7QUFJaEMsTUFBQSxTQUFTLEVBQUUsT0FBTyxDQUFDO0FBSmEsS0FBM0IsRUFLSixJQUxJLENBS0MsVUFBQyxXQUFELEVBQWlCO0FBQUE7O0FBQ3ZCLFVBQU0sUUFBUSxHQUFHLElBQUksUUFBSixDQUFhLFdBQWIsQ0FBakI7QUFDQSxVQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBeEI7QUFDQSxVQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsV0FBMUI7O0FBSHVCLGtDQUttQixNQUFJLENBQUMsY0FBTCxFQUxuQjtBQUFBLFVBS2YsVUFMZSx5QkFLZixVQUxlO0FBQUEsVUFLSCxpQkFMRyx5QkFLSCxpQkFMRzs7QUFNdkIsTUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQjtBQUNBLFFBQUEsVUFBVSxlQUNMLFVBREssNkJBRVAsVUFGTyxJQUVNLE1BRk4sYUFGUTtBQU1sQjtBQUNBLFFBQUEsaUJBQWlCLGVBQ1osaUJBRFksNkJBRWQsUUFGYyxjQUdWLGlCQUFpQixDQUFDLFFBQUQsQ0FIUCxHQUliLFVBSmE7QUFQQyxPQUFwQjs7QUFOdUIsaUNBc0JMLE1BQUksQ0FBQyxJQUFMLENBQVUsUUFBVixFQXRCSztBQUFBLFVBc0JmLEtBdEJlLHdCQXNCZixLQXRCZTs7QUF1QnZCLFVBQU0sWUFBWSxHQUFHLEVBQXJCO0FBQ0EsTUFBQSxPQUFPLENBQUMsT0FBUixDQUFnQixVQUFDLEVBQUQsRUFBUTtBQUN0QixRQUFBLFlBQVksQ0FBQyxFQUFELENBQVosR0FBbUIsTUFBSSxDQUFDLHVCQUFMLENBQTZCLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixFQUFsQixDQUE3QixFQUFvRCxNQUFwRCxDQUFuQjtBQUNELE9BRkQ7O0FBR0EsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFFBQVYsQ0FBbUI7QUFDakIsUUFBQSxLQUFLLGVBQ0EsS0FEQSxFQUVBLFlBRkE7QUFEWSxPQUFuQjs7QUFPQSxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLDhCQUFmLEVBQStDLE1BQS9DLEVBQXVELE9BQXZEOztBQUVBLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxHQUFWLHFDQUFnRCxVQUFoRDs7QUFDQSxhQUFPLFFBQVA7QUFDRCxLQTNDTSxFQTJDSixLQTNDSSxDQTJDRSxVQUFDLEdBQUQsRUFBUztBQUNoQixNQUFBLEdBQUcsQ0FBQyxPQUFKLEdBQWlCLE1BQUksQ0FBQyxJQUFMLENBQVUsd0JBQVYsQ0FBakIsVUFBeUQsR0FBRyxDQUFDLE9BQTdELENBRGdCLENBRWhCOztBQUNBLFlBQU0sR0FBTjtBQUNELEtBL0NNLENBQVA7QUFnREQsR0F6T0g7O0FBQUEsU0EyT0Usc0JBM09GLEdBMk9FLGdDQUF3QixVQUF4QixFQUFvQyxPQUFwQyxFQUE2QyxRQUE3QyxFQUF1RDtBQUFBOztBQUN2RDtBQUNFLFFBQU0sT0FBTyxHQUFHLElBQUksZUFBSixDQUFvQixLQUFLLElBQXpCLEVBQStCLFVBQS9CLENBQWhCO0FBRUEsSUFBQSxPQUFPLENBQUMsRUFBUixDQUFXLG1CQUFYLEVBQWdDLFVBQUMsRUFBRCxFQUFRO0FBQ3RDLFVBQU0sS0FBSyxHQUFHLE1BQUksQ0FBQyxnQkFBTCxDQUFzQixFQUF0QixDQUFkOztBQUNBLE1BQUEsS0FBSyxDQUFDLE9BQU4sQ0FBYyxVQUFDLElBQUQsRUFBVTtBQUN0QixRQUFBLE1BQUksQ0FBQyxjQUFMLENBQW9CLElBQUksQ0FBQyxFQUF6QixJQUErQixJQUEvQjs7QUFDQSxRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLHNCQUFmLEVBQXVDLElBQXZDO0FBQ0QsT0FIRDtBQUlELEtBTkQ7QUFRQSxJQUFBLE9BQU8sQ0FBQyxFQUFSLENBQVcsZ0JBQVgsRUFBNkIsVUFBQyxFQUFELEVBQUssS0FBTCxFQUFlO0FBQzVDO0FBQ0UsVUFBTSxLQUFLLEdBQUcsTUFBSSxDQUFDLGdCQUFMLENBQXNCLEVBQXRCLENBQWQ7O0FBQ0EsTUFBQSxLQUFLLENBQUMsT0FBTixDQUFjLFVBQUMsSUFBRCxFQUFVO0FBQ3hCO0FBQ0UsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEtBQXJDOztBQUVBLFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsc0JBQWYsRUFBdUMsSUFBdkM7QUFDRCxPQUxEO0FBTUQsS0FURDtBQVdBLFNBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsSUFBa0MsT0FBbEM7QUFDRCxHQW5RSDs7QUFBQSxTQXFRRSxzQkFyUUYsR0FxUUUsa0NBQTBCO0FBQ3hCLFdBQU8sS0FBSyxJQUFMLENBQVUsZUFBVixJQUE2QixLQUFLLElBQUwsQ0FBVSxlQUE5QztBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUE1UUE7O0FBQUEsU0E2UUUsYUE3UUYsR0E2UUUsdUJBQWUsUUFBZixFQUF5QixPQUF6QixFQUFrQztBQUFBOztBQUNoQyxXQUFPLE9BQU8sQ0FBQyxHQUFSLENBQVksT0FBTyxDQUFDLEdBQVIsQ0FBWSxVQUFDLE1BQUQsRUFBWTtBQUN6QyxVQUFNLElBQUksR0FBRyxNQUFJLENBQUMsSUFBTCxDQUFVLE9BQVYsQ0FBa0IsTUFBbEIsQ0FBYjs7QUFDQSxhQUFPLE1BQUksQ0FBQyxNQUFMLENBQVksV0FBWixDQUF3QixRQUFRLENBQUMsTUFBakMsRUFBeUMsSUFBekMsQ0FBUDtBQUNELEtBSGtCLENBQVosQ0FBUDtBQUlEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUF2UkE7O0FBQUEsU0F3UkUseUJBeFJGLEdBd1JFLG1DQUEyQixPQUEzQixFQUFvQztBQUFBOztBQUNsQyxRQUFNLElBQUksR0FBRyxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLE9BQU8sQ0FBQyxFQUExQixDQUFiOztBQUNBLFFBQUksQ0FBQyxJQUFELElBQVMsQ0FBQyxJQUFJLENBQUMsV0FBZixJQUE4QixDQUFDLElBQUksQ0FBQyxXQUFMLENBQWlCLFFBQXBELEVBQThEO0FBQzVEO0FBQ0Q7O0FBSmlDLCtCQU1YLEtBQUssY0FBTCxFQU5XO0FBQUEsUUFNMUIsVUFOMEIsd0JBTTFCLFVBTjBCOztBQU9sQyxRQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQUwsQ0FBaUIsUUFBbEIsQ0FBM0I7QUFFQSxTQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLFFBQXBCLEVBQThCLElBQTlCLEVBQW9DLEtBQXBDLENBQTBDLFVBQUMsR0FBRCxFQUFTO0FBQ2pELE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZDs7QUFDQSxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLDBCQUFmLEVBQTJDLFFBQTNDLEVBQXFELElBQUksQ0FBQyxFQUExRCxFQUE4RCxHQUE5RDtBQUNELEtBSEQ7QUFJRCxHQXJTSDs7QUFBQSxTQXVTRSxTQXZTRixHQXVTRSxtQkFBVyxZQUFYLEVBQXlCO0FBQ3ZCLFFBQU0sS0FBSyxHQUFHLEtBQUssSUFBTCxDQUFVLFFBQVYsRUFBZDs7QUFDQSxTQUFLLElBQUksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUExQixFQUFrQyxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLFVBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFELENBQWxCLENBRHFDLENBRXJDOztBQUNBLFVBQUksSUFBSSxDQUFDLFNBQUwsS0FBbUIsWUFBWSxDQUFDLGNBQXBDLEVBQW9EO0FBQ2xELGVBQU8sSUFBUDtBQUNELE9BTG9DLENBTXJDOzs7QUFDQSxVQUFJLElBQUksQ0FBQyxHQUFMLElBQVksSUFBSSxDQUFDLEdBQUwsQ0FBUyxTQUFULEtBQXVCLFlBQVksQ0FBQyxjQUFwRCxFQUFvRTtBQUNsRSxlQUFPLElBQVA7QUFDRDs7QUFDRCxVQUFJLENBQUMsWUFBWSxDQUFDLFdBQWxCLEVBQStCO0FBQzdCO0FBQ0EsWUFBSSxJQUFJLENBQUMsSUFBTCxLQUFjLFlBQVksQ0FBQyxJQUEzQixJQUFtQyxJQUFJLENBQUMsSUFBTCxLQUFjLFlBQVksQ0FBQyxJQUFsRSxFQUF3RTtBQUN0RSxpQkFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsR0ExVEg7O0FBQUEsU0E0VEUscUJBNVRGLEdBNFRFLCtCQUF1QixVQUF2QixFQUFtQyxZQUFuQyxFQUFpRDtBQUFBOztBQUMvQyxRQUFNLEtBQUssR0FBRyxLQUFLLGNBQUwsRUFBZDs7QUFDQSxRQUFNLElBQUksR0FBRyxLQUFLLFNBQUwsQ0FBZSxZQUFmLENBQWI7O0FBQ0EsUUFBSSxDQUFDLElBQUwsRUFBVztBQUNULFdBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyw0RUFBZDtBQUNBO0FBQ0Q7O0FBQ0QsU0FBSyxjQUFMLENBQW9CO0FBQ2xCLE1BQUEsS0FBSyxlQUNBLEtBQUssQ0FBQyxLQUROLDZCQUVGLFlBQVksQ0FBQyxFQUZYLElBRWdCO0FBQ2pCLFFBQUEsUUFBUSxFQUFFLFVBRE87QUFFakIsUUFBQSxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBRlE7QUFHakIsUUFBQSxZQUFZLEVBQVo7QUFIaUIsT0FGaEI7QUFEYSxLQUFwQjtBQVVBLFNBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxvQkFBZixFQUFxQyxZQUFyQyxFQUFtRCxLQUFLLFdBQUwsQ0FBaUIsVUFBakIsQ0FBbkQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdFZBOztBQUFBLFNBdVZFLFNBdlZGLEdBdVZFLG1CQUFXLFVBQVgsRUFBdUIsUUFBdkIsRUFBaUMsTUFBakMsRUFBeUM7QUFDdkMsUUFBTSxLQUFLLEdBQUcsS0FBSyxjQUFMLEVBQWQ7QUFDQSxRQUFNLElBQUksR0FBRyxLQUFLLENBQUMsS0FBTixDQUFZLE1BQU0sQ0FBQyxXQUFuQixDQUFiLENBRnVDLENBR3ZDOztBQUNBLElBQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFSLEdBQWEsSUFBbEM7QUFFQSxRQUFNLEtBQUssR0FBRztBQUNaLE1BQUEsTUFBTSxFQUFOLE1BRFk7QUFFWixNQUFBLFFBQVEsRUFBUixRQUZZO0FBR1osTUFBQSxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBSEM7QUFJWixNQUFBLFFBQVEsRUFBRTtBQUpFLEtBQWQ7QUFPQSxTQUFLLGNBQUwsQ0FBb0I7QUFDbEIsTUFBQSxPQUFPLFlBQU0sS0FBSyxDQUFDLE9BQVosR0FBcUIsS0FBckI7QUFEVyxLQUFwQjtBQUdBLFNBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxvQkFBZixFQUFxQyxRQUFyQyxFQUErQyxNQUEvQyxFQUF1RCxLQUFLLFdBQUwsQ0FBaUIsVUFBakIsQ0FBdkQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9XQTs7QUFBQSxTQWdYRSxtQkFoWEYsR0FnWEUsNkJBQXFCLE1BQXJCLEVBQTZCO0FBQUE7O0FBQzNCLFFBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxnQkFBbkI7QUFDQSxTQUFLLE1BQUwsQ0FBWSxpQkFBWixDQUE4QixHQUE5QixFQUFtQyxJQUFuQyxDQUF3QyxVQUFDLFdBQUQsRUFBaUI7QUFBQTs7QUFDdkQsVUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLFdBQS9COztBQUNBLFVBQU0sS0FBSyxHQUFHLE1BQUksQ0FBQyxjQUFMLEVBQWQ7O0FBQ0EsTUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQixRQUFBLFVBQVUsZUFDTCxLQUFLLENBQUMsVUFERCw2QkFFUCxVQUZPLElBRU0sV0FGTjtBQURRLE9BQXBCOztBQU1BLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsc0JBQWYsRUFBdUMsV0FBdkM7QUFDRCxLQVZEO0FBV0QsR0E3WEg7O0FBQUEsU0ErWEUsZUEvWEYsR0ErWEUseUJBQWlCLFFBQWpCLEVBQTJCO0FBQUE7O0FBQ3pCLFdBQU8sS0FBSyxNQUFMLENBQVksY0FBWixDQUEyQixRQUEzQixFQUFxQyxJQUFyQyxDQUEwQyxZQUFNO0FBQ3JEO0FBQ0EsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxnQ0FBZixFQUFpRCxRQUFqRDtBQUNELEtBSE0sQ0FBUDtBQUlEO0FBRUQ7QUFDRjtBQUNBO0FBeFlBOztBQUFBLFNBeVlFLFlBellGLEdBeVlFLHdCQUFnQjtBQUFBOztBQUFBLGdDQUNnQixLQUFLLGNBQUwsRUFEaEI7QUFBQSxRQUNOLGlCQURNLHlCQUNOLGlCQURNOztBQUdkLFFBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksaUJBQVosRUFBK0IsTUFBL0IsQ0FBc0MsVUFBQyxHQUFELEVBQU0sUUFBTixFQUFtQjtBQUMzRSxNQUFBLEdBQUcsQ0FBQyxJQUFKLE9BQUEsR0FBRyxFQUFTLGlCQUFpQixDQUFDLFFBQUQsQ0FBMUIsQ0FBSDtBQUNBLGFBQU8sR0FBUDtBQUNELEtBSG1CLEVBR2pCLEVBSGlCLENBQXBCO0FBS0EsUUFBTSxjQUFjLEdBQUcsV0FBVyxDQUFDLEdBQVosQ0FBZ0IsVUFBQyxVQUFELEVBQWdCO0FBQ3JELFVBQU0sUUFBUSxHQUFHLE1BQUksQ0FBQyxXQUFMLENBQWlCLFVBQWpCLENBQWpCOztBQUNBLGFBQU8sTUFBSSxDQUFDLGVBQUwsQ0FBcUIsUUFBckIsQ0FBUDtBQUNELEtBSHNCLENBQXZCO0FBS0EsSUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLGNBQVosRUFBNEIsS0FBNUIsQ0FBa0MsVUFBQyxHQUFELEVBQVM7QUFDekMsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkO0FBQ0QsS0FGRDtBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaGFBOztBQUFBLFNBaWFFLGtCQWphRixHQWlhRSw0QkFBb0IsT0FBcEIsRUFBNkI7QUFBQTs7QUFDM0IsUUFBTSxLQUFLLEdBQUcsS0FBSyxjQUFMLEVBQWQ7QUFDQSxRQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsVUFBekI7QUFDQSxRQUFNLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxpQkFBaEM7QUFFQSxJQUFBLE9BQU8sMEJBQ0osS0FBSyxFQURELElBQ007QUFDVCxNQUFBLFVBQVUsRUFBVixVQURTO0FBRVQsTUFBQSxpQkFBaUIsRUFBakI7QUFGUyxLQUROLFlBQVA7QUFNRCxHQTVhSDs7QUFBQSxTQThhRSxXQTlhRixHQThhRSxxQkFBYSxVQUFiLEVBQXlCO0FBQUE7O0FBQ3ZCLFFBQU0sVUFBVSxHQUFHLFVBQVUsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFOLENBQXhCLEdBQW9DLFVBQVUsQ0FBQyxLQUFLLEVBQU4sQ0FBOUMsR0FBMEQsRUFBN0U7QUFDQSxRQUFNLGtCQUFrQixHQUFHLFVBQVUsQ0FBQyxVQUFYLElBQXlCLEVBQXBEO0FBQ0EsUUFBTSxpQkFBaUIsR0FBRyxVQUFVLENBQUMsaUJBQVgsSUFBZ0MsRUFBMUQ7O0FBRUEsUUFBSSxNQUFNLENBQUMsSUFBUCxDQUFZLGlCQUFaLEVBQStCLE1BQS9CLEtBQTBDLENBQTlDLEVBQWlEO0FBQy9DO0FBQ0E7QUFDRCxLQVJzQixDQVV2Qjs7O0FBQ0EsUUFBTSxZQUFZLEdBQUcsU0FBZixZQUFlLENBQUMsVUFBRCxFQUFnQjtBQUNuQyxVQUFNLEtBQUssR0FBRyxFQUFkO0FBQ0EsVUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFDQSxNQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksVUFBWixFQUF3QixPQUF4QixDQUFnQyxVQUFDLEVBQUQsRUFBUTtBQUN0QyxZQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsRUFBRCxDQUF6QjtBQUVBLFFBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxPQUFmLENBQXVCLFVBQUMsWUFBRCxFQUFrQjtBQUN2QyxjQUFNLElBQUksR0FBRyxPQUFJLENBQUMsU0FBTCxDQUFlLFlBQWYsQ0FBYjs7QUFDQSxVQUFBLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBZCxDQUFMLEdBQXlCO0FBQ3ZCLFlBQUEsRUFBRSxFQUFFLElBQUksQ0FBQyxFQURjO0FBRXZCLFlBQUEsUUFBUSxFQUFFLEVBRmE7QUFHdkIsWUFBQSxZQUFZLEVBQVo7QUFIdUIsV0FBekI7QUFLRCxTQVBEOztBQVNBLFlBQU0sS0FBSyxHQUFHLE9BQUksQ0FBQyxjQUFMLEVBQWQ7O0FBQ0EsUUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE1BQU0sQ0FBQyxPQUFuQixFQUE0QixPQUE1QixDQUFvQyxVQUFDLFFBQUQsRUFBYztBQUNoRCxVQUFBLE1BQU0sQ0FBQyxPQUFQLENBQWUsUUFBZixFQUF5QixPQUF6QixDQUFpQyxVQUFDLE1BQUQsRUFBWTtBQUMzQyxnQkFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLEtBQU4sQ0FBWSxNQUFNLENBQUMsV0FBbkIsQ0FBYjtBQUNBLFlBQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFSLEdBQWEsSUFBbEM7QUFDQSxZQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWE7QUFDWCxjQUFBLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFEQTtBQUVYLGNBQUEsTUFBTSxFQUFOLE1BRlc7QUFHWCxjQUFBLFFBQVEsRUFBUixRQUhXO0FBSVgsY0FBQSxRQUFRLEVBQUU7QUFKQyxhQUFiO0FBTUQsV0FURDtBQVVELFNBWEQ7QUFZRCxPQXpCRDs7QUEyQkEsTUFBQSxPQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQixRQUFBLFVBQVUsRUFBVixVQURrQjtBQUVsQixRQUFBLEtBQUssRUFBTCxLQUZrQjtBQUdsQixRQUFBLE9BQU8sRUFBUCxPQUhrQjtBQUlsQixRQUFBLGlCQUFpQixFQUFqQjtBQUprQixPQUFwQjtBQU1ELEtBcENELENBWHVCLENBaUR2Qjs7O0FBQ0EsUUFBTSxpQkFBaUIsR0FBRyxTQUFwQixpQkFBb0IsR0FBTTtBQUFBLGtDQUNZLE9BQUksQ0FBQyxjQUFMLEVBRFo7QUFBQSxVQUN0QixVQURzQix5QkFDdEIsVUFEc0I7QUFBQSxVQUNWLGlCQURVLHlCQUNWLGlCQURVLEVBRzlCOzs7QUFDQSxNQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksaUJBQVosRUFBK0IsT0FBL0IsQ0FBdUMsVUFBQyxRQUFELEVBQWM7QUFDbkQsWUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsUUFBRCxDQUFyQztBQUNBLFlBQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxNQUFaLENBQW1CLFVBQUMsR0FBRCxFQUFNLFVBQU4sRUFBcUI7QUFDOUQsY0FBTSxpQkFBaUIsR0FBRyxPQUFJLENBQUMsZ0JBQUwsQ0FBc0IsVUFBdEIsRUFBa0MsR0FBbEMsQ0FBc0MsVUFBQyxJQUFEO0FBQUEsbUJBQVUsSUFBSSxDQUFDLEVBQWY7QUFBQSxXQUF0QyxDQUExQjs7QUFDQSxVQUFBLEdBQUcsQ0FBQyxJQUFKLE9BQUEsR0FBRyxFQUFTLGlCQUFULENBQUg7QUFDQSxpQkFBTyxHQUFQO0FBQ0QsU0FKdUIsRUFJckIsRUFKcUIsQ0FBeEI7O0FBS0EsUUFBQSxPQUFJLENBQUMsc0JBQUwsQ0FBNEIsV0FBNUIsRUFBeUMsZUFBekMsRUFBMEQsUUFBMUQ7QUFDRCxPQVJEO0FBVUEsVUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxVQUFaLENBQXZCO0FBQ0EsTUFBQSxjQUFjLENBQUMsT0FBZixDQUF1QixVQUFDLEVBQUQsRUFBUTtBQUM3QixZQUFNLFFBQVEsR0FBRyxJQUFJLFFBQUosQ0FBYSxVQUFVLENBQUMsRUFBRCxDQUF2QixDQUFqQjs7QUFDQSxRQUFBLE9BQUksQ0FBQyxnQkFBTCxDQUFzQixRQUF0QjtBQUNELE9BSEQ7QUFJRCxLQW5CRCxDQWxEdUIsQ0F1RXZCOzs7QUFDQSxRQUFNLGdCQUFnQixHQUFHLFNBQW5CLGdCQUFtQixHQUFNO0FBQUEsbUNBQ04sT0FBSSxDQUFDLGNBQUwsRUFETTtBQUFBLFVBQ3JCLFVBRHFCLDBCQUNyQixVQURxQjs7QUFFN0IsYUFBTyxPQUFPLENBQUMsR0FBUixDQUNMLE1BQU0sQ0FBQyxJQUFQLENBQVksVUFBWixFQUF3QixHQUF4QixDQUE0QixVQUFDLEVBQUQsRUFBUTtBQUNsQyxlQUFPLE9BQUksQ0FBQyxnQkFBTCxDQUFzQixFQUF0QixFQUEwQixNQUExQixFQUFQO0FBQ0QsT0FGRCxDQURLLENBQVA7QUFLRCxLQVBELENBeEV1QixDQWlGdkI7OztBQUNBLFNBQUssUUFBTCxHQUFnQixPQUFPLENBQUMsT0FBUixHQUFrQixJQUFsQixDQUF1QixZQUFNO0FBQzNDLE1BQUEsWUFBWSxDQUFDLGtCQUFELENBQVo7QUFDQSxNQUFBLGlCQUFpQjtBQUNqQixhQUFPLGdCQUFnQixFQUF2QjtBQUNELEtBSmUsQ0FBaEI7QUFNQSxTQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFlBQU07QUFDdkIsTUFBQSxPQUFJLENBQUMsUUFBTCxHQUFnQixJQUFoQjtBQUNELEtBRkQ7QUFHRCxHQXpnQkg7O0FBQUEsU0EyZ0JFLGdCQTNnQkYsR0EyZ0JFLDBCQUFrQixRQUFsQixFQUE0QjtBQUFBOztBQUFBLFFBQ2xCLE1BRGtCLEdBQ1AsUUFETyxDQUNsQixNQURrQjtBQUUxQixRQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsV0FBbEI7QUFDQSxTQUFLLGdCQUFMLENBQXNCLEVBQXRCLElBQTRCLFFBQTVCLENBSDBCLENBSzFCOztBQUNBLElBQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxRQUFaLEVBQXNCLFVBQUMsU0FBRCxFQUFlO0FBQUE7O0FBQUEsa0NBQ1osT0FBSSxDQUFDLGNBQUwsRUFEWTtBQUFBLFVBQzNCLFVBRDJCLHlCQUMzQixVQUQyQjs7QUFFbkMsTUFBQSxPQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQixRQUFBLFVBQVUsZUFDTCxVQURLLDZCQUVQLEVBRk8sSUFFRixTQUZFO0FBRFEsT0FBcEI7QUFNRCxLQVJEO0FBVUEsSUFBQSxRQUFRLENBQUMsRUFBVCxDQUFZLFFBQVosRUFBc0IsVUFBQyxJQUFELEVBQVU7QUFDOUIsTUFBQSxPQUFJLENBQUMscUJBQUwsQ0FBMkIsRUFBM0IsRUFBK0IsSUFBL0I7QUFDRCxLQUZEO0FBR0EsSUFBQSxRQUFRLENBQUMsRUFBVCxDQUFZLE9BQVosRUFBcUIsVUFBQyxLQUFELEVBQVc7QUFDOUIsTUFBQSxLQUFLLENBQUMsUUFBTixHQUFpQixRQUFRLENBQUMsTUFBMUI7O0FBQ0EsTUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSw0QkFBZixFQUE2QyxRQUFRLENBQUMsTUFBdEQsRUFBOEQsS0FBOUQ7QUFDRCxLQUhEO0FBS0EsSUFBQSxRQUFRLENBQUMsRUFBVCxDQUFZLFdBQVosRUFBeUIsWUFBTTtBQUM3QixNQUFBLE9BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGdDQUFmLEVBQWlELFFBQVEsQ0FBQyxNQUExRDtBQUNELEtBRkQ7O0FBSUEsUUFBSSxLQUFLLElBQUwsQ0FBVSxlQUFkLEVBQStCO0FBQzdCLE1BQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxRQUFaLEVBQXNCLFVBQUMsUUFBRCxFQUFXLE1BQVgsRUFBc0I7QUFDMUMsUUFBQSxPQUFJLENBQUMsU0FBTCxDQUFlLEVBQWYsRUFBbUIsUUFBbkIsRUFBNkIsTUFBN0I7QUFDRCxPQUZEO0FBR0Q7O0FBRUQsUUFBSSxLQUFLLElBQUwsQ0FBVSxlQUFkLEVBQStCO0FBQzdCLE1BQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxVQUFaLEVBQXdCLFlBQU07QUFDNUIsUUFBQSxPQUFJLENBQUMsbUJBQUwsQ0FBeUIsUUFBUSxDQUFDLE1BQWxDO0FBQ0QsT0FGRDtBQUdELEtBSkQsTUFJTyxJQUFJLEtBQUssSUFBTCxDQUFVLGVBQWQsRUFBK0I7QUFDcEMsTUFBQSxRQUFRLENBQUMsRUFBVCxDQUFZLFVBQVosRUFBd0IsWUFBTTtBQUM1QixRQUFBLE9BQUksQ0FBQyxtQkFBTCxDQUF5QixRQUFRLENBQUMsTUFBbEM7QUFDRCxPQUZEO0FBR0QsS0ExQ3lCLENBNEMxQjs7O0FBQ0EsUUFBSSxRQUFRLENBQUMsRUFBVCxLQUFnQixtQkFBcEIsRUFBeUM7QUFDdkMsYUFBTyxRQUFQO0FBQ0QsS0EvQ3lCLENBaUQxQjtBQUNBOzs7QUFDQSxRQUFNLFNBQVMsR0FBRyxJQUFJLE9BQUosQ0FBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCO0FBQ2pELE1BQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxTQUFkLEVBQXlCLE9BQXpCO0FBQ0EsTUFBQSxRQUFRLENBQUMsSUFBVCxDQUFjLFFBQWQsRUFBd0IsT0FBeEI7QUFDQSxNQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsT0FBZCxFQUF1QixNQUF2QjtBQUNELEtBSmlCLEVBSWYsSUFKZSxDQUlWLFlBQU07QUFDWixNQUFBLE9BQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFjLCtCQUFkO0FBQ0QsS0FOaUIsQ0FBbEI7QUFRQSxJQUFBLFFBQVEsQ0FBQyxPQUFUO0FBQ0EsV0FBTyxRQUFQO0FBQ0QsR0F4a0JIOztBQUFBLFNBMGtCRSxjQTFrQkYsR0Ewa0JFLHdCQUFnQixPQUFoQixFQUF5QixRQUF6QixFQUFtQztBQUFBO0FBQUE7O0FBQ2pDO0FBQ0EsSUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQVIsQ0FBZSxVQUFDLElBQUQ7QUFBQSxhQUFVLENBQUMsSUFBSSxDQUFDLEtBQWhCO0FBQUEsS0FBZixDQUFWO0FBRUEsSUFBQSxPQUFPLENBQUMsT0FBUixDQUFnQixVQUFDLE1BQUQsRUFBWTtBQUMxQixVQUFNLElBQUksR0FBRyxPQUFJLENBQUMsSUFBTCxDQUFVLE9BQVYsQ0FBa0IsTUFBbEIsQ0FBYjs7QUFDQSxNQUFBLE9BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLHFCQUFmLEVBQXNDLElBQXRDLEVBQTRDO0FBQzFDLFFBQUEsSUFBSSxFQUFFLGVBRG9DO0FBRTFDLFFBQUEsT0FBTyxFQUFFLE9BQUksQ0FBQyxJQUFMLENBQVUsa0JBQVY7QUFGaUMsT0FBNUM7QUFJRCxLQU5EOztBQVFBLFFBQU0sY0FBYyxHQUFHLFNBQWpCLGNBQWlCLE9BQTBCO0FBQUEsVUFBdkIsT0FBdUIsUUFBdkIsT0FBdUI7QUFBQSxVQUFkLE9BQWMsUUFBZCxPQUFjO0FBQy9DLFVBQUksZUFBSjtBQUNBLGFBQU8sT0FBSSxDQUFDLGVBQUwsQ0FBcUIsT0FBckIsRUFBOEIsUUFBOUIsRUFBd0MsT0FBeEMsRUFBaUQsSUFBakQsQ0FBc0QsVUFBQyxRQUFELEVBQWM7QUFDekUsUUFBQSxlQUFlLEdBQUcsUUFBbEI7O0FBQ0EsWUFBSSxPQUFJLENBQUMsSUFBTCxDQUFVLG9CQUFkLEVBQW9DO0FBQ2xDLGlCQUFPLE9BQUksQ0FBQyxhQUFMLENBQW1CLFFBQW5CLEVBQTZCLE9BQTdCLENBQVA7QUFDRDtBQUNGLE9BTE0sRUFLSixJQUxJLENBS0MsWUFBTTtBQUNaLFFBQUEsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsVUFBQyxNQUFELEVBQVk7QUFDMUIsY0FBTSxJQUFJLEdBQUcsT0FBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLE1BQWxCLENBQWI7O0FBQ0EsVUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxxQkFBZixFQUFzQyxJQUF0QztBQUNELFNBSEQ7QUFJQSxlQUFPLGVBQVA7QUFDRCxPQVhNLEVBV0osS0FYSSxDQVdFLFVBQUMsR0FBRCxFQUFTO0FBQ2hCLFFBQUEsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsVUFBQyxNQUFELEVBQVk7QUFDMUIsY0FBTSxJQUFJLEdBQUcsT0FBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLE1BQWxCLENBQWIsQ0FEMEIsQ0FFMUI7QUFDQTs7O0FBQ0EsVUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxxQkFBZixFQUFzQyxJQUF0Qzs7QUFDQSxVQUFBLE9BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGNBQWYsRUFBK0IsSUFBL0IsRUFBcUMsR0FBckM7QUFDRCxTQU5EO0FBT0EsY0FBTSxHQUFOO0FBQ0QsT0FwQk0sQ0FBUDtBQXFCRCxLQXZCRDs7QUFaaUMsZ0NBcUNILEtBQUssY0FBTCxFQXJDRztBQUFBLFFBcUN6QixpQkFyQ3lCLHlCQXFDekIsaUJBckN5Qjs7QUFzQ2pDLFNBQUssY0FBTCxDQUFvQjtBQUNsQixNQUFBLGlCQUFpQixlQUNaLGlCQURZLDZCQUVkLFFBRmMsSUFFSCxFQUZHO0FBREMsS0FBcEI7QUFPQSxRQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsR0FBUixDQUFZLFVBQUMsRUFBRDtBQUFBLGFBQVEsT0FBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLEVBQWxCLENBQVI7QUFBQSxLQUFaLENBQWQ7QUFDQSxRQUFNLGVBQWUsR0FBRyxJQUFJLGVBQUosQ0FBb0IsS0FBcEIsRUFBMkIsS0FBSyxJQUFoQyxDQUF4QjtBQUVBLFdBQU8sZUFBZSxDQUFDLEtBQWhCLEdBQXdCLElBQXhCLENBQ0wsVUFBQyxVQUFEO0FBQUEsYUFBZ0IsT0FBTyxDQUFDLEdBQVIsQ0FDZCxVQUFVLENBQUMsR0FBWCxDQUFlLGNBQWYsQ0FEYyxFQUVkLElBRmMsQ0FFVCxVQUFDLGlCQUFELEVBQXVCO0FBQzVCLFlBQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLEdBQWxCLENBQXNCLFVBQUEsUUFBUTtBQUFBLGlCQUFJLFFBQVEsQ0FBQyxNQUFULENBQWdCLFdBQXBCO0FBQUEsU0FBOUIsQ0FBcEI7O0FBQ0EsUUFBQSxPQUFJLENBQUMsc0JBQUwsQ0FBNEIsV0FBNUIsRUFBeUMsT0FBekMsRUFBa0QsUUFBbEQ7O0FBQ0EsUUFBQSxpQkFBaUIsQ0FBQyxHQUFsQixDQUFzQixVQUFBLFFBQVE7QUFBQSxpQkFBSSxPQUFJLENBQUMsZ0JBQUwsQ0FBc0IsUUFBdEIsQ0FBSjtBQUFBLFNBQTlCO0FBQ0QsT0FOZSxDQUFoQjtBQUFBLEtBREssRUFRTDtBQUNBO0FBQ0EsY0FBQyxHQUFELEVBQVM7QUFDUCxNQUFBLE9BQU8sQ0FBQyxPQUFSLENBQWdCLFVBQUMsTUFBRCxFQUFZO0FBQzFCLFlBQU0sSUFBSSxHQUFHLE9BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFiOztBQUNBLFFBQUEsT0FBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUscUJBQWYsRUFBc0MsSUFBdEM7O0FBQ0EsUUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEdBQXJDO0FBQ0QsT0FKRDtBQUtBLFlBQU0sR0FBTjtBQUNELEtBakJJLENBQVA7QUFtQkQsR0E3b0JIOztBQUFBLFNBK29CRSxZQS9vQkYsR0Erb0JFLHNCQUFjLE9BQWQsRUFBdUIsUUFBdkIsRUFBaUM7QUFBQTs7QUFDL0IsUUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEdBQVIsQ0FBWSxVQUFBLE1BQU07QUFBQSxhQUFJLE9BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFKO0FBQUEsS0FBbEIsQ0FBZCxDQUQrQixDQUUvQjs7QUFDQSxJQUFBLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTixDQUFhLFVBQUMsSUFBRDtBQUFBLGFBQVUsQ0FBQyxJQUFJLENBQUMsS0FBaEI7QUFBQSxLQUFiLEVBQW9DLEdBQXBDLENBQXdDLFVBQUEsSUFBSTtBQUFBLGFBQUksSUFBSSxDQUFDLEVBQVQ7QUFBQSxLQUE1QyxDQUFWO0FBRUEsUUFBTSxLQUFLLEdBQUcsS0FBSyxjQUFMLEVBQWQsQ0FMK0IsQ0FPL0I7O0FBQ0EsUUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDakIsYUFBTyxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFlBQU07QUFDOUIsZUFBTyxPQUFJLENBQUMsWUFBTCxDQUFrQixPQUFsQixFQUEyQixRQUEzQixDQUFQO0FBQ0QsT0FGTSxDQUFQO0FBR0Q7O0FBRUQsUUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLGlCQUFOLENBQXdCLFFBQXhCLENBQXBCOztBQUVBLFFBQU0sc0JBQXNCLEdBQUcsU0FBekIsc0JBQXlCLEdBQU07QUFDbkMsTUFBQSxXQUFXLENBQUMsT0FBWixDQUFvQixVQUFDLFVBQUQsRUFBZ0I7QUFDbEMsWUFBTSxRQUFRLEdBQUcsT0FBSSxDQUFDLGdCQUFMLENBQXNCLFVBQXRCLENBQWpCO0FBQ0EsUUFBQSxRQUFRLENBQUMsS0FBVDtBQUNBLGVBQU8sT0FBSSxDQUFDLGdCQUFMLENBQXNCLFVBQXRCLENBQVA7QUFDRCxPQUpEO0FBS0QsS0FORCxDQWhCK0IsQ0F3Qi9CO0FBQ0E7OztBQUNBLFFBQUksQ0FBQyxLQUFLLHNCQUFMLEVBQUwsRUFBb0M7QUFDbEMsTUFBQSxzQkFBc0I7QUFDdEIsVUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLEdBQVosQ0FBZ0IsVUFBQyxFQUFEO0FBQUEsZUFBUSxPQUFJLENBQUMsV0FBTCxDQUFpQixFQUFqQixDQUFSO0FBQUEsT0FBaEIsQ0FBbkI7QUFDQSxXQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLFFBQXhCLEVBQWtDO0FBQUUsUUFBQSxXQUFXLEVBQUU7QUFBZixPQUFsQztBQUNBLGFBQU8sT0FBTyxDQUFDLE9BQVIsRUFBUDtBQUNELEtBL0I4QixDQWlDL0I7QUFDQTs7O0FBQ0EsUUFBSSxXQUFXLENBQUMsTUFBWixLQUF1QixDQUEzQixFQUE4QjtBQUM1QixXQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLFFBQXhCLEVBQWtDO0FBQUUsUUFBQSxXQUFXLEVBQUU7QUFBZixPQUFsQztBQUNBLGFBQU8sT0FBTyxDQUFDLE9BQVIsRUFBUDtBQUNEOztBQUVELFFBQU0sZUFBZSxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsVUFBQSxJQUFJO0FBQUEsYUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFJLENBQUMsY0FBTixFQUFzQixJQUFJLENBQUMsRUFBM0IsQ0FBaEI7QUFBQSxLQUFqQixDQUF4QjtBQUNBLElBQUEsZUFBZSxDQUFDLE9BQWhCLENBQXdCLFVBQUMsSUFBRCxFQUFVO0FBQ2hDLE1BQUEsT0FBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsc0JBQWYsRUFBdUMsSUFBdkMsRUFBNkM7QUFDM0MsUUFBQSxJQUFJLEVBQUUsZUFEcUM7QUFFM0MsUUFBQSxPQUFPLEVBQUUsT0FBSSxDQUFDLElBQUwsQ0FBVSxVQUFWO0FBRmtDLE9BQTdDO0FBSUQsS0FMRDtBQU9BLFFBQU0sT0FBTyxHQUFHLEtBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsQ0FBaEI7QUFDQSxXQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLElBQWhCLENBQXFCLFlBQU07QUFDaEMsTUFBQSxzQkFBc0I7QUFFdEIsVUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLEdBQVosQ0FBZ0IsVUFBQyxFQUFEO0FBQUEsZUFBUSxPQUFJLENBQUMsV0FBTCxDQUFpQixFQUFqQixDQUFSO0FBQUEsT0FBaEIsQ0FBbkIsQ0FIZ0MsQ0FLaEM7QUFDQTs7QUFDQSxVQUFNLEtBQUssR0FBRyxPQUFJLENBQUMsY0FBTCxFQUFkOztBQUNBLFVBQU0saUJBQWlCLGdCQUFRLEtBQUssQ0FBQyxpQkFBZCxDQUF2Qjs7QUFDQSxhQUFPLGlCQUFpQixDQUFDLFFBQUQsQ0FBeEI7O0FBQ0EsTUFBQSxPQUFJLENBQUMsY0FBTCxDQUFvQjtBQUFFLFFBQUEsaUJBQWlCLEVBQWpCO0FBQUYsT0FBcEI7O0FBRUEsTUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLGFBQVYsQ0FBd0IsUUFBeEIsRUFBa0M7QUFDaEMsUUFBQSxXQUFXLEVBQUU7QUFEbUIsT0FBbEM7QUFHRCxLQWZNLENBQVA7QUFnQkQsR0FodEJIOztBQUFBLFNBa3RCRSxRQWx0QkYsR0FrdEJFLGtCQUFVLEdBQVYsRUFBc0IsUUFBdEIsRUFBZ0M7QUFBQTs7QUFBQSxRQUF0QixHQUFzQjtBQUF0QixNQUFBLEdBQXNCLEdBQWhCLElBQWdCO0FBQUE7O0FBQzlCLFFBQU0sS0FBSyxHQUFHLEtBQUssY0FBTCxFQUFkO0FBQ0EsUUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLGlCQUFOLENBQXdCLFFBQXhCLENBQXBCO0FBRUEsSUFBQSxXQUFXLENBQUMsT0FBWixDQUFvQixVQUFDLFVBQUQsRUFBZ0I7QUFDbEMsVUFBSSxPQUFJLENBQUMsZ0JBQUwsQ0FBc0IsVUFBdEIsQ0FBSixFQUF1QztBQUNyQyxRQUFBLE9BQUksQ0FBQyxnQkFBTCxDQUFzQixVQUF0QixFQUFrQyxLQUFsQztBQUNEO0FBQ0YsS0FKRDtBQUtELEdBM3RCSDs7QUFBQSxTQTZ0QkUsV0E3dEJGLEdBNnRCRSxxQkFBYSxHQUFiLEVBQWtCO0FBQ2hCLFFBQUksR0FBRyxJQUFJLFNBQVMsSUFBVCxDQUFjLEdBQUcsQ0FBQyxPQUFsQixDQUFYLEVBQXVDO0FBQ3JDLFVBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxlQUFKLEdBQXNCLEdBQUcsQ0FBQyxlQUFKLENBQW9CLG1CQUFwQixFQUF0QixHQUFrRSxJQUE5RTtBQUNBLFVBQU0sR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsV0FBWCxHQUF5QixHQUFHLENBQUMsV0FBN0IsR0FBMkMsSUFBdkQ7QUFDQSxXQUFLLE1BQUwsQ0FBWSxXQUFaLENBQXdCLEdBQXhCLEVBQTZCO0FBQUUsUUFBQSxHQUFHLEVBQUgsR0FBRjtBQUFPLFFBQUEsSUFBSSxFQUFFO0FBQWIsT0FBN0IsRUFBeUQsSUFBekQsQ0FBOEQsVUFBQyxDQUFELEVBQU8sQ0FDbkU7QUFDRCxPQUZEO0FBR0Q7QUFDRixHQXJ1Qkg7O0FBQUEsU0F1dUJFLE9BdnVCRixHQXV1QkUsbUJBQVc7QUFDVCxTQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLEtBQUssY0FBL0I7QUFDQSxTQUFLLElBQUwsQ0FBVSxnQkFBVixDQUEyQixLQUFLLFlBQWhDLEVBRlMsQ0FJVDs7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsT0FBYixFQUFzQixLQUFLLFFBQTNCLEVBTFMsQ0FPVDs7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsWUFBYixFQUEyQixLQUFLLFlBQWhDLEVBUlMsQ0FVVDs7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsY0FBYixFQUE2QixLQUFLLFdBQWxDOztBQUVBLFFBQUksS0FBSyxJQUFMLENBQVUsb0JBQWQsRUFBb0M7QUFDbEM7QUFDQSxXQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsZ0JBQWIsRUFBK0IsS0FBSyx5QkFBcEM7QUFDRCxLQUhELE1BR087QUFDTCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxFQUFtQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFBLDJCQUEyQixFQUFFLEtBVlo7QUFXakIsUUFBQSxNQUFNLEVBQUUsS0FYUztBQVlqQjtBQUNBO0FBQ0EsUUFBQSxrQkFBa0IsRUFBRSxLQWRIO0FBZWpCO0FBQ0EsUUFBQSxVQUFVLEVBQUUsQ0FBQyxjQUFELEVBQWlCLFVBQWpCLEVBQTZCLFdBQTdCLENBaEJLO0FBaUJqQjtBQUNBLFFBQUEsS0FBSyxFQUFFLEtBQUssSUFBTCxDQUFVO0FBbEJBLE9BQW5CO0FBb0JEOztBQUVELFNBQUssSUFBTCxDQUFVLEVBQVYsQ0FBYSxrQkFBYixFQUFpQyxLQUFLLGtCQUF0QztBQUNBLFNBQUssSUFBTCxDQUFVLEVBQVYsQ0FBYSxVQUFiLEVBQXlCLEtBQUssV0FBOUI7QUFFQSxTQUFLLGNBQUwsQ0FBb0I7QUFDbEI7QUFDQSxNQUFBLFVBQVUsRUFBRSxFQUZNO0FBR2xCO0FBQ0EsTUFBQSxpQkFBaUIsRUFBRSxFQUpEO0FBS2xCO0FBQ0EsTUFBQSxLQUFLLEVBQUUsRUFOVztBQU9sQjtBQUNBLE1BQUEsT0FBTyxFQUFFO0FBUlMsS0FBcEIsRUExQ1MsQ0FxRFQ7O0FBckRTLDhCQXNEZ0IsS0FBSyxJQUFMLENBQVUsUUFBVixFQXREaEI7QUFBQSxRQXNERCxZQXREQyx1QkFzREQsWUF0REM7O0FBdURULFNBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUI7QUFDakIsTUFBQSxZQUFZLGVBQ1AsWUFETztBQUVWLFFBQUEsc0JBQXNCLEVBQUU7QUFGZDtBQURLLEtBQW5CO0FBTUQsR0FweUJIOztBQUFBLFNBc3lCRSxTQXR5QkYsR0FzeUJFLHFCQUFhO0FBQ1gsU0FBSyxJQUFMLENBQVUsa0JBQVYsQ0FBNkIsS0FBSyxjQUFsQztBQUNBLFNBQUssSUFBTCxDQUFVLG1CQUFWLENBQThCLEtBQUssWUFBbkM7QUFDQSxTQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsT0FBZCxFQUF1QixLQUFLLFFBQTVCOztBQUVBLFFBQUksS0FBSyxJQUFMLENBQVUsb0JBQWQsRUFBb0M7QUFDbEMsV0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLGdCQUFkLEVBQWdDLEtBQUsseUJBQXJDO0FBQ0Q7O0FBUFUsK0JBU2MsS0FBSyxJQUFMLENBQVUsUUFBVixFQVRkO0FBQUEsUUFTSCxZQVRHLHdCQVNILFlBVEc7O0FBVVgsU0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQjtBQUNqQixNQUFBLFlBQVksZUFDUCxZQURPO0FBRVYsUUFBQSxzQkFBc0IsRUFBRTtBQUZkO0FBREssS0FBbkI7QUFNRCxHQXR6Qkg7O0FBQUEsU0F3ekJFLFdBeHpCRixHQXd6QkUscUJBQWEsRUFBYixFQUFpQjtBQUFBLGdDQUNRLEtBQUssY0FBTCxFQURSO0FBQUEsUUFDUCxVQURPLHlCQUNQLFVBRE87O0FBRWYsV0FBTyxVQUFVLENBQUMsRUFBRCxDQUFqQjtBQUNELEdBM3pCSDs7QUFBQSxTQTZ6QkUsZ0JBN3pCRixHQTZ6QkUsMEJBQWtCLFVBQWxCLEVBQThCO0FBQzVCLFdBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixHQUFxQixNQUFyQixDQUE0QixVQUFDLElBQUQsRUFBVTtBQUMzQyxhQUFPLElBQUksSUFBSSxJQUFJLENBQUMsV0FBYixJQUE0QixJQUFJLENBQUMsV0FBTCxDQUFpQixRQUFqQixLQUE4QixVQUFqRTtBQUNELEtBRk0sQ0FBUDtBQUdELEdBajBCSDs7QUFBQTtBQUFBLEVBQTJDLE1BQTNDLFVBQ1MsT0FEVCxHQUNtQixPQUFPLENBQUMsaUJBQUQsQ0FBUCxDQUEyQixPQUQ5QztBQW8wQkEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxTQUFmLEdBQTJCLFNBQTNCO0FBQ0EsTUFBTSxDQUFDLE9BQVAsQ0FBZSxXQUFmLEdBQTZCLFNBQTdCO0FBQ0EsTUFBTSxDQUFDLE9BQVAsQ0FBZSxpQkFBZixHQUFtQyx5QkFBbkM7OztBQ2oyQkEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxRQUFULENBQW1CLEdBQW5CLEVBQXdCO0FBQ3ZDLE1BQU0sTUFBTSxHQUFHLFlBQVksSUFBWixDQUFpQixHQUFqQixDQUFmO0FBQ0EsTUFBSSxDQUFDLEdBQUcsQ0FBUjs7QUFDQSxNQUFJLE1BQUosRUFBWTtBQUNWLElBQUEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxNQUFWLEdBQW1CLENBQXZCO0FBQ0Q7O0FBQ0QsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDLE9BQUosQ0FBWSxHQUFaLEVBQWlCLENBQWpCLENBQW5COztBQUNBLE1BQUksVUFBVSxLQUFLLENBQUMsQ0FBcEIsRUFBdUI7QUFDckIsV0FBTztBQUNMLE1BQUEsTUFBTSxFQUFFLEdBREg7QUFFTCxNQUFBLFFBQVEsRUFBRTtBQUZMLEtBQVA7QUFJRDs7QUFFRCxTQUFPO0FBQ0wsSUFBQSxNQUFNLEVBQUUsR0FBRyxDQUFDLEtBQUosQ0FBVSxDQUFWLEVBQWEsVUFBYixDQURIO0FBRUwsSUFBQSxRQUFRLEVBQUUsR0FBRyxDQUFDLEtBQUosQ0FBVSxVQUFWO0FBRkwsR0FBUDtBQUlELENBbEJEOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBLElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxlQUFELENBQW5COztBQUVBLFNBQVMsU0FBVCxHQUFzQjtBQUNwQixTQUFPLE9BQU8sTUFBUCxLQUFrQixXQUFsQixLQUNMLE9BQU8sTUFBTSxDQUFDLFFBQWQsS0FBMkIsV0FBM0IsSUFDRyxPQUFPLE1BQU0sQ0FBQyxPQUFkLEtBQTBCLFdBRDdCLElBRUcsT0FBTyxNQUFNLENBQUMsT0FBZCxLQUEwQixXQUh4QixDQUFQO0FBS0Q7O0FBRUQsU0FBUyxhQUFULEdBQTBCO0FBQ3hCLFNBQU8sT0FBTyxTQUFQLEtBQXFCLFdBQXJCLElBQ0YsT0FBTyxTQUFTLENBQUMsT0FBakIsS0FBNkIsUUFEM0IsSUFFRixTQUFTLENBQUMsT0FBVixDQUFrQixXQUFsQixPQUFvQyxhQUZ6QztBQUdELEMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLGNBQVQsQ0FBeUIsV0FBekIsRUFBc0M7QUFDckQsU0FBTyxVQUFVLElBQVYsRUFBZ0IsT0FBaEIsRUFBeUI7QUFDOUIsUUFBSSxTQUFTLE1BQU0sYUFBYSxFQUFoQyxFQUFvQztBQUNsQyxhQUFPLEdBQUcsQ0FBQyxjQUFKLENBQW1CLFdBQW5CLENBQStCLElBQS9CLEVBQXFDLE9BQXJDLENBQVA7QUFDRDs7QUFFRCxRQUFNLGVBQWUsR0FBRyxDQUN0QixLQURzQixFQUV0QixXQUFXLENBQUMsRUFGVSxFQUd0QixPQUFPLENBQUMsUUFIYyxFQUl0QixJQUpzQixDQUlqQixHQUppQixDQUF4QjtBQU1BLFdBQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsZUFBaEIsQ0FBUDtBQUNELEdBWkQ7QUFhRCxDQWREOzs7Ozs7Ozs7Ozs7O2VDeEJtQixPQUFPLENBQUMsWUFBRCxDO0lBQWxCLE0sWUFBQSxNOztBQUNSLElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxlQUFELENBQW5COztnQkFDNEMsT0FBTyxDQUFDLHdCQUFELEM7SUFBM0MsUSxhQUFBLFE7SUFBVSxhLGFBQUEsYTtJQUFlLE0sYUFBQSxNOztBQUNqQyxJQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxvQ0FBRCxDQUFsQzs7QUFDQSxJQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsK0JBQUQsQ0FBN0I7O0FBQ0EsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLHdCQUFELENBQXRCOztBQUNBLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyw4QkFBRCxDQUE1Qjs7QUFDQSxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsOEJBQUQsQ0FBNUI7O0FBQ0EsSUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLGdDQUFELENBQTlCOztBQUNBLElBQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLGtDQUFELENBQWhDOztBQUNBLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyw2QkFBRCxDQUEzQjs7QUFDQSxJQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsa0JBQUQsQ0FBOUI7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLElBQU0saUJBQWlCLEdBQUc7QUFDeEIsRUFBQSxRQUFRLEVBQUUsRUFEYztBQUd4QixFQUFBLFNBQVMsRUFBRSxJQUhhO0FBSXhCLEVBQUEsUUFBUSxFQUFFLEVBSmM7QUFLeEIsRUFBQSxVQUFVLEVBQUUsSUFMWTtBQU94QixFQUFBLFVBQVUsRUFBRSxJQVBZO0FBUXhCLEVBQUEsZUFBZSxFQUFFLElBUk87QUFTeEIsRUFBQSxTQUFTLEVBQUUsSUFUYTtBQVV4QixFQUFBLE9BQU8sRUFBRSxJQVZlO0FBWXhCLEVBQUEsbUJBQW1CLEVBQUUsS0FaRztBQWF4QixFQUFBLE9BQU8sRUFBRSxFQWJlO0FBY3hCLEVBQUEsWUFBWSxFQUFFLEtBZFU7QUFnQnhCLEVBQUEsU0FBUyxFQUFFLFFBaEJhO0FBaUJ4QixFQUFBLFdBQVcsRUFBRSxDQUFDLENBQUQsRUFBSSxJQUFKLEVBQVUsSUFBVixFQUFnQixJQUFoQixDQWpCVztBQWtCeEIsRUFBQSxlQUFlLEVBQUUsQ0FsQk87QUFtQnhCLEVBQUEsMkJBQTJCLEVBQUUsSUFuQkw7QUFvQnhCLEVBQUEsMEJBQTBCLEVBQUUsS0FwQko7QUFxQnhCLEVBQUEsb0JBQW9CLEVBQUUsS0FyQkU7QUFzQnhCLEVBQUEsd0JBQXdCLEVBQUU7QUF0QkYsQ0FBMUI7QUF5QkE7QUFDQTtBQUNBOztBQUNBLE1BQU0sQ0FBQyxPQUFQO0FBQUE7O0FBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDRSxlQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUI7QUFBQTs7QUFDdkIsK0JBQU0sSUFBTixFQUFZLElBQVo7QUFDQSxVQUFLLElBQUwsR0FBWSxVQUFaO0FBQ0EsVUFBSyxFQUFMLEdBQVUsTUFBSyxJQUFMLENBQVUsRUFBVixJQUFnQixLQUExQjtBQUNBLFVBQUssS0FBTCxHQUFhLEtBQWIsQ0FKdUIsQ0FNdkI7O0FBQ0EsUUFBTSxjQUFjLEdBQUc7QUFDckIsTUFBQSxTQUFTLEVBQUUsSUFEVTtBQUVyQixNQUFBLE1BQU0sRUFBRSxJQUZhO0FBR3JCLE1BQUEsa0JBQWtCLEVBQUUsSUFIQztBQUlyQixNQUFBLEtBQUssRUFBRSxDQUpjO0FBS3JCLE1BQUEsV0FBVyxFQUFFLENBQUMsQ0FBRCxFQUFJLElBQUosRUFBVSxJQUFWLEVBQWdCLElBQWhCLENBTFE7QUFNckIsTUFBQSxlQUFlLEVBQUU7QUFOSSxLQUF2QixDQVB1QixDQWdCdkI7O0FBQ0E7O0FBQ0EsVUFBSyxJQUFMLGdCQUFpQixjQUFqQixFQUFvQyxJQUFwQztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBQ0ksVUFBSyxRQUFMLEdBQWdCLElBQUksZ0JBQUosQ0FBcUIsTUFBSyxJQUFMLENBQVUsS0FBL0IsQ0FBaEI7QUFFQSxVQUFLLFNBQUwsR0FBaUIsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLENBQWpCO0FBQ0EsVUFBSyxjQUFMLEdBQXNCLE1BQU0sQ0FBQyxNQUFQLENBQWMsSUFBZCxDQUF0QjtBQUNBLFVBQUssZUFBTCxHQUF1QixNQUFNLENBQUMsTUFBUCxDQUFjLElBQWQsQ0FBdkI7QUFFQSxVQUFLLG1CQUFMLEdBQTJCLE1BQUssbUJBQUwsQ0FBeUIsSUFBekIsK0JBQTNCO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLE1BQUssWUFBTCxDQUFrQixJQUFsQiwrQkFBcEI7QUFoQ3VCO0FBaUN4Qjs7QUF4Q0g7O0FBQUEsU0EwQ0UsbUJBMUNGLEdBMENFLCtCQUF1QjtBQUNyQixRQUFNLEtBQUssZ0JBQVEsS0FBSyxJQUFMLENBQVUsUUFBVixHQUFxQixLQUE3QixDQUFYOztBQUNBLElBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxLQUFaLEVBQW1CLE9BQW5CLENBQTJCLFVBQUMsTUFBRCxFQUFZO0FBQ3JDO0FBQ0EsVUFBSSxLQUFLLENBQUMsTUFBRCxDQUFMLENBQWMsR0FBZCxJQUFxQixLQUFLLENBQUMsTUFBRCxDQUFMLENBQWMsR0FBZCxDQUFrQixTQUEzQyxFQUFzRDtBQUNwRCxZQUFNLFFBQVEsZ0JBQVEsS0FBSyxDQUFDLE1BQUQsQ0FBTCxDQUFjLEdBQXRCLENBQWQ7O0FBQ0EsZUFBTyxRQUFRLENBQUMsU0FBaEI7QUFDQSxRQUFBLEtBQUssQ0FBQyxNQUFELENBQUwsZ0JBQXFCLEtBQUssQ0FBQyxNQUFELENBQTFCO0FBQW9DLFVBQUEsR0FBRyxFQUFFO0FBQXpDO0FBQ0Q7QUFDRixLQVBEO0FBU0EsU0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQjtBQUFFLE1BQUEsS0FBSyxFQUFMO0FBQUYsS0FBbkI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdEQTs7QUFBQSxTQThERSx1QkE5REYsR0E4REUsaUNBQXlCLE1BQXpCLEVBQWlDLElBQWpDLEVBQTRDO0FBQUEsUUFBWCxJQUFXO0FBQVgsTUFBQSxJQUFXLEdBQUosRUFBSTtBQUFBOztBQUMxQyxRQUFJLEtBQUssU0FBTCxDQUFlLE1BQWYsQ0FBSixFQUE0QjtBQUMxQixVQUFNLFFBQVEsR0FBRyxLQUFLLFNBQUwsQ0FBZSxNQUFmLENBQWpCO0FBQ0EsTUFBQSxRQUFRLENBQUMsS0FBVDs7QUFDQSxVQUFJLElBQUksQ0FBQyxLQUFULEVBQWdCO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBQSxVQUFVLENBQUM7QUFBQSxpQkFBTSxRQUFRLENBQUMsS0FBVCxDQUFlLElBQWYsQ0FBTjtBQUFBLFNBQUQsRUFBNkIsSUFBN0IsQ0FBVjtBQUNEOztBQUNELFdBQUssU0FBTCxDQUFlLE1BQWYsSUFBeUIsSUFBekI7QUFDRDs7QUFDRCxRQUFJLEtBQUssY0FBTCxDQUFvQixNQUFwQixDQUFKLEVBQWlDO0FBQy9CLFdBQUssY0FBTCxDQUFvQixNQUFwQixFQUE0QixNQUE1QjtBQUNBLFdBQUssY0FBTCxDQUFvQixNQUFwQixJQUE4QixJQUE5QjtBQUNEOztBQUNELFFBQUksS0FBSyxlQUFMLENBQXFCLE1BQXJCLENBQUosRUFBa0M7QUFDaEMsV0FBSyxlQUFMLENBQXFCLE1BQXJCLEVBQTZCLEtBQTdCO0FBQ0EsV0FBSyxlQUFMLENBQXFCLE1BQXJCLElBQStCLElBQS9CO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEhBOztBQUFBLFNBbUhFLE1BbkhGLEdBbUhFLGdCQUFRLElBQVIsRUFBYyxPQUFkLEVBQXVCLEtBQXZCLEVBQThCO0FBQUE7O0FBQzVCLFNBQUssdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDLEVBRDRCLENBRzVCOztBQUNBLFdBQU8sSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLEVBQWlDLElBQWpDOztBQUVBLFVBQU0sSUFBSSxnQkFDTCxNQUFJLENBQUMsSUFEQSxFQUVKLElBQUksQ0FBQyxHQUFMLElBQVksRUFGUixDQUFWO0FBS0E7OztBQUNBLFVBQU0sYUFBYSxnQkFDZCxpQkFEYyxFQUdkLElBSGMsQ0FBbkI7O0FBTUEsYUFBTyxhQUFhLENBQUMsTUFBckIsQ0Fmc0MsQ0FpQnRDO0FBQ0E7O0FBQ0EsVUFBSSxJQUFJLENBQUMsTUFBVCxFQUFpQjtBQUNmLFFBQUEsYUFBYSxDQUFDLDJCQUFkLEdBQTRDLElBQTVDO0FBQ0QsT0FyQnFDLENBdUJ0QztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBQSxhQUFhLENBQUMsV0FBZCxHQUE0QixjQUFjLENBQUMsSUFBRCxDQUExQzs7QUFFQSxNQUFBLGFBQWEsQ0FBQyxlQUFkLEdBQWdDLFVBQUMsR0FBRCxFQUFTO0FBQ3ZDLFlBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxtQkFBSixFQUFaO0FBQ0EsUUFBQSxHQUFHLENBQUMsZUFBSixHQUFzQixDQUFDLENBQUMsSUFBSSxDQUFDLGVBQTdCOztBQUVBLFlBQUksT0FBTyxJQUFJLENBQUMsZUFBWixLQUFnQyxVQUFwQyxFQUFnRDtBQUM5QyxVQUFBLElBQUksQ0FBQyxlQUFMLENBQXFCLEdBQXJCO0FBQ0Q7QUFDRixPQVBEOztBQVNBLE1BQUEsYUFBYSxDQUFDLE9BQWQsR0FBd0IsVUFBQyxHQUFELEVBQVM7QUFDL0IsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkOztBQUVBLFlBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxlQUFKLEdBQXNCLEdBQUcsQ0FBQyxlQUFKLENBQW9CLG1CQUFwQixFQUF0QixHQUFrRSxJQUE5RTs7QUFDQSxZQUFJLGNBQWMsQ0FBQyxHQUFELENBQWxCLEVBQXlCO0FBQ3ZCLFVBQUEsR0FBRyxHQUFHLElBQUksWUFBSixDQUFpQixHQUFqQixFQUFzQixHQUF0QixDQUFOO0FBQ0Q7O0FBRUQsUUFBQSxNQUFJLENBQUMsdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDOztBQUNBLFFBQUEsYUFBYSxDQUFDLElBQWQ7O0FBRUEsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEdBQXJDOztBQUVBLFFBQUEsTUFBTSxDQUFDLEdBQUQsQ0FBTjtBQUNELE9BZEQ7O0FBZ0JBLE1BQUEsYUFBYSxDQUFDLFVBQWQsR0FBMkIsVUFBQyxhQUFELEVBQWdCLFVBQWhCLEVBQStCO0FBQ3hELFFBQUEsTUFBSSxDQUFDLGtCQUFMLENBQXdCLElBQXhCLEVBQThCLE1BQU0sQ0FBQyxHQUFyQzs7QUFDQSxRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGlCQUFmLEVBQWtDLElBQWxDLEVBQXdDO0FBQ3RDLFVBQUEsUUFBUSxFQUFFLE1BRDRCO0FBRXRDLFVBQUEsYUFBYSxFQUFiLGFBRnNDO0FBR3RDLFVBQUEsVUFBVSxFQUFWO0FBSHNDLFNBQXhDO0FBS0QsT0FQRDs7QUFTQSxNQUFBLGFBQWEsQ0FBQyxTQUFkLEdBQTBCLFlBQU07QUFDOUIsWUFBTSxVQUFVLEdBQUc7QUFDakIsVUFBQSxTQUFTLEVBQUUsTUFBTSxDQUFDO0FBREQsU0FBbkI7O0FBSUEsUUFBQSxNQUFJLENBQUMsdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDOztBQUNBLFFBQUEsYUFBYSxDQUFDLElBQWQ7O0FBRUEsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxnQkFBZixFQUFpQyxJQUFqQyxFQUF1QyxVQUF2Qzs7QUFFQSxZQUFJLE1BQU0sQ0FBQyxHQUFYLEVBQWdCO0FBQ2QsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsZUFBMEIsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUF0QyxjQUFtRCxNQUFNLENBQUMsR0FBMUQ7QUFDRDs7QUFFRCxRQUFBLE9BQU8sQ0FBQyxNQUFELENBQVA7QUFDRCxPQWZEOztBQWlCQSxVQUFNLFFBQVEsR0FBRyxTQUFYLFFBQVcsQ0FBQyxHQUFELEVBQU0sT0FBTixFQUFlLFFBQWYsRUFBNEI7QUFDM0MsWUFBSSxXQUFXLENBQUMsR0FBRCxFQUFNLE9BQU4sQ0FBWCxJQUE2QixDQUFDLFdBQVcsQ0FBQyxHQUFELEVBQU0sUUFBTixDQUE3QyxFQUE4RDtBQUM1RCxVQUFBLEdBQUcsQ0FBQyxRQUFELENBQUgsR0FBZ0IsR0FBRyxDQUFDLE9BQUQsQ0FBbkI7QUFDRDtBQUNGLE9BSkQ7QUFNQTs7O0FBQ0EsVUFBTSxJQUFJLEdBQUcsRUFBYjtBQUNBLFVBQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBSSxDQUFDLFVBQW5CLElBQ2YsSUFBSSxDQUFDLFVBRFUsQ0FFakI7QUFGaUIsUUFHZixNQUFNLENBQUMsSUFBUCxDQUFZLElBQUksQ0FBQyxJQUFqQixDQUhKO0FBSUEsTUFBQSxVQUFVLENBQUMsT0FBWCxDQUFtQixVQUFDLElBQUQsRUFBVTtBQUMzQixRQUFBLElBQUksQ0FBQyxJQUFELENBQUosR0FBYSxJQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBYjtBQUNELE9BRkQsRUE1RnNDLENBZ0d0Qzs7QUFDQSxNQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlLFVBQWYsQ0FBUjtBQUNBLE1BQUEsUUFBUSxDQUFDLElBQUQsRUFBTyxNQUFQLEVBQWUsVUFBZixDQUFSO0FBRUEsTUFBQSxhQUFhLENBQUMsUUFBZCxHQUF5QixJQUF6QjtBQUVBLFVBQU0sTUFBTSxHQUFHLElBQUksR0FBRyxDQUFDLE1BQVIsQ0FBZSxJQUFJLENBQUMsSUFBcEIsRUFBMEIsYUFBMUIsQ0FBZjtBQUNBLE1BQUEsTUFBSSxDQUFDLFNBQUwsQ0FBZSxJQUFJLENBQUMsRUFBcEIsSUFBMEIsTUFBMUI7QUFDQSxNQUFBLE1BQUksQ0FBQyxjQUFMLENBQW9CLElBQUksQ0FBQyxFQUF6QixJQUErQixJQUFJLFlBQUosQ0FBaUIsTUFBSSxDQUFDLElBQXRCLENBQS9CLENBeEdzQyxDQTBHdEM7QUFDQTs7QUFDQSxVQUFJLElBQUksQ0FBQyxNQUFULEVBQWlCO0FBQ2YsUUFBQSxNQUFNLENBQUMsbUJBQVAsR0FBNkIsSUFBN0IsQ0FBa0MsVUFBQyxlQUFELEVBQXFCO0FBQ3JELGNBQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxDQUFELENBQXRDOztBQUNBLGNBQUksY0FBSixFQUFvQjtBQUNsQixZQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBViwrQkFBMEMsSUFBSSxDQUFDLEVBQS9DLG9CQUFnRSxjQUFjLENBQUMsWUFBL0U7O0FBQ0EsWUFBQSxNQUFNLENBQUMsd0JBQVAsQ0FBZ0MsY0FBaEM7QUFDRDtBQUNGLFNBTkQ7QUFPRDs7QUFFRCxVQUFJLGFBQWEsR0FBRyxNQUFJLENBQUMsUUFBTCxDQUFjLEdBQWQsQ0FBa0IsWUFBTTtBQUMxQyxZQUFJLENBQUMsSUFBSSxDQUFDLFFBQVYsRUFBb0I7QUFDbEI7QUFDQTtBQUNBLFVBQUEsT0FBTyxDQUFDLE9BQVIsR0FBa0IsSUFBbEIsQ0FBdUIsWUFBTTtBQUMzQixZQUFBLE1BQU0sQ0FBQyxLQUFQO0FBQ0QsV0FGRDtBQUdELFNBUHlDLENBUTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsZUFBTyxZQUFNLENBQUUsQ0FBZjtBQUNELE9BZm1CLENBQXBCOztBQWlCQSxNQUFBLE1BQUksQ0FBQyxZQUFMLENBQWtCLElBQUksQ0FBQyxFQUF2QixFQUEyQixVQUFDLFlBQUQsRUFBa0I7QUFDM0MsUUFBQSxhQUFhLENBQUMsS0FBZDs7QUFDQSxRQUFBLE1BQUksQ0FBQyx1QkFBTCxDQUE2QixJQUFJLENBQUMsRUFBbEMsRUFBc0M7QUFBRSxVQUFBLEtBQUssRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQWxCLFNBQXRDOztBQUNBLFFBQUEsT0FBTyxhQUFXLFlBQVgsa0JBQVA7QUFDRCxPQUpEOztBQU1BLE1BQUEsTUFBSSxDQUFDLE9BQUwsQ0FBYSxJQUFJLENBQUMsRUFBbEIsRUFBc0IsVUFBQyxRQUFELEVBQWM7QUFDbEMsWUFBSSxRQUFKLEVBQWM7QUFDWjtBQUNBLFVBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDQSxVQUFBLE1BQU0sQ0FBQyxLQUFQO0FBQ0QsU0FKRCxNQUlPO0FBQ0w7QUFDQSxVQUFBLGFBQWEsQ0FBQyxLQUFkO0FBQ0EsVUFBQSxhQUFhLEdBQUcsTUFBSSxDQUFDLFFBQUwsQ0FBYyxHQUFkLENBQWtCLFlBQU07QUFDdEMsWUFBQSxNQUFNLENBQUMsS0FBUDtBQUNBLG1CQUFPLFlBQU0sQ0FBRSxDQUFmO0FBQ0QsV0FIZSxDQUFoQjtBQUlEO0FBQ0YsT0FiRDs7QUFlQSxNQUFBLE1BQUksQ0FBQyxVQUFMLENBQWdCLElBQUksQ0FBQyxFQUFyQixFQUF5QixZQUFNO0FBQzdCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDQSxRQUFBLE1BQU0sQ0FBQyxLQUFQO0FBQ0QsT0FIRDs7QUFLQSxNQUFBLE1BQUksQ0FBQyxXQUFMLENBQWlCLElBQUksQ0FBQyxFQUF0QixFQUEwQixZQUFNO0FBQzlCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7O0FBQ0EsUUFBQSxNQUFJLENBQUMsdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDLEVBQXNDO0FBQUUsVUFBQSxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUFsQixTQUF0Qzs7QUFDQSxRQUFBLE9BQU8sYUFBVyxJQUFJLENBQUMsRUFBaEIsbUJBQVA7QUFDRCxPQUpEOztBQU1BLE1BQUEsTUFBSSxDQUFDLFdBQUwsQ0FBaUIsSUFBSSxDQUFDLEVBQXRCLEVBQTBCLFlBQU07QUFDOUIsUUFBQSxhQUFhLENBQUMsS0FBZDs7QUFDQSxZQUFJLElBQUksQ0FBQyxLQUFULEVBQWdCO0FBQ2QsVUFBQSxNQUFNLENBQUMsS0FBUDtBQUNEOztBQUNELFFBQUEsYUFBYSxHQUFHLE1BQUksQ0FBQyxRQUFMLENBQWMsR0FBZCxDQUFrQixZQUFNO0FBQ3RDLFVBQUEsTUFBTSxDQUFDLEtBQVA7QUFDQSxpQkFBTyxZQUFNLENBQUUsQ0FBZjtBQUNELFNBSGUsQ0FBaEI7QUFJRCxPQVREO0FBVUQsS0FqTE0sRUFpTEosS0FqTEksQ0FpTEUsVUFBQyxHQUFELEVBQVM7QUFDaEIsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEdBQXJDOztBQUNBLFlBQU0sR0FBTjtBQUNELEtBcExNLENBQVA7QUFxTEQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuVEE7O0FBQUEsU0FvVEUsWUFwVEYsR0FvVEUsc0JBQWMsSUFBZCxFQUFvQixPQUFwQixFQUE2QixLQUE3QixFQUFvQztBQUFBOztBQUNsQyxTQUFLLHVCQUFMLENBQTZCLElBQUksQ0FBQyxFQUFsQzs7QUFFQSxRQUFNLElBQUksZ0JBQVEsS0FBSyxJQUFiLENBQVY7O0FBQ0EsUUFBSSxJQUFJLENBQUMsR0FBVCxFQUFjO0FBQ1o7QUFDQSxlQUFjLElBQWQsRUFBb0IsSUFBSSxDQUFDLEdBQXpCO0FBQ0Q7O0FBRUQsU0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLEVBQWlDLElBQWpDO0FBQ0EsU0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLElBQUksQ0FBQyxNQUFMLENBQVksR0FBMUI7O0FBRUEsUUFBSSxJQUFJLENBQUMsV0FBVCxFQUFzQjtBQUNwQixhQUFPLEtBQUsscUJBQUwsQ0FBMkIsSUFBM0IsQ0FBUDtBQUNEOztBQUVELFdBQU8sSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxVQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFZLGVBQVosQ0FBNEIsUUFBNUIsR0FBdUMsUUFBdkMsR0FBa0QsYUFBakU7QUFDQSxVQUFNLE1BQU0sR0FBRyxJQUFJLE1BQUosQ0FBVyxNQUFJLENBQUMsSUFBaEIsRUFBc0IsSUFBSSxDQUFDLE1BQUwsQ0FBWSxlQUFsQyxDQUFmLENBRnNDLENBSXRDOztBQUNBLE1BQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFJLENBQUMsTUFBTCxDQUFZLEdBQXhCLGVBQ0ssSUFBSSxDQUFDLE1BQUwsQ0FBWSxJQURqQjtBQUVFLFFBQUEsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUZqQjtBQUdFLFFBQUEsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUhsQjtBQUlFLFFBQUEsUUFBUSxFQUFFLEtBSlo7QUFLRSxRQUFBLElBQUksRUFBRSxJQUFJLENBQUMsSUFBTCxDQUFVLElBTGxCO0FBTUUsUUFBQSxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BTmhCO0FBT0UsUUFBQSxRQUFRLEVBQUUsSUFBSSxDQUFDO0FBUGpCLFVBUUcsSUFSSCxDQVFRLFVBQUMsR0FBRCxFQUFTO0FBQ2YsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFlBQVYsQ0FBdUIsSUFBSSxDQUFDLEVBQTVCLEVBQWdDO0FBQUUsVUFBQSxXQUFXLEVBQUUsR0FBRyxDQUFDO0FBQW5CLFNBQWhDOztBQUNBLFFBQUEsSUFBSSxHQUFHLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixJQUFJLENBQUMsRUFBdkIsQ0FBUDtBQUNBLGVBQU8sTUFBSSxDQUFDLHFCQUFMLENBQTJCLElBQTNCLENBQVA7QUFDRCxPQVpELEVBWUcsSUFaSCxDQVlRLFlBQU07QUFDWixRQUFBLE9BQU87QUFDUixPQWRELEVBY0csS0FkSCxDQWNTLFVBQUMsR0FBRCxFQUFTO0FBQ2hCLFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsY0FBZixFQUErQixJQUEvQixFQUFxQyxHQUFyQzs7QUFDQSxRQUFBLE1BQU0sQ0FBQyxHQUFELENBQU47QUFDRCxPQWpCRDtBQWtCRCxLQXZCTSxDQUFQO0FBd0JEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwV0E7O0FBQUEsU0FxV0UscUJBcldGLEdBcVdFLCtCQUF1QixJQUF2QixFQUE2QjtBQUFBOztBQUMzQixXQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDdEMsVUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQW5CO0FBQ0EsVUFBTSxJQUFJLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFMLENBQVksWUFBYixDQUExQjtBQUNBLFVBQU0sTUFBTSxHQUFHLElBQUksTUFBSixDQUFXO0FBQUUsUUFBQSxNQUFNLEVBQUssSUFBTCxhQUFpQixLQUF6QjtBQUFrQyxRQUFBLFFBQVEsRUFBRTtBQUE1QyxPQUFYLENBQWY7QUFDQSxNQUFBLE1BQUksQ0FBQyxlQUFMLENBQXFCLElBQUksQ0FBQyxFQUExQixJQUFnQyxNQUFoQztBQUNBLE1BQUEsTUFBSSxDQUFDLGNBQUwsQ0FBb0IsSUFBSSxDQUFDLEVBQXpCLElBQStCLElBQUksWUFBSixDQUFpQixNQUFJLENBQUMsSUFBdEIsQ0FBL0I7O0FBRUEsTUFBQSxNQUFJLENBQUMsWUFBTCxDQUFrQixJQUFJLENBQUMsRUFBdkIsRUFBMkIsWUFBTTtBQUMvQixRQUFBLGFBQWEsQ0FBQyxLQUFkLEdBRCtCLENBRS9CO0FBQ0E7O0FBQ0EsUUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDQSxRQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksUUFBWixFQUFzQixFQUF0Qjs7QUFDQSxRQUFBLE1BQUksQ0FBQyx1QkFBTCxDQUE2QixJQUFJLENBQUMsRUFBbEM7O0FBQ0EsUUFBQSxPQUFPLGFBQVcsSUFBSSxDQUFDLEVBQWhCLGtCQUFQO0FBQ0QsT0FSRDs7QUFVQSxNQUFBLE1BQUksQ0FBQyxPQUFMLENBQWEsSUFBSSxDQUFDLEVBQWxCLEVBQXNCLFVBQUMsUUFBRCxFQUFjO0FBQ2xDLFlBQUksUUFBSixFQUFjO0FBQ1o7QUFDQSxVQUFBLGFBQWEsQ0FBQyxLQUFkO0FBQ0EsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDRCxTQUpELE1BSU87QUFDTDtBQUNBLFVBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDQSxVQUFBLGFBQWEsR0FBRyxNQUFJLENBQUMsUUFBTCxDQUFjLEdBQWQsQ0FBa0IsWUFBTTtBQUN0QyxZQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksUUFBWixFQUFzQixFQUF0QjtBQUNBLG1CQUFPLFlBQU0sQ0FBRSxDQUFmO0FBQ0QsV0FIZSxDQUFoQjtBQUlEO0FBQ0YsT0FiRDs7QUFlQSxNQUFBLE1BQUksQ0FBQyxVQUFMLENBQWdCLElBQUksQ0FBQyxFQUFyQixFQUF5QixZQUFNO0FBQzdCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDQSxRQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksT0FBWixFQUFxQixFQUFyQjtBQUNELE9BSEQ7O0FBS0EsTUFBQSxNQUFJLENBQUMsV0FBTCxDQUFpQixJQUFJLENBQUMsRUFBdEIsRUFBMEIsWUFBTTtBQUM5QixRQUFBLGFBQWEsQ0FBQyxLQUFkLEdBRDhCLENBRTlCO0FBQ0E7O0FBQ0EsUUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDQSxRQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksUUFBWixFQUFzQixFQUF0Qjs7QUFDQSxRQUFBLE1BQUksQ0FBQyx1QkFBTCxDQUE2QixJQUFJLENBQUMsRUFBbEM7O0FBQ0EsUUFBQSxPQUFPLGFBQVcsSUFBSSxDQUFDLEVBQWhCLG1CQUFQO0FBQ0QsT0FSRDs7QUFVQSxNQUFBLE1BQUksQ0FBQyxXQUFMLENBQWlCLElBQUksQ0FBQyxFQUF0QixFQUEwQixZQUFNO0FBQzlCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7O0FBQ0EsWUFBSSxJQUFJLENBQUMsS0FBVCxFQUFnQjtBQUNkLFVBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFaLEVBQXFCLEVBQXJCO0FBQ0Q7O0FBQ0QsUUFBQSxhQUFhLEdBQUcsTUFBSSxDQUFDLFFBQUwsQ0FBYyxHQUFkLENBQWtCLFlBQU07QUFDdEMsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLFFBQVosRUFBc0IsRUFBdEI7QUFDQSxpQkFBTyxZQUFNLENBQUUsQ0FBZjtBQUNELFNBSGUsQ0FBaEI7QUFJRCxPQVREOztBQVdBLE1BQUEsTUFBSSxDQUFDLE9BQUwsQ0FBYSxJQUFJLENBQUMsRUFBbEIsRUFBc0IsWUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksTUFBTSxDQUFDLE1BQVgsRUFBbUI7QUFDakIsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDQSxVQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksUUFBWixFQUFzQixFQUF0QjtBQUNEO0FBQ0YsT0FURDs7QUFXQSxNQUFBLE1BQUksQ0FBQyxVQUFMLENBQWdCLElBQUksQ0FBQyxFQUFyQixFQUF5QixZQUFNO0FBQzdCO0FBQ0EsWUFBSSxNQUFNLENBQUMsTUFBWCxFQUFtQjtBQUNqQixVQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksT0FBWixFQUFxQixFQUFyQjtBQUNBLFVBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxRQUFaLEVBQXNCLEVBQXRCO0FBQ0Q7QUFDRixPQU5EOztBQVFBLE1BQUEsTUFBTSxDQUFDLEVBQVAsQ0FBVSxVQUFWLEVBQXNCLFVBQUMsWUFBRDtBQUFBLGVBQWtCLGtCQUFrQixDQUFDLE1BQUQsRUFBTyxZQUFQLEVBQXFCLElBQXJCLENBQXBDO0FBQUEsT0FBdEI7QUFFQSxNQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsT0FBVixFQUFtQixVQUFDLE9BQUQsRUFBYTtBQUFBLFlBQ3RCLE9BRHNCLEdBQ1YsT0FBTyxDQUFDLEtBREUsQ0FDdEIsT0FEc0I7O0FBRTlCLFlBQU0sS0FBSyxHQUFHLFNBQWMsSUFBSSxLQUFKLENBQVUsT0FBVixDQUFkLEVBQWtDO0FBQUUsVUFBQSxLQUFLLEVBQUUsT0FBTyxDQUFDO0FBQWpCLFNBQWxDLENBQWQsQ0FGOEIsQ0FJOUI7QUFDQTs7O0FBQ0EsWUFBSSxDQUFDLE1BQUksQ0FBQyxJQUFMLENBQVUsa0JBQWYsRUFBbUM7QUFDakMsVUFBQSxNQUFJLENBQUMsdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDLEVBRGlDLENBRWpDOzs7QUFDQSxVQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsWUFBVixDQUF1QixJQUFJLENBQUMsRUFBNUIsRUFBZ0M7QUFDOUIsWUFBQSxXQUFXLEVBQUU7QUFEaUIsV0FBaEM7QUFHRCxTQU5ELE1BTU87QUFDTCxVQUFBLE1BQU0sQ0FBQyxLQUFQO0FBQ0Q7O0FBRUQsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEtBQXJDOztBQUNBLFFBQUEsYUFBYSxDQUFDLElBQWQ7QUFDQSxRQUFBLE1BQU0sQ0FBQyxLQUFELENBQU47QUFDRCxPQW5CRDtBQXFCQSxNQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsU0FBVixFQUFxQixVQUFDLElBQUQsRUFBVTtBQUM3QixZQUFNLFVBQVUsR0FBRztBQUNqQixVQUFBLFNBQVMsRUFBRSxJQUFJLENBQUM7QUFEQyxTQUFuQjs7QUFJQSxRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLEVBQWlDLElBQWpDLEVBQXVDLFVBQXZDOztBQUNBLFFBQUEsTUFBSSxDQUFDLHVCQUFMLENBQTZCLElBQUksQ0FBQyxFQUFsQzs7QUFDQSxRQUFBLGFBQWEsQ0FBQyxJQUFkO0FBRUEsUUFBQSxPQUFPO0FBQ1IsT0FWRDs7QUFZQSxVQUFJLGFBQWEsR0FBRyxNQUFJLENBQUMsUUFBTCxDQUFjLEdBQWQsQ0FBa0IsWUFBTTtBQUMxQyxRQUFBLE1BQU0sQ0FBQyxJQUFQOztBQUNBLFlBQUksSUFBSSxDQUFDLFFBQVQsRUFBbUI7QUFDakIsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDRCxTQUp5QyxDQU0xQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGVBQU8sWUFBTSxDQUFFLENBQWY7QUFDRCxPQWJtQixDQUFwQjtBQWNELEtBOUhNLENBQVA7QUErSEQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdlQTs7QUFBQSxTQThlRSxrQkE5ZUYsR0E4ZUUsNEJBQW9CLElBQXBCLEVBQTBCLFNBQTFCLEVBQXFDO0FBQ25DLFFBQU0sV0FBVyxHQUFHLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsSUFBSSxDQUFDLEVBQXZCLENBQXBCO0FBQ0EsUUFBSSxDQUFDLFdBQUwsRUFBa0IsT0FGaUIsQ0FHbkM7O0FBQ0EsUUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFiLElBQW9CLFdBQVcsQ0FBQyxHQUFaLENBQWdCLFNBQWhCLEtBQThCLFNBQXRELEVBQWlFO0FBQy9ELFdBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYywwQkFBZDtBQUNBLFdBQUssSUFBTCxDQUFVLFlBQVYsQ0FBdUIsV0FBVyxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLFFBQUEsR0FBRyxlQUFPLFdBQVcsQ0FBQyxHQUFuQjtBQUF3QixVQUFBLFNBQVMsRUFBRTtBQUFuQztBQURrQyxPQUF2QztBQUdEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQTdmQTs7QUFBQSxTQThmRSxZQTlmRixHQThmRSxzQkFBYyxNQUFkLEVBQXNCLEVBQXRCLEVBQTBCO0FBQ3hCLFNBQUssY0FBTCxDQUFvQixNQUFwQixFQUE0QixFQUE1QixDQUErQixjQUEvQixFQUErQyxVQUFDLElBQUQsRUFBVTtBQUN2RCxVQUFJLE1BQU0sS0FBSyxJQUFJLENBQUMsRUFBcEIsRUFBd0IsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFOLENBQUY7QUFDekIsS0FGRDtBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUF2Z0JBOztBQUFBLFNBd2dCRSxPQXhnQkYsR0F3Z0JFLGlCQUFTLE1BQVQsRUFBaUIsRUFBakIsRUFBcUI7QUFDbkIsU0FBSyxjQUFMLENBQW9CLE1BQXBCLEVBQTRCLEVBQTVCLENBQStCLGNBQS9CLEVBQStDLFVBQUMsWUFBRCxFQUFlLFFBQWYsRUFBNEI7QUFDekUsVUFBSSxNQUFNLEtBQUssWUFBZixFQUE2QjtBQUMzQjtBQUNBLFFBQUEsRUFBRSxDQUFDLFFBQUQsQ0FBRjtBQUNEO0FBQ0YsS0FMRDtBQU1EO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFwaEJBOztBQUFBLFNBcWhCRSxPQXJoQkYsR0FxaEJFLGlCQUFTLE1BQVQsRUFBaUIsRUFBakIsRUFBcUI7QUFDbkIsU0FBSyxjQUFMLENBQW9CLE1BQXBCLEVBQTRCLEVBQTVCLENBQStCLGNBQS9CLEVBQStDLFVBQUMsWUFBRCxFQUFrQjtBQUMvRCxVQUFJLE1BQU0sS0FBSyxZQUFmLEVBQTZCO0FBQzNCLFFBQUEsRUFBRTtBQUNIO0FBQ0YsS0FKRDtBQUtEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFoaUJBOztBQUFBLFNBaWlCRSxVQWppQkYsR0FpaUJFLG9CQUFZLE1BQVosRUFBb0IsRUFBcEIsRUFBd0I7QUFBQTs7QUFDdEIsU0FBSyxjQUFMLENBQW9CLE1BQXBCLEVBQTRCLEVBQTVCLENBQStCLFdBQS9CLEVBQTRDLFVBQUMsWUFBRCxFQUFrQjtBQUM1RCxVQUFJLENBQUMsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLE1BQWxCLENBQUwsRUFBZ0M7QUFDaEMsTUFBQSxFQUFFO0FBQ0gsS0FIRDtBQUlEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUEzaUJBOztBQUFBLFNBNGlCRSxVQTVpQkYsR0E0aUJFLG9CQUFZLE1BQVosRUFBb0IsRUFBcEIsRUFBd0I7QUFBQTs7QUFDdEIsU0FBSyxjQUFMLENBQW9CLE1BQXBCLEVBQTRCLEVBQTVCLENBQStCLFdBQS9CLEVBQTRDLFlBQU07QUFDaEQsVUFBSSxDQUFDLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFMLEVBQWdDO0FBQ2hDLE1BQUEsRUFBRTtBQUNILEtBSEQ7QUFJRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBdGpCQTs7QUFBQSxTQXVqQkUsV0F2akJGLEdBdWpCRSxxQkFBYSxNQUFiLEVBQXFCLEVBQXJCLEVBQXlCO0FBQUE7O0FBQ3ZCLFNBQUssY0FBTCxDQUFvQixNQUFwQixFQUE0QixFQUE1QixDQUErQixZQUEvQixFQUE2QyxZQUFNO0FBQ2pELFVBQUksQ0FBQyxNQUFJLENBQUMsSUFBTCxDQUFVLE9BQVYsQ0FBa0IsTUFBbEIsQ0FBTCxFQUFnQztBQUNoQyxNQUFBLEVBQUU7QUFDSCxLQUhEO0FBSUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQWprQkE7O0FBQUEsU0Fra0JFLFdBbGtCRixHQWtrQkUscUJBQWEsTUFBYixFQUFxQixFQUFyQixFQUF5QjtBQUFBOztBQUN2QixTQUFLLGNBQUwsQ0FBb0IsTUFBcEIsRUFBNEIsRUFBNUIsQ0FBK0IsWUFBL0IsRUFBNkMsWUFBTTtBQUNqRCxVQUFJLENBQUMsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLE1BQWxCLENBQUwsRUFBZ0M7QUFDaEMsTUFBQSxFQUFFO0FBQ0gsS0FIRDtBQUlEO0FBRUQ7QUFDRjtBQUNBO0FBM2tCQTs7QUFBQSxTQTRrQkUsV0E1a0JGLEdBNGtCRSxxQkFBYSxLQUFiLEVBQW9CO0FBQUE7O0FBQ2xCLFFBQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxHQUFOLENBQVUsVUFBQyxJQUFELEVBQU8sQ0FBUCxFQUFhO0FBQ3RDLFVBQU0sT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFwQjtBQUNBLFVBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFwQjs7QUFFQSxVQUFJLFdBQVcsSUFBWCxJQUFtQixJQUFJLENBQUMsS0FBNUIsRUFBbUM7QUFDakMsZUFBTyxPQUFPLENBQUMsTUFBUixDQUFlLElBQUksS0FBSixDQUFVLElBQUksQ0FBQyxLQUFmLENBQWYsQ0FBUDtBQUNEOztBQUFDLFVBQUksSUFBSSxDQUFDLFFBQVQsRUFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsWUFBSSxDQUFDLElBQUksQ0FBQyxRQUFMLENBQWMsYUFBZixJQUFnQyxDQUFDLElBQUksQ0FBQyxVQUExQyxFQUFzRDtBQUNwRCxVQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLEVBQWlDLElBQWpDO0FBQ0Q7O0FBQ0QsZUFBTyxNQUFJLENBQUMsWUFBTCxDQUFrQixJQUFsQixFQUF3QixPQUF4QixFQUFpQyxLQUFqQyxDQUFQO0FBQ0QsT0FkcUMsQ0FldEM7OztBQUNBLFVBQUksQ0FBQyxJQUFJLENBQUMsUUFBTCxDQUFjLGFBQWYsSUFBZ0MsQ0FBQyxJQUFJLENBQUMsVUFBMUMsRUFBc0Q7QUFDcEQsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxnQkFBZixFQUFpQyxJQUFqQztBQUNEOztBQUNELGFBQU8sTUFBSSxDQUFDLE1BQUwsQ0FBWSxJQUFaLEVBQWtCLE9BQWxCLEVBQTJCLEtBQTNCLENBQVA7QUFDRCxLQXBCZ0IsQ0FBakI7QUFzQkEsV0FBTyxNQUFNLENBQUMsUUFBRCxDQUFiO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUF4bUJBOztBQUFBLFNBeW1CRSxZQXptQkYsR0F5bUJFLHNCQUFjLE9BQWQsRUFBdUI7QUFBQTs7QUFDckIsUUFBSSxPQUFPLENBQUMsTUFBUixLQUFtQixDQUF2QixFQUEwQjtBQUN4QixXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsMEJBQWQ7QUFDQSxhQUFPLE9BQU8sQ0FBQyxPQUFSLEVBQVA7QUFDRDs7QUFFRCxRQUFJLEtBQUssSUFBTCxDQUFVLEtBQVYsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekIsV0FBSyxJQUFMLENBQVUsR0FBVixDQUNFLHFPQURGLEVBRUUsU0FGRjtBQUlEOztBQUVELFNBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxvQkFBZDtBQUNBLFFBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxHQUFSLENBQVksVUFBQyxNQUFEO0FBQUEsYUFBWSxPQUFJLENBQUMsSUFBTCxDQUFVLE9BQVYsQ0FBa0IsTUFBbEIsQ0FBWjtBQUFBLEtBQVosQ0FBdEI7QUFFQSxXQUFPLEtBQUssV0FBTCxDQUFpQixhQUFqQixFQUNKLElBREksQ0FDQztBQUFBLGFBQU0sSUFBTjtBQUFBLEtBREQsQ0FBUDtBQUVELEdBM25CSDs7QUFBQSxTQTZuQkUsT0E3bkJGLEdBNm5CRSxtQkFBVztBQUNULFNBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUI7QUFDakIsTUFBQSxZQUFZLGVBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixHQUFxQixZQUE1QjtBQUEwQyxRQUFBLGdCQUFnQixFQUFFO0FBQTVEO0FBREssS0FBbkI7QUFHQSxTQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLEtBQUssWUFBM0I7QUFFQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsZ0JBQWIsRUFBK0IsS0FBSyxtQkFBcEM7O0FBRUEsUUFBSSxLQUFLLElBQUwsQ0FBVSxTQUFkLEVBQXlCO0FBQ3ZCLFdBQUssSUFBTCxDQUFVLEVBQVYsQ0FBYSxhQUFiLEVBQTRCLEtBQUssSUFBTCxDQUFVLFFBQXRDO0FBQ0Q7QUFDRixHQXhvQkg7O0FBQUEsU0Ewb0JFLFNBMW9CRixHQTBvQkUscUJBQWE7QUFDWCxTQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CO0FBQ2pCLE1BQUEsWUFBWSxlQUFPLEtBQUssSUFBTCxDQUFVLFFBQVYsR0FBcUIsWUFBNUI7QUFBMEMsUUFBQSxnQkFBZ0IsRUFBRTtBQUE1RDtBQURLLEtBQW5CO0FBR0EsU0FBSyxJQUFMLENBQVUsY0FBVixDQUF5QixLQUFLLFlBQTlCOztBQUVBLFFBQUksS0FBSyxJQUFMLENBQVUsU0FBZCxFQUF5QjtBQUN2QixXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsYUFBZCxFQUE2QixLQUFLLElBQUwsQ0FBVSxRQUF2QztBQUNEO0FBQ0YsR0FucEJIOztBQUFBO0FBQUEsRUFBbUMsTUFBbkMsVUFDUyxPQURULEdBQ21CLE9BQU8sQ0FBQyxpQkFBRCxDQUFQLENBQTJCLE9BRDlDOzs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztlQ2hDeUIsT0FBTyxDQUFDLFFBQUQsQztJQUF4QixDLFlBQUEsQztJQUFHLFMsWUFBQSxTOztJQUVMLEs7OztBQUNKLGlCQUFhLEtBQWIsRUFBb0I7QUFBQTs7QUFDbEIsa0NBQU0sS0FBTjtBQUNBLFVBQUssY0FBTCxHQUFzQixNQUFLLGNBQUwsQ0FBb0IsSUFBcEIsK0JBQXRCO0FBQ0EsVUFBSyxXQUFMLEdBQW1CLE1BQUssV0FBTCxDQUFpQixJQUFqQiwrQkFBbkI7QUFIa0I7QUFJbkI7Ozs7U0FFRCxpQixHQUFBLDZCQUFxQjtBQUNuQixTQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CLEVBQW5CO0FBQ0QsRzs7U0FFRCxjLEdBQUEsd0JBQWdCLEVBQWhCLEVBQW9CO0FBQ2xCLFFBQUksRUFBRSxDQUFDLE9BQUgsS0FBZSxFQUFuQixFQUF1QjtBQUNyQixXQUFLLEtBQUwsQ0FBVyxPQUFYLENBQW1CLEtBQUssS0FBTCxDQUFXLEtBQTlCO0FBQ0Q7QUFDRixHOztTQUVELFcsR0FBQSx1QkFBZTtBQUNiLFNBQUssS0FBTCxDQUFXLE9BQVgsQ0FBbUIsS0FBSyxLQUFMLENBQVcsS0FBOUI7QUFDRCxHOztTQUVELE0sR0FBQSxrQkFBVTtBQUFBOztBQUNSLFdBQ0U7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLE9BQ0U7QUFDRSxNQUFBLFNBQVMsRUFBQyw4Q0FEWjtBQUVFLE1BQUEsSUFBSSxFQUFDLE1BRlA7QUFHRSxvQkFBWSxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLGtCQUFoQixDQUhkO0FBSUUsTUFBQSxXQUFXLEVBQUUsS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixrQkFBaEIsQ0FKZjtBQUtFLE1BQUEsT0FBTyxFQUFFLEtBQUssY0FMaEI7QUFNRSxNQUFBLEdBQUcsRUFBRSxhQUFDLEtBQUQsRUFBVztBQUFFLFFBQUEsTUFBSSxDQUFDLEtBQUwsR0FBYSxLQUFiO0FBQW9CLE9BTnhDO0FBT0U7QUFQRixNQURGLEVBVUU7QUFDRSxNQUFBLFNBQVMsRUFBQyxrRUFEWjtBQUVFLE1BQUEsSUFBSSxFQUFDLFFBRlA7QUFHRSxNQUFBLE9BQU8sRUFBRSxLQUFLO0FBSGhCLE9BS0csS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixRQUFoQixDQUxILENBVkYsQ0FERjtBQW9CRCxHOzs7RUExQ2lCLFM7O0FBNkNwQixNQUFNLENBQUMsT0FBUCxHQUFpQixLQUFqQjs7Ozs7Ozs7Ozs7OztlQy9DbUIsT0FBTyxDQUFDLFlBQUQsQztJQUFsQixNLFlBQUEsTTs7QUFDUixJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsNEJBQUQsQ0FBMUI7O2dCQUNjLE9BQU8sQ0FBQyxRQUFELEM7SUFBYixDLGFBQUEsQzs7Z0JBQ2tCLE9BQU8sQ0FBQyx3QkFBRCxDO0lBQXpCLGEsYUFBQSxhOztBQUNSLElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxZQUFELENBQXJCOztBQUNBLElBQU0seUJBQXlCLEdBQUcsT0FBTyxDQUFDLG1DQUFELENBQXpDOztBQUVBLFNBQVMsT0FBVCxHQUFvQjtBQUNsQixTQUNFO0FBQUssbUJBQVksTUFBakI7QUFBd0IsSUFBQSxTQUFTLEVBQUMsT0FBbEM7QUFBMEMsSUFBQSxLQUFLLEVBQUMsSUFBaEQ7QUFBcUQsSUFBQSxNQUFNLEVBQUMsSUFBNUQ7QUFBaUUsSUFBQSxPQUFPLEVBQUM7QUFBekUsS0FDRTtBQUFHLElBQUEsSUFBSSxFQUFDLE1BQVI7QUFBZSxJQUFBLFFBQVEsRUFBQztBQUF4QixLQUNFO0FBQU0sSUFBQSxTQUFTLEVBQUMscUJBQWhCO0FBQXNDLElBQUEsSUFBSSxFQUFDLFNBQTNDO0FBQXFELElBQUEsS0FBSyxFQUFDLElBQTNEO0FBQWdFLElBQUEsTUFBTSxFQUFDLElBQXZFO0FBQTRFLElBQUEsRUFBRSxFQUFDO0FBQS9FLElBREYsRUFFRTtBQUFNLElBQUEsQ0FBQyxFQUFDLDgyQkFBUjtBQUF1M0IsSUFBQSxJQUFJLEVBQUMsTUFBNTNCO0FBQW00QixJQUFBLFFBQVEsRUFBQztBQUE1NEIsSUFGRixDQURGLENBREY7QUFRRDtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsT0FBUDtBQUFBOztBQUdFLGVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QjtBQUFBOztBQUN2QiwrQkFBTSxJQUFOLEVBQVksSUFBWjtBQUNBLFVBQUssRUFBTCxHQUFVLE1BQUssSUFBTCxDQUFVLEVBQVYsSUFBZ0IsS0FBMUI7QUFDQSxVQUFLLEtBQUwsR0FBYSxNQUFLLElBQUwsQ0FBVSxLQUFWLElBQW1CLE1BQWhDO0FBQ0EsVUFBSyxJQUFMLEdBQVksVUFBWjs7QUFDQSxVQUFLLElBQUwsR0FBWTtBQUFBLGFBQU0sRUFBQyxPQUFELE9BQU47QUFBQSxLQUFaLENBTHVCLENBT3ZCOzs7QUFDQSxVQUFLLGFBQUwsR0FBcUI7QUFDbkIsTUFBQSxPQUFPLEVBQUU7QUFDUCxRQUFBLE1BQU0sRUFBRSxRQUREO0FBRVAsUUFBQSxnQkFBZ0IsRUFBRSw0QkFGWDtBQUdQLFFBQUEsYUFBYSxFQUFFLG1FQUhSO0FBSVAsUUFBQSxlQUFlLEVBQUU7QUFKVjtBQURVLEtBQXJCO0FBU0EsUUFBTSxjQUFjLEdBQUcsRUFBdkI7QUFFQSxVQUFLLElBQUwsZ0JBQWlCLGNBQWpCLEVBQW9DLElBQXBDOztBQUVBLFVBQUssUUFBTDs7QUFFQSxVQUFLLFFBQUwsR0FBZ0IsTUFBSyxJQUFMLENBQVUsWUFBMUI7O0FBRUEsUUFBSSxDQUFDLE1BQUssUUFBVixFQUFvQjtBQUNsQixZQUFNLElBQUksS0FBSixDQUFVLCtFQUFWLENBQU47QUFDRCxLQTNCc0IsQ0E2QnZCOzs7QUFDQSxVQUFLLE9BQUwsR0FBZSxNQUFLLE9BQUwsQ0FBYSxJQUFiLCtCQUFmO0FBQ0EsVUFBSyxPQUFMLEdBQWUsTUFBSyxPQUFMLENBQWEsSUFBYiwrQkFBZjtBQUNBLFVBQUssY0FBTCxHQUFzQixNQUFLLGNBQUwsQ0FBb0IsSUFBcEIsK0JBQXRCO0FBQ0EsVUFBSyxlQUFMLEdBQXVCLE1BQUssZUFBTCxDQUFxQixJQUFyQiwrQkFBdkI7QUFFQSxVQUFLLE1BQUwsR0FBYyxJQUFJLGFBQUosQ0FBa0IsSUFBbEIsRUFBd0I7QUFDcEMsTUFBQSxZQUFZLEVBQUUsTUFBSyxJQUFMLENBQVUsWUFEWTtBQUVwQyxNQUFBLGdCQUFnQixFQUFFLE1BQUssSUFBTCxDQUFVLGdCQUFWLElBQThCLE1BQUssSUFBTCxDQUFVLGFBRnRCO0FBR3BDLE1BQUEsb0JBQW9CLEVBQUUsTUFBSyxJQUFMLENBQVU7QUFISSxLQUF4QixDQUFkO0FBbkN1QjtBQXdDeEI7O0FBM0NIOztBQUFBLFNBNkNFLFVBN0NGLEdBNkNFLG9CQUFZLE9BQVosRUFBcUI7QUFDbkIsc0JBQU0sVUFBTixZQUFpQixPQUFqQjs7QUFDQSxTQUFLLFFBQUw7QUFDRCxHQWhESDs7QUFBQSxTQWtERSxRQWxERixHQWtERSxvQkFBWTtBQUNWLFNBQUssVUFBTCxHQUFrQixJQUFJLFVBQUosQ0FBZSxDQUFDLEtBQUssYUFBTixFQUFxQixLQUFLLElBQUwsQ0FBVSxNQUEvQixFQUF1QyxLQUFLLElBQUwsQ0FBVSxNQUFqRCxDQUFmLENBQWxCO0FBQ0EsU0FBSyxJQUFMLEdBQVksS0FBSyxVQUFMLENBQWdCLFNBQWhCLENBQTBCLElBQTFCLENBQStCLEtBQUssVUFBcEMsQ0FBWjtBQUNBLFNBQUssU0FBTCxHQUFpQixLQUFLLFVBQUwsQ0FBZ0IsY0FBaEIsQ0FBK0IsSUFBL0IsQ0FBb0MsS0FBSyxVQUF6QyxDQUFqQjtBQUNBLFNBQUssY0FBTCxHQUpVLENBSVk7QUFDdkIsR0F2REg7O0FBQUEsU0F5REUsa0JBekRGLEdBeURFLDRCQUFvQixHQUFwQixFQUF5QjtBQUN2QixXQUFPLEdBQUcsQ0FBQyxTQUFKLENBQWMsR0FBRyxDQUFDLFdBQUosQ0FBZ0IsR0FBaEIsSUFBdUIsQ0FBckMsQ0FBUDtBQUNELEdBM0RIOztBQUFBLFNBNkRFLGlCQTdERixHQTZERSwyQkFBbUIsR0FBbkIsRUFBd0I7QUFDdEIsUUFBSSxDQUFDLEdBQUwsRUFBVSxPQUFPLEtBQVA7QUFFVixRQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsS0FBSixDQUFVLG1CQUFWLEVBQStCLENBQS9CLENBQWpCOztBQUNBLFFBQUksUUFBUSxLQUFLLE1BQWIsSUFBdUIsUUFBUSxLQUFLLE9BQXhDLEVBQWlEO0FBQy9DLGFBQU8sS0FBUDtBQUNEOztBQUVELFdBQU8sSUFBUDtBQUNELEdBdEVIOztBQUFBLFNBd0VFLGdCQXhFRixHQXdFRSwwQkFBa0IsR0FBbEIsRUFBdUI7QUFDckIsUUFBTSxhQUFhLEdBQUcsaUJBQXRCO0FBQ0EsUUFBTSxlQUFlLEdBQUcsU0FBeEI7O0FBQ0EsUUFBSSxhQUFhLENBQUMsSUFBZCxDQUFtQixHQUFuQixDQUFKLEVBQTZCO0FBQzNCLGFBQU8sR0FBUDtBQUNEOztBQUVELFdBQU8sZUFBZSxHQUFHLEdBQXpCO0FBQ0QsR0FoRkg7O0FBQUEsU0FrRkUsT0FsRkYsR0FrRkUsaUJBQVMsR0FBVCxFQUFjO0FBQUE7O0FBQ1osV0FBTyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLFVBQWpCLEVBQTZCO0FBQUUsTUFBQSxHQUFHLEVBQUg7QUFBRixLQUE3QixFQUNKLElBREksQ0FDQyxVQUFDLEdBQUQsRUFBUztBQUNiLFVBQUksR0FBRyxDQUFDLEtBQVIsRUFBZTtBQUNiLFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxHQUFWLENBQWMsY0FBZDs7QUFDQSxRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQUcsQ0FBQyxLQUFsQjs7QUFDQSxjQUFNLElBQUksS0FBSixDQUFVLDBCQUFWLENBQU47QUFDRDs7QUFDRCxhQUFPLEdBQVA7QUFDRCxLQVJJLENBQVA7QUFTRCxHQTVGSDs7QUFBQSxTQThGRSxPQTlGRixHQThGRSxpQkFBUyxHQUFULEVBQWM7QUFBQTs7QUFDWixJQUFBLEdBQUcsR0FBRyxLQUFLLGdCQUFMLENBQXNCLEdBQXRCLENBQU47O0FBQ0EsUUFBSSxDQUFDLEtBQUssaUJBQUwsQ0FBdUIsR0FBdkIsQ0FBTCxFQUFrQztBQUNoQyxXQUFLLElBQUwsQ0FBVSxHQUFWLG1DQUE4QyxHQUE5QztBQUNBLFdBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxLQUFLLElBQUwsQ0FBVSxpQkFBVixDQUFmLEVBQTZDLE9BQTdDLEVBQXNELElBQXREO0FBQ0E7QUFDRDs7QUFFRCxXQUFPLEtBQUssT0FBTCxDQUFhLEdBQWIsRUFDSixJQURJLENBQ0MsVUFBQyxJQUFELEVBQVU7QUFDZCxVQUFNLE9BQU8sR0FBRztBQUNkLFFBQUEsTUFBTSxFQUFFLE1BQUksQ0FBQyxFQURDO0FBRWQsUUFBQSxJQUFJLEVBQUUsTUFBSSxDQUFDLGtCQUFMLENBQXdCLEdBQXhCLENBRlE7QUFHZCxRQUFBLElBQUksRUFBRSxJQUFJLENBQUMsSUFIRztBQUlkLFFBQUEsSUFBSSxFQUFFO0FBQ0osVUFBQSxJQUFJLEVBQUUsSUFBSSxDQUFDO0FBRFAsU0FKUTtBQU9kLFFBQUEsUUFBUSxFQUFFLElBUEk7QUFRZCxRQUFBLElBQUksRUFBRTtBQUNKLFVBQUEsR0FBRyxFQUFIO0FBREksU0FSUTtBQVdkLFFBQUEsTUFBTSxFQUFFO0FBQ04sVUFBQSxZQUFZLEVBQUUsTUFBSSxDQUFDLElBQUwsQ0FBVSxZQURsQjtBQUVOLFVBQUEsR0FBRyxFQUFLLE1BQUksQ0FBQyxRQUFWLGFBRkc7QUFHTixVQUFBLElBQUksRUFBRTtBQUNKLFlBQUEsTUFBTSxFQUFFLEdBREo7QUFFSixZQUFBLEdBQUcsRUFBSDtBQUZJLFdBSEE7QUFPTixVQUFBLGVBQWUsRUFBRSxNQUFJLENBQUMsTUFBTCxDQUFZO0FBUHZCO0FBWE0sT0FBaEI7QUFxQkEsYUFBTyxPQUFQO0FBQ0QsS0F4QkksRUF5QkosSUF6QkksQ0F5QkMsVUFBQyxPQUFELEVBQWE7QUFDakIsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYywwQkFBZDs7QUFDQSxVQUFJO0FBQ0YsZUFBTyxNQUFJLENBQUMsSUFBTCxDQUFVLE9BQVYsQ0FBa0IsT0FBbEIsQ0FBUDtBQUNELE9BRkQsQ0FFRSxPQUFPLEdBQVAsRUFBWTtBQUNaLFlBQUksQ0FBQyxHQUFHLENBQUMsYUFBVCxFQUF3QjtBQUN0QixVQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQ7QUFDRDs7QUFDRCxlQUFPLEdBQVA7QUFDRDtBQUNGLEtBbkNJLEVBb0NKLEtBcENJLENBb0NFLFVBQUMsR0FBRCxFQUFTO0FBQ2QsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkOztBQUNBLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWU7QUFDYixRQUFBLE9BQU8sRUFBRSxNQUFJLENBQUMsSUFBTCxDQUFVLGVBQVYsQ0FESTtBQUViLFFBQUEsT0FBTyxFQUFFO0FBRkksT0FBZixFQUdHLE9BSEgsRUFHWSxJQUhaOztBQUlBLGFBQU8sR0FBUDtBQUNELEtBM0NJLENBQVA7QUE0Q0QsR0FsSkg7O0FBQUEsU0FvSkUsY0FwSkYsR0FvSkUsd0JBQWdCLENBQWhCLEVBQW1CO0FBQUE7O0FBQ2pCLElBQUEseUJBQXlCLENBQUMsQ0FBQyxDQUFDLFlBQUgsRUFBaUIsTUFBakIsRUFBeUIsVUFBQyxHQUFELEVBQVM7QUFDekQsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsMENBQXFELEdBQXJEOztBQUNBLE1BQUEsTUFBSSxDQUFDLE9BQUwsQ0FBYSxHQUFiO0FBQ0QsS0FId0IsQ0FBekI7QUFJRCxHQXpKSDs7QUFBQSxTQTJKRSxlQTNKRixHQTJKRSx5QkFBaUIsQ0FBakIsRUFBb0I7QUFBQTs7QUFDbEIsSUFBQSx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsYUFBSCxFQUFrQixPQUFsQixFQUEyQixVQUFDLEdBQUQsRUFBUztBQUMzRCxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBVix5Q0FBb0QsR0FBcEQ7O0FBQ0EsTUFBQSxNQUFJLENBQUMsT0FBTCxDQUFhLEdBQWI7QUFDRCxLQUh3QixDQUF6QjtBQUlELEdBaEtIOztBQUFBLFNBa0tFLE1BbEtGLEdBa0tFLGdCQUFRLEtBQVIsRUFBZTtBQUNiLFdBQU8sRUFBQyxLQUFEO0FBQU8sTUFBQSxJQUFJLEVBQUUsS0FBSyxJQUFsQjtBQUF3QixNQUFBLE9BQU8sRUFBRSxLQUFLO0FBQXRDLE1BQVA7QUFDRCxHQXBLSDs7QUFBQSxTQXNLRSxPQXRLRixHQXNLRSxtQkFBVztBQUNULFFBQU0sTUFBTSxHQUFHLEtBQUssSUFBTCxDQUFVLE1BQXpCOztBQUNBLFFBQUksTUFBSixFQUFZO0FBQ1YsV0FBSyxLQUFMLENBQVcsTUFBWCxFQUFtQixJQUFuQjtBQUNEO0FBQ0YsR0EzS0g7O0FBQUEsU0E2S0UsU0E3S0YsR0E2S0UscUJBQWE7QUFDWCxTQUFLLE9BQUw7QUFDRCxHQS9LSDs7QUFBQTtBQUFBLEVBQW1DLE1BQW5DLFVBQ1MsT0FEVCxHQUNtQixPQUFPLENBQUMsaUJBQUQsQ0FBUCxDQUEyQixPQUQ5Qzs7O0FDdEJBLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyx5QkFBRCxDQUF2QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyx5QkFBVCxDQUFvQyxZQUFwQyxFQUFrRCxhQUFsRCxFQUFpRSxRQUFqRSxFQUEyRTtBQUMxRixNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQWQsQ0FBckI7QUFFQSxNQUFJLFFBQUo7O0FBRUEsVUFBUSxhQUFSO0FBQ0UsU0FBSyxPQUFMO0FBQWM7QUFDWixZQUFNLHVCQUF1QixHQUFHLEtBQUssQ0FBQyxJQUFOLENBQVcsVUFBQyxJQUFEO0FBQUEsaUJBQVUsSUFBSSxDQUFDLElBQUwsS0FBYyxNQUF4QjtBQUFBLFNBQVgsQ0FBaEM7O0FBQ0EsWUFBSSx1QkFBSixFQUE2QjtBQUMzQjtBQUNEOztBQUNELFFBQUEsUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsVUFBQyxJQUFEO0FBQUEsaUJBQ3RCLElBQUksQ0FBQyxJQUFMLEtBQWMsUUFBZCxJQUNLLElBQUksQ0FBQyxJQUFMLEtBQWMsWUFGRztBQUFBLFNBQWIsQ0FBWDtBQUlBO0FBQ0Q7O0FBQ0QsU0FBSyxNQUFMO0FBQWE7QUFDWCxRQUFBLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBTixDQUFhLFVBQUMsSUFBRDtBQUFBLGlCQUN0QixJQUFJLENBQUMsSUFBTCxLQUFjLFFBQWQsSUFDRyxJQUFJLENBQUMsSUFBTCxLQUFjLGVBRks7QUFBQSxTQUFiLENBQVg7QUFHQTtBQUNEOztBQUNEO0FBQVM7QUFDUCxjQUFNLElBQUksS0FBSiwrREFBc0UsYUFBdEUsQ0FBTjtBQUNEO0FBcEJIOztBQXVCQSxFQUFBLFFBQVEsQ0FBQyxPQUFULENBQWlCLFVBQUMsSUFBRCxFQUFVO0FBQ3pCLElBQUEsSUFBSSxDQUFDLFdBQUwsQ0FBaUIsVUFBQyxTQUFEO0FBQUEsYUFDZixRQUFRLENBQUMsU0FBRCxDQURPO0FBQUEsS0FBakI7QUFFRCxHQUhEO0FBSUQsQ0FoQ0Q7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxPQUFQO0FBQ0Usd0JBQWEsT0FBYixFQUFzQjtBQUNwQixTQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBSyxRQUFMLEdBQWdCLE9BQWhCO0FBQ0Q7O0FBSkg7O0FBQUEsU0FNRSxFQU5GLEdBTUUsWUFBSSxLQUFKLEVBQVcsRUFBWCxFQUFlO0FBQ2IsU0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixDQUFDLEtBQUQsRUFBUSxFQUFSLENBQWxCOztBQUNBLFdBQU8sS0FBSyxRQUFMLENBQWMsRUFBZCxDQUFpQixLQUFqQixFQUF3QixFQUF4QixDQUFQO0FBQ0QsR0FUSDs7QUFBQSxTQVdFLE1BWEYsR0FXRSxrQkFBVTtBQUFBOztBQUNSLFNBQUssT0FBTCxDQUFhLE9BQWIsQ0FBcUIsZ0JBQWlCO0FBQUEsVUFBZixLQUFlO0FBQUEsVUFBUixFQUFROztBQUNwQyxNQUFBLEtBQUksQ0FBQyxRQUFMLENBQWMsR0FBZCxDQUFrQixLQUFsQixFQUF5QixFQUF6QjtBQUNELEtBRkQ7QUFHRCxHQWZIOztBQUFBO0FBQUE7OztBQ0pBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLENBQ2YsOERBRGUsRUFFZixpRUFGZSxFQUdmLHVEQUhlLEVBSWYsd0RBSmUsRUFLZiwwREFMZSxFQU1mLHdEQU5lLEVBT2YsNkRBUGUsRUFRZiw2REFSZSxFQVNmLDREQVRlLEVBVWYsd0VBVmUsRUFXZixpRUFYZSxDQUFqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNBTSxZOzs7QUFDSix3QkFBYSxLQUFiLEVBQW9CLEdBQXBCLEVBQWdDO0FBQUE7O0FBQUEsUUFBWixHQUFZO0FBQVosTUFBQSxHQUFZLEdBQU4sSUFBTTtBQUFBOztBQUM5QiwySkFBaUksS0FBakk7QUFFQSxVQUFLLGNBQUwsR0FBc0IsSUFBdEI7QUFDQSxVQUFLLE9BQUwsR0FBZSxHQUFmO0FBSjhCO0FBSy9COzs7aUNBTndCLEs7O0FBUzNCLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFlBQWpCOzs7QUNUQSxJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBRCxDQUF6Qjs7QUFFQSxTQUFTLGlCQUFULEdBQThCO0FBQzVCLFNBQU8sSUFBSSxLQUFKLENBQVUsV0FBVixDQUFQO0FBQ0Q7O0FBRUQsTUFBTSxDQUFDLE9BQVA7QUFDRSw0QkFBYSxLQUFiLEVBQW9CO0FBQ2xCLFFBQUksT0FBTyxLQUFQLEtBQWlCLFFBQWpCLElBQTZCLEtBQUssS0FBSyxDQUEzQyxFQUE4QztBQUM1QyxXQUFLLEtBQUwsR0FBYSxRQUFiO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNEOztBQUVELFNBQUssY0FBTCxHQUFzQixDQUF0QjtBQUNBLFNBQUssY0FBTCxHQUFzQixFQUF0QjtBQUNEOztBQVZIOztBQUFBLFNBWUUsS0FaRixHQVlFLGVBQU8sRUFBUCxFQUFXO0FBQUE7O0FBQ1QsU0FBSyxjQUFMLElBQXVCLENBQXZCO0FBRUEsUUFBSSxLQUFJLEdBQUcsS0FBWDtBQUVBLFFBQUksWUFBSjs7QUFDQSxRQUFJO0FBQ0YsTUFBQSxZQUFZLEdBQUcsRUFBRSxFQUFqQjtBQUNELEtBRkQsQ0FFRSxPQUFPLEdBQVAsRUFBWTtBQUNaLFdBQUssY0FBTCxJQUF1QixDQUF2QjtBQUNBLFlBQU0sR0FBTjtBQUNEOztBQUVELFdBQU87QUFDTCxNQUFBLEtBQUssRUFBRSxpQkFBTTtBQUNYLFlBQUksS0FBSixFQUFVO0FBQ1YsUUFBQSxLQUFJLEdBQUcsSUFBUDtBQUNBLFFBQUEsS0FBSSxDQUFDLGNBQUwsSUFBdUIsQ0FBdkI7QUFDQSxRQUFBLFlBQVk7O0FBQ1osUUFBQSxLQUFJLENBQUMsVUFBTDtBQUNELE9BUEk7QUFTTCxNQUFBLElBQUksRUFBRSxnQkFBTTtBQUNWLFlBQUksS0FBSixFQUFVO0FBQ1YsUUFBQSxLQUFJLEdBQUcsSUFBUDtBQUNBLFFBQUEsS0FBSSxDQUFDLGNBQUwsSUFBdUIsQ0FBdkI7O0FBQ0EsUUFBQSxLQUFJLENBQUMsVUFBTDtBQUNEO0FBZEksS0FBUDtBQWdCRCxHQXpDSDs7QUFBQSxTQTJDRSxVQTNDRixHQTJDRSxzQkFBYztBQUFBOztBQUNaO0FBQ0E7QUFDQTtBQUNBLElBQUEsT0FBTyxDQUFDLE9BQVIsR0FBa0IsSUFBbEIsQ0FBdUIsWUFBTTtBQUMzQixNQUFBLE1BQUksQ0FBQyxLQUFMO0FBQ0QsS0FGRDtBQUdELEdBbERIOztBQUFBLFNBb0RFLEtBcERGLEdBb0RFLGlCQUFTO0FBQ1AsUUFBSSxLQUFLLGNBQUwsSUFBdUIsS0FBSyxLQUFoQyxFQUF1QztBQUNyQztBQUNEOztBQUNELFFBQUksS0FBSyxjQUFMLENBQW9CLE1BQXBCLEtBQStCLENBQW5DLEVBQXNDO0FBQ3BDO0FBQ0QsS0FOTSxDQVFQO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBTSxJQUFJLEdBQUcsS0FBSyxjQUFMLENBQW9CLEtBQXBCLEVBQWI7O0FBQ0EsUUFBTSxPQUFPLEdBQUcsS0FBSyxLQUFMLENBQVcsSUFBSSxDQUFDLEVBQWhCLENBQWhCOztBQUNBLElBQUEsSUFBSSxDQUFDLEtBQUwsR0FBYSxPQUFPLENBQUMsS0FBckI7QUFDQSxJQUFBLElBQUksQ0FBQyxJQUFMLEdBQVksT0FBTyxDQUFDLElBQXBCO0FBQ0QsR0FuRUg7O0FBQUEsU0FxRUUsTUFyRUYsR0FxRUUsZ0JBQVEsRUFBUixFQUFZLE9BQVosRUFBMEI7QUFBQTs7QUFBQSxRQUFkLE9BQWM7QUFBZCxNQUFBLE9BQWMsR0FBSixFQUFJO0FBQUE7O0FBQ3hCLFFBQU0sT0FBTyxHQUFHO0FBQ2QsTUFBQSxFQUFFLEVBQUYsRUFEYztBQUVkLE1BQUEsUUFBUSxFQUFFLE9BQU8sQ0FBQyxRQUFSLElBQW9CLENBRmhCO0FBR2QsTUFBQSxLQUFLLEVBQUUsaUJBQU07QUFDWCxRQUFBLE1BQUksQ0FBQyxRQUFMLENBQWMsT0FBZDtBQUNELE9BTGE7QUFNZCxNQUFBLElBQUksRUFBRSxnQkFBTTtBQUNWLGNBQU0sSUFBSSxLQUFKLENBQVUsNERBQVYsQ0FBTjtBQUNEO0FBUmEsS0FBaEI7QUFXQSxRQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsS0FBSyxjQUFOLEVBQXNCLFVBQUMsS0FBRCxFQUFXO0FBQ3RELGFBQU8sT0FBTyxDQUFDLFFBQVIsR0FBbUIsS0FBSyxDQUFDLFFBQWhDO0FBQ0QsS0FGc0IsQ0FBdkI7O0FBR0EsUUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFmLEVBQWtCO0FBQ2hCLFdBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixPQUF6QjtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUssY0FBTCxDQUFvQixNQUFwQixDQUEyQixLQUEzQixFQUFrQyxDQUFsQyxFQUFxQyxPQUFyQztBQUNEOztBQUNELFdBQU8sT0FBUDtBQUNELEdBMUZIOztBQUFBLFNBNEZFLFFBNUZGLEdBNEZFLGtCQUFVLE9BQVYsRUFBbUI7QUFDakIsUUFBTSxLQUFLLEdBQUcsS0FBSyxjQUFMLENBQW9CLE9BQXBCLENBQTRCLE9BQTVCLENBQWQ7O0FBQ0EsUUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFmLEVBQWtCO0FBQ2hCLFdBQUssY0FBTCxDQUFvQixNQUFwQixDQUEyQixLQUEzQixFQUFrQyxDQUFsQztBQUNEO0FBQ0YsR0FqR0g7O0FBQUEsU0FtR0UsR0FuR0YsR0FtR0UsYUFBSyxFQUFMLEVBQVMsWUFBVCxFQUF1QjtBQUNyQixRQUFJLEtBQUssY0FBTCxHQUFzQixLQUFLLEtBQS9CLEVBQXNDO0FBQ3BDLGFBQU8sS0FBSyxLQUFMLENBQVcsRUFBWCxDQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxLQUFLLE1BQUwsQ0FBWSxFQUFaLEVBQWdCLFlBQWhCLENBQVA7QUFDRCxHQXhHSDs7QUFBQSxTQTBHRSxtQkExR0YsR0EwR0UsNkJBQXFCLEVBQXJCLEVBQXlCLFlBQXpCLEVBQXVDO0FBQUE7O0FBQ3JDLFdBQU8sWUFBYTtBQUFBLHdDQUFULElBQVM7QUFBVCxRQUFBLElBQVM7QUFBQTs7QUFDbEIsVUFBSSxhQUFKO0FBQ0EsVUFBTSxZQUFZLEdBQUcsSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUNwRCxRQUFBLGFBQWEsR0FBRyxNQUFJLENBQUMsR0FBTCxDQUFTLFlBQU07QUFDN0IsY0FBSSxXQUFKO0FBQ0EsY0FBSSxZQUFKOztBQUNBLGNBQUk7QUFDRixZQUFBLFlBQVksR0FBRyxPQUFPLENBQUMsT0FBUixDQUFnQixFQUFFLE1BQUYsU0FBTSxJQUFOLENBQWhCLENBQWY7QUFDRCxXQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWixZQUFBLFlBQVksR0FBRyxPQUFPLENBQUMsTUFBUixDQUFlLEdBQWYsQ0FBZjtBQUNEOztBQUVELFVBQUEsWUFBWSxDQUFDLElBQWIsQ0FBa0IsVUFBQyxNQUFELEVBQVk7QUFDNUIsZ0JBQUksV0FBSixFQUFpQjtBQUNmLGNBQUEsTUFBTSxDQUFDLFdBQUQsQ0FBTjtBQUNELGFBRkQsTUFFTztBQUNMLGNBQUEsYUFBYSxDQUFDLElBQWQ7QUFDQSxjQUFBLE9BQU8sQ0FBQyxNQUFELENBQVA7QUFDRDtBQUNGLFdBUEQsRUFPRyxVQUFDLEdBQUQsRUFBUztBQUNWLGdCQUFJLFdBQUosRUFBaUI7QUFDZixjQUFBLE1BQU0sQ0FBQyxXQUFELENBQU47QUFDRCxhQUZELE1BRU87QUFDTCxjQUFBLGFBQWEsQ0FBQyxJQUFkO0FBQ0EsY0FBQSxNQUFNLENBQUMsR0FBRCxDQUFOO0FBQ0Q7QUFDRixXQWREO0FBZ0JBLGlCQUFPLFlBQU07QUFDWCxZQUFBLFdBQVcsR0FBRyxpQkFBaUIsRUFBL0I7QUFDRCxXQUZEO0FBR0QsU0E1QmUsRUE0QmIsWUE1QmEsQ0FBaEI7QUE2QkQsT0E5Qm9CLENBQXJCOztBQWdDQSxNQUFBLFlBQVksQ0FBQyxLQUFiLEdBQXFCLFlBQU07QUFDekIsUUFBQSxhQUFhLENBQUMsS0FBZDtBQUNELE9BRkQ7O0FBSUEsYUFBTyxZQUFQO0FBQ0QsS0F2Q0Q7QUF3Q0QsR0FuSkg7O0FBQUE7QUFBQTs7Ozs7QUNOQSxJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsZUFBRCxDQUFuQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxPQUFQO0FBQ0U7QUFDRjtBQUNBO0FBQ0Usc0JBQWEsT0FBYixFQUFzQjtBQUFBOztBQUNwQixTQUFLLE1BQUwsR0FBYztBQUNaLE1BQUEsT0FBTyxFQUFFLEVBREc7QUFFWixNQUFBLFNBRlkscUJBRUQsQ0FGQyxFQUVFO0FBQ1osWUFBSSxDQUFDLEtBQUssQ0FBVixFQUFhO0FBQ1gsaUJBQU8sQ0FBUDtBQUNEOztBQUNELGVBQU8sQ0FBUDtBQUNEO0FBUFcsS0FBZDs7QUFVQSxRQUFJLEtBQUssQ0FBQyxPQUFOLENBQWMsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLE1BQUEsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsVUFBQyxNQUFEO0FBQUEsZUFBWSxLQUFJLENBQUMsTUFBTCxDQUFZLE1BQVosQ0FBWjtBQUFBLE9BQWhCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBSyxNQUFMLENBQVksT0FBWjtBQUNEO0FBQ0Y7O0FBcEJIOztBQUFBLFNBc0JFLE1BdEJGLEdBc0JFLGdCQUFRLE1BQVIsRUFBZ0I7QUFDZCxRQUFJLENBQUMsTUFBRCxJQUFXLENBQUMsTUFBTSxDQUFDLE9BQXZCLEVBQWdDO0FBQzlCO0FBQ0Q7O0FBRUQsUUFBTSxVQUFVLEdBQUcsS0FBSyxNQUF4QjtBQUNBLFNBQUssTUFBTCxnQkFBbUIsVUFBbkI7QUFBK0IsTUFBQSxPQUFPLGVBQU8sVUFBVSxDQUFDLE9BQWxCLEVBQThCLE1BQU0sQ0FBQyxPQUFyQztBQUF0QztBQUNBLFNBQUssTUFBTCxDQUFZLFNBQVosR0FBd0IsTUFBTSxDQUFDLFNBQVAsSUFBb0IsVUFBVSxDQUFDLFNBQXZEO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUNBOztBQUFBLFNBMkNFLFdBM0NGLEdBMkNFLHFCQUFhLE1BQWIsRUFBcUIsT0FBckIsRUFBOEI7QUFBQSw0QkFDRCxNQUFNLENBQUMsU0FETjtBQUFBLFFBQ3BCLEtBRG9CLHFCQUNwQixLQURvQjtBQUFBLFFBQ2IsT0FEYSxxQkFDYixPQURhO0FBRTVCLFFBQU0sV0FBVyxHQUFHLEtBQXBCO0FBQ0EsUUFBTSxlQUFlLEdBQUcsTUFBeEI7QUFDQSxRQUFJLFlBQVksR0FBRyxDQUFDLE1BQUQsQ0FBbkI7O0FBRUEsU0FBSyxJQUFNLEdBQVgsSUFBa0IsT0FBbEIsRUFBMkI7QUFDekIsVUFBSSxHQUFHLEtBQUssR0FBUixJQUFlLEdBQUcsQ0FBQyxPQUFELEVBQVUsR0FBVixDQUF0QixFQUFzQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRCxDQUF6Qjs7QUFDQSxZQUFJLE9BQU8sV0FBUCxLQUF1QixRQUEzQixFQUFxQztBQUNuQyxVQUFBLFdBQVcsR0FBRyxPQUFPLENBQUMsSUFBUixDQUFhLE9BQU8sQ0FBQyxHQUFELENBQXBCLEVBQTJCLFdBQTNCLEVBQXdDLGVBQXhDLENBQWQ7QUFDRCxTQVBtQyxDQVFwQztBQUNBO0FBQ0E7OztBQUNBLFFBQUEsWUFBWSxHQUFHLGlCQUFpQixDQUFDLFlBQUQsRUFBZSxJQUFJLE1BQUosVUFBa0IsR0FBbEIsVUFBNEIsR0FBNUIsQ0FBZixFQUFpRCxXQUFqRCxDQUFoQztBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxZQUFQOztBQUVBLGFBQVMsaUJBQVQsQ0FBNEIsTUFBNUIsRUFBb0MsRUFBcEMsRUFBd0MsV0FBeEMsRUFBcUQ7QUFDbkQsVUFBTSxRQUFRLEdBQUcsRUFBakI7QUFDQSxNQUFBLE1BQU0sQ0FBQyxPQUFQLENBQWUsVUFBQyxLQUFELEVBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixpQkFBTyxRQUFRLENBQUMsSUFBVCxDQUFjLEtBQWQsQ0FBUDtBQUNEOztBQUVELFFBQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxLQUFYLEVBQWtCLEVBQWxCLEVBQXNCLE9BQXRCLENBQThCLFVBQUMsR0FBRCxFQUFNLENBQU4sRUFBUyxJQUFULEVBQWtCO0FBQzlDLGNBQUksR0FBRyxLQUFLLEVBQVosRUFBZ0I7QUFDZCxZQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsR0FBZDtBQUNELFdBSDZDLENBSzlDOzs7QUFDQSxjQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTCxHQUFjLENBQXRCLEVBQXlCO0FBQ3ZCLFlBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxXQUFkO0FBQ0Q7QUFDRixTQVREO0FBVUQsT0FuQkQ7QUFvQkEsYUFBTyxRQUFQO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkdBOztBQUFBLFNBb0dFLFNBcEdGLEdBb0dFLG1CQUFXLEdBQVgsRUFBZ0IsT0FBaEIsRUFBeUI7QUFDdkIsV0FBTyxLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsRUFBeUIsT0FBekIsRUFBa0MsSUFBbEMsQ0FBdUMsRUFBdkMsQ0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5R0E7O0FBQUEsU0ErR0UsY0EvR0YsR0ErR0Usd0JBQWdCLEdBQWhCLEVBQXFCLE9BQXJCLEVBQThCO0FBQzVCLFFBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxNQUFMLENBQVksT0FBYixFQUFzQixHQUF0QixDQUFSLEVBQW9DO0FBQ2xDLFlBQU0sSUFBSSxLQUFKLHNCQUE2QixHQUE3QixDQUFOO0FBQ0Q7O0FBRUQsUUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixHQUFwQixDQUFmO0FBQ0EsUUFBTSxjQUFjLEdBQUcsT0FBTyxNQUFQLEtBQWtCLFFBQXpDOztBQUVBLFFBQUksY0FBSixFQUFvQjtBQUNsQixVQUFJLE9BQU8sSUFBSSxPQUFPLE9BQU8sQ0FBQyxXQUFmLEtBQStCLFdBQTlDLEVBQTJEO0FBQ3pELFlBQU0sTUFBTSxHQUFHLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsT0FBTyxDQUFDLFdBQTlCLENBQWY7QUFDQSxlQUFPLEtBQUssV0FBTCxDQUFpQixNQUFNLENBQUMsTUFBRCxDQUF2QixFQUFpQyxPQUFqQyxDQUFQO0FBQ0Q7O0FBQ0QsWUFBTSxJQUFJLEtBQUosQ0FBVSx3RkFBVixDQUFOO0FBQ0Q7O0FBRUQsV0FBTyxLQUFLLFdBQUwsQ0FBaUIsTUFBakIsRUFBeUIsT0FBekIsQ0FBUDtBQUNELEdBaElIOztBQUFBO0FBQUE7OztBQ2JBLElBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxpQkFBRCxDQUE3QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxZQUFULENBQXVCLE1BQXZCLEVBQStCLElBQS9CLEVBQXFDLE9BQXJDLEVBQThDO0FBQzdELE1BQUksTUFBTSxDQUFDLE1BQVgsRUFBbUI7QUFDakIsV0FBTyxJQUFJLE9BQUosQ0FBWSxVQUFDLE9BQUQsRUFBYTtBQUM5QixNQUFBLE1BQU0sQ0FBQyxNQUFQLENBQWMsT0FBZCxFQUF1QixJQUF2QixFQUE2QixPQUE3QjtBQUNELEtBRk0sQ0FBUDtBQUdEOztBQUNELFNBQU8sT0FBTyxDQUFDLE9BQVIsR0FBa0IsSUFBbEIsQ0FBdUIsWUFBTTtBQUNsQyxXQUFPLGFBQWEsQ0FBQyxNQUFNLENBQUMsU0FBUCxDQUFpQixJQUFqQixFQUF1QixPQUF2QixDQUFELEVBQWtDLEVBQWxDLENBQXBCO0FBQ0QsR0FGTSxDQUFQO0FBR0QsQ0FURDs7O0FDUkEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxhQUFULENBQXdCLE9BQXhCLEVBQWlDLElBQWpDLEVBQXVDLE1BQXZDLEVBQStDO0FBQzlEO0FBQ0EsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLEtBQVIsQ0FBYyxHQUFkLEVBQW1CLENBQW5CLENBQWIsQ0FGOEQsQ0FJOUQ7O0FBQ0EsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQUwsSUFBaUIsT0FBTyxDQUFDLEtBQVIsQ0FBYyxHQUFkLEVBQW1CLENBQW5CLEVBQXNCLEtBQXRCLENBQTRCLEdBQTVCLEVBQWlDLENBQWpDLEVBQW9DLEtBQXBDLENBQTBDLEdBQTFDLEVBQStDLENBQS9DLENBQWhDLENBTDhELENBTzlEOztBQUNBLE1BQUksUUFBUSxJQUFJLElBQWhCLEVBQXNCO0FBQ3BCLElBQUEsUUFBUSxHQUFHLFlBQVg7QUFDRDs7QUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBRCxDQUFuQjtBQUNBLE1BQU0sS0FBSyxHQUFHLEVBQWQ7O0FBQ0EsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBM0IsRUFBbUMsQ0FBQyxFQUFwQyxFQUF3QztBQUN0QyxJQUFBLEtBQUssQ0FBQyxJQUFOLENBQVcsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsQ0FBbEIsQ0FBWDtBQUNEOztBQUVELE1BQUksS0FBSjs7QUFDQSxNQUFJO0FBQ0YsSUFBQSxLQUFLLEdBQUcsSUFBSSxVQUFKLENBQWUsS0FBZixDQUFSLENBREUsQ0FDNEI7QUFDL0IsR0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1osV0FBTyxJQUFQO0FBQ0QsR0F2QjZELENBeUI5RDs7O0FBQ0EsTUFBSSxNQUFKLEVBQVk7QUFDVixXQUFPLElBQUksSUFBSixDQUFTLENBQUMsS0FBRCxDQUFULEVBQWtCLElBQUksQ0FBQyxJQUFMLElBQWEsRUFBL0IsRUFBbUM7QUFBRSxNQUFBLElBQUksRUFBRTtBQUFSLEtBQW5DLENBQVA7QUFDRDs7QUFFRCxTQUFPLElBQUksSUFBSixDQUFTLENBQUMsS0FBRCxDQUFULEVBQWtCO0FBQUUsSUFBQSxJQUFJLEVBQUU7QUFBUixHQUFsQixDQUFQO0FBQ0QsQ0EvQkQ7OztBQ0FBLElBQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxpQkFBRCxDQUF4Qjs7QUFFQSxTQUFTLG1CQUFULENBQThCLFFBQTlCLEVBQXdDLFlBQXhDLEVBQXNELElBQXRELEVBQTREO0FBQUEsTUFDbEQsUUFEa0QsR0FDVixZQURVLENBQ2xELFFBRGtEO0FBQUEsTUFDeEMsYUFEd0MsR0FDVixZQURVLENBQ3hDLGFBRHdDO0FBQUEsTUFDekIsVUFEeUIsR0FDVixZQURVLENBQ3pCLFVBRHlCOztBQUUxRCxNQUFJLFFBQUosRUFBYztBQUNaLElBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxHQUFkLHVCQUFzQyxRQUF0QztBQUNBLElBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxJQUFkLENBQW1CLGlCQUFuQixFQUFzQyxJQUF0QyxFQUE0QztBQUMxQyxNQUFBLFFBQVEsRUFBUixRQUQwQztBQUUxQyxNQUFBLGFBQWEsRUFBYixhQUYwQztBQUcxQyxNQUFBLFVBQVUsRUFBVjtBQUgwQyxLQUE1QztBQUtEO0FBQ0Y7O0FBRUQsTUFBTSxDQUFDLE9BQVAsR0FBaUIsUUFBUSxDQUFDLG1CQUFELEVBQXNCLEdBQXRCLEVBQTJCO0FBQ2xELEVBQUEsT0FBTyxFQUFFLElBRHlDO0FBRWxELEVBQUEsUUFBUSxFQUFFO0FBRndDLENBQTNCLENBQXpCOzs7QUNkQSxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsZ0JBQUQsQ0FBNUI7QUFFQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMscUJBQVQsR0FBNEM7QUFDM0QsU0FBTyxLQUFLLE1BQUwsb0JBQ0osS0FESSxDQUNFLFVBQUMsR0FBRCxFQUFTO0FBQ2QsUUFBSSxHQUFHLENBQUMsSUFBSixLQUFhLFlBQWpCLEVBQStCO0FBQzdCLFlBQU0sR0FBTjtBQUNELEtBRkQsTUFFTztBQUNMLFlBQU0sSUFBSSxZQUFKLENBQWlCLEdBQWpCLENBQU47QUFDRDtBQUNGLEdBUEksQ0FBUDtBQVFELENBVEQ7OztBQ0xBLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxnQkFBRCxDQUE1QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxrQkFBVCxDQUE2QixPQUE3QixFQUFzQztBQUNyRCxNQUFJLE9BQU8sT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQixRQUFNLFFBQVEsR0FBRyxHQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsUUFBUSxDQUFDLGdCQUFULENBQTBCLE9BQTFCLENBQWQsQ0FBakI7QUFDQSxXQUFPLFFBQVEsQ0FBQyxNQUFULEdBQWtCLENBQWxCLEdBQXNCLFFBQXRCLEdBQWlDLElBQXhDO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPLE9BQVAsS0FBbUIsUUFBbkIsSUFBK0IsWUFBWSxDQUFDLE9BQUQsQ0FBL0MsRUFBMEQ7QUFDeEQsV0FBTyxDQUFDLE9BQUQsQ0FBUDtBQUNEO0FBQ0YsQ0FURDs7O0FDUkEsSUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLGdCQUFELENBQTVCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLGNBQVQsQ0FBeUIsT0FBekIsRUFBa0MsT0FBbEMsRUFBc0Q7QUFBQSxNQUFwQixPQUFvQjtBQUFwQixJQUFBLE9BQW9CLEdBQVYsUUFBVTtBQUFBOztBQUNyRSxNQUFJLE9BQU8sT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQixXQUFPLE9BQU8sQ0FBQyxhQUFSLENBQXNCLE9BQXRCLENBQVA7QUFDRDs7QUFFRCxNQUFJLFlBQVksQ0FBQyxPQUFELENBQWhCLEVBQTJCO0FBQ3pCLFdBQU8sT0FBUDtBQUNEO0FBQ0YsQ0FSRDs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFNBQVQsQ0FBb0IsS0FBcEIsRUFBMkIsU0FBM0IsRUFBc0M7QUFDckQsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBMUIsRUFBa0MsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxRQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQWIsRUFBeUIsT0FBTyxDQUFQO0FBQzFCOztBQUNELFNBQU8sQ0FBQyxDQUFSO0FBQ0QsQ0FMRDs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLGNBQVQsQ0FBeUIsSUFBekIsRUFBK0I7QUFDOUM7QUFDQTtBQUVBLE1BQUksRUFBRSxHQUFHLE1BQVQ7O0FBQ0EsTUFBSSxPQUFPLElBQUksQ0FBQyxJQUFaLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDLElBQUEsRUFBRSxVQUFRLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBTCxDQUFVLFdBQVYsRUFBRCxDQUF4QjtBQUNEOztBQUVELE1BQUksSUFBSSxDQUFDLElBQUwsS0FBYyxTQUFsQixFQUE2QjtBQUMzQixJQUFBLEVBQUUsVUFBUSxJQUFJLENBQUMsSUFBZjtBQUNEOztBQUVELE1BQUksSUFBSSxDQUFDLElBQUwsSUFBYSxPQUFPLElBQUksQ0FBQyxJQUFMLENBQVUsWUFBakIsS0FBa0MsUUFBbkQsRUFBNkQ7QUFDM0QsSUFBQSxFQUFFLFVBQVEsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFMLENBQVUsWUFBVixDQUF1QixXQUF2QixFQUFELENBQXhCO0FBQ0Q7O0FBRUQsTUFBSSxJQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsS0FBbUIsU0FBdkIsRUFBa0M7QUFDaEMsSUFBQSxFQUFFLFVBQVEsSUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFwQjtBQUNEOztBQUNELE1BQUksSUFBSSxDQUFDLElBQUwsQ0FBVSxZQUFWLEtBQTJCLFNBQS9CLEVBQTBDO0FBQ3hDLElBQUEsRUFBRSxVQUFRLElBQUksQ0FBQyxJQUFMLENBQVUsWUFBcEI7QUFDRDs7QUFFRCxTQUFPLEVBQVA7QUFDRCxDQXpCRDs7QUEyQkEsU0FBUyxjQUFULENBQXlCLElBQXpCLEVBQStCO0FBQzdCLE1BQUksTUFBTSxHQUFHLEVBQWI7QUFDQSxTQUFPLElBQUksQ0FBQyxPQUFMLENBQWEsYUFBYixFQUE0QixVQUFDLFNBQUQsRUFBZTtBQUNoRCxJQUFBLE1BQU0sVUFBUSxlQUFlLENBQUMsU0FBRCxDQUE3QjtBQUNBLFdBQU8sR0FBUDtBQUNELEdBSE0sSUFHRixNQUhMO0FBSUQ7O0FBRUQsU0FBUyxlQUFULENBQTBCLFNBQTFCLEVBQXFDO0FBQ25DLFNBQU8sU0FBUyxDQUFDLFVBQVYsQ0FBcUIsQ0FBckIsRUFBd0IsUUFBeEIsQ0FBaUMsRUFBakMsQ0FBUDtBQUNEOzs7QUM1Q0QsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxpQkFBVCxDQUE0QixZQUE1QixFQUEwQztBQUN6RCxTQUFPLFlBQVksQ0FBQyxVQUFiLEdBQTBCLFlBQVksQ0FBQyxhQUE5QztBQUNELENBRkQ7OztBQ0FBLElBQU0sbUJBQW1CLEdBQUcsT0FBTyxDQUFDLG1DQUFELENBQW5DOztBQUNBLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxxQkFBRCxDQUEzQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxlQUFULENBQTBCLFlBQTFCLFNBQTBFO0FBQUEsZ0NBQUosRUFBSTtBQUFBLCtCQUFoQyxZQUFnQztBQUFBLE1BQWhDLFlBQWdDLGtDQUFqQixZQUFNLENBQUUsQ0FBUzs7QUFDekY7QUFDQSxNQUFJLFlBQVksQ0FBQyxLQUFiLElBQXNCLFlBQVksQ0FBQyxLQUFiLENBQW1CLENBQW5CLENBQXRCLElBQStDLHNCQUFzQixZQUFZLENBQUMsS0FBYixDQUFtQixDQUFuQixDQUF6RSxFQUFnRztBQUM5RixXQUFPLG1CQUFtQixDQUFDLFlBQUQsRUFBZSxZQUFmLENBQTFCLENBRDhGLENBRWhHO0FBQ0M7O0FBQ0QsU0FBTyxXQUFXLENBQUMsWUFBRCxDQUFsQjtBQUNELENBUEQ7OztBQ1pBLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxlQUFELENBQXZCLEMsQ0FFQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxXQUFULENBQXNCLFlBQXRCLEVBQW9DO0FBQ25ELE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsS0FBZCxDQUFyQjtBQUNBLFNBQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsS0FBaEIsQ0FBUDtBQUNELENBSEQ7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLG1DQUFULENBQThDLGVBQTlDLEVBQStELFVBQS9ELEVBQTJFLFlBQTNFLFFBQXdHO0FBQUEsTUFBYixTQUFhLFFBQWIsU0FBYTtBQUN2SCxFQUFBLGVBQWUsQ0FBQyxXQUFoQixDQUNFLFVBQUMsT0FBRCxFQUFhO0FBQ1gsUUFBTSxVQUFVLGFBQU8sVUFBUCxFQUFzQixPQUF0QixDQUFoQixDQURXLENBRVg7O0FBQ0EsUUFBSSxPQUFPLENBQUMsTUFBWixFQUFvQjtBQUNsQixNQUFBLFVBQVUsQ0FBQyxZQUFNO0FBQ2YsUUFBQSxtQ0FBbUMsQ0FBQyxlQUFELEVBQWtCLFVBQWxCLEVBQThCLFlBQTlCLEVBQTRDO0FBQUUsVUFBQSxTQUFTLEVBQVQ7QUFBRixTQUE1QyxDQUFuQztBQUNELE9BRlMsRUFFUCxDQUZPLENBQVYsQ0FEa0IsQ0FJcEI7QUFDQyxLQUxELE1BS087QUFDTCxNQUFBLFNBQVMsQ0FBQyxVQUFELENBQVQ7QUFDRDtBQUNGLEdBWkgsRUFhRTtBQUNBLFlBQUMsS0FBRCxFQUFXO0FBQ1QsSUFBQSxZQUFZLENBQUMsS0FBRCxDQUFaO0FBQ0EsSUFBQSxTQUFTLENBQUMsVUFBRCxDQUFUO0FBQ0QsR0FqQkg7QUFtQkQsQ0FwQkQ7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxlQUFULENBQTBCLFNBQTFCLEVBQXFDO0FBQ3BEO0FBQ0E7QUFDQSxNQUFJLENBQUMsU0FBUyxDQUFDLFFBQVgsSUFBdUIsU0FBUyxDQUFDLFFBQVYsV0FBMkIsU0FBUyxDQUFDLElBQWhFLEVBQXdFO0FBQ3RFLFdBQU8sSUFBUDtBQUNEOztBQUNELFNBQU8sU0FBUyxDQUFDLFFBQWpCO0FBQ0QsQ0FQRDs7O0FDUEEsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLGtCQUFELENBQXZCOztBQUNBLElBQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxtQkFBRCxDQUEvQjs7QUFDQSxJQUFNLG1DQUFtQyxHQUFHLE9BQU8sQ0FBQyx1Q0FBRCxDQUFuRDs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLG1CQUFULENBQThCLFlBQTlCLEVBQTRDLFlBQTVDLEVBQTBEO0FBQ3pFLE1BQU0sS0FBSyxHQUFHLEVBQWQ7QUFFQSxNQUFNLFlBQVksR0FBRyxFQUFyQjtBQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDRSxNQUFNLHNDQUFzQyxHQUFHLFNBQXpDLHNDQUF5QyxDQUFDLEtBQUQ7QUFBQSxXQUM3QyxJQUFJLE9BQUosQ0FBWSxVQUFDLE9BQUQsRUFBYTtBQUN2QjtBQUNBLFVBQUksS0FBSyxDQUFDLE1BQVYsRUFBa0I7QUFDaEI7QUFDQSxRQUFBLEtBQUssQ0FBQyxJQUFOLENBQ0UsVUFBQyxJQUFELEVBQVU7QUFDUixVQUFBLElBQUksQ0FBQyxZQUFMLEdBQW9CLGVBQWUsQ0FBQyxLQUFELENBQW5DO0FBQ0EsVUFBQSxLQUFLLENBQUMsSUFBTixDQUFXLElBQVg7QUFDQSxVQUFBLE9BQU87QUFDUixTQUxILEVBTUU7QUFDQSxrQkFBQyxLQUFELEVBQVc7QUFDVCxVQUFBLFlBQVksQ0FBQyxLQUFELENBQVo7QUFDQSxVQUFBLE9BQU87QUFDUixTQVZILEVBRmdCLENBY2xCO0FBQ0MsT0FmRCxNQWVPLElBQUksS0FBSyxDQUFDLFdBQVYsRUFBdUI7QUFDNUIsWUFBTSxlQUFlLEdBQUcsS0FBSyxDQUFDLFlBQU4sRUFBeEI7QUFDQSxRQUFBLG1DQUFtQyxDQUFDLGVBQUQsRUFBa0IsRUFBbEIsRUFBc0IsWUFBdEIsRUFBb0M7QUFDckUsVUFBQSxTQUFTLEVBQUUsbUJBQUMsT0FBRCxFQUFhO0FBQ3RCLGdCQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsR0FBUixDQUFZLFVBQUMsS0FBRDtBQUFBLHFCQUFXLHNDQUFzQyxDQUFDLEtBQUQsQ0FBakQ7QUFBQSxhQUFaLENBQWpCO0FBQ0EsWUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLFFBQVosRUFBc0IsSUFBdEIsQ0FBMkI7QUFBQSxxQkFBTSxPQUFPLEVBQWI7QUFBQSxhQUEzQjtBQUNEO0FBSm9FLFNBQXBDLENBQW5DO0FBTUQ7QUFDRixLQTFCRCxDQUQ2QztBQUFBLEdBQS9DLENBWHlFLENBd0N6RTs7O0FBQ0EsRUFBQSxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQWQsQ0FBUCxDQUNHLE9BREgsQ0FDVyxVQUFDLElBQUQsRUFBVTtBQUNqQixRQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsZ0JBQUwsRUFBZCxDQURpQixDQUVqQjs7QUFDQSxRQUFJLEtBQUosRUFBVztBQUNULE1BQUEsWUFBWSxDQUFDLElBQWIsQ0FBa0Isc0NBQXNDLENBQUMsS0FBRCxDQUF4RDtBQUNEO0FBQ0YsR0FQSDtBQVNBLFNBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBWSxZQUFaLEVBQ0osSUFESSxDQUNDO0FBQUEsV0FBTSxLQUFOO0FBQUEsR0FERCxDQUFQO0FBRUQsQ0FwREQ7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsdUJBQVQsQ0FBa0MsWUFBbEMsRUFBZ0Q7QUFDL0QsTUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDLFdBQWIsQ0FBeUIsR0FBekIsQ0FBaEIsQ0FEK0QsQ0FFL0Q7O0FBQ0EsTUFBSSxPQUFPLEtBQUssQ0FBQyxDQUFiLElBQWtCLE9BQU8sS0FBSyxZQUFZLENBQUMsTUFBYixHQUFzQixDQUF4RCxFQUEyRDtBQUN6RCxXQUFPO0FBQ0wsTUFBQSxJQUFJLEVBQUUsWUFERDtBQUVMLE1BQUEsU0FBUyxFQUFFO0FBRk4sS0FBUDtBQUlEOztBQUNELFNBQU87QUFDTCxJQUFBLElBQUksRUFBRSxZQUFZLENBQUMsS0FBYixDQUFtQixDQUFuQixFQUFzQixPQUF0QixDQUREO0FBRUwsSUFBQSxTQUFTLEVBQUUsWUFBWSxDQUFDLEtBQWIsQ0FBbUIsT0FBTyxHQUFHLENBQTdCO0FBRk4sR0FBUDtBQUlELENBYkQ7OztBQ05BLElBQU0sdUJBQXVCLEdBQUcsT0FBTyxDQUFDLDJCQUFELENBQXZDOztBQUNBLElBQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFELENBQXpCOztBQUVBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsV0FBVCxDQUFzQixJQUF0QixFQUE0QjtBQUMzQyxNQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBTCxHQUFZLHVCQUF1QixDQUFDLElBQUksQ0FBQyxJQUFOLENBQXZCLENBQW1DLFNBQS9DLEdBQTJELElBQS9FO0FBQ0EsRUFBQSxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsQ0FBQyxXQUFkLEVBQUgsR0FBaUMsSUFBOUQ7O0FBRUEsTUFBSSxJQUFJLENBQUMsSUFBVCxFQUFlO0FBQ2I7QUFDQSxXQUFPLElBQUksQ0FBQyxJQUFaO0FBQ0Q7O0FBQUMsTUFBSSxhQUFhLElBQUksU0FBUyxDQUFDLGFBQUQsQ0FBOUIsRUFBK0M7QUFDL0M7QUFDQSxXQUFPLFNBQVMsQ0FBQyxhQUFELENBQWhCO0FBQ0QsR0FWMEMsQ0FXM0M7OztBQUNBLFNBQU8sMEJBQVA7QUFDRCxDQWJEOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU0sZ0JBQWdCLEdBQUc7QUFDdkIsZUFBYSxLQURVO0FBRXZCLGVBQWEsS0FGVTtBQUd2QixlQUFhLEtBSFU7QUFJdkIsZ0JBQWMsTUFKUztBQUt2QixlQUFhLEtBTFU7QUFNdkIsZ0JBQWMsTUFOUztBQU92QixnQkFBYyxNQVBTO0FBUXZCLGdCQUFjLEtBUlM7QUFTdkIsZUFBYSxLQVRVO0FBVXZCLG1CQUFpQixLQVZNO0FBV3ZCLGVBQWEsS0FYVTtBQVl2QixlQUFhLEtBWlU7QUFhdkIscUJBQW1CLEtBYkk7QUFjdkIsZ0JBQWMsTUFkUztBQWV2QixzQkFBb0IsS0FmRztBQWdCdkIscUJBQW1CO0FBaEJJLENBQXpCOztBQW1CQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLG9CQUFULENBQStCLFFBQS9CLEVBQXlDO0FBQ3hEO0FBQ0EsRUFBQSxRQUFRLEdBQUcsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsTUFBakIsRUFBeUIsRUFBekIsQ0FBWDtBQUNBLFNBQU8sZ0JBQWdCLENBQUMsUUFBRCxDQUFoQixJQUE4QixJQUFyQztBQUNELENBSkQ7OztBQ3ZCQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLGFBQVQsQ0FBd0IsR0FBeEIsRUFBNkI7QUFDNUM7QUFDQSxNQUFJLEtBQUssR0FBRyx3REFBWjtBQUNBLE1BQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFOLENBQVcsR0FBWCxFQUFnQixDQUFoQixDQUFYO0FBQ0EsTUFBSSxjQUFjLEdBQUcsY0FBYyxJQUFkLENBQW1CLEdBQW5CLElBQTBCLElBQTFCLEdBQWlDLEtBQXREO0FBRUEsU0FBVSxjQUFWLFdBQThCLElBQTlCO0FBQ0QsQ0FQRDs7O0FDQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxRQUFULENBQW1CLFlBQW5CLEVBQWlDO0FBQ2hELE1BQUksQ0FBQyxZQUFZLENBQUMsYUFBbEIsRUFBaUMsT0FBTyxDQUFQO0FBRWpDLE1BQU0sV0FBVyxHQUFJLElBQUksSUFBSixFQUFELEdBQWUsWUFBWSxDQUFDLGFBQWhEO0FBQ0EsTUFBTSxXQUFXLEdBQUcsWUFBWSxDQUFDLGFBQWIsSUFBOEIsV0FBVyxHQUFHLElBQTVDLENBQXBCO0FBQ0EsU0FBTyxXQUFQO0FBQ0QsQ0FORDs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsU0FBUyxnQkFBVCxDQUEyQixPQUEzQixFQUFvQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUEzQixFQUFnQztBQUM5QixJQUFBLE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBbEI7QUFDRDs7QUFDRCxTQUFPLE9BQU8sR0FBRyxPQUFPLENBQUMsR0FBWCxHQUFpQixTQUEvQjtBQUNEOztBQUVELE1BQU0sQ0FBQyxPQUFQLEdBQWlCLGdCQUFqQjs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsWUFBVCxHQUF5QjtBQUN4QyxNQUFJLElBQUksR0FBRyxJQUFJLElBQUosRUFBWDtBQUNBLE1BQUksS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBTCxHQUFnQixRQUFoQixFQUFELENBQWY7QUFDQSxNQUFJLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQUwsR0FBa0IsUUFBbEIsRUFBRCxDQUFqQjtBQUNBLE1BQUksT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBTCxHQUFrQixRQUFsQixFQUFELENBQWpCO0FBQ0EsU0FBVSxLQUFWLFNBQW1CLE9BQW5CLFNBQThCLE9BQTlCO0FBQ0QsQ0FORDtBQVFBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxHQUFULENBQWMsR0FBZCxFQUFtQjtBQUNqQixTQUFPLEdBQUcsQ0FBQyxNQUFKLEtBQWUsQ0FBZixHQUFtQixJQUFJLEdBQXZCLEdBQTZCLEdBQXBDO0FBQ0Q7OztBQ2hCRCxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLEdBQVQsQ0FBYyxNQUFkLEVBQXNCLEdBQXRCLEVBQTJCO0FBQzFDLFNBQU8sTUFBTSxDQUFDLFNBQVAsQ0FBaUIsY0FBakIsQ0FBZ0MsSUFBaEMsQ0FBcUMsTUFBckMsRUFBNkMsR0FBN0MsQ0FBUDtBQUNELENBRkQ7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFlBQVQsQ0FBdUIsR0FBdkIsRUFBNEI7QUFDM0MsU0FBTyxHQUFHLElBQUksT0FBTyxHQUFQLEtBQWUsUUFBdEIsSUFBa0MsR0FBRyxDQUFDLFFBQUosS0FBaUIsSUFBSSxDQUFDLFlBQS9EO0FBQ0QsQ0FGRDs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsbUJBQVQsR0FBZ0M7QUFDL0MsTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjs7QUFFQSxNQUFJLEVBQUUsZUFBZSxHQUFqQixLQUF5QixFQUFFLGlCQUFpQixHQUFqQixJQUF3QixZQUFZLEdBQXRDLENBQTdCLEVBQXlFO0FBQ3ZFLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUksRUFBRSxjQUFjLE1BQWhCLENBQUosRUFBNkI7QUFDM0IsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSSxFQUFFLGdCQUFnQixNQUFsQixDQUFKLEVBQStCO0FBQzdCLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNELENBaEJEOzs7QUNMQSxTQUFTLGNBQVQsQ0FBeUIsR0FBekIsRUFBOEI7QUFDNUIsTUFBSSxDQUFDLEdBQUwsRUFBVTtBQUNSLFdBQU8sS0FBUDtBQUNEOztBQUNELFNBQVEsR0FBRyxDQUFDLFVBQUosS0FBbUIsQ0FBbkIsSUFBd0IsR0FBRyxDQUFDLFVBQUosS0FBbUIsQ0FBNUMsSUFBa0QsR0FBRyxDQUFDLE1BQUosS0FBZSxDQUF4RTtBQUNEOztBQUVELE1BQU0sQ0FBQyxPQUFQLEdBQWlCLGNBQWpCOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFdBQVQsQ0FBc0IsR0FBdEIsRUFBMkI7QUFDMUMsU0FBTyxHQUFHLENBQUMsT0FBSixDQUFZLE9BQVosTUFBeUIsQ0FBaEM7QUFDRCxDQUZEOzs7QUNOQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLGtCQUFULENBQTZCLFFBQTdCLEVBQXVDO0FBQ3RELE1BQUksQ0FBQyxRQUFMLEVBQWUsT0FBTyxLQUFQO0FBQ2YsTUFBTSxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsS0FBVCxDQUFlLEdBQWYsRUFBb0IsQ0FBcEIsQ0FBekIsQ0FGc0QsQ0FHdEQ7O0FBQ0EsTUFBSSwrQ0FBK0MsSUFBL0MsQ0FBb0QsZ0JBQXBELENBQUosRUFBMkU7QUFDekUsV0FBTyxJQUFQO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFQO0FBQ0QsQ0FSRDs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQjtBQUNmLEVBQUEsRUFBRSxFQUFFLGVBRFc7QUFFZixFQUFBLFFBQVEsRUFBRSxlQUZLO0FBR2YsRUFBQSxHQUFHLEVBQUUsV0FIVTtBQUlmLEVBQUEsR0FBRyxFQUFFLFdBSlU7QUFLZixFQUFBLEdBQUcsRUFBRSxlQUxVO0FBTWYsRUFBQSxHQUFHLEVBQUUsWUFOVTtBQU9mLEVBQUEsR0FBRyxFQUFFLFdBUFU7QUFRZixFQUFBLEdBQUcsRUFBRSxXQVJVO0FBU2YsRUFBQSxJQUFJLEVBQUUsWUFUUztBQVVmLEVBQUEsSUFBSSxFQUFFLFlBVlM7QUFXZixFQUFBLElBQUksRUFBRSxXQVhTO0FBWWYsRUFBQSxHQUFHLEVBQUUsV0FaVTtBQWFmLEVBQUEsR0FBRyxFQUFFLFVBYlU7QUFjZixFQUFBLEdBQUcsRUFBRSwyQkFkVTtBQWVmLEVBQUEsR0FBRyxFQUFFLDJCQWZVO0FBZ0JmLEVBQUEsR0FBRyxFQUFFLGlCQWhCVTtBQWlCZixFQUFBLEdBQUcsRUFBRSxrQkFqQlU7QUFrQmYsRUFBQSxHQUFHLEVBQUUsa0JBbEJVO0FBbUJmLEVBQUEsR0FBRyxFQUFFLGlCQW5CVTtBQW9CZixFQUFBLEdBQUcsRUFBRSxvQkFwQlU7QUFxQmYsRUFBQSxJQUFJLEVBQUUsa0RBckJTO0FBc0JmLEVBQUEsSUFBSSxFQUFFLHlFQXRCUztBQXVCZixFQUFBLEdBQUcsRUFBRSxvQkF2QlU7QUF3QmYsRUFBQSxJQUFJLEVBQUUsa0RBeEJTO0FBeUJmLEVBQUEsSUFBSSxFQUFFLHlFQXpCUztBQTBCZixFQUFBLEdBQUcsRUFBRSwwQkExQlU7QUEyQmYsRUFBQSxJQUFJLEVBQUUsZ0RBM0JTO0FBNEJmLEVBQUEsR0FBRyxFQUFFLDBCQTVCVTtBQTZCZixFQUFBLEdBQUcsRUFBRSx5QkE3QlU7QUE4QmYsRUFBQSxHQUFHLEVBQUUsMEJBOUJVO0FBK0JmLEVBQUEsR0FBRyxFQUFFLDBCQS9CVTtBQWdDZixFQUFBLElBQUksRUFBRSx1REFoQ1M7QUFpQ2YsRUFBQSxJQUFJLEVBQUUsZ0RBakNTO0FBa0NmLEVBQUEsSUFBSSxFQUFFLG1FQWxDUztBQW1DZixFQUFBLEdBQUcsRUFBRSwwQkFuQ1U7QUFvQ2YsRUFBQSxJQUFJLEVBQUUsbURBcENTO0FBcUNmLEVBQUEsSUFBSSxFQUFFLHNFQXJDUztBQXNDZixFQUFBLEdBQUcsRUFBRSwwQkF0Q1U7QUF1Q2YsRUFBQSxHQUFHLEVBQUUsWUF2Q1U7QUF3Q2YsRUFBQSxJQUFJLEVBQUUsWUF4Q1M7QUF5Q2YsRUFBQSxJQUFJLEVBQUUsWUF6Q1M7QUEwQ2YsRUFBQSxHQUFHLEVBQUUsWUExQ1U7QUEyQ2YsRUFBQSxHQUFHLEVBQUUsaUJBM0NVO0FBNENmLEVBQUEsR0FBRyxFQUFFLGlCQTVDVTtBQTZDZixRQUFNLDZCQTdDUztBQThDZixFQUFBLEdBQUcsRUFBRSw4QkE5Q1U7QUErQ2YsRUFBQSxHQUFHLEVBQUUsbUJBL0NVO0FBZ0RmLEVBQUEsRUFBRSxFQUFFLGtCQWhEVztBQWlEZixFQUFBLEdBQUcsRUFBRTtBQWpEVSxDQUFqQjs7O0FDTEEsSUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLGlCQUFELENBQTdCOztBQUVBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsU0FBVCxDQUFvQixPQUFwQixFQUE2QjtBQUM1QyxNQUFNLElBQUksR0FBRyxhQUFhLENBQUMsT0FBRCxDQUExQixDQUQ0QyxDQUc1QztBQUNBO0FBQ0E7O0FBQ0EsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUwsR0FBZ0IsSUFBSSxDQUFDLEtBQXJCLFVBQWlDLEVBQWxEO0FBQ0EsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUwsR0FBYSxPQUFLLElBQUksQ0FBQyxPQUFWLEVBQXFCLE1BQXJCLENBQTRCLENBQUMsQ0FBN0IsQ0FBYixHQUErQyxJQUFJLENBQUMsT0FBdkU7QUFDQSxNQUFNLFVBQVUsR0FBRyxVQUFVLEdBQU0sVUFBTixTQUFzQixFQUFuRDtBQUNBLE1BQU0sVUFBVSxHQUFHLFVBQVUsR0FBRyxPQUFLLElBQUksQ0FBQyxPQUFWLEVBQXFCLE1BQXJCLENBQTRCLENBQUMsQ0FBN0IsQ0FBSCxHQUFxQyxJQUFJLENBQUMsT0FBdkU7QUFDQSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBTCxHQUFhLEVBQWIsR0FBbUIsVUFBVSxTQUFPLFVBQVAsU0FBMEIsVUFBMUIsTUFBaEQ7QUFFQSxjQUFVLFFBQVYsR0FBcUIsVUFBckIsR0FBa0MsVUFBbEM7QUFDRCxDQWJEOzs7OztBQ0ZBLElBQU0sdUJBQXVCLEdBQUcsT0FBTyxDQUFDLDJCQUFELENBQXZDOztBQUVBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsb0JBQVQsQ0FBK0IsSUFBL0IsRUFBcUM7QUFDcEQsc0JBQ0ssSUFETDtBQUVFLElBQUEsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUZiO0FBR0UsSUFBQSxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUwsR0FBWSx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsSUFBTixDQUF2QixDQUFtQyxTQUEvQyxHQUEyRDtBQUh4RTtBQUtELENBTkQ7OztBQ0ZBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsYUFBVCxDQUF3QixVQUF4QixFQUFvQztBQUNuRCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLFVBQVUsR0FBRyxJQUF4QixJQUFnQyxFQUE5QztBQUNBLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsVUFBVSxHQUFHLEVBQXhCLElBQThCLEVBQTlDO0FBQ0EsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxVQUFVLEdBQUcsRUFBeEIsQ0FBaEI7QUFFQSxTQUFPO0FBQUUsSUFBQSxLQUFLLEVBQUwsS0FBRjtBQUFTLElBQUEsT0FBTyxFQUFQLE9BQVQ7QUFBa0IsSUFBQSxPQUFPLEVBQVA7QUFBbEIsR0FBUDtBQUNELENBTkQ7OztBQ0FBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsTUFBVCxDQUFpQixRQUFqQixFQUEyQjtBQUMxQyxNQUFNLFdBQVcsR0FBRyxFQUFwQjtBQUNBLE1BQU0sVUFBVSxHQUFHLEVBQW5COztBQUNBLFdBQVMsUUFBVCxDQUFtQixLQUFuQixFQUEwQjtBQUN4QixJQUFBLFdBQVcsQ0FBQyxJQUFaLENBQWlCLEtBQWpCO0FBQ0Q7O0FBQ0QsV0FBUyxRQUFULENBQW1CLEtBQW5CLEVBQTBCO0FBQ3hCLElBQUEsVUFBVSxDQUFDLElBQVgsQ0FBZ0IsS0FBaEI7QUFDRDs7QUFFRCxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsR0FBUixDQUNYLFFBQVEsQ0FBQyxHQUFULENBQWEsVUFBQyxPQUFEO0FBQUEsV0FBYSxPQUFPLENBQUMsSUFBUixDQUFhLFFBQWIsRUFBdUIsUUFBdkIsQ0FBYjtBQUFBLEdBQWIsQ0FEVyxDQUFiO0FBSUEsU0FBTyxJQUFJLENBQUMsSUFBTCxDQUFVLFlBQU07QUFDckIsV0FBTztBQUNMLE1BQUEsVUFBVSxFQUFFLFdBRFA7QUFFTCxNQUFBLE1BQU0sRUFBRTtBQUZILEtBQVA7QUFJRCxHQUxNLENBQVA7QUFNRCxDQXBCRDs7O0FDQUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxPQUFULENBQWtCLElBQWxCLEVBQXdCO0FBQ3ZDLFNBQU8sS0FBSyxDQUFDLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsSUFBSSxJQUFJLEVBQW5DLEVBQXVDLENBQXZDLENBQVA7QUFDRCxDQUZEOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxjQUFULENBQXlCLE1BQXpCLEVBQWlDLFNBQWpDLEVBQTRDO0FBQzNELE1BQU0sU0FBUyxHQUFHLEtBQWxCLENBRDJELENBRzNEOztBQUNBLE1BQUksTUFBTSxDQUFDLE1BQVAsSUFBaUIsU0FBckIsRUFBZ0M7QUFDOUIsV0FBTyxNQUFQLENBRDhCLENBRWhDO0FBQ0M7O0FBQUMsTUFBSSxTQUFTLElBQUksU0FBUyxDQUFDLE1BQTNCLEVBQW1DO0FBQ25DLFdBQU8sTUFBTSxDQUFDLE1BQVAsQ0FBYyxDQUFkLEVBQWlCLFNBQWpCLENBQVAsQ0FEbUMsQ0FFckM7QUFDQzs7QUFDRCxNQUFNLFdBQVcsR0FBRyxTQUFTLEdBQUcsU0FBUyxDQUFDLE1BQTFDO0FBQ0EsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUwsQ0FBVSxXQUFXLEdBQUcsQ0FBeEIsQ0FBbkI7QUFDQSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLFdBQVcsR0FBRyxDQUF6QixDQUFsQjtBQUVBLFNBQU8sTUFBTSxDQUFDLE1BQVAsQ0FBYyxDQUFkLEVBQWlCLFVBQWpCLElBQStCLFNBQS9CLEdBQTJDLE1BQU0sQ0FBQyxNQUFQLENBQWMsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsU0FBOUIsQ0FBbEQ7QUFDRCxDQWhCRDs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztlQ25DYyxPQUFPLENBQUMsUUFBRCxDO0lBQWIsQyxZQUFBLEM7O0FBRVIsTUFBTSxDQUFDLE9BQVAsR0FBaUIsVUFBQyxLQUFELEVBQVc7QUFDMUIsU0FDRTtBQUFLLG1CQUFZLE1BQWpCO0FBQXdCLElBQUEsU0FBUyxFQUFDLE9BQWxDO0FBQTBDLElBQUEsSUFBSSxFQUFDLFNBQS9DO0FBQXlELElBQUEsS0FBSyxFQUFDLElBQS9EO0FBQW9FLElBQUEsTUFBTSxFQUFDLElBQTNFO0FBQWdGLElBQUEsT0FBTyxFQUFDO0FBQXhGLEtBQ0U7QUFBTSxJQUFBLENBQUMsRUFBQyxzZUFBUjtBQUErZSxJQUFBLFFBQVEsRUFBQztBQUF4ZixJQURGLENBREY7QUFLRCxDQU5EOzs7Ozs7Ozs7QUNGQTtlQUN5QixPQUFPLENBQUMsUUFBRCxDO0lBQXhCLEMsWUFBQSxDO0lBQUcsUyxZQUFBLFM7O0FBQ1gsSUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLGtCQUFELENBQTlCOztBQUNBLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxnQkFBRCxDQUE1Qjs7QUFDQSxJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsbUJBQUQsQ0FBL0I7O0FBQ0EsSUFBTSxpQkFBaUIsR0FBRyxPQUFPLENBQUMscUJBQUQsQ0FBakM7O0FBQ0EsSUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLGdCQUFELENBQTVCOztBQUNBLElBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxpQkFBRCxDQUE3Qjs7QUFFQSxTQUFTLGVBQVQsQ0FBMEIsS0FBMUIsRUFBaUMsSUFBakMsRUFBdUM7QUFDckMsU0FBTyxLQUFLLENBQUMsT0FBTixDQUFjLElBQWQsTUFBd0IsQ0FBQyxDQUFoQztBQUNEOztJQUVLLFk7Ozs7Ozs7OztTQUNKLGlCLEdBQUEsNkJBQXFCO0FBQUEsUUFDWCxPQURXLEdBQ0MsS0FBSyxLQUROLENBQ1gsT0FEVztBQUVuQixJQUFBLE9BQU87QUFDUixHOztTQUVELG9CLEdBQUEsZ0NBQXdCO0FBQUEsUUFDZCxNQURjLEdBQ0gsS0FBSyxLQURGLENBQ2QsTUFEYztBQUV0QixJQUFBLE1BQU07QUFDUCxHOztTQUVELE0sR0FBQSxrQkFBVTtBQUFBOztBQUFBLHNCQWtCSixLQUFLLEtBbEJEO0FBQUEsUUFFTixHQUZNLGVBRU4sR0FGTTtBQUFBLFFBR04sYUFITSxlQUdOLGFBSE07QUFBQSxRQUlOLFNBSk0sZUFJTixTQUpNO0FBQUEsUUFLTixLQUxNLGVBS04sS0FMTTtBQUFBLFFBTU4saUJBTk0sZUFNTixpQkFOTTtBQUFBLFFBT04sWUFQTSxlQU9OLFlBUE07QUFBQSxRQVFOLHVCQVJNLGVBUU4sdUJBUk07QUFBQSxRQVNOLG1CQVRNLGVBU04sbUJBVE07QUFBQSxRQVVOLFFBVk0sZUFVTixRQVZNO0FBQUEsUUFXTixJQVhNLGVBV04sSUFYTTtBQUFBLFFBWU4sTUFaTSxlQVlOLE1BWk07QUFBQSxRQWFOLFVBYk0sZUFhTixVQWJNO0FBQUEsUUFjTixnQkFkTSxlQWNOLGdCQWRNO0FBQUEsUUFlTixlQWZNLGVBZU4sZUFmTTtBQUFBLFFBZ0JOLHNCQWhCTSxlQWdCTixzQkFoQk07QUFBQSxRQWlCTixzQkFqQk0sZUFpQk4sc0JBakJNO0FBb0JSLFFBQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLGFBQTNCO0FBQ0EsUUFBTSxzQkFBc0IsR0FBRyxDQUFDLGdCQUFELElBQXFCLGlCQUFyQixLQUM3QixlQUFlLENBQUMsS0FBRCxFQUFRLFlBQVIsQ0FBZixJQUNHLGVBQWUsQ0FBQyxLQUFELEVBQVEsWUFBUixDQURsQixJQUVHLGVBQWUsQ0FBQyxLQUFELEVBQVEsYUFBUixDQUhXLENBQS9CO0FBS0EsUUFBTSx3QkFBd0IsR0FBRyxDQUFDLGdCQUFELElBQXFCLGVBQWUsQ0FBQyxLQUFELEVBQVEsU0FBUixDQUFyRTtBQUNBLFFBQU0seUJBQXlCLEdBQUcsaUJBQWlCLElBQUksbUJBQXZEO0FBQ0EsUUFBTSw2QkFBNkIsR0FBRyx1QkFBdUIsSUFBSSxZQUEzQixJQUEyQyxZQUFZLENBQUMsTUFBYixHQUFzQixDQUF2RztBQUVBLFFBQU0sVUFBVSxHQUFHO0FBQ2pCLE1BQUEsV0FBVyxFQUFFO0FBREksS0FBbkI7O0FBSUEsUUFBSSxhQUFKLEVBQW1CO0FBQ2pCLE1BQUEsVUFBVSxDQUFDLEtBQVgsR0FBbUIsS0FBbkI7QUFDQSxNQUFBLFVBQVUsQ0FBQyxRQUFYLEdBQXNCLElBQXRCO0FBQ0EsTUFBQSxVQUFVLENBQUMsR0FBWCxHQUFpQixhQUFqQixDQUhpQixDQUtqQjs7QUFDQSxVQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNyQixhQUFLLFlBQUwsQ0FBa0IsU0FBbEIsR0FBOEIsU0FBOUI7QUFDRDtBQUNGLEtBVEQsTUFTTztBQUNMLE1BQUEsVUFBVSxDQUFDLEtBQVgsR0FBbUIsSUFBbkI7QUFDQSxNQUFBLFVBQVUsQ0FBQyxRQUFYLEdBQXNCLElBQXRCO0FBQ0EsTUFBQSxVQUFVLENBQUMsU0FBWCxHQUF1QixHQUF2QjtBQUNEOztBQUVELFdBQ0U7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLE9BQ0U7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLE9BQ0U7QUFDRTtBQUNBLE1BQUEsR0FBRyxFQUFFLGFBQUMsWUFBRDtBQUFBLGVBQW1CLEtBQUksQ0FBQyxZQUFMLEdBQW9CLFlBQXZDO0FBQUEsT0FGUDtBQUdFLE1BQUEsU0FBUywyQkFBd0IsTUFBTSxHQUFHLDZCQUFILEdBQW1DLEVBQWpFO0FBQ1Q7O0FBSkYsT0FLTSxVQUxOLEVBREYsQ0FERixFQVVFO0FBQUssTUFBQSxTQUFTLEVBQUM7QUFBZixPQUNFO0FBQUssTUFBQSxTQUFTLEVBQUM7QUFBZixPQUNHLDZCQUE2QixHQUMxQixpQkFBaUIsQ0FBQyxLQUFLLEtBQU4sQ0FEUyxHQUUxQixJQUhOLENBREYsRUFNRTtBQUFLLE1BQUEsU0FBUyxFQUFDO0FBQWYsT0FDRyx3QkFBd0IsSUFBSSxFQUFDLGNBQUQ7QUFBZ0IsTUFBQSxVQUFVLEVBQUUsVUFBNUI7QUFBd0MsTUFBQSxJQUFJLEVBQUU7QUFBOUMsTUFEL0IsRUFHRyxzQkFBc0IsSUFDckIsRUFBQyxZQUFEO0FBQ0UsTUFBQSxTQUFTLEVBQUUsU0FEYjtBQUVFLE1BQUEsZ0JBQWdCLEVBQUUsZ0JBRnBCO0FBR0UsTUFBQSxlQUFlLEVBQUUsZUFIbkI7QUFJRSxNQUFBLElBQUksRUFBRTtBQUpSLE1BSkosRUFZRyxnQkFBZ0IsSUFBSSxFQUFDLFlBQUQ7QUFBYyxNQUFBLFFBQVEsRUFBRSxRQUF4QjtBQUFrQyxNQUFBLElBQUksRUFBRTtBQUF4QyxNQVp2QixFQWNHLGdCQUFnQixJQUFJLEVBQUMsYUFBRDtBQUFlLE1BQUEsU0FBUyxFQUFFLHNCQUExQjtBQUFrRCxNQUFBLElBQUksRUFBRTtBQUF4RCxNQWR2QixDQU5GLEVBdUJHLHlCQUF5QixJQUN4QjtBQUFLLE1BQUEsU0FBUyxFQUFDO0FBQWYsT0FDRSxFQUFDLGVBQUQ7QUFBaUIsTUFBQSxzQkFBc0IsRUFBRSxzQkFBekM7QUFBaUUsTUFBQSxJQUFJLEVBQUU7QUFBdkUsTUFERixDQXhCSixDQVZGLENBREY7QUEwQ0QsRzs7O0VBdEd3QixTOztBQXlHM0IsTUFBTSxDQUFDLE9BQVAsR0FBaUIsWUFBakI7OztlQ3RIYyxPQUFPLENBQUMsUUFBRCxDO0lBQWIsQyxZQUFBLEM7O0FBRVIsU0FBUyxhQUFULE9BQTZDO0FBQUEsTUFBbkIsU0FBbUIsUUFBbkIsU0FBbUI7QUFBQSxNQUFSLElBQVEsUUFBUixJQUFRO0FBQzNDLFNBQ0U7QUFDRSxJQUFBLFNBQVMsRUFBQyw0Q0FEWjtBQUVFLElBQUEsSUFBSSxFQUFDLFFBRlA7QUFHRSxJQUFBLEtBQUssRUFBRSxJQUFJLENBQUMscUJBQUQsQ0FIYjtBQUlFLGtCQUFZLElBQUksQ0FBQyxxQkFBRCxDQUpsQjtBQUtFLElBQUEsT0FBTyxFQUFFLFNBTFg7QUFNRTtBQU5GLEtBUUU7QUFDRSxJQUFBLEtBQUssRUFBQyxJQURSO0FBRUUsSUFBQSxNQUFNLEVBQUMsSUFGVDtBQUdFLElBQUEsT0FBTyxFQUFDLFdBSFY7QUFJRSxJQUFBLEtBQUssRUFBQyw0QkFKUjtBQUtFLG1CQUFZLE1BTGQ7QUFNRSxJQUFBLFNBQVMsRUFBQyxPQU5aO0FBT0UsSUFBQSxTQUFTLEVBQUM7QUFQWixLQVNFO0FBQUcsSUFBQSxJQUFJLEVBQUMsTUFBUjtBQUFlLElBQUEsUUFBUSxFQUFDO0FBQXhCLEtBQ0U7QUFBTSxJQUFBLENBQUMsRUFBQztBQUFSLElBREYsRUFFRTtBQUFNLElBQUEsQ0FBQyxFQUFDO0FBQVIsSUFGRixDQVRGLENBUkYsQ0FERjtBQXlCRDs7QUFFRCxNQUFNLENBQUMsT0FBUCxHQUFpQixhQUFqQjs7O2VDOUJjLE9BQU8sQ0FBQyxRQUFELEM7SUFBYixDLFlBQUEsQzs7QUFFUixNQUFNLENBQUMsT0FBUCxHQUFpQixVQUFDLEtBQUQsRUFBVztBQUMxQixTQUNFO0FBQUssSUFBQSxTQUFTLEVBQUM7QUFBZixLQUNFO0FBQUssSUFBQSxTQUFTLEVBQUM7QUFBZixLQUE2QyxLQUFLLENBQUMsSUFBTixFQUE3QyxDQURGLEVBRUU7QUFBSSxJQUFBLFNBQVMsRUFBQztBQUFkLEtBQW1DLEtBQUssQ0FBQyxTQUFOLEdBQWtCLEtBQUssQ0FBQyxJQUFOLENBQVcsa0JBQVgsQ0FBbEIsR0FBbUQsS0FBSyxDQUFDLElBQU4sQ0FBVyxlQUFYLENBQXRGLENBRkYsRUFHRSxhQUFJLEtBQUssQ0FBQyxTQUFOLEdBQWtCLEtBQUssQ0FBQyxJQUFOLENBQVcsd0JBQVgsQ0FBbEIsR0FBeUQsS0FBSyxDQUFDLElBQU4sQ0FBVyxxQkFBWCxDQUE3RCxDQUhGLENBREY7QUFPRCxDQVJEOzs7ZUNGYyxPQUFPLENBQUMsUUFBRCxDO0lBQWIsQyxZQUFBLEM7O0FBRVIsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxZQUFULE9BQStFO0FBQUEsTUFBdEQsU0FBc0QsUUFBdEQsU0FBc0Q7QUFBQSxNQUEzQyxnQkFBMkMsUUFBM0MsZ0JBQTJDO0FBQUEsTUFBekIsZUFBeUIsUUFBekIsZUFBeUI7QUFBQSxNQUFSLElBQVEsUUFBUixJQUFROztBQUM5RixNQUFJLFNBQUosRUFBZTtBQUNiLFdBQ0U7QUFDRSxNQUFBLFNBQVMsRUFBQyw0Q0FEWjtBQUVFLE1BQUEsSUFBSSxFQUFDLFFBRlA7QUFHRSxNQUFBLEtBQUssRUFBRSxJQUFJLENBQUMsZUFBRCxDQUhiO0FBSUUsb0JBQVksSUFBSSxDQUFDLGVBQUQsQ0FKbEI7QUFLRSxNQUFBLE9BQU8sRUFBRSxlQUxYO0FBTUU7QUFORixPQVFFO0FBQUsscUJBQVksTUFBakI7QUFBd0IsTUFBQSxTQUFTLEVBQUMsT0FBbEM7QUFBMEMsTUFBQSxTQUFTLEVBQUMsYUFBcEQ7QUFBa0UsTUFBQSxLQUFLLEVBQUMsS0FBeEU7QUFBOEUsTUFBQSxNQUFNLEVBQUMsS0FBckY7QUFBMkYsTUFBQSxPQUFPLEVBQUM7QUFBbkcsT0FDRTtBQUFNLE1BQUEsQ0FBQyxFQUFDLElBQVI7QUFBYSxNQUFBLENBQUMsRUFBQyxJQUFmO0FBQW9CLE1BQUEsS0FBSyxFQUFDLElBQTFCO0FBQStCLE1BQUEsTUFBTSxFQUFDO0FBQXRDLE1BREYsQ0FSRixDQURGO0FBY0Q7O0FBRUQsU0FDRTtBQUNFLElBQUEsU0FBUyxFQUFDLDRDQURaO0FBRUUsSUFBQSxJQUFJLEVBQUMsUUFGUDtBQUdFLElBQUEsS0FBSyxFQUFFLElBQUksQ0FBQyxnQkFBRCxDQUhiO0FBSUUsa0JBQVksSUFBSSxDQUFDLGdCQUFELENBSmxCO0FBS0UsSUFBQSxPQUFPLEVBQUUsZ0JBTFg7QUFNRTtBQU5GLEtBUUU7QUFBSyxtQkFBWSxNQUFqQjtBQUF3QixJQUFBLFNBQVMsRUFBQyxPQUFsQztBQUEwQyxJQUFBLFNBQVMsRUFBQyxhQUFwRDtBQUFrRSxJQUFBLEtBQUssRUFBQyxLQUF4RTtBQUE4RSxJQUFBLE1BQU0sRUFBQyxLQUFyRjtBQUEyRixJQUFBLE9BQU8sRUFBQztBQUFuRyxLQUNFO0FBQVEsSUFBQSxFQUFFLEVBQUMsSUFBWDtBQUFnQixJQUFBLEVBQUUsRUFBQyxJQUFuQjtBQUF3QixJQUFBLENBQUMsRUFBQztBQUExQixJQURGLENBUkYsQ0FERjtBQWNELENBaENEOzs7ZUNGYyxPQUFPLENBQUMsUUFBRCxDO0lBQWIsQyxZQUFBLEM7O0FBQ1IsSUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLGlCQUFELENBQTdCOztBQUVBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsZUFBVCxPQUE0RDtBQUFBLE1BQWhDLHNCQUFnQyxRQUFoQyxzQkFBZ0M7QUFBQSxNQUFSLElBQVEsUUFBUixJQUFRO0FBQzNFLE1BQU0sK0JBQStCLEdBQUcsYUFBYSxDQUFDLHNCQUFELENBQXJEO0FBRUEsU0FDRTtBQUFNLGtCQUFZLElBQUksQ0FBQyxpQkFBRCxFQUFvQjtBQUFFLE1BQUEsZ0JBQWdCLEVBQUU7QUFBcEIsS0FBcEI7QUFBdEIsS0FDRywrQkFESCxDQURGO0FBS0QsQ0FSRDs7O2VDSGMsT0FBTyxDQUFDLFFBQUQsQztJQUFiLEMsWUFBQSxDOztBQUNSLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFELENBQTFCOztBQUVBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLGdCQUEwQjtBQUFBLE1BQXZCLFVBQXVCLFFBQXZCLFVBQXVCO0FBQUEsTUFBWCxJQUFXLFFBQVgsSUFBVztBQUN6QyxTQUNFO0FBQ0UsSUFBQSxTQUFTLEVBQUMsd0VBRFo7QUFFRSxJQUFBLElBQUksRUFBQyxRQUZQO0FBR0UsSUFBQSxLQUFLLEVBQUUsSUFBSSxDQUFDLGFBQUQsQ0FIYjtBQUlFLGtCQUFZLElBQUksQ0FBQyxhQUFELENBSmxCO0FBS0UsSUFBQSxPQUFPLEVBQUUsVUFMWDtBQU1FO0FBTkYsS0FRRyxVQUFVLEVBUmIsQ0FERjtBQVlELENBYkQ7OztlQ0hjLE9BQU8sQ0FBQyxRQUFELEM7SUFBYixDLFlBQUEsQzs7QUFFUixTQUFTLFlBQVQsT0FBMkM7QUFBQSxNQUFsQixRQUFrQixRQUFsQixRQUFrQjtBQUFBLE1BQVIsSUFBUSxRQUFSLElBQVE7QUFDekMsU0FDRTtBQUNFLElBQUEsU0FBUyxFQUFDLHVFQURaO0FBRUUsSUFBQSxJQUFJLEVBQUMsUUFGUDtBQUdFLElBQUEsS0FBSyxFQUFFLElBQUksQ0FBQyxvQkFBRCxDQUhiO0FBSUUsa0JBQVksSUFBSSxDQUFDLG9CQUFELENBSmxCO0FBS0UsSUFBQSxPQUFPLEVBQUUsUUFMWDtBQU1FO0FBTkYsS0FRRTtBQUNFLElBQUEsS0FBSyxFQUFDLElBRFI7QUFFRSxJQUFBLE1BQU0sRUFBQyxHQUZUO0FBR0UsSUFBQSxPQUFPLEVBQUMsVUFIVjtBQUlFLElBQUEsS0FBSyxFQUFDLDRCQUpSO0FBS0UsbUJBQVksTUFMZDtBQU1FLElBQUEsU0FBUyxFQUFDLE9BTlo7QUFPRSxJQUFBLFNBQVMsRUFBQztBQVBaLEtBU0U7QUFBTSxJQUFBLElBQUksRUFBQyxNQUFYO0FBQWtCLElBQUEsUUFBUSxFQUFDLFNBQTNCO0FBQXFDLElBQUEsQ0FBQyxFQUFDO0FBQXZDLElBVEYsQ0FSRixDQURGO0FBc0JEOztBQUVELE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFlBQWpCOzs7ZUMzQmMsT0FBTyxDQUFDLFFBQUQsQztJQUFiLEMsWUFBQSxDOztBQUVSLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLGdCQUE0RDtBQUFBLE1BQXpELGVBQXlELFFBQXpELGVBQXlEO0FBQUEsTUFBeEMsWUFBd0MsUUFBeEMsWUFBd0M7QUFBQSxNQUExQixtQkFBMEIsUUFBMUIsbUJBQTBCO0FBQzNFLFNBQ0U7QUFBSyxJQUFBLFNBQVMsRUFBQztBQUFmLEtBQ0U7QUFDRSxJQUFBLFNBQVMsRUFBQyw2Q0FEWjtBQUVFLElBQUEsUUFBUSxFQUFFLGtCQUFDLEtBQUQsRUFBVztBQUFFLE1BQUEsbUJBQW1CLENBQUMsS0FBSyxDQUFDLE1BQU4sQ0FBYSxLQUFkLENBQW5CO0FBQXlDO0FBRmxFLEtBSUcsWUFBWSxDQUFDLEdBQWIsQ0FBaUIsVUFBQyxXQUFEO0FBQUEsV0FDaEI7QUFDRSxNQUFBLEdBQUcsRUFBRSxXQUFXLENBQUMsUUFEbkI7QUFFRSxNQUFBLEtBQUssRUFBRSxXQUFXLENBQUMsUUFGckI7QUFHRSxNQUFBLFFBQVEsRUFBRSxXQUFXLENBQUMsUUFBWixLQUF5QjtBQUhyQyxPQUtHLFdBQVcsQ0FBQyxLQUxmLENBRGdCO0FBQUEsR0FBakIsQ0FKSCxDQURGLENBREY7QUFrQkQsQ0FuQkQ7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxhQUFULENBQXdCLE9BQXhCLEVBQWlDO0FBQ2hELFNBQVUsSUFBSSxDQUFDLEtBQUwsQ0FDUixPQUFPLEdBQUcsRUFERixDQUFWLFNBRUssTUFBTSxDQUFDLE9BQU8sR0FBRyxFQUFYLENBQU4sQ0FBcUIsUUFBckIsQ0FBOEIsQ0FBOUIsRUFBaUMsQ0FBakMsQ0FGTDtBQUdELENBSkQ7Ozs7Ozs7Ozs7Ozs7ZUNQYyxPQUFPLENBQUMsUUFBRCxDO0lBQWIsQyxZQUFBLEM7O2dCQUNXLE9BQU8sQ0FBQyxZQUFELEM7SUFBbEIsTSxhQUFBLE07O0FBQ1IsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLDRCQUFELENBQTFCOztBQUNBLElBQU0sb0JBQW9CLEdBQUcsT0FBTyxDQUFDLHNDQUFELENBQXBDOztBQUNBLElBQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQywyQkFBRCxDQUF6Qjs7QUFDQSxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsOEJBQUQsQ0FBNUI7O0FBQ0EsSUFBTSxxQkFBcUIsR0FBRyxPQUFPLENBQUMseUJBQUQsQ0FBckM7O0FBQ0EsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGNBQUQsQ0FBMUI7O0FBQ0EsSUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLGdCQUFELENBQTVCOztBQUNBLElBQU0saUJBQWlCLEdBQUcsT0FBTyxDQUFDLHFCQUFELENBQWpDOztBQUNBLElBQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLGlCQUFELENBQVAsQ0FBMkIsT0FBdEQ7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsVUFBVCxDQUFxQixRQUFyQixFQUErQjtBQUM3QixNQUFJLFFBQVEsQ0FBQyxDQUFELENBQVIsS0FBZ0IsR0FBcEIsRUFBeUI7QUFDdkIsV0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQVQsQ0FBZSxDQUFmLENBQUQsQ0FBaEI7QUFDRDs7QUFDRCxTQUFPLFFBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxlQUFULENBQTBCLFFBQTFCLEVBQW9DO0FBQ2xDLFNBQU8saUJBQWlCLElBQWpCLENBQXNCLFFBQXRCLENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxlQUFULENBQTBCLFFBQTFCLEVBQW9DO0FBQ2xDLFNBQU8saUJBQWlCLElBQWpCLENBQXNCLFFBQXRCLENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLGVBQVQsR0FBNEI7QUFDMUI7QUFDQSxNQUFJLFNBQVMsQ0FBQyxZQUFWLElBQTBCLFNBQVMsQ0FBQyxZQUFWLENBQXVCLFlBQXJELEVBQW1FO0FBQ2pFO0FBQ0EsV0FBTyxTQUFTLENBQUMsWUFBakI7QUFDRDs7QUFFRCxNQUFNLGFBQVksR0FBRyxTQUFTLENBQUMsZUFBVixJQUE2QixTQUFTLENBQUMsa0JBQTVEOztBQUNBLE1BQUksQ0FBQyxhQUFMLEVBQW1CO0FBQ2pCLFdBQU8sSUFBUDtBQUNEOztBQUVELFNBQU87QUFDTCxJQUFBLFlBREssd0JBQ1MsSUFEVCxFQUNlO0FBQ2xCLGFBQU8sSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxRQUFBLGFBQVksQ0FBQyxJQUFiLENBQWtCLFNBQWxCLEVBQTZCLElBQTdCLEVBQW1DLE9BQW5DLEVBQTRDLE1BQTVDO0FBQ0QsT0FGTSxDQUFQO0FBR0Q7QUFMSSxHQUFQO0FBT0Q7QUFDRDtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxPQUFQO0FBQUE7O0FBR0Usa0JBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QjtBQUFBOztBQUN2QiwrQkFBTSxJQUFOLEVBQVksSUFBWjtBQUNBLFVBQUssWUFBTCxHQUFvQixlQUFlLEVBQW5DO0FBQ0EsVUFBSyxpQkFBTCxHQUF5QixDQUFDLENBQUMsTUFBSyxZQUFoQyxDQUh1QixDQUl2Qjs7QUFDQSxVQUFLLFFBQUwsR0FBZ0IsUUFBUSxDQUFDLFFBQVQsQ0FBa0IsS0FBbEIsQ0FBd0IsUUFBeEIsSUFBb0MsT0FBcEMsR0FBOEMsTUFBOUQ7QUFDQSxVQUFLLEVBQUwsR0FBVSxNQUFLLElBQUwsQ0FBVSxFQUFWLElBQWdCLFFBQTFCO0FBQ0EsVUFBSyxLQUFMLEdBQWEsTUFBSyxJQUFMLENBQVUsS0FBVixJQUFtQixRQUFoQztBQUNBLFVBQUssSUFBTCxHQUFZLFVBQVo7QUFDQSxVQUFLLGlCQUFMLEdBQXlCLElBQXpCOztBQUNBLFVBQUssSUFBTCxHQUFZO0FBQUEsYUFDVjtBQUFLLHVCQUFZLE1BQWpCO0FBQXdCLFFBQUEsU0FBUyxFQUFDLE9BQWxDO0FBQTBDLFFBQUEsS0FBSyxFQUFDLElBQWhEO0FBQXFELFFBQUEsTUFBTSxFQUFDLElBQTVEO0FBQWlFLFFBQUEsT0FBTyxFQUFDO0FBQXpFLFNBQ0U7QUFBRyxRQUFBLElBQUksRUFBQyxNQUFSO0FBQWUsUUFBQSxRQUFRLEVBQUM7QUFBeEIsU0FDRTtBQUFNLFFBQUEsU0FBUyxFQUFDLHFCQUFoQjtBQUFzQyxRQUFBLElBQUksRUFBQyxTQUEzQztBQUFxRCxRQUFBLEtBQUssRUFBQyxJQUEzRDtBQUFnRSxRQUFBLE1BQU0sRUFBQyxJQUF2RTtBQUE0RSxRQUFBLEVBQUUsRUFBQztBQUEvRSxRQURGLEVBRUU7QUFBTSxRQUFBLENBQUMsRUFBQyx3WkFBUjtBQUFpYSxRQUFBLElBQUksRUFBQyxNQUF0YTtBQUE2YSxRQUFBLFFBQVEsRUFBQztBQUF0YixRQUZGLENBREYsQ0FEVTtBQUFBLEtBQVo7O0FBU0EsVUFBSyxhQUFMLEdBQXFCO0FBQ25CLE1BQUEsT0FBTyxFQUFFO0FBQ1AsUUFBQSxLQUFLLEVBQUUsUUFEQTtBQUVQLFFBQUEsV0FBVyxFQUFFLGdCQUZOO0FBR1AsUUFBQSxjQUFjLEVBQUUsdUJBSFQ7QUFJUCxRQUFBLGFBQWEsRUFBRSxzQkFKUjtBQUtQLFFBQUEsZ0JBQWdCLEVBQUUsb0NBTFg7QUFNUCxRQUFBLHNCQUFzQixFQUFFLHVHQU5qQjtBQU9QLFFBQUEsYUFBYSxFQUFFLHNCQVBSO0FBUVAsUUFBQSxtQkFBbUIsRUFBRSwyRUFSZDtBQVNQLFFBQUEsdUJBQXVCLEVBQUUsc0VBVGxCO0FBVVAsUUFBQSxlQUFlLEVBQUUsc0NBVlY7QUFXUCxRQUFBLGtCQUFrQixFQUFFLHNCQVhiO0FBWVAsUUFBQSxtQkFBbUIsRUFBRTtBQVpkO0FBRFUsS0FBckIsQ0FuQnVCLENBb0N2Qjs7QUFDQSxRQUFNLGNBQWMsR0FBRztBQUNyQixNQUFBLGdCQUFnQixFQUFFO0FBQUEsZUFBTSxPQUFPLENBQUMsT0FBUixFQUFOO0FBQUEsT0FERztBQUVyQixNQUFBLFNBQVMsRUFBRSxLQUZVO0FBR3JCLE1BQUEsS0FBSyxFQUFFLENBQ0wsYUFESyxFQUVMLFlBRkssRUFHTCxZQUhLLEVBSUwsU0FKSyxDQUhjO0FBU3JCLE1BQUEsTUFBTSxFQUFFLElBVGE7QUFVckIsTUFBQSx1QkFBdUIsRUFBRSxLQVZKO0FBV3JCLE1BQUEsVUFBVSxFQUFFLE1BWFM7QUFZckIsTUFBQSxzQkFBc0IsRUFBRSxJQVpIO0FBYXJCLE1BQUEsc0JBQXNCLEVBQUUsSUFiSDtBQWNyQixNQUFBLG1CQUFtQixFQUFFO0FBZEEsS0FBdkI7QUFpQkEsVUFBSyxJQUFMLGdCQUFpQixjQUFqQixFQUFvQyxJQUFwQzs7QUFFQSxVQUFLLFFBQUw7O0FBRUEsVUFBSyxPQUFMLEdBQWUsTUFBSyxPQUFMLENBQWEsSUFBYiwrQkFBZjtBQUNBLFVBQUssY0FBTCxHQUFzQixNQUFLLGNBQUwsQ0FBb0IsSUFBcEIsK0JBQXRCO0FBRUEsVUFBSyxNQUFMLEdBQWMsTUFBSyxNQUFMLENBQVksSUFBWiwrQkFBZCxDQTdEdUIsQ0ErRHZCOztBQUNBLFVBQUssS0FBTCxHQUFhLE1BQUssS0FBTCxDQUFXLElBQVgsK0JBQWI7QUFDQSxVQUFLLElBQUwsR0FBWSxNQUFLLElBQUwsQ0FBVSxJQUFWLCtCQUFaO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLE1BQUssWUFBTCxDQUFrQixJQUFsQiwrQkFBcEI7QUFDQSxVQUFLLGNBQUwsR0FBc0IsTUFBSyxjQUFMLENBQW9CLElBQXBCLCtCQUF0QjtBQUNBLFVBQUssYUFBTCxHQUFxQixNQUFLLGFBQUwsQ0FBbUIsSUFBbkIsK0JBQXJCO0FBQ0EsVUFBSyxvQkFBTCxHQUE0QixNQUFLLG9CQUFMLENBQTBCLElBQTFCLCtCQUE1QjtBQUNBLFVBQUssTUFBTCxHQUFjLE1BQUssTUFBTCxDQUFZLElBQVosK0JBQWQ7QUFDQSxVQUFLLGdCQUFMLEdBQXdCLE1BQUssZ0JBQUwsQ0FBc0IsSUFBdEIsK0JBQXhCO0FBQ0EsVUFBSyxLQUFMLEdBQWEsTUFBSyxLQUFMLENBQVcsSUFBWCwrQkFBYjtBQUNBLFVBQUssaUJBQUwsR0FBeUIsTUFBSyxpQkFBTCxDQUF1QixJQUF2QiwrQkFBekI7QUFFQSxVQUFLLFlBQUwsR0FBb0IsS0FBcEI7O0FBRUEsUUFBSSxNQUFLLElBQUwsQ0FBVSxTQUFkLEVBQXlCO0FBQ3ZCLFlBQUssSUFBTCxDQUFVLGdCQUFWLEdBQTZCLE1BQUssZ0JBQWxDO0FBQ0Q7O0FBRUQsVUFBSyxjQUFMLENBQW9CO0FBQ2xCLE1BQUEsU0FBUyxFQUFFLEtBRE87QUFFbEIsTUFBQSxXQUFXLEVBQUUsS0FGSztBQUdsQixNQUFBLFdBQVcsRUFBRSxJQUhLO0FBSWxCLE1BQUEsc0JBQXNCLEVBQUUsQ0FKTjtBQUtsQixNQUFBLFlBQVksRUFBRSxFQUxJO0FBTWxCLE1BQUEsZUFBZSxFQUFFO0FBTkMsS0FBcEI7O0FBakZ1QjtBQXlGeEI7O0FBNUZIOztBQUFBLFNBOEZFLFVBOUZGLEdBOEZFLG9CQUFZLE9BQVosRUFBcUI7QUFDbkIsc0JBQU0sVUFBTix5QkFDSyxPQURMO0FBRUUsTUFBQSxnQkFBZ0IsZUFFWCxLQUFLLElBQUwsQ0FBVSxnQkFGQyxFQUdYLE9BSFcsb0JBR1gsT0FBTyxDQUFFLGdCQUhFO0FBRmxCOztBQVNBLFNBQUssUUFBTDtBQUNELEdBekdIOztBQUFBLFNBMkdFLFFBM0dGLEdBMkdFLG9CQUFZO0FBQ1YsU0FBSyxVQUFMLEdBQWtCLElBQUksVUFBSixDQUFlLENBQUMsS0FBSyxhQUFOLEVBQXFCLEtBQUssSUFBTCxDQUFVLE1BQS9CLEVBQXVDLEtBQUssSUFBTCxDQUFVLE1BQWpELENBQWYsQ0FBbEI7QUFDQSxTQUFLLElBQUwsR0FBWSxLQUFLLFVBQUwsQ0FBZ0IsU0FBaEIsQ0FBMEIsSUFBMUIsQ0FBK0IsS0FBSyxVQUFwQyxDQUFaO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLEtBQUssVUFBTCxDQUFnQixjQUFoQixDQUErQixJQUEvQixDQUFvQyxLQUFLLFVBQXpDLENBQWpCO0FBQ0EsU0FBSyxjQUFMLEdBSlUsQ0FJWTtBQUN2QixHQWhISDs7QUFBQSxTQWtIRSxjQWxIRixHQWtIRSwwQkFBa0I7QUFDaEIsUUFBSSxDQUFDLEtBQUssWUFBVixFQUF3QjtBQUN0QixhQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLEtBQWhCLENBQVA7QUFDRDs7QUFFRCxXQUFPLEtBQUssWUFBTCxDQUFrQixnQkFBbEIsR0FBcUMsSUFBckMsQ0FBMEMsVUFBQSxPQUFPLEVBQUk7QUFDMUQsYUFBTyxPQUFPLENBQUMsSUFBUixDQUFhLFVBQUEsTUFBTTtBQUFBLGVBQUksTUFBTSxDQUFDLElBQVAsS0FBZ0IsWUFBcEI7QUFBQSxPQUFuQixDQUFQO0FBQ0QsS0FGTSxDQUFQO0FBR0QsR0ExSEg7O0FBQUEsU0E0SEUsV0E1SEYsR0E0SEUsdUJBQWU7QUFDYixXQUFPLEtBQUssSUFBTCxDQUFVLEtBQVYsQ0FBZ0IsTUFBaEIsS0FBMkIsQ0FBM0IsSUFBZ0MsS0FBSyxJQUFMLENBQVUsS0FBVixDQUFnQixDQUFoQixNQUF1QixZQUE5RDtBQUNELEdBOUhIOztBQUFBLFNBZ0lFLGNBaElGLEdBZ0lFLHdCQUFnQixRQUFoQixFQUFpQztBQUFBOztBQUFBLFFBQWpCLFFBQWlCO0FBQWpCLE1BQUEsUUFBaUIsR0FBTixJQUFNO0FBQUE7O0FBQy9CLFFBQU0sWUFBWSxHQUFHLEtBQUssSUFBTCxDQUFVLEtBQVYsQ0FBZ0IsT0FBaEIsQ0FBd0IsYUFBeEIsTUFBMkMsQ0FBQyxDQUE1QyxJQUNoQixLQUFLLElBQUwsQ0FBVSxLQUFWLENBQWdCLE9BQWhCLENBQXdCLFlBQXhCLE1BQTBDLENBQUMsQ0FEaEQ7QUFFQSxRQUFNLFlBQVksR0FBRyxDQUFDLEtBQUssV0FBTCxFQUFELEtBQ2IsS0FBSyxJQUFMLENBQVUsS0FBVixDQUFnQixPQUFoQixDQUF3QixhQUF4QixNQUEyQyxDQUFDLENBQTVDLElBQ0MsS0FBSyxJQUFMLENBQVUsS0FBVixDQUFnQixPQUFoQixDQUF3QixZQUF4QixNQUEwQyxDQUFDLENBRDVDLElBRUMsS0FBSyxJQUFMLENBQVUsS0FBVixDQUFnQixPQUFoQixDQUF3QixTQUF4QixNQUF1QyxDQUFDLENBSDVCLENBQXJCOztBQUtBLFFBQU0sZ0JBQWdCLHlDQUNoQixLQUFLLElBQUwsQ0FBVSxnQkFETSxvQ0FDYztBQUFFLE1BQUEsVUFBVSxFQUFFLEtBQUssSUFBTCxDQUFVO0FBQXhCLEtBRGQsRUFJaEIsUUFBUSxHQUFHO0FBQUUsTUFBQSxRQUFRLEVBQVIsUUFBRjtBQUFZLE1BQUEsVUFBVSxFQUFFO0FBQXhCLEtBQUgsR0FBb0MsRUFKNUIsQ0FBdEI7O0FBT0EsV0FBTztBQUNMLE1BQUEsS0FBSyxFQUFFLFlBREY7QUFFTCxNQUFBLEtBQUssRUFBRSxZQUFZLEdBQUcsZ0JBQUgsR0FBc0I7QUFGcEMsS0FBUDtBQUlELEdBbkpILENBcUpFO0FBckpGOztBQUFBLFNBc0pFLEtBdEpGLEdBc0pFLGVBQU8sT0FBUCxFQUF1QjtBQUFBOztBQUFBLFFBQWhCLE9BQWdCO0FBQWhCLE1BQUEsT0FBZ0IsR0FBTixJQUFNO0FBQUE7O0FBQ3JCLFFBQUksQ0FBQyxLQUFLLGlCQUFWLEVBQTZCO0FBQzNCLGFBQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxJQUFJLEtBQUosQ0FBVSw2QkFBVixDQUFmLENBQVA7QUFDRDs7QUFFRCxTQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxTQUFLLElBQUwsQ0FBVSxNQUFWLEdBQW1CLElBQW5CO0FBRUEsUUFBTSxXQUFXLEdBQUcsS0FBSyxjQUFMLENBQW9CLE9BQU8sSUFBSSxPQUFPLENBQUMsUUFBbkIsR0FBOEIsT0FBTyxDQUFDLFFBQXRDLEdBQWlELElBQXJFLENBQXBCO0FBRUEsU0FBSyxjQUFMLEdBQXNCLElBQXRCLENBQTJCLFVBQUEsU0FBUyxFQUFJO0FBQ3RDLE1BQUEsTUFBSSxDQUFDLGNBQUwsQ0FBb0I7QUFDbEIsUUFBQSxTQUFTLEVBQVQ7QUFEa0IsT0FBcEIsRUFEc0MsQ0FLdEM7OztBQUNBLGFBQU8sTUFBSSxDQUFDLFlBQUwsQ0FBa0IsWUFBbEIsQ0FBK0IsV0FBL0IsRUFDSixJQURJLENBQ0MsVUFBQyxNQUFELEVBQVk7QUFDaEIsUUFBQSxNQUFJLENBQUMsTUFBTCxHQUFjLE1BQWQ7QUFFQSxZQUFJLGVBQWUsR0FBRyxJQUF0QjtBQUNBLFlBQU0sTUFBTSxHQUFHLE1BQUksQ0FBQyxXQUFMLEtBQXFCLE1BQU0sQ0FBQyxjQUFQLEVBQXJCLEdBQStDLE1BQU0sQ0FBQyxjQUFQLEVBQTlEOztBQUVBLFlBQUksQ0FBQyxPQUFELElBQVksQ0FBQyxPQUFPLENBQUMsUUFBekIsRUFBbUM7QUFDakMsVUFBQSxlQUFlLEdBQUcsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLFdBQVYsR0FBd0IsUUFBMUM7QUFDRCxTQUZELE1BRU87QUFDTCxVQUFBLE1BQU0sQ0FBQyxPQUFQLENBQWUsVUFBQyxLQUFELEVBQVc7QUFDeEIsZ0JBQUksS0FBSyxDQUFDLFdBQU4sR0FBb0IsUUFBcEIsS0FBaUMsT0FBTyxDQUFDLFFBQTdDLEVBQXVEO0FBQ3JELGNBQUEsZUFBZSxHQUFHLEtBQUssQ0FBQyxXQUFOLEdBQW9CLFFBQXRDO0FBQ0Q7QUFDRixXQUpEO0FBS0QsU0FkZSxDQWdCaEI7OztBQUNBLFFBQUEsTUFBSSxDQUFDLGtCQUFMOztBQUVBLFFBQUEsTUFBSSxDQUFDLGNBQUwsQ0FBb0I7QUFDbEIsVUFBQSxlQUFlLEVBQWYsZUFEa0I7QUFFbEIsVUFBQSxXQUFXLEVBQUU7QUFGSyxTQUFwQjtBQUlELE9BeEJJLEVBeUJKLEtBekJJLENBeUJFLFVBQUMsR0FBRCxFQUFTO0FBQ2QsUUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQixVQUFBLFdBQVcsRUFBRSxLQURLO0FBRWxCLFVBQUEsV0FBVyxFQUFFO0FBRkssU0FBcEI7O0FBSUEsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxHQUFHLENBQUMsT0FBbkIsRUFBNEIsT0FBNUI7QUFDRCxPQS9CSSxDQUFQO0FBZ0NELEtBdENEO0FBdUNEO0FBRUQ7QUFDRjtBQUNBO0FBM01BOztBQUFBLFNBNE1FLHVCQTVNRixHQTRNRSxtQ0FBMkI7QUFDekIsUUFBTSxPQUFPLEdBQUcsRUFBaEIsQ0FEeUIsQ0FHekI7QUFDQTtBQUNBOztBQUNBLFFBQUksYUFBYSxDQUFDLGVBQWxCLEVBQW1DO0FBQUEsVUFDekIsWUFEeUIsR0FDUixLQUFLLElBQUwsQ0FBVSxJQURGLENBQ3pCLFlBRHlCO0FBRWpDLFVBQUksdUJBQXVCLEdBQUcsRUFBOUI7O0FBQ0EsVUFBSSxLQUFLLElBQUwsQ0FBVSxzQkFBZCxFQUFzQztBQUNwQyxRQUFBLHVCQUF1QixHQUFHLENBQUMsS0FBSyxJQUFMLENBQVUsc0JBQVgsQ0FBMUI7QUFDRCxPQUZELE1BRU8sSUFBSSxZQUFZLENBQUMsZ0JBQWpCLEVBQW1DO0FBQ3hDLFFBQUEsdUJBQXVCLEdBQUcsWUFBWSxDQUFDLGdCQUFiLENBQThCLEdBQTlCLENBQWtDLFVBQWxDLEVBQThDLE1BQTlDLENBQXFELGVBQXJELENBQTFCO0FBQ0Q7O0FBRUQsVUFBTSxvQkFBb0IsR0FBRyxTQUF2QixvQkFBdUIsQ0FBQyxhQUFEO0FBQUEsZUFBbUIsYUFBYSxDQUFDLGVBQWQsQ0FBOEIsYUFBOUIsS0FDM0Msb0JBQW9CLENBQUMsYUFBRCxDQURJO0FBQUEsT0FBN0I7O0FBRUEsVUFBTSxtQkFBbUIsR0FBRyx1QkFBdUIsQ0FBQyxNQUF4QixDQUErQixvQkFBL0IsQ0FBNUI7O0FBRUEsVUFBSSxtQkFBbUIsQ0FBQyxNQUFwQixHQUE2QixDQUFqQyxFQUFvQztBQUNsQztBQUNBLFFBQUEsT0FBTyxDQUFDLFFBQVIsR0FBbUIsbUJBQW1CLENBQUMsQ0FBRCxDQUF0QztBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxPQUFQO0FBQ0QsR0F0T0g7O0FBQUEsU0F3T0UsY0F4T0YsR0F3T0UsMEJBQWtCO0FBQUE7O0FBQ2hCO0FBQ0E7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsSUFBSSxhQUFKLENBQWtCLEtBQUssTUFBdkIsRUFBK0IsS0FBSyx1QkFBTCxFQUEvQixDQUFoQjtBQUNBLFNBQUssZUFBTCxHQUF1QixFQUF2QjtBQUNBLFFBQUksd0JBQXdCLEdBQUcsS0FBL0I7QUFDQSxTQUFLLFFBQUwsQ0FBYyxnQkFBZCxDQUErQixlQUEvQixFQUFnRCxVQUFDLEtBQUQsRUFBVztBQUN6RCxNQUFBLE1BQUksQ0FBQyxlQUFMLENBQXFCLElBQXJCLENBQTBCLEtBQUssQ0FBQyxJQUFoQzs7QUFEeUQsVUFHakQsWUFIaUQsR0FHaEMsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUhzQixDQUdqRCxZQUhpRDs7QUFJekQsVUFBSSxNQUFJLENBQUMsZUFBTCxDQUFxQixNQUFyQixHQUE4QixDQUE5QixJQUNHLFlBQVksQ0FBQyxXQUFiLElBQTRCLElBRC9CLElBRUcsQ0FBQyx3QkFGUixFQUVrQztBQUNoQyxZQUFNLFNBQVMsR0FBRyxNQUFJLENBQUMsZUFBTCxDQUFxQixNQUFyQixDQUE0QixVQUFDLEdBQUQsRUFBTSxLQUFOO0FBQUEsaUJBQWdCLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBNUI7QUFBQSxTQUE1QixFQUE4RCxDQUE5RCxDQUFsQixDQURnQyxDQUVoQzs7O0FBQ0EsWUFBTSxnQkFBZ0IsR0FBRyxDQUFDLFNBQVMsR0FBRyxNQUFJLENBQUMsZUFBTCxDQUFxQixDQUFyQixFQUF3QixJQUFyQyxLQUE4QyxNQUFJLENBQUMsZUFBTCxDQUFxQixNQUFyQixHQUE4QixDQUE1RSxDQUF6QjtBQUNBLFlBQU0sb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsQ0FBaEQ7QUFDQSxZQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFTLENBQVQsRUFBWSxZQUFZLENBQUMsV0FBYixHQUEyQixvQkFBdkMsQ0FBaEI7O0FBRUEsWUFBSSxTQUFTLEdBQUcsT0FBaEIsRUFBeUI7QUFDdkIsVUFBQSx3QkFBd0IsR0FBRyxJQUEzQjs7QUFDQSxVQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLE1BQUksQ0FBQyxJQUFMLENBQVUseUJBQVYsQ0FBZixFQUFxRCxTQUFyRCxFQUFnRSxJQUFoRTs7QUFDQSxVQUFBLE1BQUksQ0FBQyxhQUFMO0FBQ0Q7QUFDRjtBQUNGLEtBbkJELEVBTmdCLENBMkJoQjtBQUNBOztBQUNBLFNBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsR0FBcEI7O0FBRUEsUUFBSSxLQUFLLElBQUwsQ0FBVSxtQkFBZCxFQUFtQztBQUNqQztBQUNBLFdBQUssb0JBQUwsR0FBNEIsV0FBVyxDQUFDLFlBQU07QUFDNUMsWUFBTSxzQkFBc0IsR0FBRyxNQUFJLENBQUMsY0FBTCxHQUFzQixzQkFBckQ7O0FBQ0EsUUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUFFLFVBQUEsc0JBQXNCLEVBQUUsc0JBQXNCLEdBQUc7QUFBbkQsU0FBcEI7QUFDRCxPQUhzQyxFQUdwQyxJQUhvQyxDQUF2QztBQUlEOztBQUVELFNBQUssY0FBTCxDQUFvQjtBQUNsQixNQUFBLFdBQVcsRUFBRTtBQURLLEtBQXBCO0FBR0QsR0FsUkg7O0FBQUEsU0FvUkUsYUFwUkYsR0FvUkUseUJBQWlCO0FBQUE7O0FBQ2YsUUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQWE7QUFDdkMsTUFBQSxNQUFJLENBQUMsUUFBTCxDQUFjLGdCQUFkLENBQStCLE1BQS9CLEVBQXVDLFlBQU07QUFDM0MsUUFBQSxPQUFPO0FBQ1IsT0FGRDs7QUFHQSxNQUFBLE1BQUksQ0FBQyxRQUFMLENBQWMsSUFBZDs7QUFFQSxVQUFJLE1BQUksQ0FBQyxJQUFMLENBQVUsbUJBQWQsRUFBbUM7QUFDakM7QUFDQSxRQUFBLGFBQWEsQ0FBQyxNQUFJLENBQUMsb0JBQU4sQ0FBYjs7QUFDQSxRQUFBLE1BQUksQ0FBQyxjQUFMLENBQW9CO0FBQUUsVUFBQSxzQkFBc0IsRUFBRTtBQUExQixTQUFwQjtBQUNEO0FBQ0YsS0FYZSxDQUFoQjtBQWFBLFdBQU8sT0FBTyxDQUFDLElBQVIsQ0FBYSxZQUFNO0FBQ3hCLE1BQUEsTUFBSSxDQUFDLGNBQUwsQ0FBb0I7QUFDbEIsUUFBQSxXQUFXLEVBQUU7QUFESyxPQUFwQjs7QUFHQSxhQUFPLE1BQUksQ0FBQyxRQUFMLEVBQVA7QUFDRCxLQUxNLEVBS0osSUFMSSxDQUtDLFVBQUMsSUFBRCxFQUFVO0FBQ2hCLFVBQUk7QUFDRixRQUFBLE1BQUksQ0FBQyxpQkFBTCxHQUF5QixJQUF6QixDQURFLENBRUY7O0FBQ0EsUUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQjtBQUNBLFVBQUEsYUFBYSxFQUFFLEdBQUcsQ0FBQyxlQUFKLENBQW9CLElBQUksQ0FBQyxJQUF6QjtBQUZHLFNBQXBCOztBQUlBLFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxNQUFWLEdBQW1CLEtBQW5CO0FBQ0QsT0FSRCxDQVFFLE9BQU8sR0FBUCxFQUFZO0FBQ1o7QUFDQSxZQUFJLENBQUMsR0FBRyxDQUFDLGFBQVQsRUFBd0I7QUFDdEIsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkO0FBQ0Q7QUFDRjtBQUNGLEtBcEJNLEVBb0JKLElBcEJJLENBb0JDLFlBQU07QUFDWixNQUFBLE1BQUksQ0FBQyxlQUFMLEdBQXVCLElBQXZCO0FBQ0EsTUFBQSxNQUFJLENBQUMsUUFBTCxHQUFnQixJQUFoQjtBQUNELEtBdkJNLEVBdUJKLFVBQUMsS0FBRCxFQUFXO0FBQ1osTUFBQSxNQUFJLENBQUMsZUFBTCxHQUF1QixJQUF2QjtBQUNBLE1BQUEsTUFBSSxDQUFDLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxZQUFNLEtBQU47QUFDRCxLQTNCTSxDQUFQO0FBNEJELEdBOVRIOztBQUFBLFNBZ1VFLG9CQWhVRixHQWdVRSxnQ0FBd0I7QUFDdEIsU0FBSyxjQUFMLENBQW9CO0FBQUUsTUFBQSxhQUFhLEVBQUU7QUFBakIsS0FBcEI7QUFDQSxTQUFLLElBQUwsQ0FBVSxNQUFWLEdBQW1CLElBQW5CO0FBQ0EsU0FBSyxpQkFBTCxHQUF5QixJQUF6QjtBQUNELEdBcFVIOztBQUFBLFNBc1VFLE1BdFVGLEdBc1VFLGtCQUFVO0FBQ1IsUUFBSTtBQUNGLFVBQUksS0FBSyxpQkFBVCxFQUE0QjtBQUMxQixhQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLEtBQUssaUJBQXZCO0FBQ0Q7QUFDRixLQUpELENBSUUsT0FBTyxHQUFQLEVBQVk7QUFDWjtBQUNBLFVBQUksQ0FBQyxHQUFHLENBQUMsYUFBVCxFQUF3QjtBQUN0QixhQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxFQUFtQixPQUFuQjtBQUNEO0FBQ0Y7QUFDRixHQWpWSDs7QUFBQSxTQW1WRSxJQW5WRixHQW1WRSxnQkFBUTtBQUNOLFFBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2YsV0FBSyxNQUFMLENBQVksY0FBWixHQUE2QixPQUE3QixDQUFxQyxVQUFDLEtBQUQsRUFBVztBQUM5QyxRQUFBLEtBQUssQ0FBQyxJQUFOO0FBQ0QsT0FGRDtBQUdBLFdBQUssTUFBTCxDQUFZLGNBQVosR0FBNkIsT0FBN0IsQ0FBcUMsVUFBQyxLQUFELEVBQVc7QUFDOUMsUUFBQSxLQUFLLENBQUMsSUFBTjtBQUNELE9BRkQ7QUFHRDs7QUFDRCxTQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsU0FBSyxjQUFMLENBQW9CO0FBQ2xCLE1BQUEsYUFBYSxFQUFFO0FBREcsS0FBcEI7QUFHRCxHQWpXSDs7QUFBQSxTQW1XRSxlQW5XRixHQW1XRSwyQkFBbUI7QUFDakIsV0FBTyxLQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLG9CQUF0QixDQUFQO0FBQ0QsR0FyV0g7O0FBQUEsU0F1V0UsZ0JBdldGLEdBdVdFLDRCQUFvQjtBQUFBOztBQUNsQixXQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDdEMsVUFBSSxLQUFLLEdBQUcsTUFBSSxDQUFDLElBQUwsQ0FBVSxTQUF0QixDQURzQyxDQUd0Qzs7QUFDQSxVQUFNLFNBQVMsR0FBRyxXQUFXLENBQUMsWUFBTTtBQUNsQyxZQUFJLENBQUMsTUFBSSxDQUFDLFlBQVYsRUFBd0I7QUFDdEIsVUFBQSxhQUFhLENBQUMsU0FBRCxDQUFiO0FBQ0EsVUFBQSxNQUFJLENBQUMsaUJBQUwsR0FBeUIsS0FBekI7QUFDQSxpQkFBTyxNQUFNLENBQUMsSUFBSSxLQUFKLENBQVUsc0JBQVYsQ0FBRCxDQUFiO0FBQ0Q7O0FBRUQsWUFBSSxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ2IsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBa0IsS0FBbEIsVUFBOEIsU0FBOUIsRUFBeUMsR0FBekM7O0FBQ0EsVUFBQSxLQUFLO0FBQ04sU0FIRCxNQUdPO0FBQ0wsVUFBQSxhQUFhLENBQUMsU0FBRCxDQUFiOztBQUNBLFVBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWYsRUFBbUMsU0FBbkMsRUFBOEMsSUFBOUM7O0FBQ0EsVUFBQSxVQUFVLENBQUM7QUFBQSxtQkFBTSxPQUFPLEVBQWI7QUFBQSxXQUFELEVBQWtCLElBQWxCLENBQVY7QUFDRDtBQUNGLE9BZjRCLEVBZTFCLElBZjBCLENBQTdCO0FBZ0JELEtBcEJNLENBQVA7QUFxQkQsR0E3WEg7O0FBQUEsU0ErWEUsWUEvWEYsR0ErWEUsd0JBQWdCO0FBQUE7O0FBQ2QsUUFBSSxLQUFLLGlCQUFULEVBQTRCO0FBRTVCLFNBQUssaUJBQUwsR0FBeUIsSUFBekI7QUFFQSxTQUFLLElBQUwsQ0FBVSxnQkFBVixHQUE2QixLQUE3QixDQUFtQyxVQUFDLEdBQUQsRUFBUztBQUMxQyxVQUFNLE9BQU8sR0FBRyxPQUFPLEdBQVAsS0FBZSxRQUFmLEdBQTBCLEdBQUcsQ0FBQyxPQUE5QixHQUF3QyxHQUF4RDs7QUFDQSxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLE9BQWYsRUFBd0IsT0FBeEIsRUFBaUMsSUFBakM7O0FBQ0EsYUFBTyxPQUFPLENBQUMsTUFBUixDQUFlLElBQUksS0FBSix3QkFBK0IsT0FBL0IsQ0FBZixDQUFQO0FBQ0QsS0FKRCxFQUlHLElBSkgsQ0FJUSxZQUFNO0FBQ1osYUFBTyxNQUFJLENBQUMsUUFBTCxFQUFQO0FBQ0QsS0FORCxFQU1HLElBTkgsQ0FNUSxVQUFDLE9BQUQsRUFBYTtBQUNuQixNQUFBLE1BQUksQ0FBQyxpQkFBTCxHQUF5QixLQUF6Qjs7QUFDQSxVQUFJO0FBQ0YsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLE9BQVYsQ0FBa0IsT0FBbEI7QUFDRCxPQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWjtBQUNBLFlBQUksQ0FBQyxHQUFHLENBQUMsYUFBVCxFQUF3QjtBQUN0QixVQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQ7QUFDRDtBQUNGO0FBQ0YsS0FoQkQsRUFnQkcsVUFBQyxLQUFELEVBQVc7QUFDWixNQUFBLE1BQUksQ0FBQyxpQkFBTCxHQUF5QixLQUF6QjtBQUNBLFlBQU0sS0FBTjtBQUNELEtBbkJEO0FBb0JELEdBeFpIOztBQUFBLFNBMFpFLFFBMVpGLEdBMFpFLG9CQUFZO0FBQUE7O0FBQ1YsUUFBTSxLQUFLLEdBQUcsS0FBSyxlQUFMLEVBQWQ7O0FBQ0EsUUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWLGFBQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxJQUFJLEtBQUosQ0FBVSxvRUFBVixDQUFmLENBQVA7QUFDRDs7QUFFRCxRQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsVUFBcEI7QUFDQSxRQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBckI7QUFFQSxRQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixRQUF2QixDQUFmO0FBQ0EsSUFBQSxNQUFNLENBQUMsS0FBUCxHQUFlLEtBQWY7QUFDQSxJQUFBLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLE1BQWhCO0FBQ0EsUUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsSUFBbEIsQ0FBWjtBQUNBLElBQUEsR0FBRyxDQUFDLFNBQUosQ0FBYyxLQUFkLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCO0FBYlUsUUFlRixZQWZFLEdBZWUsS0FBSyxJQUFMLENBQVUsSUFmekIsQ0FlRixZQWZFO0FBZ0JWLFFBQUksdUJBQXVCLEdBQUcsRUFBOUI7O0FBQ0EsUUFBSSxLQUFLLElBQUwsQ0FBVSxzQkFBZCxFQUFzQztBQUNwQyxNQUFBLHVCQUF1QixHQUFHLENBQUMsS0FBSyxJQUFMLENBQVUsc0JBQVgsQ0FBMUI7QUFDRCxLQUZELE1BRU8sSUFBSSxZQUFZLENBQUMsZ0JBQWpCLEVBQW1DO0FBQ3hDLE1BQUEsdUJBQXVCLEdBQUcsWUFBWSxDQUFDLGdCQUFiLENBQThCLEdBQTlCLENBQWtDLFVBQWxDLEVBQThDLE1BQTlDLENBQXFELGVBQXJELENBQTFCO0FBQ0Q7O0FBRUQsUUFBTSxRQUFRLEdBQUcsdUJBQXVCLENBQUMsQ0FBRCxDQUF2QixJQUE4QixZQUEvQztBQUNBLFFBQU0sR0FBRyxHQUFHLG9CQUFvQixDQUFDLFFBQUQsQ0FBcEIsSUFBa0MsS0FBOUM7QUFDQSxRQUFNLElBQUksWUFBVSxJQUFJLENBQUMsR0FBTCxFQUFWLFNBQXdCLEdBQWxDO0FBRUEsV0FBTyxZQUFZLENBQUMsTUFBRCxFQUFTLFFBQVQsQ0FBWixDQUErQixJQUEvQixDQUFvQyxVQUFDLElBQUQsRUFBVTtBQUNuRCxhQUFPO0FBQ0wsUUFBQSxNQUFNLEVBQUUsTUFBSSxDQUFDLEVBRFI7QUFFTCxRQUFBLElBQUksRUFBSixJQUZLO0FBR0wsUUFBQSxJQUFJLEVBQUUsSUFBSSxJQUFKLENBQVMsQ0FBQyxJQUFELENBQVQsRUFBaUI7QUFBRSxVQUFBLElBQUksRUFBRTtBQUFSLFNBQWpCLENBSEQ7QUFJTCxRQUFBLElBQUksRUFBRTtBQUpELE9BQVA7QUFNRCxLQVBNLENBQVA7QUFRRCxHQTdiSDs7QUFBQSxTQStiRSxRQS9iRixHQStiRSxvQkFBWTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQU0sUUFBUSxHQUFHLEtBQUssZUFBTCxDQUFxQixJQUFyQixDQUEwQixVQUFBLElBQUk7QUFBQTs7QUFBQSxhQUFJLGVBQUEsSUFBSSxDQUFDLElBQUwsZ0NBQVcsTUFBWCxJQUFvQixDQUF4QjtBQUFBLEtBQTlCLEVBQXlELElBQTFFO0FBRUEsUUFBTSxhQUFhLEdBQUcsb0JBQW9CLENBQUMsUUFBRCxDQUExQzs7QUFFQSxRQUFJLENBQUMsYUFBTCxFQUFvQjtBQUNsQixhQUFPLE9BQU8sQ0FBQyxNQUFSLENBQWUsSUFBSSxLQUFKLDZEQUFtRSxRQUFuRSxRQUFmLENBQVA7QUFDRDs7QUFFRCxRQUFNLElBQUksZUFBYSxJQUFJLENBQUMsR0FBTCxFQUFiLFNBQTJCLGFBQXJDO0FBQ0EsUUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFKLENBQVMsS0FBSyxlQUFkLEVBQStCO0FBQUUsTUFBQSxJQUFJLEVBQUU7QUFBUixLQUEvQixDQUFiO0FBQ0EsUUFBTSxJQUFJLEdBQUc7QUFDWCxNQUFBLE1BQU0sRUFBRSxLQUFLLEVBREY7QUFFWCxNQUFBLElBQUksRUFBSixJQUZXO0FBR1gsTUFBQSxJQUFJLEVBQUUsSUFBSSxJQUFKLENBQVMsQ0FBQyxJQUFELENBQVQsRUFBaUI7QUFBRSxRQUFBLElBQUksRUFBRTtBQUFSLE9BQWpCLENBSEs7QUFJWCxNQUFBLElBQUksRUFBRTtBQUpLLEtBQWI7QUFPQSxXQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLElBQWhCLENBQVA7QUFDRCxHQXJkSDs7QUFBQSxTQXVkRSxLQXZkRixHQXVkRSxpQkFBUztBQUFBOztBQUNQLFFBQUksQ0FBQyxLQUFLLElBQUwsQ0FBVSxTQUFmLEVBQTBCO0FBQzFCLElBQUEsVUFBVSxDQUFDLFlBQU07QUFDZixNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFmLEVBQW1DLFNBQW5DLEVBQThDLElBQTlDO0FBQ0QsS0FGUyxFQUVQLElBRk8sQ0FBVjtBQUdELEdBNWRIOztBQUFBLFNBOGRFLGlCQTlkRixHQThkRSwyQkFBbUIsUUFBbkIsRUFBNkI7QUFDM0IsU0FBSyxJQUFMO0FBQ0EsU0FBSyxLQUFMLENBQVc7QUFBRSxNQUFBLFFBQVEsRUFBUjtBQUFGLEtBQVg7QUFDRCxHQWplSDs7QUFBQSxTQW1lRSxrQkFuZUYsR0FtZUUsOEJBQXNCO0FBQUE7O0FBQ3BCLFNBQUssWUFBTCxDQUFrQixnQkFBbEIsR0FBcUMsSUFBckMsQ0FBMEMsVUFBQSxPQUFPLEVBQUk7QUFDbkQsTUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQixRQUFBLFlBQVksRUFBRSxPQUFPLENBQUMsTUFBUixDQUFlLFVBQUMsTUFBRDtBQUFBLGlCQUFZLE1BQU0sQ0FBQyxJQUFQLEtBQWdCLFlBQTVCO0FBQUEsU0FBZjtBQURJLE9BQXBCO0FBR0QsS0FKRDtBQUtELEdBemVIOztBQUFBLFNBMmVFLE1BM2VGLEdBMmVFLGtCQUFVO0FBQ1IsUUFBSSxDQUFDLEtBQUssWUFBVixFQUF3QjtBQUN0QixXQUFLLEtBQUw7QUFDRDs7QUFFRCxRQUFNLFdBQVcsR0FBRyxLQUFLLGNBQUwsRUFBcEI7O0FBRUEsUUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFiLElBQTRCLENBQUMsV0FBVyxDQUFDLFNBQTdDLEVBQXdEO0FBQ3RELGFBQ0UsRUFBQyxpQkFBRDtBQUNFLFFBQUEsSUFBSSxFQUFFLFVBRFI7QUFFRSxRQUFBLElBQUksRUFBRSxLQUFLLElBRmI7QUFHRSxRQUFBLFNBQVMsRUFBRSxXQUFXLENBQUM7QUFIekIsUUFERjtBQU9EOztBQUVELFdBQ0UsRUFBQyxZQUFELENBQ0U7QUFERixtQkFFTSxXQUZOO0FBR0UsTUFBQSxtQkFBbUIsRUFBRSxLQUFLLGlCQUg1QjtBQUlFLE1BQUEsVUFBVSxFQUFFLEtBQUssWUFKbkI7QUFLRSxNQUFBLGdCQUFnQixFQUFFLEtBQUssY0FMekI7QUFNRSxNQUFBLGVBQWUsRUFBRSxLQUFLLGFBTnhCO0FBT0UsTUFBQSxzQkFBc0IsRUFBRSxLQUFLLG9CQVAvQjtBQVFFLE1BQUEsUUFBUSxFQUFFLEtBQUssTUFSakI7QUFTRSxNQUFBLE9BQU8sRUFBRSxLQUFLLEtBVGhCO0FBVUUsTUFBQSxNQUFNLEVBQUUsS0FBSyxJQVZmO0FBV0UsTUFBQSxJQUFJLEVBQUUsS0FBSyxJQVhiO0FBWUUsTUFBQSxLQUFLLEVBQUUsS0FBSyxJQUFMLENBQVUsS0FabkI7QUFhRSxNQUFBLG1CQUFtQixFQUFFLEtBQUssSUFBTCxDQUFVLG1CQWJqQztBQWNFLE1BQUEsdUJBQXVCLEVBQUUsS0FBSyxJQUFMLENBQVUsdUJBZHJDO0FBZUUsTUFBQSxpQkFBaUIsRUFBRSxxQkFBcUIsRUFmMUM7QUFnQkUsTUFBQSxTQUFTLEVBQUUsV0FBVyxDQUFDLFdBaEJ6QjtBQWlCRSxNQUFBLE1BQU0sRUFBRSxLQUFLLElBQUwsQ0FBVSxNQWpCcEI7QUFrQkUsTUFBQSxHQUFHLEVBQUUsS0FBSztBQWxCWixPQURGO0FBc0JELEdBbGhCSDs7QUFBQSxTQW9oQkUsT0FwaEJGLEdBb2hCRSxtQkFBVztBQUFBOztBQUNULFNBQUssY0FBTCxDQUFvQjtBQUNsQixNQUFBLFdBQVcsRUFBRSxLQURLO0FBRWxCLE1BQUEsc0JBQXNCLEVBQUU7QUFGTixLQUFwQjtBQURTLFFBTUQsTUFOQyxHQU1VLEtBQUssSUFOZixDQU1ELE1BTkM7O0FBT1QsUUFBSSxNQUFKLEVBQVk7QUFDVixXQUFLLEtBQUwsQ0FBVyxNQUFYLEVBQW1CLElBQW5CO0FBQ0Q7O0FBRUQsUUFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDckIsV0FBSyxrQkFBTDs7QUFFQSxXQUFLLFlBQUwsQ0FBa0IsY0FBbEIsR0FBbUMsWUFBTTtBQUN2QyxRQUFBLE9BQUksQ0FBQyxrQkFBTDs7QUFFQSxZQUFJLE9BQUksQ0FBQyxNQUFULEVBQWlCO0FBQ2YsY0FBSSxhQUFhLEdBQUcsSUFBcEI7O0FBRGUsc0NBRzJCLE9BQUksQ0FBQyxjQUFMLEVBSDNCO0FBQUEsY0FHUCxZQUhPLHlCQUdQLFlBSE87QUFBQSxjQUdPLGVBSFAseUJBR08sZUFIUDs7QUFLZixVQUFBLFlBQVksQ0FBQyxPQUFiLENBQXFCLFVBQUMsV0FBRCxFQUFpQjtBQUNwQyxnQkFBSSxlQUFlLEtBQUssV0FBVyxDQUFDLFFBQXBDLEVBQThDO0FBQzVDLGNBQUEsYUFBYSxHQUFHLEtBQWhCO0FBQ0Q7QUFDRixXQUpEOztBQU1BLGNBQUksYUFBSixFQUFtQjtBQUNqQixZQUFBLE9BQUksQ0FBQyxJQUFMOztBQUNBLFlBQUEsT0FBSSxDQUFDLEtBQUw7QUFDRDtBQUNGO0FBQ0YsT0FuQkQ7QUFvQkQ7QUFDRixHQXZqQkg7O0FBQUEsU0F5akJFLFNBempCRixHQXlqQkUscUJBQWE7QUFDWCxRQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNmLFdBQUssSUFBTDtBQUNEOztBQUVELFNBQUssT0FBTDtBQUNELEdBL2pCSDs7QUFBQTtBQUFBLEVBQXNDLE1BQXRDLFVBQ1MsT0FEVCxHQUNtQixrQkFEbkI7OztBQ3hFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLHFCQUFULEdBQWtDO0FBQ2pEO0FBQ0EsU0FBTyxPQUFPLGFBQVAsS0FBeUIsVUFBekIsSUFBdUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxTQUF2RCxJQUNGLE9BQU8sYUFBYSxDQUFDLFNBQWQsQ0FBd0IsS0FBL0IsS0FBeUMsVUFEOUM7QUFFQTtBQUNELENBTEQ7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0FBOUQsRUFBaUU7QUFBQSxzQkFDdkMsSUFBSSxDQUFDLEtBQUwsQ0FBVyxZQUFZLGNBQVksRUFBWixDQUF2QixDQUR1QztBQUFBLFFBQ3ZELEtBRHVELGVBQ3ZELEtBRHVEO0FBQUEsUUFDaEQsSUFEZ0QsZUFDaEQsSUFEZ0Q7O0FBRS9ELElBQUEsYUFBYSxDQUFDLEtBQUQsRUFBUSxJQUFSLENBQWI7QUFDRDtBQUNGOztBQUVELFFBQVEsQ0FBQyxhQUFULENBQXVCLE1BQXZCLEVBQStCLGdCQUEvQixDQUFnRCxRQUFoRCxFQUEwRCxVQUFDLEtBQUQsRUFBVztBQUNuRSxFQUFBLEtBQUssQ0FBQyxjQUFOO0FBRUEsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU4sQ0FBYSxhQUFiLENBQTJCLHFCQUEzQixFQUFrRCxLQUFsRCxJQUNaLGlCQURGO0FBRUEsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsS0FBOUI7QUFFQSxFQUFBLFdBQVcsQ0FBQyxLQUFELEVBQVEsSUFBUixDQUFYO0FBQ0EsRUFBQSxhQUFhLENBQUMsS0FBRCxFQUFRLElBQVIsQ0FBYjtBQUVBLEVBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxhQUFiLENBQTJCLE9BQTNCLEVBQW9DLEtBQXBDLEdBQTRDLEVBQTVDO0FBQ0EsRUFBQSxLQUFLLENBQUMsTUFBTixDQUFhLGFBQWIsQ0FBMkIsVUFBM0IsRUFBdUMsS0FBdkMsR0FBK0MsRUFBL0M7QUFDRCxDQVpEO0FBY0EsTUFBTSxDQUFDLGdCQUFQLENBQXdCLGtCQUF4QixFQUE0QyxZQUFNO0FBQ2hELEVBQUEsWUFBWTtBQUNiLENBRkQiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0ZsZXQvcHJldHRpZXItYnl0ZXMvXG4vLyBDaGFuZ2luZyAxMDAwIGJ5dGVzIHRvIDEwMjQsIHNvIHdlIGNhbiBrZWVwIHVwcGVyY2FzZSBLQiB2cyBrQlxuLy8gSVNDIExpY2Vuc2UgKGMpIERhbiBGbGV0dHJlIGh0dHBzOi8vZ2l0aHViLmNvbS9GbGV0L3ByZXR0aWVyLWJ5dGVzL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJldHRpZXJCeXRlcyAobnVtKSB7XG4gIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyB8fCBpc05hTihudW0pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBudW1iZXIsIGdvdCAnICsgdHlwZW9mIG51bSlcbiAgfVxuXG4gIHZhciBuZWcgPSBudW0gPCAwXG4gIHZhciB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddXG5cbiAgaWYgKG5lZykge1xuICAgIG51bSA9IC1udW1cbiAgfVxuXG4gIGlmIChudW0gPCAxKSB7XG4gICAgcmV0dXJuIChuZWcgPyAnLScgOiAnJykgKyBudW0gKyAnIEInXG4gIH1cblxuICB2YXIgZXhwb25lbnQgPSBNYXRoLm1pbihNYXRoLmZsb29yKE1hdGgubG9nKG51bSkgLyBNYXRoLmxvZygxMDI0KSksIHVuaXRzLmxlbmd0aCAtIDEpXG4gIG51bSA9IE51bWJlcihudW0gLyBNYXRoLnBvdygxMDI0LCBleHBvbmVudCkpXG4gIHZhciB1bml0ID0gdW5pdHNbZXhwb25lbnRdXG5cbiAgaWYgKG51bSA+PSAxMCB8fCBudW0gJSAxID09PSAwKSB7XG4gICAgLy8gRG8gbm90IHNob3cgZGVjaW1hbHMgd2hlbiB0aGUgbnVtYmVyIGlzIHR3by1kaWdpdCwgb3IgaWYgdGhlIG51bWJlciBoYXMgbm9cbiAgICAvLyBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICByZXR1cm4gKG5lZyA/ICctJyA6ICcnKSArIG51bS50b0ZpeGVkKDApICsgJyAnICsgdW5pdFxuICB9IGVsc2Uge1xuICAgIHJldHVybiAobmVnID8gJy0nIDogJycpICsgbnVtLnRvRml4ZWQoMSkgKyAnICcgKyB1bml0XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWZ0ZXJcblxuZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcbiAgICB2YXIgYmFpbCA9IGZhbHNlXG4gICAgZXJyX2NiID0gZXJyX2NiIHx8IG5vb3BcbiAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cbiAgICByZXR1cm4gKGNvdW50ID09PSAwKSA/IGNhbGxiYWNrKCkgOiBwcm94eVxuXG4gICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHByb3h5LmNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcbiAgICAgICAgfVxuICAgICAgICAtLXByb3h5LmNvdW50XG5cbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgZXJyb3IsIHJlc3QgYXJlIHBhc3NlZCB0byBlcnJfY2JcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgYmFpbCA9IHRydWVcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIC8vIGZ1dHVyZSBlcnJvciBjYWxsYmFja3Mgd2lsbCBnbyB0byBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuICAgICAgICB9IGVsc2UgaWYgKHByb3h5LmNvdW50ID09PSAwICYmICFiYWlsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG4gIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgdmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMSldO1xuICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzMpXTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKipcclxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcclxuICovXHJcblxyXG52YXIgQmxvYkJ1aWxkZXIgPSB0eXBlb2YgQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gQmxvYkJ1aWxkZXIgOlxyXG4gIHR5cGVvZiBXZWJLaXRCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBXZWJLaXRCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1TQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTVNCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIE1vekJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1vekJsb2JCdWlsZGVyIDogXHJcbiAgZmFsc2U7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xyXG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXHJcbiAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXHJcbiAqL1xyXG5cclxudmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcclxuICAgIHJldHVybiBiLnNpemUgPT09IDI7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcclxuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XHJcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcclxuICByZXR1cm4gYXJ5Lm1hcChmdW5jdGlvbihjaHVuaykge1xyXG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XHJcblxyXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcclxuICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXHJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XHJcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBidWY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNodW5rO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcclxuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICBiYi5hcHBlbmQocGFydCk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEJsb2JDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEJsb2IobWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpLCBvcHRpb25zIHx8IHt9KTtcclxufTtcclxuXHJcbmlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBCbG9iQnVpbGRlckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG4gIEJsb2JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBCbG9iLnByb3RvdHlwZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBCbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcclxuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxufSkoKTtcclxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTggSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRpZiAoYXJnLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmIChhcmcudG9TdHJpbmcgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG4gIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcbiAgZm4ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGZuO1xuICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG59OyIsIi8qKlxuICogY3VpZC5qc1xuICogQ29sbGlzaW9uLXJlc2lzdGFudCBVSUQgZ2VuZXJhdG9yIGZvciBicm93c2VycyBhbmQgbm9kZS5cbiAqIFNlcXVlbnRpYWwgZm9yIGZhc3QgZGIgbG9va3VwcyBhbmQgcmVjZW5jeSBzb3J0aW5nLlxuICogU2FmZSBmb3IgZWxlbWVudCBJRHMgYW5kIHNlcnZlci1zaWRlIGxvb2t1cHMuXG4gKlxuICogRXh0cmFjdGVkIGZyb20gQ0xDVFJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEVyaWMgRWxsaW90dCAyMDEyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbnZhciBmaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vbGliL2ZpbmdlcnByaW50LmpzJyk7XG52YXIgcGFkID0gcmVxdWlyZSgnLi9saWIvcGFkLmpzJyk7XG52YXIgZ2V0UmFuZG9tVmFsdWUgPSByZXF1aXJlKCcuL2xpYi9nZXRSYW5kb21WYWx1ZS5qcycpO1xuXG52YXIgYyA9IDAsXG4gIGJsb2NrU2l6ZSA9IDQsXG4gIGJhc2UgPSAzNixcbiAgZGlzY3JldGVWYWx1ZXMgPSBNYXRoLnBvdyhiYXNlLCBibG9ja1NpemUpO1xuXG5mdW5jdGlvbiByYW5kb21CbG9jayAoKSB7XG4gIHJldHVybiBwYWQoKGdldFJhbmRvbVZhbHVlKCkgKlxuICAgIGRpc2NyZXRlVmFsdWVzIDw8IDApXG4gICAgLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpO1xufVxuXG5mdW5jdGlvbiBzYWZlQ291bnRlciAoKSB7XG4gIGMgPSBjIDwgZGlzY3JldGVWYWx1ZXMgPyBjIDogMDtcbiAgYysrOyAvLyB0aGlzIGlzIG5vdCBzdWJsaW1pbmFsXG4gIHJldHVybiBjIC0gMTtcbn1cblxuZnVuY3Rpb24gY3VpZCAoKSB7XG4gIC8vIFN0YXJ0aW5nIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyIG1ha2VzXG4gIC8vIGl0IEhUTUwgZWxlbWVudCBJRCBmcmllbmRseS5cbiAgdmFyIGxldHRlciA9ICdjJywgLy8gaGFyZC1jb2RlZCBhbGxvd3MgZm9yIHNlcXVlbnRpYWwgYWNjZXNzXG5cbiAgICAvLyB0aW1lc3RhbXBcbiAgICAvLyB3YXJuaW5nOiB0aGlzIGV4cG9zZXMgdGhlIGV4YWN0IGRhdGUgYW5kIHRpbWVcbiAgICAvLyB0aGF0IHRoZSB1aWQgd2FzIGNyZWF0ZWQuXG4gICAgdGltZXN0YW1wID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKS50b1N0cmluZyhiYXNlKSxcblxuICAgIC8vIFByZXZlbnQgc2FtZS1tYWNoaW5lIGNvbGxpc2lvbnMuXG4gICAgY291bnRlciA9IHBhZChzYWZlQ291bnRlcigpLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpLFxuXG4gICAgLy8gQSBmZXcgY2hhcnMgdG8gZ2VuZXJhdGUgZGlzdGluY3QgaWRzIGZvciBkaWZmZXJlbnRcbiAgICAvLyBjbGllbnRzIChzbyBkaWZmZXJlbnQgY29tcHV0ZXJzIGFyZSBmYXIgbGVzc1xuICAgIC8vIGxpa2VseSB0byBnZW5lcmF0ZSB0aGUgc2FtZSBpZClcbiAgICBwcmludCA9IGZpbmdlcnByaW50KCksXG5cbiAgICAvLyBHcmFiIHNvbWUgbW9yZSBjaGFycyBmcm9tIE1hdGgucmFuZG9tKClcbiAgICByYW5kb20gPSByYW5kb21CbG9jaygpICsgcmFuZG9tQmxvY2soKTtcblxuICByZXR1cm4gbGV0dGVyICsgdGltZXN0YW1wICsgY291bnRlciArIHByaW50ICsgcmFuZG9tO1xufVxuXG5jdWlkLnNsdWcgPSBmdW5jdGlvbiBzbHVnICgpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKS50b1N0cmluZygzNiksXG4gICAgY291bnRlciA9IHNhZmVDb3VudGVyKCkudG9TdHJpbmcoMzYpLnNsaWNlKC00KSxcbiAgICBwcmludCA9IGZpbmdlcnByaW50KCkuc2xpY2UoMCwgMSkgK1xuICAgICAgZmluZ2VycHJpbnQoKS5zbGljZSgtMSksXG4gICAgcmFuZG9tID0gcmFuZG9tQmxvY2soKS5zbGljZSgtMik7XG5cbiAgcmV0dXJuIGRhdGUuc2xpY2UoLTIpICtcbiAgICBjb3VudGVyICsgcHJpbnQgKyByYW5kb207XG59O1xuXG5jdWlkLmlzQ3VpZCA9IGZ1bmN0aW9uIGlzQ3VpZCAoc3RyaW5nVG9DaGVjaykge1xuICBpZiAodHlwZW9mIHN0cmluZ1RvQ2hlY2sgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChzdHJpbmdUb0NoZWNrLnN0YXJ0c1dpdGgoJ2MnKSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmN1aWQuaXNTbHVnID0gZnVuY3Rpb24gaXNTbHVnIChzdHJpbmdUb0NoZWNrKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nVG9DaGVjayAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZ1RvQ2hlY2subGVuZ3RoO1xuICBpZiAoc3RyaW5nTGVuZ3RoID49IDcgJiYgc3RyaW5nTGVuZ3RoIDw9IDEwKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY3VpZC5maW5nZXJwcmludCA9IGZpbmdlcnByaW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN1aWQ7XG4iLCJ2YXIgcGFkID0gcmVxdWlyZSgnLi9wYWQuanMnKTtcblxudmFyIGVudiA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnID8gd2luZG93IDogc2VsZjtcbnZhciBnbG9iYWxDb3VudCA9IE9iamVjdC5rZXlzKGVudikubGVuZ3RoO1xudmFyIG1pbWVUeXBlc0xlbmd0aCA9IG5hdmlnYXRvci5taW1lVHlwZXMgPyBuYXZpZ2F0b3IubWltZVR5cGVzLmxlbmd0aCA6IDA7XG52YXIgY2xpZW50SWQgPSBwYWQoKG1pbWVUeXBlc0xlbmd0aCArXG4gIG5hdmlnYXRvci51c2VyQWdlbnQubGVuZ3RoKS50b1N0cmluZygzNikgK1xuICBnbG9iYWxDb3VudC50b1N0cmluZygzNiksIDQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmdlcnByaW50ICgpIHtcbiAgcmV0dXJuIGNsaWVudElkO1xufTtcbiIsIlxudmFyIGdldFJhbmRvbVZhbHVlO1xuXG52YXIgY3J5cHRvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgKHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvKSB8fFxuICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgc2VsZi5jcnlwdG87XG5cbmlmIChjcnlwdG8pIHtcbiAgICB2YXIgbGltID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbiAgICBnZXRSYW5kb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXSAvIGxpbSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZ2V0UmFuZG9tVmFsdWUgPSBNYXRoLnJhbmRvbTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYW5kb21WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFkIChudW0sIHNpemUpIHtcbiAgdmFyIHMgPSAnMDAwMDAwMDAwJyArIG51bTtcbiAgcmV0dXJuIHMuc3Vic3RyKHMubGVuZ3RoIC0gc2l6ZSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBkcmFnRHJvcFxuXG52YXIgZmxhdHRlbiA9IHJlcXVpcmUoJ2ZsYXR0ZW4nKVxudmFyIHBhcmFsbGVsID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsJylcblxuZnVuY3Rpb24gZHJhZ0Ryb3AgKGVsZW0sIGxpc3RlbmVycykge1xuICBpZiAodHlwZW9mIGVsZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWxlbVxuICAgIGVsZW0gPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtKVxuICAgIGlmICghZWxlbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBzZWxlY3RvciArICdcIiBkb2VzIG5vdCBtYXRjaCBhbnkgSFRNTCBlbGVtZW50cycpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFlbGVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBlbGVtICsgJ1wiIGlzIG5vdCBhIHZhbGlkIEhUTUwgZWxlbWVudCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3RlbmVycyA9IHsgb25Ecm9wOiBsaXN0ZW5lcnMgfVxuICB9XG5cbiAgdmFyIHRpbWVvdXRcblxuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIG9uRHJhZ0VudGVyLCBmYWxzZSlcbiAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIG9uRHJhZ092ZXIsIGZhbHNlKVxuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIG9uRHJhZ0xlYXZlLCBmYWxzZSlcbiAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgb25Ecm9wLCBmYWxzZSlcblxuICAvLyBGdW5jdGlvbiB0byByZW1vdmUgZHJhZy1kcm9wIGxpc3RlbmVyc1xuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICByZW1vdmVEcmFnQ2xhc3MoKVxuICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgb25EcmFnRW50ZXIsIGZhbHNlKVxuICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBvbkRyYWdPdmVyLCBmYWxzZSlcbiAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIG9uRHJhZ0xlYXZlLCBmYWxzZSlcbiAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBvbkRyb3AsIGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnRW50ZXIgKGUpIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uRHJhZ0VudGVyKSB7XG4gICAgICBsaXN0ZW5lcnMub25EcmFnRW50ZXIoZSlcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGV2ZW50XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnT3ZlciAoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGlmIChsaXN0ZW5lcnMub25EcmFnT3Zlcikge1xuICAgICAgbGlzdGVuZXJzLm9uRHJhZ092ZXIoZSlcbiAgICB9XG5cbiAgICBpZiAoZS5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIC8vIE9ubHkgYWRkIFwiZHJhZ1wiIGNsYXNzIHdoZW4gYGl0ZW1zYCBjb250YWlucyBpdGVtcyB0aGF0IGFyZSBhYmxlIHRvIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IHRoZSByZWdpc3RlcmVkIGxpc3RlbmVycyAoZmlsZXMgdnMuIHRleHQpXG4gICAgICB2YXIgaXRlbXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLml0ZW1zKVxuICAgICAgdmFyIGZpbGVJdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5raW5kID09PSAnZmlsZScgfSlcbiAgICAgIHZhciB0ZXh0SXRlbXMgPSBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ3N0cmluZycgfSlcblxuICAgICAgaWYgKGZpbGVJdGVtcy5sZW5ndGggPT09IDAgJiYgIWxpc3RlbmVycy5vbkRyb3BUZXh0KSByZXR1cm5cbiAgICAgIGlmICh0ZXh0SXRlbXMubGVuZ3RoID09PSAwICYmICFsaXN0ZW5lcnMub25Ecm9wKSByZXR1cm5cbiAgICAgIGlmIChmaWxlSXRlbXMubGVuZ3RoID09PSAwICYmIHRleHRJdGVtcy5sZW5ndGggPT09IDApIHJldHVyblxuICAgIH1cblxuICAgIGVsZW0uY2xhc3NMaXN0LmFkZCgnZHJhZycpXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG5cbiAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ0xlYXZlIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKGxpc3RlbmVycy5vbkRyYWdMZWF2ZSkge1xuICAgICAgbGlzdGVuZXJzLm9uRHJhZ0xlYXZlKGUpXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVtb3ZlRHJhZ0NsYXNzLCA1MClcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ecm9wIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKGxpc3RlbmVycy5vbkRyYWdMZWF2ZSkge1xuICAgICAgbGlzdGVuZXJzLm9uRHJhZ0xlYXZlKGUpXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgcmVtb3ZlRHJhZ0NsYXNzKClcblxuICAgIHZhciBwb3MgPSB7XG4gICAgICB4OiBlLmNsaWVudFgsXG4gICAgICB5OiBlLmNsaWVudFlcbiAgICB9XG5cbiAgICAvLyB0ZXh0IGRyb3Agc3VwcG9ydFxuICAgIHZhciB0ZXh0ID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dCcpXG4gICAgaWYgKHRleHQgJiYgbGlzdGVuZXJzLm9uRHJvcFRleHQpIHtcbiAgICAgIGxpc3RlbmVycy5vbkRyb3BUZXh0KHRleHQsIHBvcylcbiAgICB9XG5cbiAgICAvLyBGaWxlIGRyb3Agc3VwcG9ydC4gVGhlIGBkYXRhVHJhbnNmZXIuaXRlbXNgIEFQSSBzdXBwb3J0cyBkaXJlY3Rvcmllcywgc28gd2VcbiAgICAvLyB1c2UgaXQgaW5zdGVhZCBvZiBgZGF0YVRyYW5zZmVyLmZpbGVzYCwgZXZlbiB0aG91Z2ggaXQncyBtdWNoIG1vcmVcbiAgICAvLyBjb21wbGljYXRlZCB0byB1c2UuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2RyYWctZHJvcC9pc3N1ZXMvMzlcbiAgICBpZiAobGlzdGVuZXJzLm9uRHJvcCAmJiBlLmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgdmFyIGZpbGVMaXN0ID0gZS5kYXRhVHJhbnNmZXIuZmlsZXNcblxuICAgICAgLy8gSGFuZGxlIGRpcmVjdG9yaWVzIGluIENocm9tZSB1c2luZyB0aGUgcHJvcHJpZXRhcnkgRmlsZVN5c3RlbSBBUElcbiAgICAgIHZhciBpdGVtcyA9IEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuaXRlbXMpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5raW5kID09PSAnZmlsZSdcbiAgICAgIH0pXG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gICAgICBwYXJhbGxlbChpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHByb2Nlc3NFbnRyeShpdGVtLndlYmtpdEdldEFzRW50cnkoKSwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIC8vIFRoaXMgY2F0Y2hlcyBwZXJtaXNzaW9uIGVycm9ycyB3aXRoIGZpbGU6Ly8gaW4gQ2hyb21lLiBUaGlzIHNob3VsZCBuZXZlclxuICAgICAgICAvLyB0aHJvdyBpbiBwcm9kdWN0aW9uIGNvZGUsIHNvIHRoZSB1c2VyIGRvZXMgbm90IG5lZWQgdG8gdXNlIHRyeS1jYXRjaC5cbiAgICAgICAgaWYgKGVycikgdGhyb3cgZXJyXG5cbiAgICAgICAgdmFyIGVudHJpZXMgPSBmbGF0dGVuKHJlc3VsdHMpXG5cbiAgICAgICAgdmFyIGZpbGVzID0gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbS5pc0ZpbGVcbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgZGlyZWN0b3JpZXMgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtLmlzRGlyZWN0b3J5XG4gICAgICAgIH0pXG5cbiAgICAgICAgbGlzdGVuZXJzLm9uRHJvcChmaWxlcywgcG9zLCBmaWxlTGlzdCwgZGlyZWN0b3JpZXMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRHJhZ0NsYXNzICgpIHtcbiAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWcnKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbnRyeSAoZW50cnksIGNiKSB7XG4gIHZhciBlbnRyaWVzID0gW11cblxuICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgZW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgZmlsZS5mdWxsUGF0aCA9IGVudHJ5LmZ1bGxQYXRoIC8vIHByZXNlcnZlIHBhdGhpbmcgZm9yIGNvbnN1bWVyXG4gICAgICBmaWxlLmlzRmlsZSA9IHRydWVcbiAgICAgIGZpbGUuaXNEaXJlY3RvcnkgPSBmYWxzZVxuICAgICAgY2IobnVsbCwgZmlsZSlcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgfSlcbiAgfSBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgIHZhciByZWFkZXIgPSBlbnRyeS5jcmVhdGVSZWFkZXIoKVxuICAgIHJlYWRFbnRyaWVzKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRFbnRyaWVzICgpIHtcbiAgICByZWFkZXIucmVhZEVudHJpZXMoZnVuY3Rpb24gKGVudHJpZXNfKSB7XG4gICAgICBpZiAoZW50cmllc18ubGVuZ3RoID4gMCkge1xuICAgICAgICBlbnRyaWVzID0gZW50cmllcy5jb25jYXQoQXJyYXkuZnJvbShlbnRyaWVzXykpXG4gICAgICAgIHJlYWRFbnRyaWVzKCkgLy8gY29udGludWUgcmVhZGluZyBlbnRyaWVzIHVudGlsIGByZWFkRW50cmllc2AgcmV0dXJucyBubyBtb3JlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lRW50cmllcygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmVFbnRyaWVzICgpIHtcbiAgICBwYXJhbGxlbChlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgcHJvY2Vzc0VudHJ5KGVudHJ5LCBjYilcbiAgICAgIH1cbiAgICB9KSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGZ1bGxQYXRoOiBlbnRyeS5mdWxsUGF0aCxcbiAgICAgICAgICBuYW1lOiBlbnRyeS5uYW1lLFxuICAgICAgICAgIGlzRmlsZTogZmFsc2UsXG4gICAgICAgICAgaXNEaXJlY3Rvcnk6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgY2IobnVsbCwgcmVzdWx0cylcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsYXR0ZW4obGlzdCwgZGVwdGgpIHtcbiAgZGVwdGggPSAodHlwZW9mIGRlcHRoID09ICdudW1iZXInKSA/IGRlcHRoIDogSW5maW5pdHk7XG5cbiAgaWYgKCFkZXB0aCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgICByZXR1cm4gbGlzdC5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmV0dXJuIF9mbGF0dGVuKGxpc3QsIDEpO1xuXG4gIGZ1bmN0aW9uIF9mbGF0dGVuKGxpc3QsIGQpIHtcbiAgICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaXRlbSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgJiYgZCA8IGRlcHRoKSB7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KF9mbGF0dGVuKGl0ZW0sIGQgKyAxKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoaXRlbSk7XG4gICAgICB9XG4gICAgfSwgW10pO1xuICB9XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcblxudmFyIGJhc2U2NGVuY29kZXI7XG5pZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHsgdHlwZTogcGFja2V0LnR5cGUsIGRhdGE6IGZyLnJlc3VsdCB9LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBidG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIiwiXG4vKipcbiAqIEdldHMgdGhlIGtleXMgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuICB2YXIgYXJyID0gW107XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xuXG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0dmFyIHZhbHVlO1xuXHR2YXIgZXh0cmE7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR2YXIgaW5kZXggPSAtMTtcblx0dmFyIHZhbHVlO1xuXHR2YXIgb3V0cHV0ID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0fVxuXHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdH1cblx0dmFyIHN5bWJvbCA9ICcnO1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0fVxuXHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoIWNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSAweEZGRkQ7XG5cdFx0fVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0fVxuXHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRyZXR1cm4gc3ltYm9sO1xufVxuXG5mdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZywgb3B0cykge1xuXHRvcHRzID0gb3B0cyB8fCB7fTtcblx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblxuXHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHR2YXIgaW5kZXggPSAtMTtcblx0dmFyIGNvZGVQb2ludDtcblx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdH1cblx0cmV0dXJuIGJ5dGVTdHJpbmc7XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5mdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0fVxuXG5cdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlU3ltYm9sKHN0cmljdCkge1xuXHR2YXIgYnl0ZTE7XG5cdHZhciBieXRlMjtcblx0dmFyIGJ5dGUzO1xuXHR2YXIgYnl0ZTQ7XG5cdHZhciBjb2RlUG9pbnQ7XG5cblx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0fVxuXG5cdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRieXRlSW5kZXgrKztcblxuXHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRyZXR1cm4gYnl0ZTE7XG5cdH1cblxuXHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdH1cblx0fVxuXG5cdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0cmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdH1cblx0fVxuXG5cdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9XG5cdH1cblxuXHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xufVxuXG52YXIgYnl0ZUFycmF5O1xudmFyIGJ5dGVDb3VudDtcbnZhciBieXRlSW5kZXg7XG5mdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0Ynl0ZUluZGV4ID0gMDtcblx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0dmFyIHRtcDtcblx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG5cdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdH1cblx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHR2ZXJzaW9uOiAnMi4xLjInLFxuXHRlbmNvZGU6IHV0ZjhlbmNvZGUsXG5cdGRlY29kZTogdXRmOGRlY29kZVxufTtcbiIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP3QoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcImV4aWZyXCIsW1wiZXhwb3J0c1wiXSx0KTp0KChlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6ZXx8c2VsZikuZXhpZnI9e30pfSh0aGlzLChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBuKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiByKGUsdCxyKXtyZXR1cm4gdCYmbihlLnByb3RvdHlwZSx0KSxyJiZuKGUsciksZX1mdW5jdGlvbiBpKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBhKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KTt2YXIgbj1bXCJwcm90b3R5cGVcIixcIl9fcHJvdG9fX1wiLFwiY2FsbGVyXCIsXCJhcmd1bWVudHNcIixcImxlbmd0aFwiLFwibmFtZVwiXTtPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KS5mb3JFYWNoKChmdW5jdGlvbihyKXstMT09PW4uaW5kZXhPZihyKSYmZVtyXSE9PXRbcl0mJihlW3JdPXRbcl0pfSkpLHQmJnUoZSx0KX1mdW5jdGlvbiBzKGUpe3JldHVybihzPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIG8oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKGUpe3JldHVybiExfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4oZj1vKCk/UmVmbGVjdC5jb25zdHJ1Y3Q6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPVtudWxsXTtyLnB1c2guYXBwbHkocix0KTt2YXIgaT1uZXcoRnVuY3Rpb24uYmluZC5hcHBseShlLHIpKTtyZXR1cm4gbiYmdShpLG4ucHJvdG90eXBlKSxpfSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgTWFwP25ldyBNYXA6dm9pZCAwO3JldHVybihjPWZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lfHwobj1lLC0xPT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbChuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSkpcmV0dXJuIGU7dmFyIG47aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7aWYodm9pZCAwIT09dCl7aWYodC5oYXMoZSkpcmV0dXJuIHQuZ2V0KGUpO3Quc2V0KGUscil9ZnVuY3Rpb24gcigpe3JldHVybiBmKGUsYXJndW1lbnRzLHModGhpcykuY29uc3RydWN0b3IpfXJldHVybiByLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6cixlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx1KHIsZSl9KShlKX1mdW5jdGlvbiBoKGUpe2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiBlfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/aChlKTp0fWZ1bmN0aW9uIGQoZSl7dmFyIHQ9bygpO3JldHVybiBmdW5jdGlvbigpe3ZhciBuLHI9cyhlKTtpZih0KXt2YXIgaT1zKHRoaXMpLmNvbnN0cnVjdG9yO249UmVmbGVjdC5jb25zdHJ1Y3Qocixhcmd1bWVudHMsaSl9ZWxzZSBuPXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBsKHRoaXMsbil9fWZ1bmN0aW9uIHYoZSx0LG4pe3JldHVybih2PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmdldD9SZWZsZWN0LmdldDpmdW5jdGlvbihlLHQsbil7dmFyIHI9ZnVuY3Rpb24oZSx0KXtmb3IoOyFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSYmbnVsbCE9PShlPXMoZSkpOyk7cmV0dXJuIGV9KGUsdCk7aWYocil7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpO3JldHVybiBpLmdldD9pLmdldC5jYWxsKG4pOmkudmFsdWV9fSkoZSx0LG58fGUpfXZhciBwPU9iamVjdC52YWx1ZXN8fGZ1bmN0aW9uKGUpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBlKXQucHVzaChlW25dKTtyZXR1cm4gdH0seT1PYmplY3QuZW50cmllc3x8ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpdC5wdXNoKFtuLGVbbl1dKTtyZXR1cm4gdH0sZz1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLHI9MTtyPHQ7cisrKW5bci0xXT1hcmd1bWVudHNbcl07cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBuIGluIHQpZVtuXT10W25dfSkpLGV9LGs9T2JqZWN0LmZyb21FbnRyaWVzfHxmdW5jdGlvbihlKXt2YXIgdD17fTtyZXR1cm4gbShlKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lWzBdLHI9ZVsxXTt0W25dPXJ9KSksdH0sbT1BcnJheS5mcm9tfHxmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgUCl7dmFyIHQ9W107cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5wdXNoKFtuLGVdKX0pKSx0fXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKX07ZnVuY3Rpb24gYihlKXtyZXR1cm4tMSE9PXRoaXMuaW5kZXhPZihlKX1BcnJheS5wcm90b3R5cGUuaW5jbHVkZXN8fChBcnJheS5wcm90b3R5cGUuaW5jbHVkZXM9YiksU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc3x8KFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXM9YiksU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRofHwoU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoPWZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowO3JldHVybiB0aGlzLnN1YnN0cmluZyh0LHQrZS5sZW5ndGgpPT09ZX0pLFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGh8fChTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoPWZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmxlbmd0aDtyZXR1cm4gdGhpcy5zdWJzdHJpbmcodC1lLmxlbmd0aCx0KT09PWV9KTt2YXIgQT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOmdsb2JhbCx3PUEuZmV0Y2h8fGZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4scil7dmFyIGk9bmV3IFhNTEh0dHBSZXF1ZXN0O2lmKGkub3BlbihcImdldFwiLGUsITApLGkucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixpLm9uZXJyb3I9cix0LmhlYWRlcnMpZm9yKHZhciBhIGluIHQuaGVhZGVycylpLnNldFJlcXVlc3RIZWFkZXIoYSx0LmhlYWRlcnNbYV0pO2kub25sb2FkPWZ1bmN0aW9uKCl7bih7b2s6aS5zdGF0dXM+PTIwMCYmaS5zdGF0dXM8MzAwLHN0YXR1czppLnN0YXR1cyxhcnJheUJ1ZmZlcjpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5yZXNwb25zZSl9fSl9LGkuc2VuZChudWxsKX0pKX0sTz1mdW5jdGlvbihlKXt2YXIgdD1bXTtpZihPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LHtzaXplOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZW5ndGh9fSxoYXM6e3ZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybi0xIT09dGhpcy5pbmRleE9mKGUpfX0sYWRkOnt2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmhhcyhlKXx8dGhpcy5wdXNoKGUpfX0sZGVsZXRlOnt2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLmhhcyhlKSl7dmFyIHQ9dGhpcy5pbmRleE9mKGUpO3RoaXMuc3BsaWNlKHQsMSl9fX19KSxBcnJheS5pc0FycmF5KGUpKWZvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXQuYWRkKGVbbl0pO3JldHVybiB0fSxTPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUChlKX0sUD12b2lkIDAhPT1BLk1hcCYmdm9pZCAwIT09QS5NYXAucHJvdG90eXBlLmtleXM/QS5NYXA6ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4pe2lmKHQodGhpcyxlKSx0aGlzLmNsZWFyKCksbilmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl0aGlzLnNldChuW3JdWzBdLG5bcl1bMV0pfXJldHVybiByKGUsW3trZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwPXt9LHRoaXMuX2tleXM9W119fSx7a2V5Olwic2l6ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9rZXlzLmxlbmd0aH19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fbWFwW1wibWFwX1wiK2VdfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX21hcFtcIm1hcF9cIitlXT10LHRoaXMuX2tleXMuaW5kZXhPZihlKTwwJiZ0aGlzLl9rZXlzLnB1c2goZSksdGhpc319LHtrZXk6XCJoYXNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fa2V5cy5pbmRleE9mKGUpPj0wfX0se2tleTpcImRlbGV0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX2tleXMuaW5kZXhPZihlKTtyZXR1cm4hKHQ8MCkmJihkZWxldGUgdGhpcy5fbWFwW1wibWFwX1wiK2VdLHRoaXMuX2tleXMuc3BsaWNlKHQsMSksITApfX0se2tleTpcImtleXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9rZXlzLnNsaWNlKDApfX0se2tleTpcInZhbHVlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gdGhpcy5fa2V5cy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlLmdldCh0KX0pKX19LHtrZXk6XCJlbnRyaWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLl9rZXlzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuW3QsZS5nZXQodCldfSkpfX0se2tleTpcImZvckVhY2hcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248dGhpcy5fa2V5cy5sZW5ndGg7bisrKWUuY2FsbCh0LHRoaXMuX21hcFtcIm1hcF9cIit0aGlzLl9rZXlzW25dXSx0aGlzLl9rZXlzW25dLHRoaXMpfX1dKSxlfSgpLFU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpnbG9iYWwseD1cInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yLEM9eCYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQsQj0hKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWx8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBwcm9jZXNzfHwhcHJvY2Vzcy52ZXJzaW9uc3x8IXByb2Nlc3MudmVyc2lvbnMubm9kZSksaj1VLkJ1ZmZlcixfPSEhajt2YXIgVj1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZX07ZnVuY3Rpb24gSShlKXtyZXR1cm4gdm9pZCAwPT09ZXx8KGUgaW5zdGFuY2VvZiBQPzA9PT1lLnNpemU6MD09PXAoZSkuZmlsdGVyKFYpLmxlbmd0aCl9ZnVuY3Rpb24gTChlKXt2YXIgdD1uZXcgRXJyb3IoZSk7dGhyb3cgZGVsZXRlIHQuc3RhY2ssdH1mdW5jdGlvbiBUKGUpe3ZhciB0PWZ1bmN0aW9uKGUpe3ZhciB0PTA7cmV0dXJuIGUuaWZkMC5lbmFibGVkJiYodCs9MTAyNCksZS5leGlmLmVuYWJsZWQmJih0Kz0yMDQ4KSxlLm1ha2VyTm90ZSYmKHQrPTIwNDgpLGUudXNlckNvbW1lbnQmJih0Kz0xMDI0KSxlLmdwcy5lbmFibGVkJiYodCs9NTEyKSxlLmludGVyb3AuZW5hYmxlZCYmKHQrPTEwMCksZS5pZmQxLmVuYWJsZWQmJih0Kz0xMDI0KSx0KzIwNDh9KGUpO3JldHVybiBlLmpmaWYuZW5hYmxlZCYmKHQrPTUwKSxlLnhtcC5lbmFibGVkJiYodCs9MmU0KSxlLmlwdGMuZW5hYmxlZCYmKHQrPTE0ZTMpLGUuaWNjLmVuYWJsZWQmJih0Kz02ZTMpLHR9dmFyIHo9ZnVuY3Rpb24oZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlKX0sRj1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmLThcIik6dm9pZCAwO2Z1bmN0aW9uIEUoZSl7cmV0dXJuIEY/Ri5kZWNvZGUoZSk6Xz9CdWZmZXIuZnJvbShlKS50b1N0cmluZyhcInV0ZjhcIik6ZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh6KGUpKSl9dmFyIEQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowLGk9YXJndW1lbnRzLmxlbmd0aD4yP2FyZ3VtZW50c1syXTp2b2lkIDAsYT1hcmd1bWVudHMubGVuZ3RoPjM/YXJndW1lbnRzWzNdOnZvaWQgMDtpZih0KHRoaXMsZSksXCJib29sZWFuXCI9PXR5cGVvZiBhJiYodGhpcy5sZT1hKSxBcnJheS5pc0FycmF5KG4pJiYobj1uZXcgVWludDhBcnJheShuKSksMD09PW4pdGhpcy5ieXRlT2Zmc2V0PTAsdGhpcy5ieXRlTGVuZ3RoPTA7ZWxzZSBpZihuIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe3ZvaWQgMD09PWkmJihpPW4uYnl0ZUxlbmd0aC1yKTt2YXIgcz1uZXcgRGF0YVZpZXcobixyLGkpO3RoaXMuX3N3YXBEYXRhVmlldyhzKX1lbHNlIGlmKG4gaW5zdGFuY2VvZiBVaW50OEFycmF5fHxuIGluc3RhbmNlb2YgRGF0YVZpZXd8fG4gaW5zdGFuY2VvZiBlKXt2b2lkIDA9PT1pJiYoaT1uLmJ5dGVMZW5ndGgtciksKHIrPW4uYnl0ZU9mZnNldCkraT5uLmJ5dGVPZmZzZXQrbi5ieXRlTGVuZ3RoJiZMKFwiQ3JlYXRpbmcgdmlldyBvdXRzaWRlIG9mIGF2YWlsYWJsZSBtZW1vcnkgaW4gQXJyYXlCdWZmZXJcIik7dmFyIHU9bmV3IERhdGFWaWV3KG4uYnVmZmVyLHIsaSk7dGhpcy5fc3dhcERhdGFWaWV3KHUpfWVsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIG4pe3ZhciBvPW5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIobikpO3RoaXMuX3N3YXBEYXRhVmlldyhvKX1lbHNlIEwoXCJJbnZhbGlkIGlucHV0IGFyZ3VtZW50IGZvciBCdWZmZXJWaWV3OiBcIituKX1yZXR1cm4gcihlLFt7a2V5OlwiX3N3YXBBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX3N3YXBEYXRhVmlldyhuZXcgRGF0YVZpZXcoZSkpfX0se2tleTpcIl9zd2FwQnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fc3dhcERhdGFWaWV3KG5ldyBEYXRhVmlldyhlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoKSl9fSx7a2V5OlwiX3N3YXBEYXRhVmlld1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuZGF0YVZpZXc9ZSx0aGlzLmJ1ZmZlcj1lLmJ1ZmZlcix0aGlzLmJ5dGVPZmZzZXQ9ZS5ieXRlT2Zmc2V0LHRoaXMuYnl0ZUxlbmd0aD1lLmJ5dGVMZW5ndGh9fSx7a2V5OlwiX2xlbmd0aFRvRW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYnl0ZUxlbmd0aC1lfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKHQsbil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOmU7dCBpbnN0YW5jZW9mIERhdGFWaWV3fHx0IGluc3RhbmNlb2YgZT90PW5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpOnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKHQ9bmV3IFVpbnQ4QXJyYXkodCkpLHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxMKFwiQnVmZmVyVmlldy5zZXQoKTogSW52YWxpZCBkYXRhIGFyZ3VtZW50LlwiKTt2YXIgaT10aGlzLnRvVWludDgoKTtyZXR1cm4gaS5zZXQodCxuKSxuZXcgcih0aGlzLG4sdC5ieXRlTGVuZ3RoKX19LHtrZXk6XCJzdWJhcnJheVwiLHZhbHVlOmZ1bmN0aW9uKHQsbil7cmV0dXJuIG5ldyBlKHRoaXMsdCxuPW58fHRoaXMuX2xlbmd0aFRvRW5kKHQpKX19LHtrZXk6XCJ0b1VpbnQ4XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsdGhpcy5ieXRlT2Zmc2V0LHRoaXMuYnl0ZUxlbmd0aCl9fSx7a2V5OlwiZ2V0VWludDhBcnJheVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLHRoaXMuYnl0ZU9mZnNldCtlLHQpfX0se2tleTpcImdldFN0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjAsdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5ieXRlTGVuZ3RoLG49dGhpcy5nZXRVaW50OEFycmF5KGUsdCk7cmV0dXJuIEUobil9fSx7a2V5OlwiZ2V0TGF0aW4xU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmJ5dGVMZW5ndGgsbj10aGlzLmdldFVpbnQ4QXJyYXkoZSx0KTtyZXR1cm4geihuKX19LHtrZXk6XCJnZXRVbmljb2RlU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjAsdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5ieXRlTGVuZ3RoLG49W10scj0wO3I8dCYmZStyPHRoaXMuYnl0ZUxlbmd0aDtyKz0yKW4ucHVzaCh0aGlzLmdldFVpbnQxNihlK3IpKTtyZXR1cm4geihuKX19LHtrZXk6XCJnZXRJbnQ4XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0SW50OChlKX19LHtrZXk6XCJnZXRVaW50OFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQ4KGUpfX0se2tleTpcImdldEludDE2XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0SW50MTYoZSx0KX19LHtrZXk6XCJnZXRJbnQzMlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmxlO3JldHVybiB0aGlzLmRhdGFWaWV3LmdldEludDMyKGUsdCl9fSx7a2V5OlwiZ2V0VWludDE2XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDE2KGUsdCl9fSx7a2V5OlwiZ2V0VWludDMyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDMyKGUsdCl9fSx7a2V5OlwiZ2V0RmxvYXQzMlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmxlO3JldHVybiB0aGlzLmRhdGFWaWV3LmdldEZsb2F0MzIoZSx0KX19LHtrZXk6XCJnZXRGbG9hdDY0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQ2NChlLHQpfX0se2tleTpcImdldEZsb2F0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQzMihlLHQpfX0se2tleTpcImdldERvdWJsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmxlO3JldHVybiB0aGlzLmRhdGFWaWV3LmdldEZsb2F0NjQoZSx0KX19LHtrZXk6XCJnZXRVaW50Qnl0ZXNcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7c3dpdGNoKHQpe2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRVaW50OChlLG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRVaW50MTYoZSxuKTtjYXNlIDQ6cmV0dXJuIHRoaXMuZ2V0VWludDMyKGUsbik7Y2FzZSA4OnJldHVybiB0aGlzLmdldFVpbnQ2NCYmdGhpcy5nZXRVaW50NjQoZSxuKX19fSx7a2V5OlwiZ2V0VWludFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtzd2l0Y2godCl7Y2FzZSA4OnJldHVybiB0aGlzLmdldFVpbnQ4KGUsbik7Y2FzZSAxNjpyZXR1cm4gdGhpcy5nZXRVaW50MTYoZSxuKTtjYXNlIDMyOnJldHVybiB0aGlzLmdldFVpbnQzMihlLG4pO2Nhc2UgNjQ6cmV0dXJuIHRoaXMuZ2V0VWludDY0JiZ0aGlzLmdldFVpbnQ2NChlLG4pfX19LHtrZXk6XCJ0b1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRhdGFWaWV3LnRvU3RyaW5nKGUsdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKX19LHtrZXk6XCJlbnN1cmVDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKCl7fX1dLFt7a2V5OlwiZnJvbVwiLHZhbHVlOmZ1bmN0aW9uKHQsbil7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzJiZ0LmxlPT09bj90Om5ldyBlKHQsdm9pZCAwLHZvaWQgMCxuKX19XSksZX0oKTtmdW5jdGlvbiBSKGUsdCl7TChcIlwiLmNvbmNhdChlLFwiICdcIikuY29uY2F0KHQsXCInIHdhcyBub3QgbG9hZGVkLCB0cnkgdXNpbmcgZnVsbCBidWlsZCBvZiBleGlmci5cIikpfXZhciBOPWZ1bmN0aW9uKGUpe2EoaSxlKTt2YXIgbj1kKGkpO2Z1bmN0aW9uIGkoZSl7dmFyIHI7cmV0dXJuIHQodGhpcyxpKSwocj1uLmNhbGwodGhpcykpLmtpbmQ9ZSxyfXJldHVybiByKGksW3trZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmhhcyhlKXx8Uih0aGlzLmtpbmQsZSksdCYmKGUgaW4gdHx8ZnVuY3Rpb24oZSx0KXtMKFwiVW5rbm93biBcIi5jb25jYXQoZSxcIiAnXCIpLmNvbmNhdCh0LFwiJy5cIikpfSh0aGlzLmtpbmQsZSksdFtlXS5lbmFibGVkfHxSKHRoaXMua2luZCxlKSksdihzKGkucHJvdG90eXBlKSxcImdldFwiLHRoaXMpLmNhbGwodGhpcyxlKX19LHtrZXk6XCJrZXlMaXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLmtleXMoKSl9fV0pLGl9KGMoUCkpLE09bmV3IE4oXCJmaWxlIHBhcnNlclwiKSxXPW5ldyBOKFwic2VnbWVudCBwYXJzZXJcIiksSz1uZXcgTihcImZpbGUgcmVhZGVyXCIpO2Z1bmN0aW9uIEgoZSl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbl09YXJndW1lbnRzW25dO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuYXBwbHkodGhpcyx0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19ZnVuY3Rpb24gWChlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX12YXIgWT1IKChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsbil7dmFyIHI9bmV3IEZpbGVSZWFkZXI7ci5vbmxvYWRlbmQ9ZnVuY3Rpb24oKXtyZXR1cm4gdChyLnJlc3VsdHx8bmV3IEFycmF5QnVmZmVyKX0sci5vbmVycm9yPW4sci5yZWFkQXNBcnJheUJ1ZmZlcihlKX0pKX0pKSxHPUgoKGZ1bmN0aW9uKGUpe3JldHVybiB3KGUpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSl9KSksSj1IKChmdW5jdGlvbihlLHQpe3JldHVybiBYKHQoZSksKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgRChlKX0pKX0pKSxxPUgoKGZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1uZXcoSy5nZXQobikpKGUsdCk7cmV0dXJuIFgoci5yZWFkKCksKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSl9KSksUT1IKChmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gSy5oYXMobik/cShlLHQsbik6cj9KKGUscik6KEwoXCJQYXJzZXIgXCIuY29uY2F0KG4sXCIgaXMgbm90IGxvYWRlZFwiKSksWCgpKX0pKSxaPVwiSW52YWxpZCBpbnB1dCBhcmd1bWVudFwiO2Z1bmN0aW9uICQoZSx0KXtyZXR1cm4obj1lKS5zdGFydHNXaXRoKFwiZGF0YTpcIil8fG4ubGVuZ3RoPjFlND9xKGUsdCxcImJhc2U2NFwiKTp4P1EoZSx0LFwidXJsXCIsRyk6Qj9xKGUsdCxcImZzXCIpOnZvaWQgTChaKTt2YXIgbn12YXIgZWU9ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiB0KHRoaXMsaSksbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHIoaSxbe2tleTpcInRhZ0tleXNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGxLZXlzfHwodGhpcy5hbGxLZXlzPW0odGhpcy5rZXlzKCkpKSx0aGlzLmFsbEtleXN9fSx7a2V5OlwidGFnVmFsdWVzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWxsVmFsdWVzfHwodGhpcy5hbGxWYWx1ZXM9bSh0aGlzLnZhbHVlcygpKSksdGhpcy5hbGxWYWx1ZXN9fV0pLGl9KGMoUCkpO2Z1bmN0aW9uIHRlKGUsdCxuKXt2YXIgcj1uZXcgZWUsaT1uO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXt2YXIgcz1pW2FdLHU9c1swXSxvPXNbMV07ci5zZXQodSxvKX1pZihBcnJheS5pc0FycmF5KHQpKXt2YXIgZj10O0FycmF5LmlzQXJyYXkoZil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBmLmVudHJpZXMmJihmPWYuZW50cmllcygpKSxmPW0oZikpO2Zvcih2YXIgYz0wO2M8Zi5sZW5ndGg7YysrKXt2YXIgaD1mW2NdO2Uuc2V0KGgscil9fWVsc2UgZS5zZXQodCxyKTtyZXR1cm4gcn1mdW5jdGlvbiBuZShlLHQsbil7dmFyIHIsaT1lLmdldCh0KSxhPW47QXJyYXkuaXNBcnJheShhKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGEuZW50cmllcyYmKGE9YS5lbnRyaWVzKCkpLGE9bShhKSk7Zm9yKHZhciBzPTA7czxhLmxlbmd0aDtzKyspcj1hW3NdLGkuc2V0KHJbMF0sclsxXSl9dmFyIHJlPVMoKSxpZT1TKCksYWU9UygpLHNlPTM3NTAwLHVlPTM3NTEwLG9lPTMzNzIzLGZlPTM0Njc1LGNlPTM0NjY1LGhlPTM0ODUzLGxlPTQwOTY1LGRlPVtcImNodW5rZWRcIixcImZpcnN0Q2h1bmtTaXplXCIsXCJmaXJzdENodW5rU2l6ZU5vZGVcIixcImZpcnN0Q2h1bmtTaXplQnJvd3NlclwiLFwiY2h1bmtTaXplXCIsXCJjaHVua0xpbWl0XCJdLHZlPVtcImpmaWZcIixcInhtcFwiLFwiaWNjXCIsXCJpcHRjXCIsXCJpaGRyXCJdLHBlPVtcInRpZmZcIl0uY29uY2F0KHZlKSx5ZT1bXCJpZmQwXCIsXCJpZmQxXCIsXCJleGlmXCIsXCJncHNcIixcImludGVyb3BcIl0sZ2U9W10uY29uY2F0KHBlLHllKSxrZT1bXCJtYWtlck5vdGVcIixcInVzZXJDb21tZW50XCJdLG1lPVtcInRyYW5zbGF0ZUtleXNcIixcInRyYW5zbGF0ZVZhbHVlc1wiLFwicmV2aXZlVmFsdWVzXCIsXCJtdWx0aVNlZ21lbnRcIl0sYmU9W10uY29uY2F0KG1lLFtcInNhbml0aXplXCIsXCJtZXJnZU91dHB1dFwiLFwic2lsZW50RXJyb3JzXCJdKSxBZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0KHRoaXMsZSl9cmV0dXJuIHIoZSxbe2tleTpcInRyYW5zbGF0ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zbGF0ZUtleXN8fHRoaXMudHJhbnNsYXRlVmFsdWVzfHx0aGlzLnJldml2ZVZhbHVlc319XSksZX0oKSx3ZT1mdW5jdGlvbihlKXthKHMsZSk7dmFyIG49ZChzKTtmdW5jdGlvbiBzKGUscixhLHUpe3ZhciBvO2lmKHQodGhpcyxzKSxpKGgobz1uLmNhbGwodGhpcykpLFwiZW5hYmxlZFwiLCExKSxpKGgobyksXCJza2lwXCIsTygpKSxpKGgobyksXCJwaWNrXCIsTygpKSxpKGgobyksXCJkZXBzXCIsTygpKSxpKGgobyksXCJ0cmFuc2xhdGVLZXlzXCIsITEpLGkoaChvKSxcInRyYW5zbGF0ZVZhbHVlc1wiLCExKSxpKGgobyksXCJyZXZpdmVWYWx1ZXNcIiwhMSksby5rZXk9ZSxvLmVuYWJsZWQ9cixvLnBhcnNlPW8uZW5hYmxlZCxvLmFwcGx5SW5oZXJpdGFibGVzKHUpLG8uY2FuQmVGaWx0ZXJlZD15ZS5pbmNsdWRlcyhlKSxvLmNhbkJlRmlsdGVyZWQmJihvLmRpY3Q9cmUuZ2V0KGUpKSx2b2lkIDAhPT1hKWlmKEFycmF5LmlzQXJyYXkoYSkpby5wYXJzZT1vLmVuYWJsZWQ9ITAsby5jYW5CZUZpbHRlcmVkJiZhLmxlbmd0aD4wJiZvLnRyYW5zbGF0ZVRhZ1NldChhLG8ucGljayk7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgYSl7aWYoby5lbmFibGVkPSEwLG8ucGFyc2U9ITEhPT1hLnBhcnNlLG8uY2FuQmVGaWx0ZXJlZCl7dmFyIGY9YS5waWNrLGM9YS5za2lwO2YmJmYubGVuZ3RoPjAmJm8udHJhbnNsYXRlVGFnU2V0KGYsby5waWNrKSxjJiZjLmxlbmd0aD4wJiZvLnRyYW5zbGF0ZVRhZ1NldChjLG8uc2tpcCl9by5hcHBseUluaGVyaXRhYmxlcyhhKX1lbHNlITA9PT1hfHwhMT09PWE/by5wYXJzZT1vLmVuYWJsZWQ9YTpMKFwiSW52YWxpZCBvcHRpb25zIGFyZ3VtZW50OiBcIi5jb25jYXQoYSkpO3JldHVybiBvfXJldHVybiByKHMsW3trZXk6XCJuZWVkZWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfHx0aGlzLmRlcHMuc2l6ZT4wfX0se2tleTpcImFwcGx5SW5oZXJpdGFibGVzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPW1lO0FycmF5LmlzQXJyYXkocil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmVudHJpZXMmJihyPXIuZW50cmllcygpKSxyPW0ocikpO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXZvaWQgMCE9PShuPWVbdD1yW2ldXSkmJih0aGlzW3RdPW4pfX0se2tleTpcInRyYW5zbGF0ZVRhZ1NldFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodGhpcy5kaWN0KXt2YXIgbixyLGk9dGhpcy5kaWN0LGE9aS50YWdLZXlzLHM9aS50YWdWYWx1ZXMsdT1lO0FycmF5LmlzQXJyYXkodSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LmVudHJpZXMmJih1PXUuZW50cmllcygpKSx1PW0odSkpO2Zvcih2YXIgbz0wO288dS5sZW5ndGg7bysrKVwic3RyaW5nXCI9PXR5cGVvZihuPXVbb10pPygtMT09PShyPXMuaW5kZXhPZihuKSkmJihyPWEuaW5kZXhPZihOdW1iZXIobikpKSwtMSE9PXImJnQuYWRkKE51bWJlcihhW3JdKSkpOnQuYWRkKG4pfWVsc2V7dmFyIGY9ZTtBcnJheS5pc0FycmF5KGYpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgZi5lbnRyaWVzJiYoZj1mLmVudHJpZXMoKSksZj1tKGYpKTtmb3IodmFyIGM9MDtjPGYubGVuZ3RoO2MrKyl7dmFyIGg9ZltjXTt0LmFkZChoKX19fX0se2tleTpcImZpbmFsaXplRmlsdGVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7IXRoaXMuZW5hYmxlZCYmdGhpcy5kZXBzLnNpemU+MD8odGhpcy5lbmFibGVkPSEwLENlKHRoaXMucGljayx0aGlzLmRlcHMpKTp0aGlzLmVuYWJsZWQmJnRoaXMucGljay5zaXplPjAmJkNlKHRoaXMucGljayx0aGlzLmRlcHMpfX1dKSxzfShBZSksT2U9e2pmaWY6ITEsdGlmZjohMCx4bXA6ITEsaWNjOiExLGlwdGM6ITEsaWZkMDohMCxpZmQxOiExLGV4aWY6ITAsZ3BzOiEwLGludGVyb3A6ITEsaWhkcjp2b2lkIDAsbWFrZXJOb3RlOiExLHVzZXJDb21tZW50OiExLG11bHRpU2VnbWVudDohMSxza2lwOltdLHBpY2s6W10sdHJhbnNsYXRlS2V5czohMCx0cmFuc2xhdGVWYWx1ZXM6ITAscmV2aXZlVmFsdWVzOiEwLHNhbml0aXplOiEwLG1lcmdlT3V0cHV0OiEwLHNpbGVudEVycm9yczohMCxjaHVua2VkOiEwLGZpcnN0Q2h1bmtTaXplOnZvaWQgMCxmaXJzdENodW5rU2l6ZU5vZGU6NTEyLGZpcnN0Q2h1bmtTaXplQnJvd3Nlcjo2NTUzNixjaHVua1NpemU6NjU1MzYsY2h1bmtMaW1pdDo1fSxTZT1TKCksUGU9ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaShlKXt2YXIgcjtyZXR1cm4gdCh0aGlzLGkpLHI9bi5jYWxsKHRoaXMpLCEwPT09ZT9yLnNldHVwRnJvbVRydWUoKTp2b2lkIDA9PT1lP3Iuc2V0dXBGcm9tVW5kZWZpbmVkKCk6QXJyYXkuaXNBcnJheShlKT9yLnNldHVwRnJvbUFycmF5KGUpOlwib2JqZWN0XCI9PXR5cGVvZiBlP3Iuc2V0dXBGcm9tT2JqZWN0KGUpOkwoXCJJbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQgXCIuY29uY2F0KGUpKSx2b2lkIDA9PT1yLmZpcnN0Q2h1bmtTaXplJiYoci5maXJzdENodW5rU2l6ZT14P3IuZmlyc3RDaHVua1NpemVCcm93c2VyOnIuZmlyc3RDaHVua1NpemVOb2RlKSxyLm1lcmdlT3V0cHV0JiYoci5pZmQxLmVuYWJsZWQ9ITEpLHIuZmlsdGVyTmVzdGVkU2VnbWVudFRhZ3MoKSxyLnRyYXZlcnNlVGlmZkRlcGVuZGVuY3lUcmVlKCksci5jaGVja0xvYWRlZFBsdWdpbnMoKSxyfXJldHVybiByKGksW3trZXk6XCJzZXR1cEZyb21VbmRlZmluZWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQ9ZGU7QXJyYXkuaXNBcnJheSh0KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZW50cmllcyYmKHQ9dC5lbnRyaWVzKCkpLHQ9bSh0KSk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpc1tlPXRbbl1dPU9lW2VdO3ZhciByPWJlO0FycmF5LmlzQXJyYXkocil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmVudHJpZXMmJihyPXIuZW50cmllcygpKSxyPW0ocikpO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXRoaXNbZT1yW2ldXT1PZVtlXTt2YXIgYT1rZTtBcnJheS5pc0FycmF5KGEpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYS5lbnRyaWVzJiYoYT1hLmVudHJpZXMoKSksYT1tKGEpKTtmb3IodmFyIHM9MDtzPGEubGVuZ3RoO3MrKyl0aGlzW2U9YVtzXV09T2VbZV07dmFyIHU9Z2U7QXJyYXkuaXNBcnJheSh1KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHUuZW50cmllcyYmKHU9dS5lbnRyaWVzKCkpLHU9bSh1KSk7Zm9yKHZhciBvPTA7bzx1Lmxlbmd0aDtvKyspdGhpc1tlPXVbb11dPW5ldyB3ZShlLE9lW2VdLHZvaWQgMCx0aGlzKX19LHtrZXk6XCJzZXR1cEZyb21UcnVlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PWRlO0FycmF5LmlzQXJyYXkodCl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmVudHJpZXMmJih0PXQuZW50cmllcygpKSx0PW0odCkpO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXRoaXNbZT10W25dXT1PZVtlXTt2YXIgcj1iZTtBcnJheS5pc0FycmF5KHIpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygci5lbnRyaWVzJiYocj1yLmVudHJpZXMoKSkscj1tKHIpKTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl0aGlzW2U9cltpXV09T2VbZV07dmFyIGE9a2U7QXJyYXkuaXNBcnJheShhKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGEuZW50cmllcyYmKGE9YS5lbnRyaWVzKCkpLGE9bShhKSk7Zm9yKHZhciBzPTA7czxhLmxlbmd0aDtzKyspdGhpc1tlPWFbc11dPSEwO3ZhciB1PWdlO0FycmF5LmlzQXJyYXkodSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LmVudHJpZXMmJih1PXUuZW50cmllcygpKSx1PW0odSkpO2Zvcih2YXIgbz0wO288dS5sZW5ndGg7bysrKXRoaXNbZT11W29dXT1uZXcgd2UoZSwhMCx2b2lkIDAsdGhpcyl9fSx7a2V5Olwic2V0dXBGcm9tQXJyYXlcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdCxuPWRlO0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXRoaXNbdD1uW3JdXT1PZVt0XTt2YXIgaT1iZTtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl0aGlzW3Q9aVthXV09T2VbdF07dmFyIHM9a2U7QXJyYXkuaXNBcnJheShzKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHMuZW50cmllcyYmKHM9cy5lbnRyaWVzKCkpLHM9bShzKSk7Zm9yKHZhciB1PTA7dTxzLmxlbmd0aDt1KyspdGhpc1t0PXNbdV1dPU9lW3RdO3ZhciBvPWdlO0FycmF5LmlzQXJyYXkobyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLmVudHJpZXMmJihvPW8uZW50cmllcygpKSxvPW0obykpO2Zvcih2YXIgZj0wO2Y8by5sZW5ndGg7ZisrKXRoaXNbdD1vW2ZdXT1uZXcgd2UodCwhMSx2b2lkIDAsdGhpcyk7dGhpcy5zZXR1cEdsb2JhbEZpbHRlcnMoZSx2b2lkIDAseWUpfX0se2tleTpcInNldHVwRnJvbU9iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0O3llLmlmZDA9eWUuaWZkMHx8eWUuaW1hZ2UseWUuaWZkMT15ZS5pZmQxfHx5ZS50aHVtYm5haWwsZyh0aGlzLGUpO3ZhciBuPWRlO0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXRoaXNbdD1uW3JdXT14ZShlW3RdLE9lW3RdKTt2YXIgaT1iZTtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl0aGlzW3Q9aVthXV09eGUoZVt0XSxPZVt0XSk7dmFyIHM9a2U7QXJyYXkuaXNBcnJheShzKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHMuZW50cmllcyYmKHM9cy5lbnRyaWVzKCkpLHM9bShzKSk7Zm9yKHZhciB1PTA7dTxzLmxlbmd0aDt1KyspdGhpc1t0PXNbdV1dPXhlKGVbdF0sT2VbdF0pO3ZhciBvPXBlO0FycmF5LmlzQXJyYXkobyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLmVudHJpZXMmJihvPW8uZW50cmllcygpKSxvPW0obykpO2Zvcih2YXIgZj0wO2Y8by5sZW5ndGg7ZisrKXRoaXNbdD1vW2ZdXT1uZXcgd2UodCxPZVt0XSxlW3RdLHRoaXMpO3ZhciBjPXllO0FycmF5LmlzQXJyYXkoYyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBjLmVudHJpZXMmJihjPWMuZW50cmllcygpKSxjPW0oYykpO2Zvcih2YXIgaD0wO2g8Yy5sZW5ndGg7aCsrKXRoaXNbdD1jW2hdXT1uZXcgd2UodCxPZVt0XSxlW3RdLHRoaXMudGlmZik7dGhpcy5zZXR1cEdsb2JhbEZpbHRlcnMoZS5waWNrLGUuc2tpcCx5ZSxnZSksITA9PT1lLnRpZmY/dGhpcy5iYXRjaEVuYWJsZVdpdGhCb29sKHllLCEwKTohMT09PWUudGlmZj90aGlzLmJhdGNoRW5hYmxlV2l0aFVzZXJWYWx1ZSh5ZSxlKTpBcnJheS5pc0FycmF5KGUudGlmZik/dGhpcy5zZXR1cEdsb2JhbEZpbHRlcnMoZS50aWZmLHZvaWQgMCx5ZSk6XCJvYmplY3RcIj09dHlwZW9mIGUudGlmZiYmdGhpcy5zZXR1cEdsb2JhbEZpbHRlcnMoZS50aWZmLnBpY2ssZS50aWZmLnNraXAseWUpfX0se2tleTpcImJhdGNoRW5hYmxlV2l0aEJvb2xcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWU7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3RoaXNbbltyXV0uZW5hYmxlZD10fX19LHtrZXk6XCJiYXRjaEVuYWJsZVdpdGhVc2VyVmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWU7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl0sYT10W2ldO3RoaXNbaV0uZW5hYmxlZD0hMSE9PWEmJnZvaWQgMCE9PWF9fX0se2tleTpcInNldHVwR2xvYmFsRmlsdGVyc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bjtpZihlJiZlLmxlbmd0aCl7dmFyIGk9cjtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl7dmFyIHM9aVthXTt0aGlzW3NdLmVuYWJsZWQ9ITF9dmFyIHU9VWUoZSxuKSxvPXU7QXJyYXkuaXNBcnJheShvKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG8uZW50cmllcyYmKG89by5lbnRyaWVzKCkpLG89bShvKSk7Zm9yKHZhciBmPTA7ZjxvLmxlbmd0aDtmKyspe3ZhciBjPW9bZl0saD1jWzBdLGw9Y1sxXTtDZSh0aGlzW2hdLnBpY2ssbCksdGhpc1toXS5lbmFibGVkPSEwfX1lbHNlIGlmKHQmJnQubGVuZ3RoKXt2YXIgZD1VZSh0LG4pLHY9ZDtBcnJheS5pc0FycmF5KHYpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygdi5lbnRyaWVzJiYodj12LmVudHJpZXMoKSksdj1tKHYpKTtmb3IodmFyIHA9MDtwPHYubGVuZ3RoO3ArKyl7dmFyIHk9dltwXSxnPXlbMF0saz15WzFdO0NlKHRoaXNbZ10uc2tpcCxrKX19fX0se2tleTpcImZpbHRlck5lc3RlZFNlZ21lbnRUYWdzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmlmZDAsdD10aGlzLmV4aWYsbj10aGlzLnhtcCxyPXRoaXMuaXB0YyxpPXRoaXMuaWNjO3RoaXMubWFrZXJOb3RlP3QuZGVwcy5hZGQoc2UpOnQuc2tpcC5hZGQoc2UpLHRoaXMudXNlckNvbW1lbnQ/dC5kZXBzLmFkZCh1ZSk6dC5za2lwLmFkZCh1ZSksbi5lbmFibGVkfHxlLnNraXAuYWRkKDcwMCksci5lbmFibGVkfHxlLnNraXAuYWRkKG9lKSxpLmVuYWJsZWR8fGUuc2tpcC5hZGQoZmUpfX0se2tleTpcInRyYXZlcnNlVGlmZkRlcGVuZGVuY3lUcmVlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9dGhpcy5pZmQwLG49dGhpcy5leGlmLHI9dGhpcy5ncHM7dGhpcy5pbnRlcm9wLm5lZWRlZCYmKG4uZGVwcy5hZGQobGUpLHQuZGVwcy5hZGQobGUpKSxuLm5lZWRlZCYmdC5kZXBzLmFkZChjZSksci5uZWVkZWQmJnQuZGVwcy5hZGQoaGUpLHRoaXMudGlmZi5lbmFibGVkPXllLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiEwPT09ZVt0XS5lbmFibGVkfSkpfHx0aGlzLm1ha2VyTm90ZXx8dGhpcy51c2VyQ29tbWVudDt2YXIgaT15ZTtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl7dGhpc1tpW2FdXS5maW5hbGl6ZUZpbHRlcnMoKX19fSx7a2V5Olwib25seVRpZmZcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiF2ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLmVuYWJsZWR9KSkuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuITA9PT1lfSkpJiZ0aGlzLnRpZmYuZW5hYmxlZH19LHtrZXk6XCJjaGVja0xvYWRlZFBsdWdpbnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXBlO0FycmF5LmlzQXJyYXkoZSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmVudHJpZXMmJihlPWUuZW50cmllcygpKSxlPW0oZSkpO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXt2YXIgbj1lW3RdO3RoaXNbbl0uZW5hYmxlZCYmIVcuaGFzKG4pJiZSKFwic2VnbWVudCBwYXJzZXJcIixuKX19fV0sW3trZXk6XCJ1c2VDYWNoZWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1TZS5nZXQoZSk7cmV0dXJuIHZvaWQgMCE9PXR8fCh0PW5ldyB0aGlzKGUpLFNlLnNldChlLHQpKSx0fX1dKSxpfShBZSk7ZnVuY3Rpb24gVWUoZSx0KXt2YXIgbixyLGksYT1bXSxzPXQ7QXJyYXkuaXNBcnJheShzKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHMuZW50cmllcyYmKHM9cy5lbnRyaWVzKCkpLHM9bShzKSk7Zm9yKHZhciB1PTA7dTxzLmxlbmd0aDt1Kyspe3I9c1t1XSxuPVtdO3ZhciBvPXJlLmdldChyKTtBcnJheS5pc0FycmF5KG8pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygby5lbnRyaWVzJiYobz1vLmVudHJpZXMoKSksbz1tKG8pKTtmb3IodmFyIGY9MDtmPG8ubGVuZ3RoO2YrKylpPW9bZl0sKGUuaW5jbHVkZXMoaVswXSl8fGUuaW5jbHVkZXMoaVsxXSkpJiZuLnB1c2goaVswXSk7bi5sZW5ndGgmJmEucHVzaChbcixuXSl9cmV0dXJuIGF9ZnVuY3Rpb24geGUoZSx0KXtyZXR1cm4gdm9pZCAwIT09ZT9lOnZvaWQgMCE9PXQ/dDp2b2lkIDB9ZnVuY3Rpb24gQ2UoZSx0KXt2YXIgbj10O0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1uW3JdO2UuYWRkKGkpfX1mdW5jdGlvbiBCZShlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX1mdW5jdGlvbiBqZSgpe31mdW5jdGlvbiBfZShlLHQpe2lmKCF0KXJldHVybiBlJiZlLnRoZW4/ZS50aGVuKGplKTpQcm9taXNlLnJlc29sdmUoKX1mdW5jdGlvbiBWZShlLHQpe3ZhciBuPWUoKTtyZXR1cm4gbiYmbi50aGVuP24udGhlbih0KTp0KG4pfWkoUGUsXCJkZWZhdWx0XCIsT2UpO3ZhciBJZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobil7dCh0aGlzLGUpLGkodGhpcyxcInBhcnNlcnNcIix7fSksdGhpcy5vcHRpb25zPVBlLnVzZUNhY2hlZChuKX1yZXR1cm4gcihlLFt7a2V5Olwic2V0dXBcIix2YWx1ZTpmdW5jdGlvbigpe2lmKCF0aGlzLmZpbGVQYXJzZXIpe3ZhciBlPXRoaXMuZmlsZSx0PWUuZ2V0VWludDE2KDApLG49TTtBcnJheS5pc0FycmF5KG4pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygbi5lbnRyaWVzJiYobj1uLmVudHJpZXMoKSksbj1tKG4pKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxhPWlbMF0scz1pWzFdO2lmKHMuY2FuSGFuZGxlKGUsdCkpcmV0dXJuIHRoaXMuZmlsZVBhcnNlcj1uZXcgcyh0aGlzLm9wdGlvbnMsdGhpcy5maWxlLHRoaXMucGFyc2VycyksZVthXT0hMH1MKFwiVW5rbm93biBmaWxlIGZvcm1hdFwiKX19fSx7a2V5OlwicmVhZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RyeXt2YXIgdD10aGlzO3JldHVybiBCZShmdW5jdGlvbihlLHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlPyQoZSx0KTp4JiYhQyYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ/JChlLnNyYyx0KTplIGluc3RhbmNlb2YgVWludDhBcnJheXx8ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxlIGluc3RhbmNlb2YgRGF0YVZpZXc/bmV3IEQoZSk6eCYmZSBpbnN0YW5jZW9mIEJsb2I/UShlLHQsXCJibG9iXCIsWSk6dm9pZCBMKFopfShlLHQub3B0aW9ucyksKGZ1bmN0aW9uKGUpe3QuZmlsZT1lfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicGFyc2VcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2Uuc2V0dXAoKTt2YXIgdD17fSxuPVtdO3JldHVybiBWZSgoZnVuY3Rpb24oKXtyZXR1cm4gZS5vcHRpb25zLnNpbGVudEVycm9ycz9CZShlLmRvUGFyc2UodCxuKS5jYXRjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIG4ucHVzaChlKX0pKSwoZnVuY3Rpb24oKXtuLnB1c2guYXBwbHkobixlLmZpbGVQYXJzZXIuZXJyb3JzKX0pKTpfZShlLmRvUGFyc2UodCxuKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gZS5maWxlLmNsb3NlJiZlLmZpbGUuY2xvc2UoKSxlLm9wdGlvbnMuc2lsZW50RXJyb3JzJiZuLmxlbmd0aD4wJiYodC5lcnJvcnM9biksSShyPXQpP3ZvaWQgMDpyO3ZhciByfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiZG9QYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPXRoaXM7cmV0dXJuIEJlKG4uZmlsZVBhcnNlci5wYXJzZSgpLChmdW5jdGlvbigpe3ZhciByLGk9cChuLnBhcnNlcnMpLm1hcCgocj1mdW5jdGlvbih0KXtyZXR1cm4gQmUodC5wYXJzZSgpLChmdW5jdGlvbihuKXt0LmFzc2lnblRvT3V0cHV0KGUsbil9KSl9LGZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIuYXBwbHkodGhpcyxlKSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0pKTtpZihuLm9wdGlvbnMuc2lsZW50RXJyb3JzKXt2YXIgYT1mdW5jdGlvbihlKXtyZXR1cm4gdC5wdXNoKGUpfTtpPWkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5jYXRjaChhKX0pKX1yZXR1cm4gX2UoUHJvbWlzZS5hbGwoaSkpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiZXh0cmFjdFRodW1ibmFpbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7ZS5zZXR1cCgpO3ZhciB0LG49ZS5vcHRpb25zLHI9ZS5maWxlLGk9Vy5nZXQoXCJ0aWZmXCIsbik7cmV0dXJuIFZlKChmdW5jdGlvbigpe2lmKCFyLnRpZmYpcmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWUoKTtpZih0JiZ0LnRoZW4pcmV0dXJuIHQudGhlbihqZSl9KChmdW5jdGlvbigpe2lmKHIuanBlZylyZXR1cm4gQmUoZS5maWxlUGFyc2VyLmdldE9yRmluZFNlZ21lbnQoXCJ0aWZmXCIpLChmdW5jdGlvbihlKXt0PWV9KSl9KSk7dD17c3RhcnQ6MCx0eXBlOlwidGlmZlwifX0pLChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PXQpcmV0dXJuIEJlKGUuZmlsZVBhcnNlci5lbnN1cmVTZWdtZW50Q2h1bmsodCksKGZ1bmN0aW9uKHQpe3JldHVybiBCZSgoZS5wYXJzZXJzLnRpZmY9bmV3IGkodCxuLHIpKS5leHRyYWN0VGh1bWJuYWlsKCksKGZ1bmN0aW9uKGUpe3JldHVybiByLmNsb3NlJiZyLmNsb3NlKCksZX0pKX0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1dKSxlfSgpO3ZhciBMZSxUZT0oTGU9ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksYT1uZXcgSWUodCk7cmV0dXJuIG49YS5yZWFkKGUpLHI9ZnVuY3Rpb24oKXtyZXR1cm4gYS5wYXJzZSgpfSxpP3I/cihuKTpuOihuJiZuLnRoZW58fChuPVByb21pc2UucmVzb2x2ZShuKSkscj9uLnRoZW4ocik6bil9LGZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKExlLmFwcGx5KHRoaXMsZSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19KSx6ZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxwYXJzZTpUZSxFeGlmcjpJZSxmaWxlUGFyc2VyczpNLHNlZ21lbnRQYXJzZXJzOlcsZmlsZVJlYWRlcnM6Syx0YWdLZXlzOnJlLHRhZ1ZhbHVlczppZSx0YWdSZXZpdmVyczphZSxjcmVhdGVEaWN0aW9uYXJ5OnRlLGV4dGVuZERpY3Rpb25hcnk6bmUsZmV0Y2hVcmxBc0FycmF5QnVmZmVyOkcscmVhZEJsb2JBc0FycmF5QnVmZmVyOlksY2h1bmtlZFByb3BzOmRlLG90aGVyU2VnbWVudHM6dmUsc2VnbWVudHM6cGUsdGlmZkJsb2Nrczp5ZSxzZWdtZW50c0FuZEJsb2NrczpnZSx0aWZmRXh0cmFjdGFibGVzOmtlLGluaGVyaXRhYmxlczptZSxhbGxGb3JtYXR0ZXJzOmJlLE9wdGlvbnM6UGV9KTtmdW5jdGlvbiBGZSgpe312YXIgRWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4scixhKXt2YXIgcz10aGlzO3QodGhpcyxlKSxpKHRoaXMsXCJlcnJvcnNcIixbXSksaSh0aGlzLFwiZW5zdXJlU2VnbWVudENodW5rXCIsZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbl09YXJndW1lbnRzW25dO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuYXBwbHkodGhpcyx0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19KChmdW5jdGlvbihlKXt2YXIgdCxuLHIsaT1lLnN0YXJ0LGE9ZS5zaXplfHw2NTUzNjtyZXR1cm4gdD1mdW5jdGlvbigpe2lmKHMuZmlsZS5jaHVua2VkKXJldHVybiBmdW5jdGlvbihlKXt2YXIgdD1lKCk7aWYodCYmdC50aGVuKXJldHVybiB0LnRoZW4oRmUpfSgoZnVuY3Rpb24oKXtpZighcy5maWxlLmF2YWlsYWJsZShpLGEpKXJldHVybiBmdW5jdGlvbihlKXtpZihlJiZlLnRoZW4pcmV0dXJuIGUudGhlbihGZSl9KGZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPWUoKX1jYXRjaChlKXtyZXR1cm4gdChlKX1yZXR1cm4gbiYmbi50aGVuP24udGhlbih2b2lkIDAsdCk6bn0oKGZ1bmN0aW9uKCl7cmV0dXJuIHQ9cy5maWxlLnJlYWRDaHVuayhpLGEpLG49ZnVuY3Rpb24odCl7ZS5jaHVuaz10fSxyP24/bih0KTp0Oih0JiZ0LnRoZW58fCh0PVByb21pc2UucmVzb2x2ZSh0KSksbj90LnRoZW4obik6dCk7dmFyIHQsbixyfSksKGZ1bmN0aW9uKHQpe0woXCJDb3VsZG4ndCByZWFkIHNlZ21lbnQ6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShlKSxcIi4gXCIpLmNvbmNhdCh0Lm1lc3NhZ2UpKX0pKSk7ZS5jaHVuaz1zLmZpbGUuc3ViYXJyYXkoaSxhKX0pKTtzLmZpbGUuYnl0ZUxlbmd0aD5pK2E/ZS5jaHVuaz1zLmZpbGUuc3ViYXJyYXkoaSxhKTp2b2lkIDA9PT1lLnNpemU/ZS5jaHVuaz1zLmZpbGUuc3ViYXJyYXkoaSk6TChcIlNlZ21lbnQgdW5yZWFjaGFibGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpKX0sbj1mdW5jdGlvbigpe3JldHVybiBlLmNodW5rfSwocj10KCkpJiZyLnRoZW4/ci50aGVuKG4pOm4ocil9KSkpLHRoaXMuZXh0ZW5kT3B0aW9ucyYmdGhpcy5leHRlbmRPcHRpb25zKG4pLHRoaXMub3B0aW9ucz1uLHRoaXMuZmlsZT1yLHRoaXMucGFyc2Vycz1hfXJldHVybiByKGUsW3trZXk6XCJpbmplY3RTZWdtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLm9wdGlvbnNbZV0uZW5hYmxlZCYmdGhpcy5jcmVhdGVQYXJzZXIoZSx0KX19LHtrZXk6XCJjcmVhdGVQYXJzZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPW5ldyhXLmdldChlKSkodCx0aGlzLm9wdGlvbnMsdGhpcy5maWxlKTtyZXR1cm4gdGhpcy5wYXJzZXJzW2VdPW59fSx7a2V5OlwiY3JlYXRlUGFyc2Vyc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWU7QXJyYXkuaXNBcnJheSh0KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZW50cmllcyYmKHQ9dC5lbnRyaWVzKCkpLHQ9bSh0KSk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl0saT1yLnR5cGUsYT1yLmNodW5rLHM9dGhpcy5vcHRpb25zW2ldO2lmKHMmJnMuZW5hYmxlZCl7dmFyIHU9dGhpcy5wYXJzZXJzW2ldO3UmJnUuYXBwZW5kfHx1fHx0aGlzLmNyZWF0ZVBhcnNlcihpLGEpfX19fSx7a2V5OlwicmVhZFNlZ21lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PWUubWFwKHRoaXMuZW5zdXJlU2VnbWVudENodW5rKTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZighdClyZXR1cm4gZSYmZS50aGVuP2UudGhlbihGZSk6UHJvbWlzZS5yZXNvbHZlKCl9KFByb21pc2UuYWxsKHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1dKSxlfSgpLERlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShuKXt2YXIgcj10aGlzLGE9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LHM9YXJndW1lbnRzLmxlbmd0aD4yP2FyZ3VtZW50c1syXTp2b2lkIDA7dCh0aGlzLGUpLGkodGhpcyxcImVycm9yc1wiLFtdKSxpKHRoaXMsXCJyYXdcIixTKCkpLGkodGhpcyxcImhhbmRsZUVycm9yXCIsKGZ1bmN0aW9uKGUpe2lmKCFyLm9wdGlvbnMuc2lsZW50RXJyb3JzKXRocm93IGU7ci5lcnJvcnMucHVzaChlLm1lc3NhZ2UpfSkpLHRoaXMuY2h1bms9dGhpcy5ub3JtYWxpemVJbnB1dChuKSx0aGlzLmZpbGU9cyx0aGlzLnR5cGU9dGhpcy5jb25zdHJ1Y3Rvci50eXBlLHRoaXMuZ2xvYmFsT3B0aW9ucz10aGlzLm9wdGlvbnM9YSx0aGlzLmxvY2FsT3B0aW9ucz1hW3RoaXMudHlwZV0sdGhpcy5jYW5UcmFuc2xhdGU9dGhpcy5sb2NhbE9wdGlvbnMmJnRoaXMubG9jYWxPcHRpb25zLnRyYW5zbGF0ZX1yZXR1cm4gcihlLFt7a2V5Olwibm9ybWFsaXplSW5wdXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEQ/ZTpuZXcgRChlKX19LHtrZXk6XCJ0cmFuc2xhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2FuVHJhbnNsYXRlJiYodGhpcy50cmFuc2xhdGVkPXRoaXMudHJhbnNsYXRlQmxvY2sodGhpcy5yYXcsdGhpcy50eXBlKSl9fSx7a2V5Olwib3V0cHV0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlZD90aGlzLnRyYW5zbGF0ZWQ6dGhpcy5yYXc/ayh0aGlzLnJhdyk6dm9pZCAwfX0se2tleTpcInRyYW5zbGF0ZUJsb2NrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hZS5nZXQodCkscj1pZS5nZXQodCksaT1yZS5nZXQodCksYT10aGlzLm9wdGlvbnNbdF0scz1hLnJldml2ZVZhbHVlcyYmISFuLHU9YS50cmFuc2xhdGVWYWx1ZXMmJiEhcixvPWEudHJhbnNsYXRlS2V5cyYmISFpLGY9e30sYz1lO0FycmF5LmlzQXJyYXkoYyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBjLmVudHJpZXMmJihjPWMuZW50cmllcygpKSxjPW0oYykpO2Zvcih2YXIgaD0wO2g8Yy5sZW5ndGg7aCsrKXt2YXIgbD1jW2hdLGQ9bFswXSx2PWxbMV07cyYmbi5oYXMoZCk/dj1uLmdldChkKSh2KTp1JiZyLmhhcyhkKSYmKHY9dGhpcy50cmFuc2xhdGVWYWx1ZSh2LHIuZ2V0KGQpKSksbyYmaS5oYXMoZCkmJihkPWkuZ2V0KGQpfHxkKSxmW2RdPXZ9cmV0dXJuIGZ9fSx7a2V5OlwidHJhbnNsYXRlVmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0W2VdfHx0LkRFRkFVTFR8fGV9fSx7a2V5OlwiYXNzaWduVG9PdXRwdXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuYXNzaWduT2JqZWN0VG9PdXRwdXQoZSx0aGlzLmNvbnN0cnVjdG9yLnR5cGUsdCl9fSx7a2V5OlwiYXNzaWduT2JqZWN0VG9PdXRwdXRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYodGhpcy5nbG9iYWxPcHRpb25zLm1lcmdlT3V0cHV0KXJldHVybiBnKGUsbik7ZVt0XT9nKGVbdF0sbik6ZVt0XT1ufX1dLFt7a2V5OlwiZmluZFBvc2l0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmdldFVpbnQxNih0KzIpKzIscj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmhlYWRlckxlbmd0aD90aGlzLmhlYWRlckxlbmd0aChlLHQsbik6dGhpcy5oZWFkZXJMZW5ndGgsaT10K3IsYT1uLXI7cmV0dXJue29mZnNldDp0LGxlbmd0aDpuLGhlYWRlckxlbmd0aDpyLHN0YXJ0Omksc2l6ZTphLGVuZDppK2F9fX0se2tleTpcInBhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49bmV3IFBlKGkoe30sdGhpcy50eXBlLHQpKSxyPW5ldyB0aGlzKGUsbik7cmV0dXJuIHIucGFyc2UoKX19XSksZX0oKTtmdW5jdGlvbiBSZShlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX1pKERlLFwiaGVhZGVyTGVuZ3RoXCIsNCksaShEZSxcInR5cGVcIix2b2lkIDApLGkoRGUsXCJtdWx0aVNlZ21lbnRcIiwhMSksaShEZSxcImNhbkhhbmRsZVwiLChmdW5jdGlvbigpe3JldHVybiExfSkpO2Z1bmN0aW9uIE5lKCl7fWZ1bmN0aW9uIE1lKGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oTmUpOlByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIFdlKGUpe3ZhciB0PWUoKTtpZih0JiZ0LnRoZW4pcmV0dXJuIHQudGhlbihOZSl9ZnVuY3Rpb24gS2UoZSx0KXt2YXIgbj1lKCk7cmV0dXJuIG4mJm4udGhlbj9uLnRoZW4odCk6dChuKX1mdW5jdGlvbiBIZShlLHQsbil7aWYoIWUucyl7aWYobiBpbnN0YW5jZW9mIFhlKXtpZighbi5zKXJldHVybiB2b2lkKG4ubz1IZS5iaW5kKG51bGwsZSx0KSk7MSZ0JiYodD1uLnMpLG49bi52fWlmKG4mJm4udGhlbilyZXR1cm4gdm9pZCBuLnRoZW4oSGUuYmluZChudWxsLGUsdCksSGUuYmluZChudWxsLGUsMikpO2Uucz10LGUudj1uO3ZhciByPWUubztyJiZyKGUpfX12YXIgWGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKHQsbil7dmFyIHI9bmV3IGUsaT10aGlzLnM7aWYoaSl7dmFyIGE9MSZpP3Q6bjtpZihhKXt0cnl7SGUociwxLGEodGhpcy52KSl9Y2F0Y2goZSl7SGUociwyLGUpfXJldHVybiByfXJldHVybiB0aGlzfXJldHVybiB0aGlzLm89ZnVuY3Rpb24oZSl7dHJ5e3ZhciBpPWUudjsxJmUucz9IZShyLDEsdD90KGkpOmkpOm4/SGUociwxLG4oaSkpOkhlKHIsMixpKX1jYXRjaChlKXtIZShyLDIsZSl9fSxyfSxlfSgpO2Z1bmN0aW9uIFllKGUpe3JldHVybiBlIGluc3RhbmNlb2YgWGUmJjEmZS5zfWZ1bmN0aW9uIEdlKGUsdCxuKXtmb3IodmFyIHI7Oyl7dmFyIGk9ZSgpO2lmKFllKGkpJiYoaT1pLnYpLCFpKXJldHVybiBhO2lmKGkudGhlbil7cj0wO2JyZWFrfXZhciBhPW4oKTtpZihhJiZhLnRoZW4pe2lmKCFZZShhKSl7cj0xO2JyZWFrfWE9YS5zfWlmKHQpe3ZhciBzPXQoKTtpZihzJiZzLnRoZW4mJiFZZShzKSl7cj0yO2JyZWFrfX19dmFyIHU9bmV3IFhlLG89SGUuYmluZChudWxsLHUsMik7cmV0dXJuKDA9PT1yP2kudGhlbihjKToxPT09cj9hLnRoZW4oZik6cy50aGVuKGgpKS50aGVuKHZvaWQgMCxvKSx1O2Z1bmN0aW9uIGYocil7YT1yO2Rve2lmKHQmJihzPXQoKSkmJnMudGhlbiYmIVllKHMpKXJldHVybiB2b2lkIHMudGhlbihoKS50aGVuKHZvaWQgMCxvKTtpZighKGk9ZSgpKXx8WWUoaSkmJiFpLnYpcmV0dXJuIHZvaWQgSGUodSwxLGEpO2lmKGkudGhlbilyZXR1cm4gdm9pZCBpLnRoZW4oYykudGhlbih2b2lkIDAsbyk7WWUoYT1uKCkpJiYoYT1hLnYpfXdoaWxlKCFhfHwhYS50aGVuKTthLnRoZW4oZikudGhlbih2b2lkIDAsbyl9ZnVuY3Rpb24gYyhlKXtlPyhhPW4oKSkmJmEudGhlbj9hLnRoZW4oZikudGhlbih2b2lkIDAsbyk6ZihhKTpIZSh1LDEsYSl9ZnVuY3Rpb24gaCgpeyhpPWUoKSk/aS50aGVuP2kudGhlbihjKS50aGVuKHZvaWQgMCxvKTpjKGkpOkhlKHUsMSxhKX19ZnVuY3Rpb24gSmUoZSl7cmV0dXJuIDE5Mj09PWV8fDE5ND09PWV8fDE5Nj09PWV8fDIxOT09PWV8fDIyMT09PWV8fDIxOD09PWV8fDI1ND09PWV9ZnVuY3Rpb24gcWUoZSl7cmV0dXJuIGU+PTIyNCYmZTw9MjM5fWZ1bmN0aW9uIFFlKGUsdCxuKXt2YXIgcj1XO0FycmF5LmlzQXJyYXkocil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmVudHJpZXMmJihyPXIuZW50cmllcygpKSxyPW0ocikpO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgYT1yW2ldLHM9YVswXTtpZihhWzFdLmNhbkhhbmRsZShlLHQsbikpcmV0dXJuIHN9fXZhciBaZT1mdW5jdGlvbihlKXthKHMsZSk7dmFyIG49ZChzKTtmdW5jdGlvbiBzKCl7dmFyIGU7dCh0aGlzLHMpO2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLGE9bmV3IEFycmF5KHIpLHU9MDt1PHI7dSsrKWFbdV09YXJndW1lbnRzW3VdO3JldHVybiBpKGgoZT1uLmNhbGwuYXBwbHkobixbdGhpc10uY29uY2F0KGEpKSksXCJhcHBTZWdtZW50c1wiLFtdKSxpKGgoZSksXCJqcGVnU2VnbWVudHNcIixbXSksaShoKGUpLFwidW5rbm93blNlZ21lbnRzXCIsW10pLGV9cmV0dXJuIHIocyxbe2tleTpcInBhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztyZXR1cm4gUmUoZS5maW5kQXBwU2VnbWVudHMoKSwoZnVuY3Rpb24oKXtyZXR1cm4gUmUoZS5yZWFkU2VnbWVudHMoZS5hcHBTZWdtZW50cyksKGZ1bmN0aW9uKCl7ZS5tZXJnZU11bHRpU2VnbWVudHMoKSxlLmNyZWF0ZVBhcnNlcnMoZS5tZXJnZWRBcHBTZWdtZW50c3x8ZS5hcHBTZWdtZW50cyl9KSl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJzZXR1cFNlZ21lbnRGaW5kZXJBcmdzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczshMD09PWU/KHRoaXMuZmluZEFsbD0hMCx0aGlzLndhbnRlZD1PKFcua2V5TGlzdCgpKSk6KGU9dm9pZCAwPT09ZT9XLmtleUxpc3QoKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiB0Lm9wdGlvbnNbZV0uZW5hYmxlZH0pKTplLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIHQub3B0aW9uc1tlXS5lbmFibGVkJiZXLmhhcyhlKX0pKSx0aGlzLmZpbmRBbGw9ITEsdGhpcy5yZW1haW5pbmc9TyhlKSx0aGlzLndhbnRlZD1PKGUpKSx0aGlzLnVuZmluaXNoZWRNdWx0aVNlZ21lbnQ9ITF9fSx7a2V5OlwiZmluZEFwcFNlZ21lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCx0PWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwO3RyeXt2YXIgbj10aGlzO24uc2V0dXBTZWdtZW50RmluZGVyQXJncyh0KTt2YXIgcj1uLmZpbGUsaT1uLmZpbmRBbGwsYT1uLndhbnRlZCxzPW4ucmVtYWluaW5nO3JldHVybiBLZSgoZnVuY3Rpb24oKXtpZighaSYmbi5maWxlLmNodW5rZWQpcmV0dXJuIGk9bShhKS5zb21lKChmdW5jdGlvbihlKXt2YXIgdD1XLmdldChlKSxyPW4ub3B0aW9uc1tlXTtyZXR1cm4gdC5tdWx0aVNlZ21lbnQmJnIubXVsdGlTZWdtZW50fSkpLFdlKChmdW5jdGlvbigpe2lmKGkpcmV0dXJuIE1lKG4uZmlsZS5yZWFkV2hvbGUoKSl9KSl9KSwoZnVuY3Rpb24oKXt2YXIgdD0hMTtpZihlPW4uZmluZEFwcFNlZ21lbnRzSW5SYW5nZShlLHIuYnl0ZUxlbmd0aCksIW4ub3B0aW9ucy5vbmx5VGlmZilyZXR1cm4gZnVuY3Rpb24oKXtpZihyLmNodW5rZWQpe3ZhciBpPSExO3JldHVybiBHZSgoZnVuY3Rpb24oKXtyZXR1cm4hdCYmcy5zaXplPjAmJiFpJiYoISFyLmNhblJlYWROZXh0Q2h1bmt8fCEhbi51bmZpbmlzaGVkTXVsdGlTZWdtZW50KX0pLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgYT1yLm5leHRDaHVua09mZnNldCxzPW4uYXBwU2VnbWVudHMuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIW4uZmlsZS5hdmFpbGFibGUoZS5vZmZzZXR8fGUuc3RhcnQsZS5sZW5ndGh8fGUuc2l6ZSl9KSk7cmV0dXJuIEtlKChmdW5jdGlvbigpe3JldHVybiBlPmEmJiFzP1JlKHIucmVhZE5leHRDaHVuayhlKSwoZnVuY3Rpb24oZSl7aT0hZX0pKTpSZShyLnJlYWROZXh0Q2h1bmsoYSksKGZ1bmN0aW9uKGUpe2k9IWV9KSl9KSwoZnVuY3Rpb24oKXt2b2lkIDA9PT0oZT1uLmZpbmRBcHBTZWdtZW50c0luUmFuZ2UoZSxyLmJ5dGVMZW5ndGgpKSYmKHQ9ITApfSkpfSkpfX0oKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcImZpbmRBcHBTZWdtZW50c0luUmFuZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3QtPTI7Zm9yKHZhciBuLHIsaSxhLHMsdSxvPXRoaXMuZmlsZSxmPXRoaXMuZmluZEFsbCxjPXRoaXMud2FudGVkLGg9dGhpcy5yZW1haW5pbmcsbD10aGlzLm9wdGlvbnM7ZTx0O2UrKylpZigyNTU9PT1vLmdldFVpbnQ4KGUpKWlmKHFlKG49by5nZXRVaW50OChlKzEpKSl7aWYocj1vLmdldFVpbnQxNihlKzIpLChpPVFlKG8sZSxyKSkmJmMuaGFzKGkpJiYocz0oYT1XLmdldChpKSkuZmluZFBvc2l0aW9uKG8sZSksdT1sW2ldLHMudHlwZT1pLHRoaXMuYXBwU2VnbWVudHMucHVzaChzKSwhZiYmKGEubXVsdGlTZWdtZW50JiZ1Lm11bHRpU2VnbWVudD8odGhpcy51bmZpbmlzaGVkTXVsdGlTZWdtZW50PXMuY2h1bmtOdW1iZXI8cy5jaHVua0NvdW50LHRoaXMudW5maW5pc2hlZE11bHRpU2VnbWVudHx8aC5kZWxldGUoaSkpOmguZGVsZXRlKGkpLDA9PT1oLnNpemUpKSlicmVhaztsLnJlY29yZFVua25vd25TZWdtZW50cyYmKChzPURlLmZpbmRQb3NpdGlvbihvLGUpKS5tYXJrZXI9bix0aGlzLnVua25vd25TZWdtZW50cy5wdXNoKHMpKSxlKz1yKzF9ZWxzZSBpZihKZShuKSl7aWYocj1vLmdldFVpbnQxNihlKzIpLDIxOD09PW4mJiExIT09bC5zdG9wQWZ0ZXJTb3MpcmV0dXJuO2wucmVjb3JkSnBlZ1NlZ21lbnRzJiZ0aGlzLmpwZWdTZWdtZW50cy5wdXNoKHtvZmZzZXQ6ZSxsZW5ndGg6cixtYXJrZXI6bn0pLGUrPXIrMX1yZXR1cm4gZX19LHtrZXk6XCJtZXJnZU11bHRpU2VnbWVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYodGhpcy5hcHBTZWdtZW50cy5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gZS5tdWx0aVNlZ21lbnR9KSkpe3ZhciB0PWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuLHIsaSxhPVMoKSxzPTA7czxlLmxlbmd0aDtzKyspcj0obj1lW3NdKVt0XSxhLmhhcyhyKT9pPWEuZ2V0KHIpOmEuc2V0KHIsaT1bXSksaS5wdXNoKG4pO3JldHVybiBtKGEpfSh0aGlzLmFwcFNlZ21lbnRzLFwidHlwZVwiKTt0aGlzLm1lcmdlZEFwcFNlZ21lbnRzPXQubWFwKChmdW5jdGlvbih0KXt2YXIgbj10WzBdLHI9dFsxXSxpPVcuZ2V0KG4sZS5vcHRpb25zKTtyZXR1cm4gaS5oYW5kbGVNdWx0aVNlZ21lbnRzP3t0eXBlOm4sY2h1bms6aS5oYW5kbGVNdWx0aVNlZ21lbnRzKHIpfTpyWzBdfSkpfX19LHtrZXk6XCJnZXRTZWdtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXBwU2VnbWVudHMuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZT09PWV9KSl9fSx7a2V5OlwiZ2V0T3JGaW5kU2VnbWVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RyeXt2YXIgdD10aGlzLG49dC5nZXRTZWdtZW50KGUpO3JldHVybiBLZSgoZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1uKXJldHVybiBSZSh0LmZpbmRBcHBTZWdtZW50cygwLFtlXSksKGZ1bmN0aW9uKCl7bj10LmdldFNlZ21lbnQoZSl9KSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gbn0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1dLFt7a2V5OlwiY2FuSGFuZGxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gNjU0OTY9PT10fX1dKSxzfShFZSk7ZnVuY3Rpb24gJGUoKXt9aShaZSxcInR5cGVcIixcImpwZWdcIiksTS5zZXQoXCJqcGVnXCIsWmUpO2Z1bmN0aW9uIGV0KGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oJGUpOlByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIHR0KGUsdCl7dmFyIG49ZSgpO3JldHVybiBuJiZuLnRoZW4/bi50aGVuKHQpOnQobil9dmFyIG50PVt2b2lkIDAsMSwxLDIsNCw4LDEsMSwyLDQsOCw0LDgsNF07dmFyIHJ0PWZ1bmN0aW9uKGUpe2EoaSxlKTt2YXIgbj1kKGkpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gdCh0aGlzLGkpLG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiByKGksW3trZXk6XCJwYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7ZS5wYXJzZUhlYWRlcigpO3ZhciB0PWUub3B0aW9ucztyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5pZmQwLmVuYWJsZWQpcmV0dXJuIGV0KGUucGFyc2VJZmQwQmxvY2soKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5leGlmLmVuYWJsZWQpcmV0dXJuIGV0KGUuc2FmZVBhcnNlKFwicGFyc2VFeGlmQmxvY2tcIikpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKHQuZ3BzLmVuYWJsZWQpcmV0dXJuIGV0KGUuc2FmZVBhcnNlKFwicGFyc2VHcHNCbG9ja1wiKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5pbnRlcm9wLmVuYWJsZWQpcmV0dXJuIGV0KGUuc2FmZVBhcnNlKFwicGFyc2VJbnRlcm9wQmxvY2tcIikpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKHQuaWZkMS5lbmFibGVkKXJldHVybiBldChlLnNhZmVQYXJzZShcInBhcnNlVGh1bWJuYWlsQmxvY2tcIikpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIGUuY3JlYXRlT3V0cHV0KCl9KSl9KSl9KSl9KSl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJzYWZlUGFyc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzW2VdKCk7cmV0dXJuIHZvaWQgMCE9PXQuY2F0Y2gmJih0PXQuY2F0Y2godGhpcy5oYW5kbGVFcnJvcikpLHR9fSx7a2V5OlwiZmluZElmZDBPZmZzZXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZvaWQgMD09PXRoaXMuaWZkME9mZnNldCYmKHRoaXMuaWZkME9mZnNldD10aGlzLmNodW5rLmdldFVpbnQzMig0KSl9fSx7a2V5OlwiZmluZElmZDFPZmZzZXRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHZvaWQgMD09PXRoaXMuaWZkMU9mZnNldCl7dGhpcy5maW5kSWZkME9mZnNldCgpO3ZhciBlPXRoaXMuY2h1bmsuZ2V0VWludDE2KHRoaXMuaWZkME9mZnNldCksdD10aGlzLmlmZDBPZmZzZXQrMisxMiplO3RoaXMuaWZkMU9mZnNldD10aGlzLmNodW5rLmdldFVpbnQzMih0KX19fSx7a2V5OlwicGFyc2VCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49UygpO3JldHVybiB0aGlzW3RdPW4sdGhpcy5wYXJzZVRhZ3MoZSx0LG4pLG59fSx7a2V5OlwicGFyc2VJZmQwQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2lmKGUuaWZkMClyZXR1cm47dmFyIHQ9ZS5maWxlO3JldHVybiBlLmZpbmRJZmQwT2Zmc2V0KCksZS5pZmQwT2Zmc2V0PDgmJkwoXCJNYWxmb3JtZWQgRVhJRiBkYXRhXCIpLCF0LmNodW5rZWQmJmUuaWZkME9mZnNldD50LmJ5dGVMZW5ndGgmJkwoXCJJRkQwIG9mZnNldCBwb2ludHMgdG8gb3V0c2lkZSBvZiBmaWxlLlxcbnRoaXMuaWZkME9mZnNldDogXCIuY29uY2F0KGUuaWZkME9mZnNldCxcIiwgZmlsZS5ieXRlTGVuZ3RoOiBcIikuY29uY2F0KHQuYnl0ZUxlbmd0aCkpLHR0KChmdW5jdGlvbigpe2lmKHQudGlmZilyZXR1cm4gZXQodC5lbnN1cmVDaHVuayhlLmlmZDBPZmZzZXQsVChlLm9wdGlvbnMpKSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1lLnBhcnNlQmxvY2soZS5pZmQwT2Zmc2V0LFwiaWZkMFwiKTtpZigwIT09dC5zaXplKXJldHVybiBlLmV4aWZPZmZzZXQ9dC5nZXQoY2UpLGUuaW50ZXJvcE9mZnNldD10LmdldChsZSksZS5ncHNPZmZzZXQ9dC5nZXQoaGUpLGUueG1wPXQuZ2V0KDcwMCksZS5pcHRjPXQuZ2V0KG9lKSxlLmljYz10LmdldChmZSksZS5vcHRpb25zLnNhbml0aXplJiYodC5kZWxldGUoY2UpLHQuZGVsZXRlKGxlKSx0LmRlbGV0ZShoZSksdC5kZWxldGUoNzAwKSx0LmRlbGV0ZShvZSksdC5kZWxldGUoZmUpKSx0fSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicGFyc2VFeGlmQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2lmKGUuZXhpZilyZXR1cm47cmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKCFlLmlmZDApcmV0dXJuIGV0KGUucGFyc2VJZmQwQmxvY2soKSl9KSwoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1lLmV4aWZPZmZzZXQpcmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKGUuZmlsZS50aWZmKXJldHVybiBldChlLmZpbGUuZW5zdXJlQ2h1bmsoZS5leGlmT2Zmc2V0LFQoZS5vcHRpb25zKSkpfSksKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5wYXJzZUJsb2NrKGUuZXhpZk9mZnNldCxcImV4aWZcIik7cmV0dXJuIGUuaW50ZXJvcE9mZnNldHx8KGUuaW50ZXJvcE9mZnNldD10LmdldChsZSkpLGUubWFrZXJOb3RlPXQuZ2V0KHNlKSxlLnVzZXJDb21tZW50PXQuZ2V0KHVlKSxlLm9wdGlvbnMuc2FuaXRpemUmJih0LmRlbGV0ZShsZSksdC5kZWxldGUoc2UpLHQuZGVsZXRlKHVlKSksZS51bnBhY2sodCw0MTcyOCksZS51bnBhY2sodCw0MTcyOSksdH0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInVucGFja1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5nZXQodCk7biYmMT09PW4ubGVuZ3RoJiZlLnNldCh0LG5bMF0pfX0se2tleTpcInBhcnNlR3BzQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2lmKGUuZ3BzKXJldHVybjtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYoIWUuaWZkMClyZXR1cm4gZXQoZS5wYXJzZUlmZDBCbG9jaygpKX0pLChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWUuZ3BzT2Zmc2V0KXt2YXIgdD1lLnBhcnNlQmxvY2soZS5ncHNPZmZzZXQsXCJncHNcIik7cmV0dXJuIHQmJnQuaGFzKDIpJiZ0Lmhhcyg0KSYmKHQuc2V0KFwibGF0aXR1ZGVcIixpdC5hcHBseSh2b2lkIDAsdC5nZXQoMikuY29uY2F0KFt0LmdldCgxKV0pKSksdC5zZXQoXCJsb25naXR1ZGVcIixpdC5hcHBseSh2b2lkIDAsdC5nZXQoNCkuY29uY2F0KFt0LmdldCgzKV0pKSkpLHR9fSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicGFyc2VJbnRlcm9wQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO2lmKGUuaW50ZXJvcClyZXR1cm47cmV0dXJuIHR0KChmdW5jdGlvbigpe2lmKCFlLmlmZDApcmV0dXJuIGV0KGUucGFyc2VJZmQwQmxvY2soKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodm9pZCAwPT09ZS5pbnRlcm9wT2Zmc2V0JiYhZS5leGlmKXJldHVybiBldChlLnBhcnNlRXhpZkJsb2NrKCkpfSksKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09ZS5pbnRlcm9wT2Zmc2V0KXJldHVybiBlLnBhcnNlQmxvY2soZS5pbnRlcm9wT2Zmc2V0LFwiaW50ZXJvcFwiKX0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInBhcnNlVGh1bWJuYWlsQmxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07dHJ5e3ZhciB0PXRoaXM7aWYodC5pZmQxfHx0LmlmZDFQYXJzZWQpcmV0dXJuO2lmKHQub3B0aW9ucy5tZXJnZU91dHB1dCYmIWUpcmV0dXJuO3JldHVybiB0LmZpbmRJZmQxT2Zmc2V0KCksdC5pZmQxT2Zmc2V0PjAmJih0LnBhcnNlQmxvY2sodC5pZmQxT2Zmc2V0LFwiaWZkMVwiKSx0LmlmZDFQYXJzZWQ9ITApLHQuaWZkMX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcImV4dHJhY3RUaHVtYm5haWxcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO3JldHVybiBlLmhlYWRlclBhcnNlZHx8ZS5wYXJzZUhlYWRlcigpLHR0KChmdW5jdGlvbigpe2lmKCFlLmlmZDFQYXJzZWQpcmV0dXJuIGV0KGUucGFyc2VUaHVtYm5haWxCbG9jayghMCkpfSksKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09ZS5pZmQxKXt2YXIgdD1lLmlmZDEuZ2V0KDUxMyksbj1lLmlmZDEuZ2V0KDUxNCk7cmV0dXJuIGUuY2h1bmsuZ2V0VWludDhBcnJheSh0LG4pfX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcImltYWdlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWZkMH19LHtrZXk6XCJ0aHVtYm5haWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZmQxfX0se2tleTpcImNyZWF0ZU91dHB1dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdCxuLHI9e30saT15ZTtBcnJheS5pc0FycmF5KGkpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgaS5lbnRyaWVzJiYoaT1pLmVudHJpZXMoKSksaT1tKGkpKTtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKylpZighSShlPXRoaXNbdD1pW2FdXSkpaWYobj10aGlzLmNhblRyYW5zbGF0ZT90aGlzLnRyYW5zbGF0ZUJsb2NrKGUsdCk6ayhlKSx0aGlzLm9wdGlvbnMubWVyZ2VPdXRwdXQpe2lmKFwiaWZkMVwiPT09dCljb250aW51ZTtnKHIsbil9ZWxzZSByW3RdPW47cmV0dXJuIHRoaXMubWFrZXJOb3RlJiYoci5tYWtlck5vdGU9dGhpcy5tYWtlck5vdGUpLHRoaXMudXNlckNvbW1lbnQmJihyLnVzZXJDb21tZW50PXRoaXMudXNlckNvbW1lbnQpLHJ9fSx7a2V5OlwiYXNzaWduVG9PdXRwdXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKHRoaXMuZ2xvYmFsT3B0aW9ucy5tZXJnZU91dHB1dClnKGUsdCk7ZWxzZXt2YXIgbj15KHQpO0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1uW3JdLGE9aVswXSxzPWlbMV07dGhpcy5hc3NpZ25PYmplY3RUb091dHB1dChlLGEscyl9fX19XSxbe2tleTpcImNhbkhhbmRsZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIDIyNT09PWUuZ2V0VWludDgodCsxKSYmMTE2NTUxOTIwNj09PWUuZ2V0VWludDMyKHQrNCkmJjA9PT1lLmdldFVpbnQxNih0KzgpfX1dKSxpfShmdW5jdGlvbihlKXthKGksZSk7dmFyIG49ZChpKTtmdW5jdGlvbiBpKCl7cmV0dXJuIHQodGhpcyxpKSxuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gcihpLFt7a2V5OlwicGFyc2VIZWFkZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuY2h1bmsuZ2V0VWludDE2KCk7MTg3NjE9PT1lP3RoaXMubGU9ITA6MTk3ODk9PT1lJiYodGhpcy5sZT0hMSksdGhpcy5jaHVuay5sZT10aGlzLmxlLHRoaXMuaGVhZGVyUGFyc2VkPSEwfX0se2tleTpcInBhcnNlVGFnc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOlMoKSxyPXRoaXMub3B0aW9uc1t0XSxpPXIucGljayxhPXIuc2tpcCxzPShpPU8oaSkpLnNpemU+MCx1PTA9PT1hLnNpemUsbz10aGlzLmNodW5rLmdldFVpbnQxNihlKTtlKz0yO2Zvcih2YXIgZj0wO2Y8bztmKyspe3ZhciBjPXRoaXMuY2h1bmsuZ2V0VWludDE2KGUpO2lmKHMpe2lmKGkuaGFzKGMpJiYobi5zZXQoYyx0aGlzLnBhcnNlVGFnKGUsYyx0KSksaS5kZWxldGUoYyksMD09PWkuc2l6ZSkpYnJlYWt9ZWxzZSF1JiZhLmhhcyhjKXx8bi5zZXQoYyx0aGlzLnBhcnNlVGFnKGUsYyx0KSk7ZSs9MTJ9cmV0dXJuIG59fSx7a2V5OlwicGFyc2VUYWdcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT10aGlzLmNodW5rLGE9aS5nZXRVaW50MTYoZSsyKSxzPWkuZ2V0VWludDMyKGUrNCksdT1udFthXTtpZih1KnM8PTQ/ZSs9ODplPWkuZ2V0VWludDMyKGUrOCksKGE8MXx8YT4xMykmJkwoXCJJbnZhbGlkIFRJRkYgdmFsdWUgdHlwZS4gYmxvY2s6IFwiLmNvbmNhdChuLnRvVXBwZXJDYXNlKCksXCIsIHRhZzogXCIpLmNvbmNhdCh0LnRvU3RyaW5nKDE2KSxcIiwgdHlwZTogXCIpLmNvbmNhdChhLFwiLCBvZmZzZXQgXCIpLmNvbmNhdChlKSksZT5pLmJ5dGVMZW5ndGgmJkwoXCJJbnZhbGlkIFRJRkYgdmFsdWUgb2Zmc2V0LiBibG9jazogXCIuY29uY2F0KG4udG9VcHBlckNhc2UoKSxcIiwgdGFnOiBcIikuY29uY2F0KHQudG9TdHJpbmcoMTYpLFwiLCB0eXBlOiBcIikuY29uY2F0KGEsXCIsIG9mZnNldCBcIikuY29uY2F0KGUsXCIgaXMgb3V0c2lkZSBvZiBjaHVuayBzaXplIFwiKS5jb25jYXQoaS5ieXRlTGVuZ3RoKSksMT09PWEpcmV0dXJuIGkuZ2V0VWludDhBcnJheShlLHMpO2lmKDI9PT1hKXJldHVyblwiXCI9PT0ocj1mdW5jdGlvbihlKXtmb3IoO2UuZW5kc1dpdGgoXCJcXDBcIik7KWU9ZS5zbGljZSgwLC0xKTtyZXR1cm4gZX0ocj1pLmdldFN0cmluZyhlLHMpKS50cmltKCkpP3ZvaWQgMDpyO2lmKDc9PT1hKXJldHVybiBpLmdldFVpbnQ4QXJyYXkoZSxzKTtpZigxPT09cylyZXR1cm4gdGhpcy5wYXJzZVRhZ1ZhbHVlKGEsZSk7Zm9yKHZhciBvPW5ldyhmdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiBVaW50OEFycmF5O2Nhc2UgMzpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZSA0OnJldHVybiBVaW50MzJBcnJheTtjYXNlIDU6cmV0dXJuIEFycmF5O2Nhc2UgNjpyZXR1cm4gSW50OEFycmF5O2Nhc2UgODpyZXR1cm4gSW50MTZBcnJheTtjYXNlIDk6cmV0dXJuIEludDMyQXJyYXk7Y2FzZSAxMDpyZXR1cm4gQXJyYXk7Y2FzZSAxMTpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2UgMTI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnJldHVybiBBcnJheX19KGEpKShzKSxmPXUsYz0wO2M8cztjKyspb1tjXT10aGlzLnBhcnNlVGFnVmFsdWUoYSxlKSxlKz1mO3JldHVybiBvfX0se2tleTpcInBhcnNlVGFnVmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuY2h1bms7c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm4gbi5nZXRVaW50OCh0KTtjYXNlIDM6cmV0dXJuIG4uZ2V0VWludDE2KHQpO2Nhc2UgNDpyZXR1cm4gbi5nZXRVaW50MzIodCk7Y2FzZSA1OnJldHVybiBuLmdldFVpbnQzMih0KS9uLmdldFVpbnQzMih0KzQpO2Nhc2UgNjpyZXR1cm4gbi5nZXRJbnQ4KHQpO2Nhc2UgODpyZXR1cm4gbi5nZXRJbnQxNih0KTtjYXNlIDk6cmV0dXJuIG4uZ2V0SW50MzIodCk7Y2FzZSAxMDpyZXR1cm4gbi5nZXRJbnQzMih0KS9uLmdldEludDMyKHQrNCk7Y2FzZSAxMTpyZXR1cm4gbi5nZXRGbG9hdCh0KTtjYXNlIDEyOnJldHVybiBuLmdldERvdWJsZSh0KTtjYXNlIDEzOnJldHVybiBuLmdldFVpbnQzMih0KTtkZWZhdWx0OkwoXCJJbnZhbGlkIHRpZmYgdHlwZSBcIi5jb25jYXQoZSkpfX19XSksaX0oRGUpKTtmdW5jdGlvbiBpdChlLHQsbixyKXt2YXIgaT1lK3QvNjArbi8zNjAwO3JldHVyblwiU1wiIT09ciYmXCJXXCIhPT1yfHwoaSo9LTEpLGl9aShydCxcInR5cGVcIixcInRpZmZcIiksaShydCxcImhlYWRlckxlbmd0aFwiLDEwKSxXLnNldChcInRpZmZcIixydCk7dmFyIGF0PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6emUsRXhpZnI6SWUsZmlsZVBhcnNlcnM6TSxzZWdtZW50UGFyc2VyczpXLGZpbGVSZWFkZXJzOkssdGFnS2V5czpyZSx0YWdWYWx1ZXM6aWUsdGFnUmV2aXZlcnM6YWUsY3JlYXRlRGljdGlvbmFyeTp0ZSxleHRlbmREaWN0aW9uYXJ5Om5lLGZldGNoVXJsQXNBcnJheUJ1ZmZlcjpHLHJlYWRCbG9iQXNBcnJheUJ1ZmZlcjpZLGNodW5rZWRQcm9wczpkZSxvdGhlclNlZ21lbnRzOnZlLHNlZ21lbnRzOnBlLHRpZmZCbG9ja3M6eWUsc2VnbWVudHNBbmRCbG9ja3M6Z2UsdGlmZkV4dHJhY3RhYmxlczprZSxpbmhlcml0YWJsZXM6bWUsYWxsRm9ybWF0dGVyczpiZSxPcHRpb25zOlBlLHBhcnNlOlRlfSk7ZnVuY3Rpb24gc3QoZSx0LG4pe3JldHVybiBuP3Q/dChlKTplOihlJiZlLnRoZW58fChlPVByb21pc2UucmVzb2x2ZShlKSksdD9lLnRoZW4odCk6ZSl9ZnVuY3Rpb24gdXQoZSl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbl09YXJndW1lbnRzW25dO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuYXBwbHkodGhpcyx0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19dmFyIG90PXV0KChmdW5jdGlvbihlKXt2YXIgdD1uZXcgSWUodnQpO3JldHVybiBzdCh0LnJlYWQoZSksKGZ1bmN0aW9uKCl7cmV0dXJuIHN0KHQucGFyc2UoKSwoZnVuY3Rpb24oZSl7aWYoZSYmZS5pZmQwKXJldHVybiBlLmlmZDBbMjc0XX0pKX0pKX0pKSxmdD11dCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEllKGR0KTtyZXR1cm4gc3QodC5yZWFkKGUpLChmdW5jdGlvbigpe3JldHVybiBzdCh0LnBhcnNlKCksKGZ1bmN0aW9uKGUpe2lmKGUmJmUuZ3BzKXt2YXIgdD1lLmdwcztyZXR1cm57bGF0aXR1ZGU6dC5sYXRpdHVkZSxsb25naXR1ZGU6dC5sb25naXR1ZGV9fX0pKX0pKX0pKSxjdD11dCgoZnVuY3Rpb24oZSl7cmV0dXJuIHN0KHRoaXMudGh1bWJuYWlsKGUpLChmdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lKXt2YXIgdD1uZXcgQmxvYihbZV0pO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKHQpfX0pKX0pKSxodD11dCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEllKHB0KTtyZXR1cm4gc3QodC5yZWFkKGUpLChmdW5jdGlvbigpe3JldHVybiBzdCh0LmV4dHJhY3RUaHVtYm5haWwoKSwoZnVuY3Rpb24oZSl7cmV0dXJuIGUmJl8/ai5mcm9tKGUpOmV9KSl9KSl9KSksbHQ9e2lmZDA6ITEsaWZkMTohMSxleGlmOiExLGdwczohMSxpbnRlcm9wOiExLHNhbml0aXplOiExLHJldml2ZVZhbHVlczohMCx0cmFuc2xhdGVLZXlzOiExLHRyYW5zbGF0ZVZhbHVlczohMSxtZXJnZU91dHB1dDohMX0sZHQ9Zyh7fSxsdCx7Zmlyc3RDaHVua1NpemU6NGU0LGdwczpbMSwyLDMsNF19KSx2dD1nKHt9LGx0LHtmaXJzdENodW5rU2l6ZTo0ZTQsaWZkMDpbMjc0XX0pLHB0PWcoe30sbHQse3RpZmY6ITEsaWZkMTohMCxtZXJnZU91dHB1dDohMX0pLHl0PU9iamVjdC5mcmVlemUoezE6e2RpbWVuc2lvblN3YXBwZWQ6ITEsc2NhbGVYOjEsc2NhbGVZOjEsZGVnOjAscmFkOjB9LDI6e2RpbWVuc2lvblN3YXBwZWQ6ITEsc2NhbGVYOi0xLHNjYWxlWToxLGRlZzowLHJhZDowfSwzOntkaW1lbnNpb25Td2FwcGVkOiExLHNjYWxlWDoxLHNjYWxlWToxLGRlZzoxODAscmFkOjE4MCpNYXRoLlBJLzE4MH0sNDp7ZGltZW5zaW9uU3dhcHBlZDohMSxzY2FsZVg6LTEsc2NhbGVZOjEsZGVnOjE4MCxyYWQ6MTgwKk1hdGguUEkvMTgwfSw1OntkaW1lbnNpb25Td2FwcGVkOiEwLHNjYWxlWDoxLHNjYWxlWTotMSxkZWc6OTAscmFkOjkwKk1hdGguUEkvMTgwfSw2OntkaW1lbnNpb25Td2FwcGVkOiEwLHNjYWxlWDoxLHNjYWxlWToxLGRlZzo5MCxyYWQ6OTAqTWF0aC5QSS8xODB9LDc6e2RpbWVuc2lvblN3YXBwZWQ6ITAsc2NhbGVYOjEsc2NhbGVZOi0xLGRlZzoyNzAscmFkOjI3MCpNYXRoLlBJLzE4MH0sODp7ZGltZW5zaW9uU3dhcHBlZDohMCxzY2FsZVg6MSxzY2FsZVk6MSxkZWc6MjcwLHJhZDoyNzAqTWF0aC5QSS8xODB9fSk7aWYoZS5yb3RhdGVDYW52YXM9ITAsZS5yb3RhdGVDc3M9ITAsXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvcil7dmFyIGd0PW5hdmlnYXRvci51c2VyQWdlbnQ7aWYoZ3QuaW5jbHVkZXMoXCJpUGFkXCIpfHxndC5pbmNsdWRlcyhcImlQaG9uZVwiKSl7dmFyIGt0PWd0Lm1hdGNoKC9PUyAoXFxkKylfKFxcZCspLyk7aWYoa3Qpe3ZhciBtdD1rdFsxXSxidD1rdFsyXSxBdD1OdW1iZXIobXQpKy4xKk51bWJlcihidCk7ZS5yb3RhdGVDYW52YXM9QXQ8MTMuNCxlLnJvdGF0ZUNzcz0hMX19ZWxzZSBpZihndC5pbmNsdWRlcyhcIk9TIFggMTBcIikpe3ZhciB3dD1ndC5tYXRjaCgvT1MgWCAxMFtfLl0oXFxkKykvKVsxXTtlLnJvdGF0ZUNhbnZhcz1lLnJvdGF0ZUNzcz1OdW1iZXIod3QpPDE1fWlmKGd0LmluY2x1ZGVzKFwiQ2hyb21lL1wiKSl7dmFyIE90PWd0Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKVsxXTtlLnJvdGF0ZUNhbnZhcz1lLnJvdGF0ZUNzcz1OdW1iZXIoT3QpPDgxfWVsc2UgaWYoZ3QuaW5jbHVkZXMoXCJGaXJlZm94L1wiKSl7dmFyIFN0PWd0Lm1hdGNoKC9GaXJlZm94XFwvKFxcZCspLylbMV07ZS5yb3RhdGVDYW52YXM9ZS5yb3RhdGVDc3M9TnVtYmVyKFN0KTw3N319ZnVuY3Rpb24gUHQoKXt9dmFyIFV0PWZ1bmN0aW9uKGUpe2EodSxlKTt2YXIgbj1kKHUpO2Z1bmN0aW9uIHUoKXt2YXIgZTt0KHRoaXMsdSk7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkocikscz0wO3M8cjtzKyspYVtzXT1hcmd1bWVudHNbc107cmV0dXJuIGkoaChlPW4uY2FsbC5hcHBseShuLFt0aGlzXS5jb25jYXQoYSkpKSxcInJhbmdlc1wiLG5ldyB4dCksMCE9PWUuYnl0ZUxlbmd0aCYmZS5yYW5nZXMuYWRkKDAsZS5ieXRlTGVuZ3RoKSxlfXJldHVybiByKHUsW3trZXk6XCJfdHJ5RXh0ZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2lmKDA9PT1lJiYwPT09dGhpcy5ieXRlTGVuZ3RoJiZuKXt2YXIgcj1uZXcgRGF0YVZpZXcobi5idWZmZXJ8fG4sbi5ieXRlT2Zmc2V0LG4uYnl0ZUxlbmd0aCk7dGhpcy5fc3dhcERhdGFWaWV3KHIpfWVsc2V7dmFyIGk9ZSt0O2lmKGk+dGhpcy5ieXRlTGVuZ3RoKXt2YXIgYT10aGlzLl9leHRlbmQoaSkuZGF0YVZpZXc7dGhpcy5fc3dhcERhdGFWaWV3KGEpfX19fSx7a2V5OlwiX2V4dGVuZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0O3Q9Xz9qLmFsbG9jVW5zYWZlKGUpOm5ldyBVaW50OEFycmF5KGUpO3ZhciBuPW5ldyBEYXRhVmlldyh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKTtyZXR1cm4gdC5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsdGhpcy5ieXRlT2Zmc2V0LHRoaXMuYnl0ZUxlbmd0aCksMCkse3VpbnRWaWV3OnQsZGF0YVZpZXc6bn19fSx7a2V5Olwic3ViYXJyYXlcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07cmV0dXJuIHQ9dHx8dGhpcy5fbGVuZ3RoVG9FbmQoZSksbiYmdGhpcy5fdHJ5RXh0ZW5kKGUsdCksdGhpcy5yYW5nZXMuYWRkKGUsdCksdihzKHUucHJvdG90eXBlKSxcInN1YmFycmF5XCIsdGhpcykuY2FsbCh0aGlzLGUsdCl9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO24mJnRoaXMuX3RyeUV4dGVuZCh0LGUuYnl0ZUxlbmd0aCxlKTt2YXIgcj12KHModS5wcm90b3R5cGUpLFwic2V0XCIsdGhpcykuY2FsbCh0aGlzLGUsdCk7cmV0dXJuIHRoaXMucmFuZ2VzLmFkZCh0LHIuYnl0ZUxlbmd0aCkscn19LHtrZXk6XCJlbnN1cmVDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPXRoaXM7aWYoIW4uY2h1bmtlZClyZXR1cm47aWYobi5yYW5nZXMuYXZhaWxhYmxlKGUsdCkpcmV0dXJuO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCF0KXJldHVybiBlJiZlLnRoZW4/ZS50aGVuKFB0KTpQcm9taXNlLnJlc29sdmUoKX0obi5yZWFkQ2h1bmsoZSx0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJhdmFpbGFibGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnJhbmdlcy5hdmFpbGFibGUoZSx0KX19XSksdX0oRCkseHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dCh0aGlzLGUpLGkodGhpcyxcImxpc3RcIixbXSl9cmV0dXJuIHIoZSxbe2tleTpcImxlbmd0aFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpc3QubGVuZ3RofX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZSt0LHI9dGhpcy5saXN0LmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIEN0KGUsdC5vZmZzZXQsbil8fEN0KGUsdC5lbmQsbil9KSk7aWYoci5sZW5ndGg+MCl7ZT1NYXRoLm1pbi5hcHBseShNYXRoLFtlXS5jb25jYXQoci5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm9mZnNldH0pKSkpLHQ9KG49TWF0aC5tYXguYXBwbHkoTWF0aCxbbl0uY29uY2F0KHIubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5lbmR9KSkpKSktZTt2YXIgaT1yLnNoaWZ0KCk7aS5vZmZzZXQ9ZSxpLmxlbmd0aD10LGkuZW5kPW4sdGhpcy5saXN0PXRoaXMubGlzdC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiFyLmluY2x1ZGVzKGUpfSkpfWVsc2UgdGhpcy5saXN0LnB1c2goe29mZnNldDplLGxlbmd0aDp0LGVuZDpufSl9fSx7a2V5OlwiYXZhaWxhYmxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lK3Q7cmV0dXJuIHRoaXMubGlzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gdC5vZmZzZXQ8PWUmJm48PXQuZW5kfSkpfX1dKSxlfSgpO2Z1bmN0aW9uIEN0KGUsdCxuKXtyZXR1cm4gZTw9dCYmdDw9bn1mdW5jdGlvbiBCdCgpe31mdW5jdGlvbiBqdChlLHQpe2lmKCF0KXJldHVybiBlJiZlLnRoZW4/ZS50aGVuKEJ0KTpQcm9taXNlLnJlc29sdmUoKX1mdW5jdGlvbiBfdChlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX12YXIgVnQ9ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiB0KHRoaXMsaSksbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHIoaSxbe2tleTpcInJlYWRXaG9sZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7cmV0dXJuIGUuY2h1bmtlZD0hMSxfdChZKGUuaW5wdXQpLChmdW5jdGlvbih0KXtlLl9zd2FwQXJyYXlCdWZmZXIodCl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJyZWFkQ2h1bmtlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2h1bmtlZD0hMCx0aGlzLnNpemU9dGhpcy5pbnB1dC5zaXplLHYocyhpLnByb3RvdHlwZSksXCJyZWFkQ2h1bmtlZFwiLHRoaXMpLmNhbGwodGhpcyl9fSx7a2V5OlwiX3JlYWRDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPXRoaXMscj10P2UrdDp2b2lkIDAsaT1uLmlucHV0LnNsaWNlKGUscik7cmV0dXJuIF90KFkoaSksKGZ1bmN0aW9uKHQpe3JldHVybiBuLnNldCh0LGUsITApfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fV0pLGl9KGZ1bmN0aW9uKGUpe2EocyxlKTt2YXIgbj1kKHMpO2Z1bmN0aW9uIHMoZSxyKXt2YXIgYTtyZXR1cm4gdCh0aGlzLHMpLGkoaChhPW4uY2FsbCh0aGlzLDApKSxcImNodW5rc1JlYWRcIiwwKSxhLmlucHV0PWUsYS5vcHRpb25zPXIsYX1yZXR1cm4gcihzLFt7a2V5OlwicmVhZFdob2xlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztyZXR1cm4gZS5jaHVua2VkPSExLGp0KGUucmVhZENodW5rKGUubmV4dENodW5rT2Zmc2V0KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJyZWFkQ2h1bmtlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7cmV0dXJuIGUuY2h1bmtlZD0hMCxqdChlLnJlYWRDaHVuaygwLGUub3B0aW9ucy5maXJzdENodW5rU2l6ZSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicmVhZE5leHRDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RyeXt2YXIgdD10aGlzO2lmKHZvaWQgMD09PWUmJihlPXQubmV4dENodW5rT2Zmc2V0KSx0LmZ1bGx5UmVhZClyZXR1cm4gdC5jaHVua3NSZWFkKyssITE7dmFyIG49dC5vcHRpb25zLmNodW5rU2l6ZTtyZXR1cm4gcj10LnJlYWRDaHVuayhlLG4pLGk9ZnVuY3Rpb24oZSl7cmV0dXJuISFlJiZlLmJ5dGVMZW5ndGg9PT1ufSxhP2k/aShyKTpyOihyJiZyLnRoZW58fChyPVByb21pc2UucmVzb2x2ZShyKSksaT9yLnRoZW4oaSk6cil9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfXZhciByLGksYX19LHtrZXk6XCJyZWFkQ2h1bmtcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RyeXt2YXIgbj10aGlzO2lmKG4uY2h1bmtzUmVhZCsrLDA9PT0odD1uLnNhZmVXcmFwQWRkcmVzcyhlLHQpKSlyZXR1cm47cmV0dXJuIG4uX3JlYWRDaHVuayhlLHQpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5Olwic2FmZVdyYXBBZGRyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5zaXplJiZlK3Q+dGhpcy5zaXplP01hdGgubWF4KDAsdGhpcy5zaXplLWUpOnR9fSx7a2V5OlwibmV4dENodW5rT2Zmc2V0XCIsZ2V0OmZ1bmN0aW9uKCl7aWYoMCE9PXRoaXMucmFuZ2VzLmxpc3QubGVuZ3RoKXJldHVybiB0aGlzLnJhbmdlcy5saXN0WzBdLmxlbmd0aH19LHtrZXk6XCJjYW5SZWFkTmV4dENodW5rXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2h1bmtzUmVhZDx0aGlzLm9wdGlvbnMuY2h1bmtMaW1pdH19LHtrZXk6XCJmdWxseVJlYWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5zaXplJiZ0aGlzLm5leHRDaHVua09mZnNldD09PXRoaXMuc2l6ZX19LHtrZXk6XCJyZWFkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmNodW5rZWQ/dGhpcy5yZWFkQ2h1bmtlZCgpOnRoaXMucmVhZFdob2xlKCl9fSx7a2V5OlwiY2xvc2VcIix2YWx1ZTpmdW5jdGlvbigpe319XSksc30oVXQpKTtLLnNldChcImJsb2JcIixWdCksZS5FeGlmcj1JZSxlLk9wdGlvbnM9UGUsZS5hbGxGb3JtYXR0ZXJzPWJlLGUuY2h1bmtlZFByb3BzPWRlLGUuY3JlYXRlRGljdGlvbmFyeT10ZSxlLmRlZmF1bHQ9YXQsZS5kaXNhYmxlQWxsT3B0aW9ucz1sdCxlLmV4dGVuZERpY3Rpb25hcnk9bmUsZS5mZXRjaFVybEFzQXJyYXlCdWZmZXI9RyxlLmZpbGVQYXJzZXJzPU0sZS5maWxlUmVhZGVycz1LLGUuZ3BzPWZ0LGUuZ3BzT25seU9wdGlvbnM9ZHQsZS5pbmhlcml0YWJsZXM9bWUsZS5vcmllbnRhdGlvbj1vdCxlLm9yaWVudGF0aW9uT25seU9wdGlvbnM9dnQsZS5vdGhlclNlZ21lbnRzPXZlLGUucGFyc2U9VGUsZS5yZWFkQmxvYkFzQXJyYXlCdWZmZXI9WSxlLnJvdGF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBzdChvdCh0KSwoZnVuY3Rpb24odCl7cmV0dXJuIGcoe2NhbnZhczplLnJvdGF0ZUNhbnZhcyxjc3M6ZS5yb3RhdGVDc3N9LHl0W3RdKX0pKX0sZS5yb3RhdGlvbnM9eXQsZS5zZWdtZW50UGFyc2Vycz1XLGUuc2VnbWVudHM9cGUsZS5zZWdtZW50c0FuZEJsb2Nrcz1nZSxlLnRhZ0tleXM9cmUsZS50YWdSZXZpdmVycz1hZSxlLnRhZ1ZhbHVlcz1pZSxlLnRodW1ibmFpbD1odCxlLnRodW1ibmFpbE9ubHlPcHRpb25zPXB0LGUudGh1bWJuYWlsVXJsPWN0LGUudGlmZkJsb2Nrcz15ZSxlLnRpZmZFeHRyYWN0YWJsZXM9a2UsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRGb3JtRGF0YTtcbmV4cG9ydHMuZ2V0RmllbGREYXRhID0gZ2V0RmllbGREYXRhO1xudmFyIE5PREVfTElTVF9DTEFTU0VTID0ge1xuICAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nOiB0cnVlLFxuICAnW29iamVjdCBOb2RlTGlzdF0nOiB0cnVlLFxuICAnW29iamVjdCBSYWRpb05vZGVMaXN0XSc6IHRydWVcblxuICAvLyAudHlwZSB2YWx1ZXMgZm9yIGVsZW1lbnRzIHdoaWNoIGNhbiBhcHBlYXIgaW4gLmVsZW1lbnRzIGFuZCBzaG91bGQgYmUgaWdub3JlZFxufTt2YXIgSUdOT1JFRF9FTEVNRU5UX1RZUEVTID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2ZpZWxkc2V0JzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbnZhciBDSEVDS0VEX0lOUFVUX1RZUEVTID0ge1xuICAnY2hlY2tib3gnOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlXG59O1xuXG52YXIgVFJJTV9SRSA9IC9eXFxzK3xcXHMrJC9nO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsKHN0cmluZ3xBcnJheS48c3RyaW5nPik+fSBhbiBvYmplY3QgY29udGFpbmluZ1xuICogICBzdWJtaXR0YWJsZSB2YWx1ZShzKSBoZWxkIGluIHRoZSBmb3JtJ3MgLmVsZW1lbnRzIGNvbGxlY3Rpb24sIHdpdGhcbiAqICAgcHJvcGVydGllcyBuYW1lZCBhcyBwZXIgZWxlbWVudCBuYW1lcyBvciBpZHMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0Rm9ybURhdGEoZm9ybSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyB0cmltOiBmYWxzZSB9O1xuXG4gIGlmICghZm9ybSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBmb3JtIGlzIHJlcXVpcmVkIGJ5IGdldEZvcm1EYXRhLCB3YXMgZ2l2ZW4gZm9ybT0nICsgZm9ybSk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgZWxlbWVudE5hbWUgPSB2b2lkIDA7XG4gIHZhciBlbGVtZW50TmFtZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnROYW1lTG9va3VwID0ge307XG5cbiAgLy8gR2V0IHVuaXF1ZSBzdWJtaXR0YWJsZSBlbGVtZW50IG5hbWVzIGZvciB0aGUgZm9ybVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGZvcm0uZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBmb3JtLmVsZW1lbnRzW2ldO1xuICAgIGlmIChJR05PUkVEX0VMRU1FTlRfVFlQRVNbZWxlbWVudC50eXBlXSB8fCBlbGVtZW50LmRpc2FibGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZWxlbWVudE5hbWUgPSBlbGVtZW50Lm5hbWUgfHwgZWxlbWVudC5pZDtcbiAgICBpZiAoZWxlbWVudE5hbWUgJiYgIWVsZW1lbnROYW1lTG9va3VwW2VsZW1lbnROYW1lXSkge1xuICAgICAgZWxlbWVudE5hbWVzLnB1c2goZWxlbWVudE5hbWUpO1xuICAgICAgZWxlbWVudE5hbWVMb29rdXBbZWxlbWVudE5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBFeHRyYWN0IGVsZW1lbnQgZGF0YSBuYW1lLWJ5LW5hbWUgZm9yIGNvbnNpc3RlbnQgaGFuZGxpbmcgb2Ygc3BlY2lhbCBjYXNlc1xuICAvLyBhcm91bmQgZWxlbWVudHMgd2hpY2ggY29udGFpbiBtdWx0aXBsZSBpbnB1dHMuXG4gIGZvciAodmFyIF9pID0gMCwgX2wgPSBlbGVtZW50TmFtZXMubGVuZ3RoOyBfaSA8IF9sOyBfaSsrKSB7XG4gICAgZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZXNbX2ldO1xuICAgIHZhciB2YWx1ZSA9IGdldEZpZWxkRGF0YShmb3JtLCBlbGVtZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGRhdGFbZWxlbWVudE5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsoc3RyaW5nfEFycmF5LjxzdHJpbmc+KX0gc3VibWl0dGFibGUgdmFsdWUocykgaW4gdGhlIGZvcm0gZm9yIGFcbiAqICAgbmFtZWQgZWxlbWVudCBmcm9tIGl0cyAuZWxlbWVudHMgY29sbGVjdGlvbiwgb3IgbnVsbCBpZiB0aGVyZSB3YXMgbm9cbiAqICAgZWxlbWVudCB3aXRoIHRoYXQgbmFtZSBvciB0aGUgZWxlbWVudCBoYWQgbm8gc3VibWl0dGFibGUgdmFsdWUocykuXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkRGF0YShmb3JtLCBmaWVsZE5hbWUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHsgdHJpbTogZmFsc2UgfTtcblxuICBpZiAoIWZvcm0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgZm9ybSBpcyByZXF1aXJlZCBieSBnZXRGaWVsZERhdGEsIHdhcyBnaXZlbiBmb3JtPScgKyBmb3JtKTtcbiAgfVxuICBpZiAoIWZpZWxkTmFtZSAmJiB0b1N0cmluZy5jYWxsKGZpZWxkTmFtZSkgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGZpZWxkIG5hbWUgaXMgcmVxdWlyZWQgYnkgZ2V0RmllbGREYXRhLCB3YXMgZ2l2ZW4gZmllbGROYW1lPScgKyBmaWVsZE5hbWUpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBmb3JtLmVsZW1lbnRzW2ZpZWxkTmFtZV07XG4gIGlmICghZWxlbWVudCB8fCBlbGVtZW50LmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIU5PREVfTElTVF9DTEFTU0VTW3RvU3RyaW5nLmNhbGwoZWxlbWVudCldKSB7XG4gICAgcmV0dXJuIGdldEZvcm1FbGVtZW50VmFsdWUoZWxlbWVudCwgb3B0aW9ucy50cmltKTtcbiAgfVxuXG4gIC8vIERlYWwgd2l0aCBtdWx0aXBsZSBmb3JtIGNvbnRyb2xzIHdoaWNoIGhhdmUgdGhlIHNhbWUgbmFtZVxuICB2YXIgZGF0YSA9IFtdO1xuICB2YXIgYWxsUmFkaW9zID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbGVtZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChlbGVtZW50W2ldLmRpc2FibGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbFJhZGlvcyAmJiBlbGVtZW50W2ldLnR5cGUgIT09ICdyYWRpbycpIHtcbiAgICAgIGFsbFJhZGlvcyA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBnZXRGb3JtRWxlbWVudFZhbHVlKGVsZW1lbnRbaV0sIG9wdGlvbnMudHJpbSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciBhbiBlbGVtZW50IHdpdGggbXVsdGlwbGUgc2FtZS1uYW1lZCBpbnB1dHMgd2hpY2ggd2VyZSBhbGxcbiAgLy8gcmFkaW8gYnV0dG9uczogaWYgdGhlcmUgd2FzIGEgc2VsZWN0ZWQgdmFsdWUsIG9ubHkgcmV0dXJuIHRoZSB2YWx1ZS5cbiAgaWYgKGFsbFJhZGlvcyAmJiBkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkYXRhWzBdO1xuICB9XG5cbiAgcmV0dXJuIGRhdGEubGVuZ3RoID4gMCA/IGRhdGEgOiBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgYSBmb3JtIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW19IHRyaW0gc2hvdWxkIHZhbHVlcyBmb3IgdGV4dCBlbnRyeSBpbnB1dHMgYmUgdHJpbW1lZD9cbiAqIEByZXR1cm4geyhzdHJpbmd8QXJyYXkuPHN0cmluZz58RmlsZXxBcnJheS48RmlsZT4pfSB0aGUgZWxlbWVudCdzIHN1Ym1pdHRhYmxlXG4gKiAgIHZhbHVlKHMpLCBvciBudWxsIGlmIGl0IGhhZCBub25lLlxuICovXG5mdW5jdGlvbiBnZXRGb3JtRWxlbWVudFZhbHVlKGVsZW1lbnQsIHRyaW0pIHtcbiAgdmFyIHZhbHVlID0gbnVsbDtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cblxuICBpZiAodHlwZSA9PT0gJ3NlbGVjdC1vbmUnKSB7XG4gICAgaWYgKGVsZW1lbnQub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnc2VsZWN0LW11bHRpcGxlJykge1xuICAgIHZhbHVlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbGVtZW50Lm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoZWxlbWVudC5vcHRpb25zW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgIHZhbHVlLnB1c2goZWxlbWVudC5vcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBJZiBhIGZpbGUgaW5wdXQgZG9lc24ndCBoYXZlIGEgZmlsZXMgYXR0cmlidXRlLCBmYWxsIHRocm91Z2ggdG8gdXNpbmcgaXRzXG4gIC8vIHZhbHVlIGF0dHJpYnV0ZS5cbiAgaWYgKHR5cGUgPT09ICdmaWxlJyAmJiAnZmlsZXMnIGluIGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5tdWx0aXBsZSkge1xuICAgICAgdmFsdWUgPSBzbGljZS5jYWxsKGVsZW1lbnQuZmlsZXMpO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNob3VsZCBiZSBudWxsIGlmIG5vdCBwcmVzZW50LCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgICAgIHZhbHVlID0gZWxlbWVudC5maWxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKCFDSEVDS0VEX0lOUFVUX1RZUEVTW3R5cGVdKSB7XG4gICAgdmFsdWUgPSB0cmltID8gZWxlbWVudC52YWx1ZS5yZXBsYWNlKFRSSU1fUkUsICcnKSA6IGVsZW1lbnQudmFsdWU7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5jaGVja2VkKSB7XG4gICAgdmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBGb3IgVU1EIGJ1aWxkIGFjY2VzcyB0byBnZXRGaWVsZERhdGFcbmdldEZvcm1EYXRhLmdldEZpZWxkRGF0YSA9IGdldEZpZWxkRGF0YTsiLCIvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkgKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAodHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTaGFsbG93RXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlXG4gIGZvciAodmFyIGkgaW4gYSkgaWYgKCEoaSBpbiBiKSkgcmV0dXJuIGZhbHNlXG4gIGZvciAodmFyIGkgaW4gYikgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZVxuICByZXR1cm4gdHJ1ZVxufVxuIiwiLypcbiAqICBiYXNlNjQuanNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqICBSZWZlcmVuY2VzOlxuICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAqL1xuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbClcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSkgOiBmYWN0b3J5KGdsb2JhbClcbn0oKFxuICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsXG46IHRoaXNcbiksIGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICBnbG9iYWwgPSBnbG9iYWwgfHwge307XG4gICAgdmFyIF9CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIHZhciB2ZXJzaW9uID0gXCIyLjYuNFwiO1xuICAgIC8vIGNvbnN0YW50c1xuICAgIHZhciBiNjRjaGFyc1xuICAgICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICB2YXIgYjY0dGFiID0gZnVuY3Rpb24oYmluKSB7XG4gICAgICAgIHZhciB0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYmluLmxlbmd0aDsgaSA8IGw7IGkrKykgdFtiaW4uY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0oYjY0Y2hhcnMpO1xuICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIC8vIGVuY29kZXIgc3R1ZmZcbiAgICB2YXIgY2JfdXRvYiA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgcmV0dXJuIGNjIDwgMHg4MCA/IGNcbiAgICAgICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoZnJvbUNoYXJDb2RlKDB4YzAgfCAoY2MgPj4+IDYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKGNjICYgMHgzZikpKVxuICAgICAgICAgICAgICAgIDogKGZyb21DaGFyQ29kZSgweGUwIHwgKChjYyA+Pj4gMTIpICYgMHgwZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAgNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICggY2MgICAgICAgICAmIDB4M2YpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDApIC0gMHhEODAwKSAqIDB4NDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDEpIC0gMHhEQzAwKTtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKDB4ZjAgfCAoKGNjID4+PiAxOCkgJiAweDA3KSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gIDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoIGNjICAgICAgICAgJiAweDNmKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVfdXRvYiA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZGXXxbXlxceDAwLVxceDdGXS9nO1xuICAgIHZhciB1dG9iID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gdS5yZXBsYWNlKHJlX3V0b2IsIGNiX3V0b2IpO1xuICAgIH07XG4gICAgdmFyIGNiX2VuY29kZSA9IGZ1bmN0aW9uKGNjYykge1xuICAgICAgICB2YXIgcGFkbGVuID0gWzAsIDIsIDFdW2NjYy5sZW5ndGggJSAzXSxcbiAgICAgICAgb3JkID0gY2NjLmNoYXJDb2RlQXQoMCkgPDwgMTZcbiAgICAgICAgICAgIHwgKChjY2MubGVuZ3RoID4gMSA/IGNjYy5jaGFyQ29kZUF0KDEpIDogMCkgPDwgOClcbiAgICAgICAgICAgIHwgKChjY2MubGVuZ3RoID4gMiA/IGNjYy5jaGFyQ29kZUF0KDIpIDogMCkpLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGI2NGNoYXJzLmNoYXJBdCggb3JkID4+PiAxOCksXG4gICAgICAgICAgICBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gMTIpICYgNjMpLFxuICAgICAgICAgICAgcGFkbGVuID49IDIgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gNikgJiA2MyksXG4gICAgICAgICAgICBwYWRsZW4gPj0gMSA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdChvcmQgJiA2MylcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH07XG4gICAgdmFyIGJ0b2EgPSBnbG9iYWwuYnRvYSAmJiB0eXBlb2YgZ2xvYmFsLmJ0b2EgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGZ1bmN0aW9uKGIpeyByZXR1cm4gZ2xvYmFsLmJ0b2EoYikgfSA6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgaWYgKGIubWF0Y2goL1teXFx4MDAtXFx4RkZdLykpIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgJ1RoZSBzdHJpbmcgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZSgvW1xcc1xcU117MSwzfS9nLCBjYl9lbmNvZGUpO1xuICAgIH07XG4gICAgdmFyIF9lbmNvZGUgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiBidG9hKHV0b2IoU3RyaW5nKHUpKSk7XG4gICAgfTtcbiAgICB2YXIgbWtVcmlTYWZlID0gZnVuY3Rpb24gKGI2NCkge1xuICAgICAgICByZXR1cm4gYjY0LnJlcGxhY2UoL1srXFwvXS9nLCBmdW5jdGlvbihtMCkge1xuICAgICAgICAgICAgcmV0dXJuIG0wID09ICcrJyA/ICctJyA6ICdfJztcbiAgICAgICAgfSkucmVwbGFjZSgvPS9nLCAnJyk7XG4gICAgfTtcbiAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24odSwgdXJpc2FmZSkge1xuICAgICAgICByZXR1cm4gdXJpc2FmZSA/IG1rVXJpU2FmZShfZW5jb2RlKHUpKSA6IF9lbmNvZGUodSk7XG4gICAgfTtcbiAgICB2YXIgZW5jb2RlVVJJID0gZnVuY3Rpb24odSkgeyByZXR1cm4gZW5jb2RlKHUsIHRydWUpIH07XG4gICAgdmFyIGZyb21VaW50OEFycmF5O1xuICAgIGlmIChnbG9iYWwuVWludDhBcnJheSkgZnJvbVVpbnQ4QXJyYXkgPSBmdW5jdGlvbihhLCB1cmlzYWZlKSB7XG4gICAgICAgIC8vIHJldHVybiBidG9hKGZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhKSk7XG4gICAgICAgIHZhciBiNjQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgICAgICAgdmFyIGEwID0gYVtpXSwgYTEgPSBhW2krMV0sIGEyID0gYVtpKzJdO1xuICAgICAgICAgICAgdmFyIG9yZCA9IGEwIDw8IDE2IHwgYTEgPDwgOCB8IGEyO1xuICAgICAgICAgICAgYjY0ICs9ICAgIGI2NGNoYXJzLmNoYXJBdCggb3JkID4+PiAxOClcbiAgICAgICAgICAgICAgICArICAgICBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gMTIpICYgNjMpXG4gICAgICAgICAgICAgICAgKyAoIHR5cGVvZiBhMSAhPSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICA/IGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAgNikgJiA2MykgOiAnPScpXG4gICAgICAgICAgICAgICAgKyAoIHR5cGVvZiBhMiAhPSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICA/IGI2NGNoYXJzLmNoYXJBdCggb3JkICAgICAgICAgJiA2MykgOiAnPScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmlzYWZlID8gbWtVcmlTYWZlKGI2NCkgOiBiNjQ7XG4gICAgfTtcbiAgICAvLyBkZWNvZGVyIHN0dWZmXG4gICAgdmFyIHJlX2J0b3UgPSAvW1xceEMwLVxceERGXVtcXHg4MC1cXHhCRl18W1xceEUwLVxceEVGXVtcXHg4MC1cXHhCRl17Mn18W1xceEYwLVxceEY3XVtcXHg4MC1cXHhCRl17M30vZztcbiAgICB2YXIgY2JfYnRvdSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgc3dpdGNoKGNjY2MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHZhciBjcCA9ICgoMHgwNyAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTgpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgICAgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSA8PCAgNilcbiAgICAgICAgICAgICAgICB8ICAgICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgzKSksXG4gICAgICAgICAgICBvZmZzZXQgPSBjcCAtIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gKGZyb21DaGFyQ29kZSgob2Zmc2V0ICA+Pj4gMTApICsgMHhEODAwKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgob2Zmc2V0ICYgMHgzRkYpICsgMHhEQzAwKSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDBmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAgZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYnRvdSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZShyZV9idG91LCBjYl9idG91KTtcbiAgICB9O1xuICAgIHZhciBjYl9kZWNvZGUgPSBmdW5jdGlvbihjY2NjKSB7XG4gICAgICAgIHZhciBsZW4gPSBjY2NjLmxlbmd0aCxcbiAgICAgICAgcGFkbGVuID0gbGVuICUgNCxcbiAgICAgICAgbiA9IChsZW4gPiAwID8gYjY0dGFiW2NjY2MuY2hhckF0KDApXSA8PCAxOCA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAxID8gYjY0dGFiW2NjY2MuY2hhckF0KDEpXSA8PCAxMiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAyID8gYjY0dGFiW2NjY2MuY2hhckF0KDIpXSA8PCAgNiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAzID8gYjY0dGFiW2NjY2MuY2hhckF0KDMpXSAgICAgICA6IDApLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiA+Pj4gMTYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKChuID4+PiAgOCkgJiAweGZmKSxcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiAgICAgICAgICYgMHhmZilcbiAgICAgICAgXTtcbiAgICAgICAgY2hhcnMubGVuZ3RoIC09IFswLCAwLCAyLCAxXVtwYWRsZW5dO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgX2F0b2IgPSBnbG9iYWwuYXRvYiAmJiB0eXBlb2YgZ2xvYmFsLmF0b2IgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGZ1bmN0aW9uKGEpeyByZXR1cm4gZ2xvYmFsLmF0b2IoYSkgfSA6IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gYS5yZXBsYWNlKC9cXFN7MSw0fS9nLCBjYl9kZWNvZGUpO1xuICAgIH07XG4gICAgdmFyIGF0b2IgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBfYXRvYihTdHJpbmcoYSkucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKSk7XG4gICAgfTtcbiAgICB2YXIgX2RlY29kZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGJ0b3UoX2F0b2IoYSkpIH07XG4gICAgdmFyIF9mcm9tVVJJID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLnJlcGxhY2UoL1stX10vZywgZnVuY3Rpb24obTApIHtcbiAgICAgICAgICAgIHJldHVybiBtMCA9PSAnLScgPyAnKycgOiAnLydcbiAgICAgICAgfSkucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKTtcbiAgICB9O1xuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGUoX2Zyb21VUkkoYSkpO1xuICAgIH07XG4gICAgdmFyIHRvVWludDhBcnJheTtcbiAgICBpZiAoZ2xvYmFsLlVpbnQ4QXJyYXkpIHRvVWludDhBcnJheSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhdG9iKF9mcm9tVVJJKGEpKSwgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgbm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICAgICAgZ2xvYmFsLkJhc2U2NCA9IF9CYXNlNjQ7XG4gICAgICAgIHJldHVybiBCYXNlNjQ7XG4gICAgfTtcbiAgICAvLyBleHBvcnQgQmFzZTY0XG4gICAgZ2xvYmFsLkJhc2U2NCA9IHtcbiAgICAgICAgVkVSU0lPTjogdmVyc2lvbixcbiAgICAgICAgYXRvYjogYXRvYixcbiAgICAgICAgYnRvYTogYnRvYSxcbiAgICAgICAgZnJvbUJhc2U2NDogZGVjb2RlLFxuICAgICAgICB0b0Jhc2U2NDogZW5jb2RlLFxuICAgICAgICB1dG9iOiB1dG9iLFxuICAgICAgICBlbmNvZGU6IGVuY29kZSxcbiAgICAgICAgZW5jb2RlVVJJOiBlbmNvZGVVUkksXG4gICAgICAgIGJ0b3U6IGJ0b3UsXG4gICAgICAgIGRlY29kZTogZGVjb2RlLFxuICAgICAgICBub0NvbmZsaWN0OiBub0NvbmZsaWN0LFxuICAgICAgICBmcm9tVWludDhBcnJheTogZnJvbVVpbnQ4QXJyYXksXG4gICAgICAgIHRvVWludDhBcnJheTogdG9VaW50OEFycmF5XG4gICAgfTtcbiAgICAvLyBpZiBFUzUgaXMgYXZhaWxhYmxlLCBtYWtlIEJhc2U2NC5leHRlbmRTdHJpbmcoKSBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgbm9FbnVtID0gZnVuY3Rpb24odil7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlOnYsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFsLkJhc2U2NC5leHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ2Zyb21CYXNlNjQnLCBub0VudW0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAodXJpc2FmZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlKHRoaXMsIHVyaXNhZmUpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NFVSSScsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vXG4gICAgLy8gZXhwb3J0IEJhc2U2NCB0byB0aGUgbmFtZXNwYWNlXG4gICAgLy9cbiAgICBpZiAoZ2xvYmFsWydNZXRlb3InXSkgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICB9XG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgYW5kIEFNRCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgIC8vIG1vZHVsZS5leHBvcnRzIGhhcyBwcmVjZWRlbmNlLlxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCl7IHJldHVybiBnbG9iYWwuQmFzZTY0IH0pO1xuICAgIH1cbiAgICAvLyB0aGF0J3MgaXQhXG4gICAgcmV0dXJuIHtCYXNlNjQ6IGdsb2JhbC5CYXNlNjR9XG59KSk7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbiAoeCkge1xuXHRyZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzJFO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV3SW5wdXRzLCBsYXN0SW5wdXRzKSB7XG4gICAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5ld0lucHV0c1tpXSAhPT0gbGFzdElucHV0c1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplT25lKHJlc3VsdEZuLCBpc0VxdWFsKSB7XG4gICAgaWYgKGlzRXF1YWwgPT09IHZvaWQgMCkgeyBpc0VxdWFsID0gYXJlSW5wdXRzRXF1YWw7IH1cbiAgICB2YXIgbGFzdFRoaXM7XG4gICAgdmFyIGxhc3RBcmdzID0gW107XG4gICAgdmFyIGxhc3RSZXN1bHQ7XG4gICAgdmFyIGNhbGxlZE9uY2UgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBpc0VxdWFsKG5ld0FyZ3MsIGxhc3RBcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICBjYWxsZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0QXJncyA9IG5ld0FyZ3M7XG4gICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZU9uZTtcbiIsInZhciB3aWxkY2FyZCA9IHJlcXVpcmUoJ3dpbGRjYXJkJyk7XG52YXIgcmVNaW1lUGFydFNwbGl0ID0gL1tcXC9cXCtcXC5dLztcblxuLyoqXG4gICMgbWltZS1tYXRjaFxuXG4gIEEgc2ltcGxlIGZ1bmN0aW9uIHRvIGNoZWNrZXIgd2hldGhlciBhIHRhcmdldCBtaW1lIHR5cGUgbWF0Y2hlcyBhIG1pbWUtdHlwZVxuICBwYXR0ZXJuIChlLmcuIGltYWdlL2pwZWcgbWF0Y2hlcyBpbWFnZS9qcGVnIE9SIGltYWdlLyopLlxuXG4gICMjIEV4YW1wbGUgVXNhZ2VcblxuICA8PDwgZXhhbXBsZS5qc1xuXG4qKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBwYXR0ZXJuKSB7XG4gIGZ1bmN0aW9uIHRlc3QocGF0dGVybikge1xuICAgIHZhciByZXN1bHQgPSB3aWxkY2FyZChwYXR0ZXJuLCB0YXJnZXQsIHJlTWltZVBhcnRTcGxpdCk7XG5cbiAgICAvLyBlbnN1cmUgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgbWltZSB0eXBlIChzaG91bGQgaGF2ZSB0d28gcGFydHMpXG4gICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID49IDI7XG4gIH1cblxuICByZXR1cm4gcGF0dGVybiA/IHRlc3QocGF0dGVybi5zcGxpdCgnOycpWzBdKSA6IHRlc3Q7XG59O1xuIiwiLyoqXG4qIENyZWF0ZSBhbiBldmVudCBlbWl0dGVyIHdpdGggbmFtZXNwYWNlc1xuKiBAbmFtZSBjcmVhdGVOYW1lc3BhY2VFbWl0dGVyXG4qIEBleGFtcGxlXG4qIHZhciBlbWl0dGVyID0gcmVxdWlyZSgnLi9pbmRleCcpKClcbipcbiogZW1pdHRlci5vbignKicsIGZ1bmN0aW9uICgpIHtcbiogICBjb25zb2xlLmxvZygnYWxsIGV2ZW50cyBlbWl0dGVkJywgdGhpcy5ldmVudClcbiogfSlcbipcbiogZW1pdHRlci5vbignZXhhbXBsZScsIGZ1bmN0aW9uICgpIHtcbiogICBjb25zb2xlLmxvZygnZXhhbXBsZSBldmVudCBlbWl0dGVkJylcbiogfSlcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZU5hbWVzcGFjZUVtaXR0ZXIgKCkge1xuICB2YXIgZW1pdHRlciA9IHt9XG4gIHZhciBfZm5zID0gZW1pdHRlci5fZm5zID0ge31cblxuICAvKipcbiAgKiBFbWl0IGFuIGV2ZW50LiBPcHRpb25hbGx5IG5hbWVzcGFjZSB0aGUgZXZlbnQuIEhhbmRsZXJzIGFyZSBmaXJlZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHdpdGggZXhhY3QgbWF0Y2hlcyB0YWtpbmcgcHJlY2VkZW5jZS4gU2VwYXJhdGUgdGhlIG5hbWVzcGFjZSBhbmQgZXZlbnQgd2l0aCBhIGA6YFxuICAqIEBuYW1lIGVtaXRcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg4oCTIHRoZSBuYW1lIG9mIHRoZSBldmVudCwgd2l0aCBvcHRpb25hbCBuYW1lc3BhY2VcbiAgKiBAcGFyYW0gey4uLip9IGRhdGEg4oCTIHVwIHRvIDYgYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgKiBAZXhhbXBsZVxuICAqIGVtaXR0ZXIuZW1pdCgnZXhhbXBsZScpXG4gICogZW1pdHRlci5lbWl0KCdkZW1vOnRlc3QnKVxuICAqIGVtaXR0ZXIuZW1pdCgnZGF0YScsIHsgZXhhbXBsZTogdHJ1ZX0sICdhIHN0cmluZycsIDEpXG4gICovXG4gIGVtaXR0ZXIuZW1pdCA9IGZ1bmN0aW9uIGVtaXQgKGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2KSB7XG4gICAgdmFyIHRvRW1pdCA9IGdldExpc3RlbmVycyhldmVudClcblxuICAgIGlmICh0b0VtaXQubGVuZ3RoKSB7XG4gICAgICBlbWl0QWxsKGV2ZW50LCB0b0VtaXQsIFthcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2XSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBDcmVhdGUgZW4gZXZlbnQgbGlzdGVuZXIuXG4gICogQG5hbWUgb25cbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAqIEBleGFtcGxlXG4gICogZW1pdHRlci5vbignZXhhbXBsZScsIGZ1bmN0aW9uICgpIHt9KVxuICAqIGVtaXR0ZXIub24oJ2RlbW8nLCBmdW5jdGlvbiAoKSB7fSlcbiAgKi9cbiAgZW1pdHRlci5vbiA9IGZ1bmN0aW9uIG9uIChldmVudCwgZm4pIHtcbiAgICBpZiAoIV9mbnNbZXZlbnRdKSB7XG4gICAgICBfZm5zW2V2ZW50XSA9IFtdXG4gICAgfVxuXG4gICAgX2Zuc1tldmVudF0ucHVzaChmbilcbiAgfVxuXG4gIC8qKlxuICAqIENyZWF0ZSBlbiBldmVudCBsaXN0ZW5lciB0aGF0IGZpcmVzIG9uY2UuXG4gICogQG5hbWUgb25jZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICogQGV4YW1wbGVcbiAgKiBlbWl0dGVyLm9uY2UoJ2V4YW1wbGUnLCBmdW5jdGlvbiAoKSB7fSlcbiAgKiBlbWl0dGVyLm9uY2UoJ2RlbW8nLCBmdW5jdGlvbiAoKSB7fSlcbiAgKi9cbiAgZW1pdHRlci5vbmNlID0gZnVuY3Rpb24gb25jZSAoZXZlbnQsIGZuKSB7XG4gICAgZnVuY3Rpb24gb25lICgpIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIGVtaXR0ZXIub2ZmKGV2ZW50LCBvbmUpXG4gICAgfVxuICAgIHRoaXMub24oZXZlbnQsIG9uZSlcbiAgfVxuXG4gIC8qKlxuICAqIFN0b3AgbGlzdGVuaW5nIHRvIGFuIGV2ZW50LiBTdG9wIGFsbCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgYnkgb25seSBwYXNzaW5nIHRoZSBldmVudCBuYW1lLiBTdG9wIGEgc2luZ2xlIGxpc3RlbmVyIGJ5IHBhc3NpbmcgdGhhdCBldmVudCBoYW5kbGVyIGFzIGEgY2FsbGJhY2suXG4gICogWW91IG11c3QgYmUgZXhwbGljaXQgYWJvdXQgd2hhdCB3aWxsIGJlIHVuc3Vic2NyaWJlZDogYGVtaXR0ZXIub2ZmKCdkZW1vJylgIHdpbGwgdW5zdWJzY3JpYmUgYW4gYGVtaXR0ZXIub24oJ2RlbW8nKWAgbGlzdGVuZXIsXG4gICogYGVtaXR0ZXIub2ZmKCdkZW1vOmV4YW1wbGUnKWAgd2lsbCB1bnN1YnNjcmliZSBhbiBgZW1pdHRlci5vbignZGVtbzpleGFtcGxlJylgIGxpc3RlbmVyXG4gICogQG5hbWUgb2ZmXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSDigJMgdGhlIHNwZWNpZmljIGhhbmRsZXJcbiAgKiBAZXhhbXBsZVxuICAqIGVtaXR0ZXIub2ZmKCdleGFtcGxlJylcbiAgKiBlbWl0dGVyLm9mZignZGVtbycsIGZ1bmN0aW9uICgpIHt9KVxuICAqL1xuICBlbWl0dGVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIGtlZXAgPSBbXVxuXG4gICAgaWYgKGV2ZW50ICYmIGZuKSB7XG4gICAgICB2YXIgZm5zID0gdGhpcy5fZm5zW2V2ZW50XVxuICAgICAgdmFyIGkgPSAwXG4gICAgICB2YXIgbCA9IGZucyA/IGZucy5sZW5ndGggOiAwXG5cbiAgICAgIGZvciAoaTsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoZm5zW2ldICE9PSBmbikge1xuICAgICAgICAgIGtlZXAucHVzaChmbnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZWVwLmxlbmd0aCA/IHRoaXMuX2Zuc1tldmVudF0gPSBrZWVwIDogZGVsZXRlIHRoaXMuX2Zuc1tldmVudF1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpc3RlbmVycyAoZSkge1xuICAgIHZhciBvdXQgPSBfZm5zW2VdID8gX2Zuc1tlXSA6IFtdXG4gICAgdmFyIGlkeCA9IGUuaW5kZXhPZignOicpXG4gICAgdmFyIGFyZ3MgPSAoaWR4ID09PSAtMSkgPyBbZV0gOiBbZS5zdWJzdHJpbmcoMCwgaWR4KSwgZS5zdWJzdHJpbmcoaWR4ICsgMSldXG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKF9mbnMpXG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aFxuXG4gICAgZm9yIChpOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgaWYgKGtleSA9PT0gJyonKSB7XG4gICAgICAgIG91dCA9IG91dC5jb25jYXQoX2Zuc1trZXldKVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDIgJiYgYXJnc1swXSA9PT0ga2V5KSB7XG4gICAgICAgIG91dCA9IG91dC5jb25jYXQoX2Zuc1trZXldKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRBbGwgKGUsIGZucywgYXJncykge1xuICAgIHZhciBpID0gMFxuICAgIHZhciBsID0gZm5zLmxlbmd0aFxuXG4gICAgZm9yIChpOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoIWZuc1tpXSkgYnJlYWtcbiAgICAgIGZuc1tpXS5ldmVudCA9IGVcbiAgICAgIGZuc1tpXS5hcHBseShmbnNbaV0sIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVtaXR0ZXJcbn1cbiIsIiFmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gVk5vZGUoKSB7fVxuICAgIGZ1bmN0aW9uIGgobm9kZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGxhc3RTaW1wbGUsIGNoaWxkLCBzaW1wbGUsIGksIGNoaWxkcmVuID0gRU1QVFlfQ0hJTERSRU47XG4gICAgICAgIGZvciAoaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGktLSA+IDI7ICkgc3RhY2sucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICBpZiAoYXR0cmlidXRlcyAmJiBudWxsICE9IGF0dHJpYnV0ZXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoKSBzdGFjay5wdXNoKGF0dHJpYnV0ZXMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkgaWYgKChjaGlsZCA9IHN0YWNrLnBvcCgpKSAmJiB2b2lkIDAgIT09IGNoaWxkLnBvcCkgZm9yIChpID0gY2hpbGQubGVuZ3RoOyBpLS07ICkgc3RhY2sucHVzaChjaGlsZFtpXSk7IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCdib29sZWFuJyA9PSB0eXBlb2YgY2hpbGQpIGNoaWxkID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzaW1wbGUgPSAnZnVuY3Rpb24nICE9IHR5cGVvZiBub2RlTmFtZSkgaWYgKG51bGwgPT0gY2hpbGQpIGNoaWxkID0gJyc7IGVsc2UgaWYgKCdudW1iZXInID09IHR5cGVvZiBjaGlsZCkgY2hpbGQgPSBTdHJpbmcoY2hpbGQpOyBlbHNlIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgY2hpbGQpIHNpbXBsZSA9ICExO1xuICAgICAgICAgICAgaWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSArPSBjaGlsZDsgZWxzZSBpZiAoY2hpbGRyZW4gPT09IEVNUFRZX0NISUxEUkVOKSBjaGlsZHJlbiA9IFsgY2hpbGQgXTsgZWxzZSBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIGxhc3RTaW1wbGUgPSBzaW1wbGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBuZXcgVk5vZGUoKTtcbiAgICAgICAgcC5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuICAgICAgICBwLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHAuYXR0cmlidXRlcyA9IG51bGwgPT0gYXR0cmlidXRlcyA/IHZvaWQgMCA6IGF0dHJpYnV0ZXM7XG4gICAgICAgIHAua2V5ID0gbnVsbCA9PSBhdHRyaWJ1dGVzID8gdm9pZCAwIDogYXR0cmlidXRlcy5rZXk7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUocCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRlbmQob2JqLCBwcm9wcykge1xuICAgICAgICBmb3IgKHZhciBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVFbGVtZW50KHZub2RlLCBwcm9wcykge1xuICAgICAgICByZXR1cm4gaCh2bm9kZS5ub2RlTmFtZSwgZXh0ZW5kKGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyksIHByb3BzKSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiB2bm9kZS5jaGlsZHJlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghY29tcG9uZW50Ll9fZCAmJiAoY29tcG9uZW50Ll9fZCA9ICEwKSAmJiAxID09IGl0ZW1zLnB1c2goY29tcG9uZW50KSkgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgfHwgZGVmZXIpKHJlcmVuZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXIoKSB7XG4gICAgICAgIHZhciBwLCBsaXN0ID0gaXRlbXM7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIHdoaWxlIChwID0gbGlzdC5wb3AoKSkgaWYgKHAuX19kKSByZW5kZXJDb21wb25lbnQocCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU2FtZU5vZGVUeXBlKG5vZGUsIHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2bm9kZSB8fCAnbnVtYmVyJyA9PSB0eXBlb2Ygdm5vZGUpIHJldHVybiB2b2lkIDAgIT09IG5vZGUuc3BsaXRUZXh0O1xuICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZub2RlLm5vZGVOYW1lKSByZXR1cm4gIW5vZGUuX2NvbXBvbmVudENvbnN0cnVjdG9yICYmIGlzTmFtZWROb2RlKG5vZGUsIHZub2RlLm5vZGVOYW1lKTsgZWxzZSByZXR1cm4gaHlkcmF0aW5nIHx8IG5vZGUuX2NvbXBvbmVudENvbnN0cnVjdG9yID09PSB2bm9kZS5ub2RlTmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOYW1lZE5vZGUobm9kZSwgbm9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuX19uID09PSBub2RlTmFtZSB8fCBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5vZGVQcm9wcyh2bm9kZSkge1xuICAgICAgICB2YXIgcHJvcHMgPSBleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpO1xuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdm5vZGUubm9kZU5hbWUuZGVmYXVsdFByb3BzO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBkZWZhdWx0UHJvcHMpIGZvciAodmFyIGkgaW4gZGVmYXVsdFByb3BzKSBpZiAodm9pZCAwID09PSBwcm9wc1tpXSkgcHJvcHNbaV0gPSBkZWZhdWx0UHJvcHNbaV07XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTm9kZShub2RlTmFtZSwgaXNTdmcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBpc1N2ZyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBub2RlTmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgbm9kZS5fX24gPSBub2RlTmFtZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEFjY2Vzc29yKG5vZGUsIG5hbWUsIG9sZCwgdmFsdWUsIGlzU3ZnKSB7XG4gICAgICAgIGlmICgnY2xhc3NOYW1lJyA9PT0gbmFtZSkgbmFtZSA9ICdjbGFzcyc7XG4gICAgICAgIGlmICgna2V5JyA9PT0gbmFtZSkgOyBlbHNlIGlmICgncmVmJyA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKG9sZCkgb2xkKG51bGwpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICgnY2xhc3MnID09PSBuYW1lICYmICFpc1N2Zykgbm9kZS5jbGFzc05hbWUgPSB2YWx1ZSB8fCAnJzsgZWxzZSBpZiAoJ3N0eWxlJyA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCAnc3RyaW5nJyA9PSB0eXBlb2YgdmFsdWUgfHwgJ3N0cmluZycgPT0gdHlwZW9mIG9sZCkgbm9kZS5zdHlsZS5jc3NUZXh0ID0gdmFsdWUgfHwgJyc7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBvbGQpIGZvciAodmFyIGkgaW4gb2xkKSBpZiAoIShpIGluIHZhbHVlKSkgbm9kZS5zdHlsZVtpXSA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdmFsdWUpIG5vZGUuc3R5bGVbaV0gPSAnbnVtYmVyJyA9PSB0eXBlb2YgdmFsdWVbaV0gJiYgITEgPT09IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGkpID8gdmFsdWVbaV0gKyAncHgnIDogdmFsdWVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSBub2RlLmlubmVySFRNTCA9IHZhbHVlLl9faHRtbCB8fCAnJztcbiAgICAgICAgfSBlbHNlIGlmICgnbycgPT0gbmFtZVswXSAmJiAnbicgPT0gbmFtZVsxXSkge1xuICAgICAgICAgICAgdmFyIHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50UHJveHksIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgIChub2RlLl9fbCB8fCAobm9kZS5fX2wgPSB7fSkpW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2xpc3QnICE9PSBuYW1lICYmICd0eXBlJyAhPT0gbmFtZSAmJiAhaXNTdmcgJiYgbmFtZSBpbiBub2RlKSB7XG4gICAgICAgICAgICBzZXRQcm9wZXJ0eShub2RlLCBuYW1lLCBudWxsID09IHZhbHVlID8gJycgOiB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PSB2YWx1ZSB8fCAhMSA9PT0gdmFsdWUpIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5zID0gaXNTdmcgJiYgbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL154bGluazo/LywgJycpKTtcbiAgICAgICAgICAgIGlmIChudWxsID09IHZhbHVlIHx8ICExID09PSB2YWx1ZSkgaWYgKG5zKSBub2RlLnJlbW92ZUF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgbmFtZS50b0xvd2VyQ2FzZSgpKTsgZWxzZSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgZWxzZSBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgdmFsdWUpIGlmIChucykgbm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIG5hbWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpOyBlbHNlIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICBmdW5jdGlvbiBldmVudFByb3h5KGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19sW2UudHlwZV0ob3B0aW9ucy5ldmVudCAmJiBvcHRpb25zLmV2ZW50KGUpIHx8IGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaE1vdW50cygpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHdoaWxlIChjID0gbW91bnRzLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlck1vdW50KSBvcHRpb25zLmFmdGVyTW91bnQoYyk7XG4gICAgICAgICAgICBpZiAoYy5jb21wb25lbnREaWRNb3VudCkgYy5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIHBhcmVudCwgY29tcG9uZW50Um9vdCkge1xuICAgICAgICBpZiAoIWRpZmZMZXZlbCsrKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBudWxsICE9IHBhcmVudCAmJiB2b2lkIDAgIT09IHBhcmVudC5vd25lclNWR0VsZW1lbnQ7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSBudWxsICE9IGRvbSAmJiAhKCdfX3ByZWFjdGF0dHJfJyBpbiBkb20pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSBpZGlmZihkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCwgY29tcG9uZW50Um9vdCk7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcmV0LnBhcmVudE5vZGUgIT09IHBhcmVudCkgcGFyZW50LmFwcGVuZENoaWxkKHJldCk7XG4gICAgICAgIGlmICghLS1kaWZmTGV2ZWwpIHtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9ICExO1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnRSb290KSBmbHVzaE1vdW50cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBjb21wb25lbnRSb290KSB7XG4gICAgICAgIHZhciBvdXQgPSBkb20sIHByZXZTdmdNb2RlID0gaXNTdmdNb2RlO1xuICAgICAgICBpZiAobnVsbCA9PSB2bm9kZSB8fCAnYm9vbGVhbicgPT0gdHlwZW9mIHZub2RlKSB2bm9kZSA9ICcnO1xuICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZub2RlIHx8ICdudW1iZXInID09IHR5cGVvZiB2bm9kZSkge1xuICAgICAgICAgICAgaWYgKGRvbSAmJiB2b2lkIDAgIT09IGRvbS5zcGxpdFRleHQgJiYgZG9tLnBhcmVudE5vZGUgJiYgKCFkb20uX2NvbXBvbmVudCB8fCBjb21wb25lbnRSb290KSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZVZhbHVlICE9IHZub2RlKSBkb20ubm9kZVZhbHVlID0gdm5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb20ucGFyZW50Tm9kZSkgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG91dCwgZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUoZG9tLCAhMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0Ll9fcHJlYWN0YXR0cl8gPSAhMDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZub2RlTmFtZSA9IHZub2RlLm5vZGVOYW1lO1xuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygdm5vZGVOYW1lKSByZXR1cm4gYnVpbGRDb21wb25lbnRGcm9tVk5vZGUoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwpO1xuICAgICAgICBpc1N2Z01vZGUgPSAnc3ZnJyA9PT0gdm5vZGVOYW1lID8gITAgOiAnZm9yZWlnbk9iamVjdCcgPT09IHZub2RlTmFtZSA/ICExIDogaXNTdmdNb2RlO1xuICAgICAgICB2bm9kZU5hbWUgPSBTdHJpbmcodm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKCFkb20gfHwgIWlzTmFtZWROb2RlKGRvbSwgdm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgb3V0ID0gY3JlYXRlTm9kZSh2bm9kZU5hbWUsIGlzU3ZnTW9kZSk7XG4gICAgICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5maXJzdENoaWxkKSBvdXQuYXBwZW5kQ2hpbGQoZG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChkb20ucGFyZW50Tm9kZSkgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG91dCwgZG9tKTtcbiAgICAgICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShkb20sICEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZmMgPSBvdXQuZmlyc3RDaGlsZCwgcHJvcHMgPSBvdXQuX19wcmVhY3RhdHRyXywgdmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChudWxsID09IHByb3BzKSB7XG4gICAgICAgICAgICBwcm9wcyA9IG91dC5fX3ByZWFjdGF0dHJfID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBhID0gb3V0LmF0dHJpYnV0ZXMsIGkgPSBhLmxlbmd0aDsgaS0tOyApIHByb3BzW2FbaV0ubmFtZV0gPSBhW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaHlkcmF0aW5nICYmIHZjaGlsZHJlbiAmJiAxID09PSB2Y2hpbGRyZW4ubGVuZ3RoICYmICdzdHJpbmcnID09IHR5cGVvZiB2Y2hpbGRyZW5bMF0gJiYgbnVsbCAhPSBmYyAmJiB2b2lkIDAgIT09IGZjLnNwbGl0VGV4dCAmJiBudWxsID09IGZjLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoZmMubm9kZVZhbHVlICE9IHZjaGlsZHJlblswXSkgZmMubm9kZVZhbHVlID0gdmNoaWxkcmVuWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHZjaGlsZHJlbiAmJiB2Y2hpbGRyZW4ubGVuZ3RoIHx8IG51bGwgIT0gZmMpIGlubmVyRGlmZk5vZGUob3V0LCB2Y2hpbGRyZW4sIGNvbnRleHQsIG1vdW50QWxsLCBoeWRyYXRpbmcgfHwgbnVsbCAhPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCk7XG4gICAgICAgIGRpZmZBdHRyaWJ1dGVzKG91dCwgdm5vZGUuYXR0cmlidXRlcywgcHJvcHMpO1xuICAgICAgICBpc1N2Z01vZGUgPSBwcmV2U3ZnTW9kZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5uZXJEaWZmTm9kZShkb20sIHZjaGlsZHJlbiwgY29udGV4dCwgbW91bnRBbGwsIGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciBqLCBjLCBmLCB2Y2hpbGQsIGNoaWxkLCBvcmlnaW5hbENoaWxkcmVuID0gZG9tLmNoaWxkTm9kZXMsIGNoaWxkcmVuID0gW10sIGtleWVkID0ge30sIGtleWVkTGVuID0gMCwgbWluID0gMCwgbGVuID0gb3JpZ2luYWxDaGlsZHJlbi5sZW5ndGgsIGNoaWxkcmVuTGVuID0gMCwgdmxlbiA9IHZjaGlsZHJlbiA/IHZjaGlsZHJlbi5sZW5ndGggOiAwO1xuICAgICAgICBpZiAoMCAhPT0gbGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2NoaWxkID0gb3JpZ2luYWxDaGlsZHJlbltpXSwgcHJvcHMgPSBfY2hpbGQuX19wcmVhY3RhdHRyXywga2V5ID0gdmxlbiAmJiBwcm9wcyA/IF9jaGlsZC5fY29tcG9uZW50ID8gX2NoaWxkLl9jb21wb25lbnQuX19rIDogcHJvcHMua2V5IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChudWxsICE9IGtleSkge1xuICAgICAgICAgICAgICAgIGtleWVkTGVuKys7XG4gICAgICAgICAgICAgICAga2V5ZWRba2V5XSA9IF9jaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMgfHwgKHZvaWQgMCAhPT0gX2NoaWxkLnNwbGl0VGV4dCA/IGlzSHlkcmF0aW5nID8gX2NoaWxkLm5vZGVWYWx1ZS50cmltKCkgOiAhMCA6IGlzSHlkcmF0aW5nKSkgY2hpbGRyZW5bY2hpbGRyZW5MZW4rK10gPSBfY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgIT09IHZsZW4pIGZvciAodmFyIGkgPSAwOyBpIDwgdmxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2Y2hpbGQgPSB2Y2hpbGRyZW5baV07XG4gICAgICAgICAgICBjaGlsZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIga2V5ID0gdmNoaWxkLmtleTtcbiAgICAgICAgICAgIGlmIChudWxsICE9IGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXllZExlbiAmJiB2b2lkIDAgIT09IGtleWVkW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBrZXllZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBrZXllZFtrZXldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBrZXllZExlbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNoaWxkICYmIG1pbiA8IGNoaWxkcmVuTGVuKSBmb3IgKGogPSBtaW47IGogPCBjaGlsZHJlbkxlbjsgaisrKSBpZiAodm9pZCAwICE9PSBjaGlsZHJlbltqXSAmJiBpc1NhbWVOb2RlVHlwZShjID0gY2hpbGRyZW5bal0sIHZjaGlsZCwgaXNIeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2pdID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBjaGlsZHJlbkxlbiAtIDEpIGNoaWxkcmVuTGVuLS07XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IG1pbikgbWluKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGlkaWZmKGNoaWxkLCB2Y2hpbGQsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgICAgIGYgPSBvcmlnaW5hbENoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSBkb20gJiYgY2hpbGQgIT09IGYpIGlmIChudWxsID09IGYpIGRvbS5hcHBlbmRDaGlsZChjaGlsZCk7IGVsc2UgaWYgKGNoaWxkID09PSBmLm5leHRTaWJsaW5nKSByZW1vdmVOb2RlKGYpOyBlbHNlIGRvbS5pbnNlcnRCZWZvcmUoY2hpbGQsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXllZExlbikgZm9yICh2YXIgaSBpbiBrZXllZCkgaWYgKHZvaWQgMCAhPT0ga2V5ZWRbaV0pIHJlY29sbGVjdE5vZGVUcmVlKGtleWVkW2ldLCAhMSk7XG4gICAgICAgIHdoaWxlIChtaW4gPD0gY2hpbGRyZW5MZW4pIGlmICh2b2lkIDAgIT09IChjaGlsZCA9IGNoaWxkcmVuW2NoaWxkcmVuTGVuLS1dKSkgcmVjb2xsZWN0Tm9kZVRyZWUoY2hpbGQsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb2xsZWN0Tm9kZVRyZWUobm9kZSwgdW5tb3VudE9ubHkpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IG5vZGUuX2NvbXBvbmVudDtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkgdW5tb3VudENvbXBvbmVudChjb21wb25lbnQpOyBlbHNlIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9IG5vZGUuX19wcmVhY3RhdHRyXyAmJiBub2RlLl9fcHJlYWN0YXR0cl8ucmVmKSBub2RlLl9fcHJlYWN0YXR0cl8ucmVmKG51bGwpO1xuICAgICAgICAgICAgaWYgKCExID09PSB1bm1vdW50T25seSB8fCBudWxsID09IG5vZGUuX19wcmVhY3RhdHRyXykgcmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKG5vZGUsICEwKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpZmZBdHRyaWJ1dGVzKGRvbSwgYXR0cnMsIG9sZCkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgZm9yIChuYW1lIGluIG9sZCkgaWYgKCghYXR0cnMgfHwgbnVsbCA9PSBhdHRyc1tuYW1lXSkgJiYgbnVsbCAhPSBvbGRbbmFtZV0pIHNldEFjY2Vzc29yKGRvbSwgbmFtZSwgb2xkW25hbWVdLCBvbGRbbmFtZV0gPSB2b2lkIDAsIGlzU3ZnTW9kZSk7XG4gICAgICAgIGZvciAobmFtZSBpbiBhdHRycykgaWYgKCEoJ2NoaWxkcmVuJyA9PT0gbmFtZSB8fCAnaW5uZXJIVE1MJyA9PT0gbmFtZSB8fCBuYW1lIGluIG9sZCAmJiBhdHRyc1tuYW1lXSA9PT0gKCd2YWx1ZScgPT09IG5hbWUgfHwgJ2NoZWNrZWQnID09PSBuYW1lID8gZG9tW25hbWVdIDogb2xkW25hbWVdKSkpIHNldEFjY2Vzc29yKGRvbSwgbmFtZSwgb2xkW25hbWVdLCBvbGRbbmFtZV0gPSBhdHRyc1tuYW1lXSwgaXNTdmdNb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sbGVjdENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgKGNvbXBvbmVudHNbbmFtZV0gfHwgKGNvbXBvbmVudHNbbmFtZV0gPSBbXSkpLnB1c2goY29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KEN0b3IsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpbnN0LCBsaXN0ID0gY29tcG9uZW50c1tDdG9yLm5hbWVdO1xuICAgICAgICBpZiAoQ3Rvci5wcm90b3R5cGUgJiYgQ3Rvci5wcm90b3R5cGUucmVuZGVyKSB7XG4gICAgICAgICAgICBpbnN0ID0gbmV3IEN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgQ29tcG9uZW50LmNhbGwoaW5zdCwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgaW5zdC5jb25zdHJ1Y3RvciA9IEN0b3I7XG4gICAgICAgICAgICBpbnN0LnJlbmRlciA9IGRvUmVuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0KSBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGg7IGktLTsgKSBpZiAobGlzdFtpXS5jb25zdHJ1Y3RvciA9PT0gQ3Rvcikge1xuICAgICAgICAgICAgaW5zdC5fX2IgPSBsaXN0W2ldLl9fYjtcbiAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvUmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldENvbXBvbmVudFByb3BzKGNvbXBvbmVudCwgcHJvcHMsIG9wdHMsIGNvbnRleHQsIG1vdW50QWxsKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50Ll9feCkge1xuICAgICAgICAgICAgY29tcG9uZW50Ll9feCA9ICEwO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fX3IgPSBwcm9wcy5yZWYpIGRlbGV0ZSBwcm9wcy5yZWY7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Ll9fayA9IHByb3BzLmtleSkgZGVsZXRlIHByb3BzLmtleTtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LmJhc2UgfHwgbW91bnRBbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxNb3VudCkgY29tcG9uZW50LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgY29tcG9uZW50LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dCAhPT0gY29tcG9uZW50LmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5fX2MpIGNvbXBvbmVudC5fX2MgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5fX3ApIGNvbXBvbmVudC5fX3AgPSBjb21wb25lbnQucHJvcHM7XG4gICAgICAgICAgICBjb21wb25lbnQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX3ggPSAhMTtcbiAgICAgICAgICAgIGlmICgwICE9PSBvcHRzKSBpZiAoMSA9PT0gb3B0cyB8fCAhMSAhPT0gb3B0aW9ucy5zeW5jQ29tcG9uZW50VXBkYXRlcyB8fCAhY29tcG9uZW50LmJhc2UpIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQsIDEsIG1vdW50QWxsKTsgZWxzZSBlbnF1ZXVlUmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Ll9fcikgY29tcG9uZW50Ll9fcihjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQsIG9wdHMsIG1vdW50QWxsLCBpc0NoaWxkKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50Ll9feCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkLCBpbnN0LCBjYmFzZSwgcHJvcHMgPSBjb21wb25lbnQucHJvcHMsIHN0YXRlID0gY29tcG9uZW50LnN0YXRlLCBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQsIHByZXZpb3VzUHJvcHMgPSBjb21wb25lbnQuX19wIHx8IHByb3BzLCBwcmV2aW91c1N0YXRlID0gY29tcG9uZW50Ll9fcyB8fCBzdGF0ZSwgcHJldmlvdXNDb250ZXh0ID0gY29tcG9uZW50Ll9fYyB8fCBjb250ZXh0LCBpc1VwZGF0ZSA9IGNvbXBvbmVudC5iYXNlLCBuZXh0QmFzZSA9IGNvbXBvbmVudC5fX2IsIGluaXRpYWxCYXNlID0gaXNVcGRhdGUgfHwgbmV4dEJhc2UsIGluaXRpYWxDaGlsZENvbXBvbmVudCA9IGNvbXBvbmVudC5fY29tcG9uZW50LCBza2lwID0gITE7XG4gICAgICAgICAgICBpZiAoaXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucHJvcHMgPSBwcmV2aW91c1Byb3BzO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdGF0ZSA9IHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKDIgIT09IG9wdHMgJiYgY29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJiAhMSA9PT0gY29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpKSBza2lwID0gITA7IGVsc2UgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsVXBkYXRlKSBjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudC5fX3AgPSBjb21wb25lbnQuX19zID0gY29tcG9uZW50Ll9fYyA9IGNvbXBvbmVudC5fX2IgPSBudWxsO1xuICAgICAgICAgICAgY29tcG9uZW50Ll9fZCA9ICExO1xuICAgICAgICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWQgPSBjb21wb25lbnQucmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5nZXRDaGlsZENvbnRleHQpIGNvbnRleHQgPSBleHRlbmQoZXh0ZW5kKHt9LCBjb250ZXh0KSwgY29tcG9uZW50LmdldENoaWxkQ29udGV4dCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9Vbm1vdW50LCBiYXNlLCBjaGlsZENvbXBvbmVudCA9IHJlbmRlcmVkICYmIHJlbmRlcmVkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBjaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRQcm9wcyA9IGdldE5vZGVQcm9wcyhyZW5kZXJlZCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3QgPSBpbml0aWFsQ2hpbGRDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0ICYmIGluc3QuY29uc3RydWN0b3IgPT09IGNoaWxkQ29tcG9uZW50ICYmIGNoaWxkUHJvcHMua2V5ID09IGluc3QuX19rKSBzZXRDb21wb25lbnRQcm9wcyhpbnN0LCBjaGlsZFByb3BzLCAxLCBjb250ZXh0LCAhMSk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9Vbm1vdW50ID0gaW5zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5fY29tcG9uZW50ID0gaW5zdCA9IGNyZWF0ZUNvbXBvbmVudChjaGlsZENvbXBvbmVudCwgY2hpbGRQcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0Ll9fYiA9IGluc3QuX19iIHx8IG5leHRCYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC5fX3UgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21wb25lbnRQcm9wcyhpbnN0LCBjaGlsZFByb3BzLCAwLCBjb250ZXh0LCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDb21wb25lbnQoaW5zdCwgMSwgbW91bnRBbGwsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYXNlID0gaW5zdC5iYXNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNiYXNlID0gaW5pdGlhbEJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHRvVW5tb3VudCA9IGluaXRpYWxDaGlsZENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvVW5tb3VudCkgY2Jhc2UgPSBjb21wb25lbnQuX2NvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQmFzZSB8fCAxID09PSBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Jhc2UpIGNiYXNlLl9jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGRpZmYoY2Jhc2UsIHJlbmRlcmVkLCBjb250ZXh0LCBtb3VudEFsbCB8fCAhaXNVcGRhdGUsIGluaXRpYWxCYXNlICYmIGluaXRpYWxCYXNlLnBhcmVudE5vZGUsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEJhc2UgJiYgYmFzZSAhPT0gaW5pdGlhbEJhc2UgJiYgaW5zdCAhPT0gaW5pdGlhbENoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlUGFyZW50ID0gaW5pdGlhbEJhc2UucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VQYXJlbnQgJiYgYmFzZSAhPT0gYmFzZVBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVBhcmVudC5yZXBsYWNlQ2hpbGQoYmFzZSwgaW5pdGlhbEJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0b1VubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQmFzZS5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShpbml0aWFsQmFzZSwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b1VubW91bnQpIHVubW91bnRDb21wb25lbnQodG9Vbm1vdW50KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYmFzZSA9IGJhc2U7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgJiYgIWlzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudCwgdCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPSB0Ll9fdSkgKGNvbXBvbmVudFJlZiA9IHQpLmJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgICAgICAgICBiYXNlLl9jb21wb25lbnQgPSBjb21wb25lbnRSZWY7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UuX2NvbXBvbmVudENvbnN0cnVjdG9yID0gY29tcG9uZW50UmVmLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVcGRhdGUgfHwgbW91bnRBbGwpIG1vdW50cy51bnNoaWZ0KGNvbXBvbmVudCk7IGVsc2UgaWYgKCFza2lwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUpIGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUocHJldmlvdXNQcm9wcywgcHJldmlvdXNTdGF0ZSwgcHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlclVwZGF0ZSkgb3B0aW9ucy5hZnRlclVwZGF0ZShjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bGwgIT0gY29tcG9uZW50Ll9faCkgd2hpbGUgKGNvbXBvbmVudC5fX2gubGVuZ3RoKSBjb21wb25lbnQuX19oLnBvcCgpLmNhbGwoY29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmICghZGlmZkxldmVsICYmICFpc0NoaWxkKSBmbHVzaE1vdW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RnJvbVZOb2RlKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsKSB7XG4gICAgICAgIHZhciBjID0gZG9tICYmIGRvbS5fY29tcG9uZW50LCBvcmlnaW5hbENvbXBvbmVudCA9IGMsIG9sZERvbSA9IGRvbSwgaXNEaXJlY3RPd25lciA9IGMgJiYgZG9tLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWUsIGlzT3duZXIgPSBpc0RpcmVjdE93bmVyLCBwcm9wcyA9IGdldE5vZGVQcm9wcyh2bm9kZSk7XG4gICAgICAgIHdoaWxlIChjICYmICFpc093bmVyICYmIChjID0gYy5fX3UpKSBpc093bmVyID0gYy5jb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG4gICAgICAgIGlmIChjICYmIGlzT3duZXIgJiYgKCFtb3VudEFsbCB8fCBjLl9jb21wb25lbnQpKSB7XG4gICAgICAgICAgICBzZXRDb21wb25lbnRQcm9wcyhjLCBwcm9wcywgMywgY29udGV4dCwgbW91bnRBbGwpO1xuICAgICAgICAgICAgZG9tID0gYy5iYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ29tcG9uZW50ICYmICFpc0RpcmVjdE93bmVyKSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudENvbXBvbmVudChvcmlnaW5hbENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgZG9tID0gb2xkRG9tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSBjcmVhdGVDb21wb25lbnQodm5vZGUubm9kZU5hbWUsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChkb20gJiYgIWMuX19iKSB7XG4gICAgICAgICAgICAgICAgYy5fX2IgPSBkb207XG4gICAgICAgICAgICAgICAgb2xkRG9tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAxLCBjb250ZXh0LCBtb3VudEFsbCk7XG4gICAgICAgICAgICBkb20gPSBjLmJhc2U7XG4gICAgICAgICAgICBpZiAob2xkRG9tICYmIGRvbSAhPT0gb2xkRG9tKSB7XG4gICAgICAgICAgICAgICAgb2xkRG9tLl9jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKG9sZERvbSwgITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVubW91bnRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJlZm9yZVVubW91bnQpIG9wdGlvbnMuYmVmb3JlVW5tb3VudChjb21wb25lbnQpO1xuICAgICAgICB2YXIgYmFzZSA9IGNvbXBvbmVudC5iYXNlO1xuICAgICAgICBjb21wb25lbnQuX194ID0gITA7XG4gICAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICBjb21wb25lbnQuYmFzZSA9IG51bGw7XG4gICAgICAgIHZhciBpbm5lciA9IGNvbXBvbmVudC5fY29tcG9uZW50O1xuICAgICAgICBpZiAoaW5uZXIpIHVubW91bnRDb21wb25lbnQoaW5uZXIpOyBlbHNlIGlmIChiYXNlKSB7XG4gICAgICAgICAgICBpZiAoYmFzZS5fX3ByZWFjdGF0dHJfICYmIGJhc2UuX19wcmVhY3RhdHRyXy5yZWYpIGJhc2UuX19wcmVhY3RhdHRyXy5yZWYobnVsbCk7XG4gICAgICAgICAgICBjb21wb25lbnQuX19iID0gYmFzZTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoYmFzZSk7XG4gICAgICAgICAgICBjb2xsZWN0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50Ll9fcikgY29tcG9uZW50Ll9fcihudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX19kID0gITA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGUgfHwge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBtZXJnZSkge1xuICAgICAgICByZXR1cm4gZGlmZihtZXJnZSwgdm5vZGUsIHt9LCAhMSwgcGFyZW50LCAhMSk7XG4gICAgfVxuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIEVNUFRZX0NISUxEUkVOID0gW107XG4gICAgdmFyIGRlZmVyID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgUHJvbWlzZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSkgOiBzZXRUaW1lb3V0O1xuICAgIHZhciBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgbW91bnRzID0gW107XG4gICAgdmFyIGRpZmZMZXZlbCA9IDA7XG4gICAgdmFyIGlzU3ZnTW9kZSA9ICExO1xuICAgIHZhciBoeWRyYXRpbmcgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50cyA9IHt9O1xuICAgIGV4dGVuZChDb21wb25lbnQucHJvdG90eXBlLCB7XG4gICAgICAgIHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fX3MpIHRoaXMuX19zID0gZXh0ZW5kKHt9LCBzKTtcbiAgICAgICAgICAgIGV4dGVuZChzLCAnZnVuY3Rpb24nID09IHR5cGVvZiBzdGF0ZSA/IHN0YXRlKHMsIHRoaXMucHJvcHMpIDogc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSAodGhpcy5fX2ggPSB0aGlzLl9faCB8fCBbXSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICBlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgKHRoaXMuX19oID0gdGhpcy5fX2ggfHwgW10pLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmVuZGVyQ29tcG9uZW50KHRoaXMsIDIpO1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge31cbiAgICB9KTtcbiAgICB2YXIgcHJlYWN0ID0ge1xuICAgICAgICBoOiBoLFxuICAgICAgICBjcmVhdGVFbGVtZW50OiBoLFxuICAgICAgICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcbiAgICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICByZXJlbmRlcjogcmVyZW5kZXIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IHByZWFjdDsgZWxzZSBzZWxmLnByZWFjdCA9IHByZWFjdDtcbn0oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5qcy5tYXAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuLyoqXG4gKiBTdHJpbmdpZnkgYW4gb2JqZWN0IGZvciB1c2UgaW4gYSBxdWVyeSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IC0gV2hlbiBuZXN0aW5nLCB0aGUgcGFyZW50IGtleS5cbiAqICAgICBrZXlzIGluIGBvYmpgIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgYHByZWZpeFtrZXldYC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBxdWVyeVN0cmluZ2lmeSAob2JqLCBwcmVmaXgpIHtcbiAgdmFyIHBhaXJzID0gW11cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmICghaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IG9ialtrZXldXG4gICAgdmFyIGVua2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICB2YXIgcGFpclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBwYWlyID0gcXVlcnlTdHJpbmdpZnkodmFsdWUsIHByZWZpeCA/IHByZWZpeCArICdbJyArIGVua2V5ICsgJ10nIDogZW5rZXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXIgPSAocHJlZml4ID8gcHJlZml4ICsgJ1snICsgZW5rZXkgKyAnXScgOiBlbmtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpXG4gICAgfVxuICAgIHBhaXJzLnB1c2gocGFpcilcbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgdW5kZWY7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGVuY29kZSBhIGdpdmVuIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGVuY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/IyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAvL1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBlbmNvZGUoa2V5KTtcbiAgICAgIHZhbHVlID0gZW5jb2RlKHZhbHVlKTtcblxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBlbmNvZGUgdGhlIHN0cmluZ3MsIHdlIHNob3VsZCBiYWlsIG91dCBhcyB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBhZGQgaW52YWxpZCBzdHJpbmdzIHRvIHRoZSBxdWVyeS5cbiAgICAgIC8vXG4gICAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsnPScrIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiLyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubGV0IHByb21pc2VcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbidcbiAgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxuICAvLyByZXVzZSByZXNvbHZlZCBwcm9taXNlLCBhbmQgYWxsb2NhdGUgaXQgbGF6aWx5XG4gIDogY2IgPT4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpXG4gICAgLnRoZW4oY2IpXG4gICAgLmNhdGNoKGVyciA9PiBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZXJyIH0sIDApKVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuUmVzaXplT2JzZXJ2ZXIgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcclxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBSZXNpemVPYnNlcnZlclxyXG4gICAgICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICAgICAqL1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYywgdmFsaWQtanNkb2MgKi9cclxuICAgIHZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEluZGV4KGFyciwga2V5KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN0eCA9PT0gdm9pZCAwKSB7IGN0eCA9IG51bGw7IH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZW50cnlbMV0sIGVudHJ5WzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICAgICAgfSgpKTtcclxuICAgIH0pKCk7XG5cbiAgICAvKipcclxuICAgICAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gICAgICovXHJcbiAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50O1xuXG4gICAgLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgIHZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbiAgICB9KSgpO1xuXG4gICAgLyoqXHJcbiAgICAgKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gICAgICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAgICAgKi9cclxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgICAgICAvLyBhbiBcIkludmFsaWQgY2FsbGluZyBvYmplY3RcIiBlcnJvciBpZiByQUYgaXMgaW52b2tlZCB3aXRob3V0IHRoZSBnbG9iYWxcclxuICAgICAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxuICAgIH0pKCk7XG5cbiAgICAvLyBEZWZpbmVzIG1pbmltdW0gdGltZW91dCBiZWZvcmUgYWRkaW5nIGEgdHJhaWxpbmcgY2FsbC5cclxuICAgIHZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG4gICAgICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVQZW5kaW5nKCkge1xyXG4gICAgICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgICAgIHByb3h5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBwcm94eSgpIHtcclxuICAgICAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBjYWxscy5cclxuICAgICAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgc28gdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB3ZSBtaWdodCBtaXNzIG9uZSBpZiBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9XG5cbiAgICAvLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxuICAgIHZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbiAgICAvLyBBIGxpc3Qgb2Ygc3Vic3RyaW5ncyBvZiBDU1MgcHJvcGVydGllcyB1c2VkIHRvIGZpbmQgdHJhbnNpdGlvbiBldmVudHMgdGhhdFxyXG4gICAgLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbiAgICB2YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuICAgIC8vIENoZWNrIGlmIE11dGF0aW9uT2JzZXJ2ZXIgaXMgYXZhaWxhYmxlLlxyXG4gICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICAvKipcclxuICAgICAqIFNpbmdsZXRvbiBjb250cm9sbGVyIGNsYXNzIHdoaWNoIGhhbmRsZXMgdXBkYXRlcyBvZiBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7TXV0YXRpb25PYnNlcnZlcn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2ZXJTUEk+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kXyA9IHRoaXMub25UcmFuc2l0aW9uRW5kXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIGFkZGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9ic2VydmVyIGlmIGl0J3MgcHJlc2VudCBpbiByZWdpc3RyeS5cclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgICAgIC8vIGJlIGZ1dHVyZSBvbmVzIGNhdXNlZCBieSBDU1MgdHJhbnNpdGlvbnMuXHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGV2ZXJ5IG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QgYW5kIG5vdGlmaWVzIHRoZW0gb2YgcXVldWVkXHJcbiAgICAgICAgICogZW50cmllcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gRGVsaXZlciBub3RpZmljYXRpb25zIGluIGEgc2VwYXJhdGUgY3ljbGUgaW4gb3JkZXIgdG8gYXZvaWQgYW55XHJcbiAgICAgICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAgICAgLy8gb2YgdGhlbSBjaGFuZ2VzIGNvbnRlbnQgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgdGFyZ2V0LiBTb21ldGltZXNcclxuICAgICAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZU9ic2VydmVycy5sZW5ndGggPiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgICAgICAvLyBkZWxheWVkIHRyYW5zaXRpb25zLiBUaGlzIHdheSBpdCdzIHBvc3NpYmxlIHRvIGNhcHR1cmUgYXQgbGVhc3QgdGhlXHJcbiAgICAgICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSByZW1vdmVkLlxyXG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXykge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIF9iID0gX2EucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcclxuICAgICAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIX5wcm9wZXJ0eU5hbWUuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VfO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyJ3MgaW5zdGFuY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbiAgICB9KCkpO1xuXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB2YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfSk7XG5cbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAvLyBBc3N1bWUgdGhhdCB0aGUgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiBOb2RlLCB3aGljaCBtZWFucyB0aGF0IGl0XHJcbiAgICAgICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgICAgIHZhciBvd25lckdsb2JhbCA9IHRhcmdldCAmJiB0YXJnZXQub3duZXJEb2N1bWVudCAmJiB0YXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgICAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgICAgcmV0dXJuIG93bmVyR2xvYmFsIHx8IGdsb2JhbCQxO1xyXG4gICAgfSk7XG5cbiAgICAvLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgIHZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplICsgdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFBhZGRpbmdzKHN0eWxlcykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcG9zaXRpb25zXzEgPSBwb3NpdGlvbnM7IF9pIDwgcG9zaXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgICAgIHBhZGRpbmdzW3Bvc2l0aW9uXSA9IHRvRmxvYXQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFkZGluZ3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICAgICAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgICAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgICAgIHZhciBjbGllbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgICAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAgICAgLy8gdGhhbiAwLjUgd2lsbCBiZSBkaXNjYXJkZWQgYXMgd2VsbC5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgICAgIC8vIHRob3NlIGNhc2VzIGFuZCBpdCdzIG5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGEgcHJlY2lzZSBhbmQgcGVyZm9ybWFuY2VcclxuICAgICAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgICAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICAgICAgaWYgKCFjbGllbnRXaWR0aCAmJiAhY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcclxuICAgICAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgICAgICB2YXIgdmVydFBhZCA9IHBhZGRpbmdzLnRvcCArIHBhZGRpbmdzLmJvdHRvbTtcclxuICAgICAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgICAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAgICAgLy8gYmUgcG9zc2libGUgdG8gdXRpbGl6ZSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlmIG9ubHkgaXQncyBkYXRhIHdhc24ndFxyXG4gICAgICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgICAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAgICAgLy8gV2lkdGggJiBoZWlnaHQgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB3aGVuIHRoZSAnYm9yZGVyLWJveCcgYm94XHJcbiAgICAgICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICAgICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgICAgICAvLyBGb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgcmVxdWlyZWQgdG8gaGFuZGxlIEludGVybmV0IEV4cGxvcmVyIHdoaWNoXHJcbiAgICAgICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gV2UgY2FuIHNheSB0aGF0IGlmIENTUyBkaW1lbnNpb25zICsgcGFkZGluZ3MgYXJlIGVxdWFsIHRvIHRoZSBcImNsaWVudFwiXHJcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgICAgICBpZiAoTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAhPT0gY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpICE9PSBjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgICAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAgICAgLy8gQmVzaWRlcywgaXQncyBhcyB3ZWxsIG5vdCBuZWNlc3NhcnkgYXMgdGhlIDxodG1sPiBpdHNlbGYgbmVpdGhlciBoYXNcclxuICAgICAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgKG9ubHkgaW4gRmlyZWZveCwgYWN0dWFsbHkpIENTUyB3aWR0aCAmIGhlaWdodFxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAgICAgLy8gYW5kIFwiY2xpZW50XCIgcHJvcGVydGllcywgdGhvdWdoIHRoYXQgaXMgbm90IGFsd2F5cyB0cnVlIGluIENocm9tZS5cclxuICAgICAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIENocm9tZSBoYXMgYSByYXRoZXIgd2VpcmQgcm91bmRpbmcgb2YgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAgICAgLy8gMzE0cHguIEFuZCBpdCBkb2Vzbid0IGhhcHBlbiBhbGwgdGhlIHRpbWUuIFNvIGp1c3QgaWdub3JlIHRoaXMgZGVsdGFcclxuICAgICAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgLT0gaG9yaXpTY3JvbGxiYXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KHBhZGRpbmdzLmxlZnQsIHBhZGRpbmdzLnRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFNWR0dyYXBoaWNzRWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB2YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMsIG5hbWVseSBJRSBhbmQgRWRnZSwgZG9uJ3QgaGF2ZSB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50XHJcbiAgICAgICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdHcmFwaGljc0VsZW1lbnQ7IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgICAgIC8vIFNWR0VsZW1lbnQgYW5kIHRoYXQgaXQgaGFzIHRoZSBcImdldEJCb3hcIiBtZXRob2QuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB0YXJnZXQuZ2V0QkJveCA9PT0gJ2Z1bmN0aW9uJyk7IH07XHJcbiAgICB9KSgpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGEgZG9jdW1lbnQgZWxlbWVudCAoPGh0bWw+KS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0ID09PSBnZXRXaW5kb3dPZih0YXJnZXQpLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbiBhcHByb3ByaWF0ZSBjb250ZW50IHJlY3RhbmdsZSBmb3IgcHJvdmlkZWQgaHRtbCBvciBzdmcgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU1ZHR3JhcGhpY3NFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgcmVjdGFuZ2xlIHdpdGggYW4gaW50ZXJmYWNlIG9mIHRoZSBET01SZWN0UmVhZE9ubHkuXHJcbiAgICAgKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBPYmplY3Qgd2l0aCByZWN0YW5nbGUncyB4L3kgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMuXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcclxuICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICAgICAgdmFyIENvbnN0ciA9IHR5cGVvZiBET01SZWN0UmVhZE9ubHkgIT09ICd1bmRlZmluZWQnID8gRE9NUmVjdFJlYWRPbmx5IDogT2JqZWN0O1xyXG4gICAgICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgICAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgICAgIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XHJcbiAgICAgICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIHRvcDogeSxcclxuICAgICAgICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcclxuICAgICAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgICAgICBsZWZ0OiB4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gICAgICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gUmVjdGFuZ2xlJ3Mgd2lkdGguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAgICAgKiBwcm92aWRlZCBET00gZWxlbWVudCBhbmQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaXQncyBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtET01SZWN0SW5pdH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIGFuZCB0ZWxscyB3aGV0aGVyIGl0J3Mgd2lkdGggb3IgaGVpZ2h0IHByb3BlcnRpZXNcclxuICAgICAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICE9PSB0aGlzLmJyb2FkY2FzdEhlaWdodCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzICdicm9hZGNhc3RXaWR0aCcgYW5kICdicm9hZGNhc3RIZWlnaHQnIHByb3BlcnRpZXMgd2l0aCBhIGRhdGFcclxuICAgICAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9IExhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50UmVjdF87XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyRW50cnkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIERhdGEgb2YgdGhlIGVsZW1lbnQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY3JlYXRlUmVhZE9ubHlSZWN0KHJlY3RJbml0KTtcclxuICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgICAgIC8vIGRvbid0IHN1cHBvcnQgdGhpcyB0eXBlIG9mIGNvbGxlY3Rpb25zLlxyXG4gICAgICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJFbnRyeTtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWRcclxuICAgICAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICAgICAqICAgICAgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB1cGRhdGVzIG9mIG9ic2VydmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29sbGVjdGlvbiBvZiByZXNpemUgb2JzZXJ2YXRpb25zIHRoYXQgaGF2ZSBkZXRlY3RlZCBjaGFuZ2VzIGluIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtNYXA8RWxlbWVudCwgUmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdHMgb2JzZXJ2YXRpb24gaW5zdGFuY2VzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgb2Ygd2hpY2ggaGFzIGNoYW5nZWRcclxuICAgICAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZhdGlvbi5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnZva2VzIGluaXRpYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIGxpc3Qgb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeVxyXG4gICAgICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgb2JzZXJ2ZXIgZG9lc24ndCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubWFwKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tfLmNhbGwoY3R4LCBlbnRyaWVzLCBjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHdoZXRoZXIgb2JzZXJ2ZXIgaGFzIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbiAgICB9KCkpO1xuXG4gICAgLy8gUmVnaXN0cnkgb2YgaW50ZXJuYWwgb2JzZXJ2ZXJzLiBJZiBXZWFrTWFwIGlzIG5vdCBhdmFpbGFibGUgdXNlIGN1cnJlbnQgc2hpbVxyXG4gICAgLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4gICAgLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbiAgICB2YXIgb2JzZXJ2ZXJzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gbmV3IFdlYWtNYXAoKSA6IG5ldyBNYXBTaGltKCk7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICAgICAqIGV4cG9zaW5nIG9ubHkgdGhvc2UgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSBzcGVjLlxyXG4gICAgICovXHJcbiAgICB2YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlblxyXG4gICAgICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc2V0KHRoaXMsIG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfSgpKTtcclxuICAgIC8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgIFtcclxuICAgICAgICAnb2JzZXJ2ZScsXHJcbiAgICAgICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAgICAgJ2Rpc2Nvbm5lY3QnXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBvYnNlcnZlcnMuZ2V0KHRoaXMpKVttZXRob2RdLmFwcGx5KF9hLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcblxuICAgIHZhciBpbmRleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG5cbn0pKSk7XG4iLCIvKiEgcnVuLXBhcmFsbGVsLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5tb2R1bGUuZXhwb3J0cyA9IHJ1blBhcmFsbGVsXG5cbmNvbnN0IHF1ZXVlTWljcm90YXNrID0gcmVxdWlyZSgncXVldWUtbWljcm90YXNrJylcblxuZnVuY3Rpb24gcnVuUGFyYWxsZWwgKHRhc2tzLCBjYikge1xuICBsZXQgcmVzdWx0cywgcGVuZGluZywga2V5c1xuICBsZXQgaXNTeW5jID0gdHJ1ZVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRhc2tzKSkge1xuICAgIHJlc3VsdHMgPSBbXVxuICAgIHBlbmRpbmcgPSB0YXNrcy5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModGFza3MpXG4gICAgcmVzdWx0cyA9IHt9XG4gICAgcGVuZGluZyA9IGtleXMubGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgaWYgKGNiKSBjYihlcnIsIHJlc3VsdHMpXG4gICAgICBjYiA9IG51bGxcbiAgICB9XG4gICAgaWYgKGlzU3luYykgcXVldWVNaWNyb3Rhc2soZW5kKVxuICAgIGVsc2UgZW5kKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhY2ggKGksIGVyciwgcmVzdWx0KSB7XG4gICAgcmVzdWx0c1tpXSA9IHJlc3VsdFxuICAgIGlmICgtLXBlbmRpbmcgPT09IDAgfHwgZXJyKSB7XG4gICAgICBkb25lKGVycilcbiAgICB9XG4gIH1cblxuICBpZiAoIXBlbmRpbmcpIHtcbiAgICAvLyBlbXB0eVxuICAgIGRvbmUobnVsbClcbiAgfSBlbHNlIGlmIChrZXlzKSB7XG4gICAgLy8gb2JqZWN0XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHRhc2tzW2tleV0oZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goa2V5LCBlcnIsIHJlc3VsdCkgfSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGFycmF5XG4gICAgdGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaywgaSkge1xuICAgICAgdGFzayhmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChpLCBlcnIsIHJlc3VsdCkgfSlcbiAgICB9KVxuICB9XG5cbiAgaXNTeW5jID0gZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9pc1JlYWN0TmF0aXZlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1JlYWN0TmF0aXZlXCIpKTtcblxudmFyIF91cmlUb0Jsb2IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3VyaVRvQmxvYlwiKSk7XG5cbnZhciBfaXNDb3Jkb3ZhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0NvcmRvdmFcIikpO1xuXG52YXIgX3JlYWRBc0J5dGVBcnJheSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVhZEFzQnl0ZUFycmF5XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgRmlsZVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIE1ha2UgdGhpcy5zaXplIGEgbWV0aG9kXG4gIGZ1bmN0aW9uIEZpbGVTb3VyY2UoZmlsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlU291cmNlKTtcblxuICAgIHRoaXMuX2ZpbGUgPSBmaWxlO1xuICAgIHRoaXMuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWxlU291cmNlLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAvLyBJbiBBcGFjaGUgQ29yZG92YSBhcHBsaWNhdGlvbnMsIGEgRmlsZSBtdXN0IGJlIHJlc29sdmVkIHVzaW5nXG4gICAgICAvLyBGaWxlUmVhZGVyIGluc3RhbmNlcywgc2VlXG4gICAgICAvLyBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuLzgueC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gICAgICBpZiAoKDAsIF9pc0NvcmRvdmEuZGVmYXVsdCkoKSkge1xuICAgICAgICByZXR1cm4gKDAsIF9yZWFkQXNCeXRlQXJyYXkuZGVmYXVsdCkodGhpcy5fZmlsZS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHsvLyBOb3RoaW5nIHRvIGRvIGhlcmUgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMuXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVTb3VyY2U7XG59KCk7XG5cbnZhciBTdHJlYW1Tb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJlYW1Tb3VyY2UocmVhZGVyLCBjaHVua1NpemUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyZWFtU291cmNlKTtcblxuICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICB0aGlzLl9idWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmVhbVNvdXJjZSwgW3tcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5fYnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgZGF0YSBpcyBiZWZvcmUgdGhlIHJlYWRlcidzIGN1cnJlbnQgb2Zmc2V0XCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBoYXNFbm91Z2hEYXRhID0gZW5kIDw9IHRoaXMuX2J1ZmZlck9mZnNldCArIGxlbih0aGlzLl9idWZmZXIpO1xuXG4gICAgICBpZiAodGhpcy5fZG9uZSB8fCBoYXNFbm91Z2hEYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldERhdGFGcm9tQnVmZmVyKHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIHZhciBkb25lID0gdmFsdWUgPT0gbnVsbCA/IHRoaXMuX2RvbmUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgICAgIGRvbmUgPSBfcmVmLmRvbmU7XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBfdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuX2J1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMuX2J1ZmZlciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9idWZmZXIgPSBjb25jYXQoX3RoaXMuX2J1ZmZlciwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREYXRhRnJvbUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGF0YUZyb21CdWZmZXIoc3RhcnQsIGVuZCkge1xuICAgICAgLy8gUmVtb3ZlIGRhdGEgZnJvbSBidWZmZXIgYmVmb3JlIGBzdGFydGAuXG4gICAgICAvLyBEYXRhIG1pZ2h0IGJlIHJlcmVhZCBmcm9tIHRoZSBidWZmZXIgaWYgYW4gdXBsb2FkIGZhaWxzLCBzbyB3ZSBjYW4gb25seVxuICAgICAgLy8gc2FmZWx5IGRlbGV0ZSBkYXRhIHdoZW4gaXQgY29tZXMgKmJlZm9yZSogd2hhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC5cbiAgICAgIGlmIChzdGFydCA+IHRoaXMuX2J1ZmZlck9mZnNldCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2Uoc3RhcnQgLSB0aGlzLl9idWZmZXJPZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSBzdGFydDtcbiAgICAgIH0gLy8gSWYgdGhlIGJ1ZmZlciBpcyBlbXB0eSBhZnRlciByZW1vdmluZyBvbGQgZGF0YSwgYWxsIGRhdGEgaGFzIGJlZW4gcmVhZC5cblxuXG4gICAgICB2YXIgaGFzQWxsRGF0YUJlZW5SZWFkID0gbGVuKHRoaXMuX2J1ZmZlcikgPT09IDA7XG5cbiAgICAgIGlmICh0aGlzLl9kb25lICYmIGhhc0FsbERhdGFCZWVuUmVhZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gV2UgYWxyZWFkeSByZW1vdmVkIGRhdGEgYmVmb3JlIGBzdGFydGAsIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmaXJzdFxuICAgICAgLy8gY2h1bmsgZnJvbSB0aGUgYnVmZmVyLlxuXG5cbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuc2xpY2UoMCwgZW5kIC0gc3RhcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkZXIuY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyZWFtU291cmNlO1xufSgpO1xuXG5mdW5jdGlvbiBsZW4oYmxvYk9yQXJyYXkpIHtcbiAgaWYgKGJsb2JPckFycmF5ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICBpZiAoYmxvYk9yQXJyYXkuc2l6ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYmxvYk9yQXJyYXkuc2l6ZTtcbiAgcmV0dXJuIGJsb2JPckFycmF5Lmxlbmd0aDtcbn1cbi8qXG4gIFR5cGVkIGFycmF5cyBhbmQgYmxvYnMgZG9uJ3QgaGF2ZSBhIGNvbmNhdCBtZXRob2QuXG4gIFRoaXMgZnVuY3Rpb24gaGVscHMgU3RyZWFtU291cmNlIGFjY3VtdWxhdGUgZGF0YSB0byByZWFjaCBjaHVua1NpemUuXG4qL1xuXG5cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGlmIChhLmNvbmNhdCkge1xuICAgIC8vIElzIGBhYCBhbiBBcnJheT9cbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW2EsIGJdLCB7XG4gICAgICB0eXBlOiBhLnR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhLnNldCkge1xuICAgIC8vIElzIGBhYCBhIHR5cGVkIGFycmF5P1xuICAgIHZhciBjID0gbmV3IGEuY29uc3RydWN0b3IoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgYy5zZXQoYSk7XG4gICAgYy5zZXQoYiwgYS5sZW5ndGgpO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGVcIik7XG59XG5cbnZhciBGaWxlUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmlsZVJlYWRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsZVJlYWRlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmlsZVJlYWRlciwgW3tcbiAgICBrZXk6IFwib3BlbkZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbkZpbGUoaW5wdXQsIGNodW5rU2l6ZSkge1xuICAgICAgLy8gSW4gUmVhY3QgTmF0aXZlLCB3aGVuIHVzZXIgc2VsZWN0cyBhIGZpbGUsIGluc3RlYWQgb2YgYSBGaWxlIG9yIEJsb2IsXG4gICAgICAvLyB5b3UgdXN1YWxseSBnZXQgYSBmaWxlIG9iamVjdCB7fSB3aXRoIGEgdXJpIHByb3BlcnR5IHRoYXQgY29udGFpbnNcbiAgICAgIC8vIGEgbG9jYWwgcGF0aCB0byB0aGUgZmlsZS4gV2UgdXNlIFhNTEh0dHBSZXF1ZXN0IHRvIGZldGNoXG4gICAgICAvLyB0aGUgZmlsZSBibG9iLCBiZWZvcmUgdXBsb2FkaW5nIHdpdGggdHVzLlxuICAgICAgaWYgKCgwLCBfaXNSZWFjdE5hdGl2ZS5kZWZhdWx0KSgpICYmIGlucHV0ICYmIHR5cGVvZiBpbnB1dC51cmkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfdXJpVG9CbG9iLmRlZmF1bHQpKGlucHV0LnVyaSkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgIHJldHVybiBuZXcgRmlsZVNvdXJjZShibG9iKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHVzOiBjYW5ub3QgZmV0Y2ggYGZpbGUudXJpYCBhcyBCbG9iLCBtYWtlIHN1cmUgdGhlIHVyaSBpcyBjb3JyZWN0IGFuZCBhY2Nlc3NpYmxlLiBcIiArIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBTaW5jZSB3ZSBlbXVsYXRlIHRoZSBCbG9iIHR5cGUgaW4gb3VyIHRlc3RzIChub3QgYWxsIHRhcmdldCBicm93c2Vyc1xuICAgICAgLy8gc3VwcG9ydCBpdCksIHdlIGNhbm5vdCB1c2UgYGluc3RhbmNlb2ZgIGZvciB0ZXN0aW5nIHdoZXRoZXIgdGhlIGlucHV0IHZhbHVlXG4gICAgICAvLyBjYW4gYmUgaGFuZGxlZC4gSW5zdGVhZCwgd2Ugc2ltcGx5IGNoZWNrIGlzIHRoZSBzbGljZSgpIGZ1bmN0aW9uIGFuZCB0aGVcbiAgICAgIC8vIHNpemUgcHJvcGVydHkgYXJlIGF2YWlsYWJsZS5cblxuXG4gICAgICBpZiAodHlwZW9mIGlucHV0LnNsaWNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGlucHV0LnNpemUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRmlsZVNvdXJjZShpbnB1dCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGlucHV0LnJlYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjaHVua1NpemUgPSArY2h1bmtTaXplO1xuXG4gICAgICAgIGlmICghaXNGaW5pdGUoY2h1bmtTaXplKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJjYW5ub3QgY3JlYXRlIHNvdXJjZSBmb3Igc3RyZWFtIHdpdGhvdXQgYSBmaW5pdGUgdmFsdWUgZm9yIHRoZSBgY2h1bmtTaXplYCBvcHRpb25cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU3RyZWFtU291cmNlKGlucHV0LCBjaHVua1NpemUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNvdXJjZSBvYmplY3QgbWF5IG9ubHkgYmUgYW4gaW5zdGFuY2Ugb2YgRmlsZSwgQmxvYiwgb3IgUmVhZGVyIGluIHRoaXMgZW52aXJvbm1lbnRcIikpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWxlUmVhZGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGaWxlUmVhZGVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmluZ2VycHJpbnQ7XG5cbnZhciBfaXNSZWFjdE5hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNSZWFjdE5hdGl2ZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIFRPRE86IERpZmZlcmVuY2lhdGUgYmV0d2VlbiBpbnB1dCB0eXBlc1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmluZ2VycHJpbnQgZm9yIGEgZmlsZSB3aGljaCB3aWxsIGJlIHVzZWQgdGhlIHN0b3JlIHRoZSBlbmRwb2ludFxuICpcbiAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpIHtcbiAgaWYgKCgwLCBfaXNSZWFjdE5hdGl2ZS5kZWZhdWx0KSgpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFjdE5hdGl2ZUZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoW1widHVzLWJyXCIsIGZpbGUubmFtZSwgZmlsZS50eXBlLCBmaWxlLnNpemUsIGZpbGUubGFzdE1vZGlmaWVkLCBvcHRpb25zLmVuZHBvaW50XS5qb2luKFwiLVwiKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWN0TmF0aXZlRmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucykge1xuICB2YXIgZXhpZkhhc2ggPSBmaWxlLmV4aWYgPyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShmaWxlLmV4aWYpKSA6IFwibm9leGlmXCI7XG4gIHJldHVybiBbXCJ0dXMtcm5cIiwgZmlsZS5uYW1lIHx8IFwibm9uYW1lXCIsIGZpbGUuc2l6ZSB8fCBcIm5vc2l6ZVwiLCBleGlmSGFzaCwgb3B0aW9ucy5lbmRwb2ludF0uam9pbihcIi9cIik7XG59XG5cbmZ1bmN0aW9uIGhhc2hDb2RlKHN0cikge1xuICAvLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84ODMxOTM3LzE1MTY2NlxuICB2YXIgaGFzaCA9IDA7XG5cbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgX2NoYXI7XG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIFhIUkh0dHBTdGFjayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhIUkh0dHBTdGFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWEhSSHR0cFN0YWNrKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYSFJIdHRwU3RhY2ssIFt7XG4gICAga2V5OiBcImNyZWF0ZVJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lKCkge1xuICAgICAgcmV0dXJuIFwiWEhSSHR0cFN0YWNrXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFhIUkh0dHBTdGFjaztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gWEhSSHR0cFN0YWNrO1xuXG52YXIgUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVxdWVzdCk7XG5cbiAgICB0aGlzLl94aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHRoaXMuX3hoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5faGVhZGVycyA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlcXVlc3QsIFt7XG4gICAga2V5OiBcImdldE1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRob2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0aG9kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVUkxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VVJMKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhlYWRlcihoZWFkZXIsIHZhbHVlKSB7XG4gICAgICB0aGlzLl94aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcblxuICAgICAgdGhpcy5faGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9ncmVzc0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvZ3Jlc3NIYW5kbGVyKHByb2dyZXNzSGFuZGxlcikge1xuICAgICAgLy8gVGVzdCBzdXBwb3J0IGZvciBwcm9ncmVzcyBldmVudHMgYmVmb3JlIGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgaWYgKCEoXCJ1cGxvYWRcIiBpbiB0aGlzLl94aHIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5feGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmVzc0hhbmRsZXIoZS5sb2FkZWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGJvZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpcy5feGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShfdGhpcy5feGhyKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX3hoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLl94aHIuc2VuZChib2R5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhYm9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVuZGVybHlpbmdPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VW5kZXJseWluZ09iamVjdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlcXVlc3Q7XG59KCk7XG5cbnZhciBSZXNwb25zZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3BvbnNlKHhocikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zZSk7XG5cbiAgICB0aGlzLl94aHIgPSB4aHI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVzcG9uc2UsIFt7XG4gICAga2V5OiBcImdldFN0YXR1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLnN0YXR1cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlYWRlcihoZWFkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm9keVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVuZGVybHlpbmdPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VW5kZXJseWluZ09iamVjdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlc3BvbnNlO1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5hYmxlRGVidWdMb2dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2xvZ2dlci5lbmFibGVEZWJ1Z0xvZztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYW5TdG9yZVVSTHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3VybFN0b3JhZ2UuY2FuU3RvcmVVUkxzO1xuICB9XG59KTtcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5VcGxvYWQgPSB2b2lkIDA7XG5cbnZhciBfdXBsb2FkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXBsb2FkXCIpKTtcblxudmFyIF9ub29wVXJsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vb3BVcmxTdG9yYWdlXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xuXG52YXIgX3VybFN0b3JhZ2UgPSByZXF1aXJlKFwiLi91cmxTdG9yYWdlXCIpO1xuXG52YXIgX2h0dHBTdGFjayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaHR0cFN0YWNrXCIpKTtcblxudmFyIF9maWxlUmVhZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9maWxlUmVhZGVyXCIpKTtcblxudmFyIF9maW5nZXJwcmludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmluZ2VycHJpbnRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG4vKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgX3VwbG9hZC5kZWZhdWx0LmRlZmF1bHRPcHRpb25zLCB7XG4gIGh0dHBTdGFjazogbmV3IF9odHRwU3RhY2suZGVmYXVsdCgpLFxuICBmaWxlUmVhZGVyOiBuZXcgX2ZpbGVSZWFkZXIuZGVmYXVsdCgpLFxuICB1cmxTdG9yYWdlOiBfdXJsU3RvcmFnZS5jYW5TdG9yZVVSTHMgPyBuZXcgX3VybFN0b3JhZ2UuV2ViU3RvcmFnZVVybFN0b3JhZ2UoKSA6IG5ldyBfbm9vcFVybFN0b3JhZ2UuZGVmYXVsdCgpLFxuICBmaW5nZXJwcmludDogX2ZpbmdlcnByaW50LmRlZmF1bHRcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG5cbnZhciBVcGxvYWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlVXBsb2FkKSB7XG4gIF9pbmhlcml0cyhVcGxvYWQsIF9CYXNlVXBsb2FkKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFVwbG9hZCk7XG5cbiAgZnVuY3Rpb24gVXBsb2FkKCkge1xuICAgIHZhciBmaWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVcGxvYWQpO1xuXG4gICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLCB7fSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZpbGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFVwbG9hZCwgbnVsbCwgW3tcbiAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSh1cmwsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMsIHt9LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBfdXBsb2FkLmRlZmF1bHQudGVybWluYXRlKHVybCwgb3B0aW9ucywgY2IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVcGxvYWQ7XG59KF91cGxvYWQuZGVmYXVsdCk7XG5cbmV4cG9ydHMuVXBsb2FkID0gVXBsb2FkO1xudmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgWE1MSHR0cFJlcXVlc3QgPSBfd2luZG93LlhNTEh0dHBSZXF1ZXN0LFxuICAgIEJsb2IgPSBfd2luZG93LkJsb2I7XG52YXIgaXNTdXBwb3J0ZWQgPSBYTUxIdHRwUmVxdWVzdCAmJiBCbG9iICYmIHR5cGVvZiBCbG9iLnByb3RvdHlwZS5zbGljZSA9PT0gXCJmdW5jdGlvblwiO1xuZXhwb3J0cy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaXNDb3Jkb3ZhID0gZnVuY3Rpb24gaXNDb3Jkb3ZhKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2Ygd2luZG93LlBob25lR2FwICE9IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdy5Db3Jkb3ZhICE9IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdy5jb3Jkb3ZhICE9IFwidW5kZWZpbmVkXCIpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gaXNDb3Jkb3ZhO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBpc1JlYWN0TmF0aXZlID0gZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcInN0cmluZ1wiICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09IFwicmVhY3RuYXRpdmVcIjtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGlzUmVhY3ROYXRpdmU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlYWRBc0J5dGVBcnJheTtcblxuLyoqXG4gKiByZWFkQXNCeXRlQXJyYXkgY29udmVydHMgYSBGaWxlIG9iamVjdCB0byBhIFVpbnQ4QXJyYXkuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBvbiB0aGUgQXBhY2hlIENvcmRvdmEgcGxhdGZvcm0uXG4gKiBTZWUgaHR0cHM6Ly9jb3Jkb3ZhLmFwYWNoZS5vcmcvZG9jcy9lbi9sYXRlc3QvcmVmZXJlbmNlL2NvcmRvdmEtcGx1Z2luLWZpbGUvaW5kZXguaHRtbCNyZWFkLWEtZmlsZVxuICovXG5mdW5jdGlvbiByZWFkQXNCeXRlQXJyYXkoY2h1bmspIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0KTtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG5cbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoY2h1bmspO1xuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaVRvQmxvYjtcblxuLyoqXG4gKiB1cmlUb0Jsb2IgcmVzb2x2ZXMgYSBVUkkgdG8gYSBCbG9iIG9iamVjdC4gVGhpcyBpcyB1c2VkIGZvclxuICogUmVhY3QgTmF0aXZlIHRvIHJldHJpZXZlIGEgZmlsZSAoaWRlbnRpZmllZCBieSBhIGZpbGU6Ly9cbiAqIFVSSSkgYXMgYSBibG9iLlxuICovXG5mdW5jdGlvbiB1cmlUb0Jsb2IodXJpKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImJsb2JcIjtcblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYmxvYiA9IHhoci5yZXNwb25zZTtcbiAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgfTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfTtcblxuICAgIHhoci5vcGVuKFwiR0VUXCIsIHVyaSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLldlYlN0b3JhZ2VVcmxTdG9yYWdlID0gZXhwb3J0cy5jYW5TdG9yZVVSTHMgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3csIGxvY2FsU3RvcmFnZSAqL1xuXG5cbnZhciBoYXNTdG9yYWdlID0gZmFsc2U7XG5cbnRyeSB7XG4gIGhhc1N0b3JhZ2UgPSBcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdzsgLy8gQXR0ZW1wdCB0byBzdG9yZSBhbmQgcmVhZCBlbnRyaWVzIGZyb20gdGhlIGxvY2FsIHN0b3JhZ2UgdG8gZGV0ZWN0IFByaXZhdGVcbiAgLy8gTW9kZSBvbiBTYWZhcmkgb24gaU9TIChzZWUgIzQ5KVxuXG4gIHZhciBrZXkgPSBcInR1c1N1cHBvcnRcIjtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gSWYgd2UgdHJ5IHRvIGFjY2VzcyBsb2NhbFN0b3JhZ2UgaW5zaWRlIGEgc2FuZGJveGVkIGlmcmFtZSwgYSBTZWN1cml0eUVycm9yXG4gIC8vIGlzIHRocm93bi4gV2hlbiBpbiBwcml2YXRlIG1vZGUgb24gaU9TIFNhZmFyaSwgYSBRdW90YUV4Y2VlZGVkRXJyb3IgaXNcbiAgLy8gdGhyb3duIChzZWUgIzQ5KVxuICBpZiAoZS5jb2RlID09PSBlLlNFQ1VSSVRZX0VSUiB8fCBlLmNvZGUgPT09IGUuUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgaGFzU3RvcmFnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxudmFyIGNhblN0b3JlVVJMcyA9IGhhc1N0b3JhZ2U7XG5leHBvcnRzLmNhblN0b3JlVVJMcyA9IGNhblN0b3JlVVJMcztcblxudmFyIFdlYlN0b3JhZ2VVcmxTdG9yYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViU3RvcmFnZVVybFN0b3JhZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYlN0b3JhZ2VVcmxTdG9yYWdlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJTdG9yYWdlVXJsU3RvcmFnZSwgW3tcbiAgICBrZXk6IFwiZmluZEFsbFVwbG9hZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFsbFVwbG9hZHMoKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuX2ZpbmRFbnRyaWVzKFwidHVzOjpcIik7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRVcGxvYWRzQnlGaW5nZXJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fZmluZEVudHJpZXMoXCJ0dXM6OlwiLmNvbmNhdChmaW5nZXJwcmludCwgXCI6OlwiKSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVcGxvYWQodXJsU3RvcmFnZUtleSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odXJsU3RvcmFnZUtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRVcGxvYWQoZmluZ2VycHJpbnQsIHVwbG9hZCkge1xuICAgICAgdmFyIGlkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxMik7XG4gICAgICB2YXIga2V5ID0gXCJ0dXM6OlwiLmNvbmNhdChmaW5nZXJwcmludCwgXCI6OlwiKS5jb25jYXQoaWQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh1cGxvYWQpKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRFbnRyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kRW50cmllcyhwcmVmaXgpIHtcbiAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfa2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcblxuICAgICAgICBpZiAoX2tleS5pbmRleE9mKHByZWZpeCkgIT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oX2tleSkpO1xuICAgICAgICAgIHVwbG9hZC51cmxTdG9yYWdlS2V5ID0gX2tleTtcbiAgICAgICAgICByZXN1bHRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIFRoZSBKU09OIHBhcnNlIGVycm9yIGlzIGludGVudGlvbmFsbHkgaWdub3JlZCBoZXJlLCBzbyBhIG1hbGZvcm1lZFxuICAgICAgICAgIC8vIGVudHJ5IGluIHRoZSBzdG9yYWdlIGNhbm5vdCBwcmV2ZW50IGFuIHVwbG9hZC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViU3RvcmFnZVVybFN0b3JhZ2U7XG59KCk7XG5cbmV4cG9ydHMuV2ViU3RvcmFnZVVybFN0b3JhZ2UgPSBXZWJTdG9yYWdlVXJsU3RvcmFnZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbnZhciBEZXRhaWxlZEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKERldGFpbGVkRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEZXRhaWxlZEVycm9yKTtcblxuICBmdW5jdGlvbiBEZXRhaWxlZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgY2F1c2luZ0VyciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICB2YXIgcmVxID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGV0YWlsZWRFcnJvcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLm9yaWdpbmFsUmVxdWVzdCA9IHJlcTtcbiAgICBfdGhpcy5vcmlnaW5hbFJlc3BvbnNlID0gcmVzO1xuICAgIF90aGlzLmNhdXNpbmdFcnJvciA9IGNhdXNpbmdFcnI7XG5cbiAgICBpZiAoY2F1c2luZ0VyciAhPSBudWxsKSB7XG4gICAgICBtZXNzYWdlICs9IFwiLCBjYXVzZWQgYnkgXCIuY29uY2F0KGNhdXNpbmdFcnIudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVxdWVzdElkID0gcmVxLmdldEhlYWRlcihcIlgtUmVxdWVzdC1JRFwiKSB8fCBcIm4vYVwiO1xuICAgICAgdmFyIG1ldGhvZCA9IHJlcS5nZXRNZXRob2QoKTtcbiAgICAgIHZhciB1cmwgPSByZXEuZ2V0VVJMKCk7XG4gICAgICB2YXIgc3RhdHVzID0gcmVzID8gcmVzLmdldFN0YXR1cygpIDogXCJuL2FcIjtcbiAgICAgIHZhciBib2R5ID0gcmVzID8gcmVzLmdldEJvZHkoKSB8fCBcIlwiIDogXCJuL2FcIjtcbiAgICAgIG1lc3NhZ2UgKz0gXCIsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFwiLmNvbmNhdChtZXRob2QsIFwiLCB1cmw6IFwiKS5jb25jYXQodXJsLCBcIiwgcmVzcG9uc2UgY29kZTogXCIpLmNvbmNhdChzdGF0dXMsIFwiLCByZXNwb25zZSB0ZXh0OiBcIikuY29uY2F0KGJvZHksIFwiLCByZXF1ZXN0IGlkOiBcIikuY29uY2F0KHJlcXVlc3RJZCwgXCIpXCIpO1xuICAgIH1cblxuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBEZXRhaWxlZEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIF9kZWZhdWx0ID0gRGV0YWlsZWRFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5lbmFibGVEZWJ1Z0xvZyA9IGVuYWJsZURlYnVnTG9nO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5cbi8qIGVzbGludCBuby1jb25zb2xlOiBcIm9mZlwiICovXG52YXIgaXNFbmFibGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVuYWJsZURlYnVnTG9nKCkge1xuICBpc0VuYWJsZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2cobXNnKSB7XG4gIGlmICghaXNFbmFibGVkKSByZXR1cm47XG4gIGNvbnNvbGUubG9nKG1zZyk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuXG5cbnZhciBOb29wVXJsU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vb3BVcmxTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb29wVXJsU3RvcmFnZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9vcFVybFN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImxpc3RBbGxVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RBbGxVcGxvYWRzKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRVcGxvYWRzQnlGaW5nZXJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVXBsb2FkKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFVwbG9hZChmaW5nZXJwcmludCwgdXBsb2FkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb29wVXJsU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTm9vcFVybFN0b3JhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfZXJyb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Vycm9yXCIpKTtcblxudmFyIF91dWlkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dWlkXCIpKTtcblxudmFyIF9qc0Jhc2UgPSByZXF1aXJlKFwianMtYmFzZTY0XCIpO1xuXG52YXIgX3VybFBhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidXJsLXBhcnNlXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVuZHBvaW50OiBudWxsLFxuICB1cGxvYWRVcmw6IG51bGwsXG4gIG1ldGFkYXRhOiB7fSxcbiAgZmluZ2VycHJpbnQ6IG51bGwsXG4gIHVwbG9hZFNpemU6IG51bGwsXG4gIG9uUHJvZ3Jlc3M6IG51bGwsXG4gIG9uQ2h1bmtDb21wbGV0ZTogbnVsbCxcbiAgb25TdWNjZXNzOiBudWxsLFxuICBvbkVycm9yOiBudWxsLFxuICBfb25VcGxvYWRVcmxBdmFpbGFibGU6IG51bGwsXG4gIG92ZXJyaWRlUGF0Y2hNZXRob2Q6IGZhbHNlLFxuICBoZWFkZXJzOiB7fSxcbiAgYWRkUmVxdWVzdElkOiBmYWxzZSxcbiAgb25CZWZvcmVSZXF1ZXN0OiBudWxsLFxuICBvbkFmdGVyUmVzcG9uc2U6IG51bGwsXG4gIGNodW5rU2l6ZTogSW5maW5pdHksXG4gIHJldHJ5RGVsYXlzOiBbMCwgMTAwMCwgMzAwMCwgNTAwMF0sXG4gIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nOiB0cnVlLFxuICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gIHVwbG9hZExlbmd0aERlZmVycmVkOiBmYWxzZSxcbiAgdXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uOiBmYWxzZSxcbiAgdXJsU3RvcmFnZTogbnVsbCxcbiAgZmlsZVJlYWRlcjogbnVsbCxcbiAgaHR0cFN0YWNrOiBudWxsXG59O1xuXG52YXIgQmFzZVVwbG9hZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VVcGxvYWQoZmlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVXBsb2FkKTsgLy8gV2FybiBhYm91dCByZW1vdmVkIG9wdGlvbnMgZnJvbSBwcmV2aW91cyB2ZXJzaW9uc1xuXG5cbiAgICBpZiAoXCJyZXN1bWVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInR1czogVGhlIGByZXN1bWVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkIGluIHR1cy1qcy1jbGllbnQgdjIuIFBsZWFzZSB1c2UgdGhlIFVSTCBzdG9yYWdlIEFQSSBpbnN0ZWFkLlwiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfSAvLyBUaGUgZGVmYXVsdCBvcHRpb25zIHdpbGwgYWxyZWFkeSBiZSBhZGRlZCBmcm9tIHRoZSB3cmFwcGVyIGNsYXNzZXMuXG5cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IC8vIFRoZSBzdG9yYWdlIG1vZHVsZSB1c2VkIHRvIHN0b3JlIFVSTHNcblxuICAgIHRoaXMuX3VybFN0b3JhZ2UgPSB0aGlzLm9wdGlvbnMudXJsU3RvcmFnZTsgLy8gVGhlIHVuZGVybHlpbmcgRmlsZS9CbG9iIG9iamVjdFxuXG4gICAgdGhpcy5maWxlID0gZmlsZTsgLy8gVGhlIFVSTCBhZ2FpbnN0IHdoaWNoIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWRcblxuICAgIHRoaXMudXJsID0gbnVsbDsgLy8gVGhlIHVuZGVybHlpbmcgcmVxdWVzdCBvYmplY3QgZm9yIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3RcblxuICAgIHRoaXMuX3JlcSA9IG51bGw7IC8vIFRoZSBmaW5nZXJwaW5ydCBmb3IgdGhlIGN1cnJlbnQgZmlsZSAoc2V0IGFmdGVyIHN0YXJ0KCkpXG5cbiAgICB0aGlzLl9maW5nZXJwcmludCA9IG51bGw7IC8vIFRoZSBrZXkgdGhhdCB0aGUgVVJMIHN0b3JhZ2UgcmV0dXJuZWQgd2hlbiBzYXZpbmcgYW4gVVJMIHdpdGggYSBmaW5nZXJwcmludCxcblxuICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBudWxsOyAvLyBUaGUgb2Zmc2V0IHVzZWQgaW4gdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdFxuXG4gICAgdGhpcy5fb2Zmc2V0ID0gbnVsbDsgLy8gVHJ1ZSBpZiB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWRcblxuICAgIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTsgLy8gVGhlIGZpbGUncyBzaXplIGluIGJ5dGVzXG5cbiAgICB0aGlzLl9zaXplID0gbnVsbDsgLy8gVGhlIFNvdXJjZSBvYmplY3Qgd2hpY2ggd2lsbCB3cmFwIGFyb3VuZCB0aGUgZ2l2ZW4gZmlsZSBhbmQgcHJvdmlkZXMgdXNcbiAgICAvLyB3aXRoIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGdldHRpbmcgaXRzIHNpemUgYW5kIHNsaWNlIGNodW5rcyBmcm9tIGl0c1xuICAgIC8vIGNvbnRlbnQgYWxsb3dpbmcgdXMgdG8gZWFzaWx5IGhhbmRsZSBGaWxlcywgQmxvYnMsIEJ1ZmZlcnMgYW5kIFN0cmVhbXMuXG5cbiAgICB0aGlzLl9zb3VyY2UgPSBudWxsOyAvLyBUaGUgY3VycmVudCBjb3VudCBvZiBhdHRlbXB0cyB3aGljaCBoYXZlIGJlZW4gbWFkZS4gWmVybyBpbmRpY2F0ZXMgbm9uZS5cblxuICAgIHRoaXMuX3JldHJ5QXR0ZW1wdCA9IDA7IC8vIFRoZSB0aW1lb3V0J3MgSUQgd2hpY2ggaXMgdXNlZCB0byBkZWxheSB0aGUgbmV4dCByZXRyeVxuXG4gICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gbnVsbDsgLy8gVGhlIG9mZnNldCBvZiB0aGUgcmVtb3RlIHVwbG9hZCBiZWZvcmUgdGhlIGxhdGVzdCBhdHRlbXB0IHdhcyBzdGFydGVkLlxuXG4gICAgdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnkgPSAwOyAvLyBBbiBhcnJheSBvZiBCYXNlVXBsb2FkIGluc3RhbmNlcyB3aGljaCBhcmUgdXNlZCBmb3IgdXBsb2FkaW5nIHRoZSBkaWZmZXJlbnRcbiAgICAvLyBwYXJ0cywgaWYgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gaXMgdXNlZC5cblxuICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkcyA9IG51bGw7IC8vIEFuIGFycmF5IG9mIHVwbG9hZCBVUkxzIHdoaWNoIGFyZSB1c2VkIGZvciB1cGxvYWRpbmcgdGhlIGRpZmZlcmVudFxuICAgIC8vIHBhcnRzLCBpZiB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiBpcyB1c2VkLlxuXG4gICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXNlIHRoZSBUZXJtaW5hdGlvbiBleHRlbnNpb24gdG8gZGVsZXRlIGFuIHVwbG9hZCBmcm9tIHRoZSBzZXJ2ZXIgYnkgc2VuZGluZyBhIERFTEVURVxuICAgKiByZXF1ZXN0IHRvIHRoZSBzcGVjaWZpZWQgdXBsb2FkIFVSTC4gVGhpcyBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgdGhlXG4gICAqIFRlcm1pbmF0aW9uIGV4dGVuc2lvbi4gSWYgdGhlIGBvcHRpb25zLnJldHJ5RGVsYXlzYCBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBtZXRob2Qgd2lsbFxuICAgKiBhbHNvIHJldHJ5IGlmIGFuIGVycm9yIG9jdXJycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXBsb2FkJ3MgVVJMIHdoaWNoIHdpbGwgYmUgdGVybWluYXRlZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgaW5mbHVlbmNpbmcgSFRUUCByZXF1ZXN0cy5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIFByb21pc2Ugd2lsbCBiZSByZXNvbHZlZC9yZWplY3RlZCB3aGVuIHRoZSByZXF1ZXN0cyBmaW5pc2guXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VVcGxvYWQsIFt7XG4gICAga2V5OiBcImZpbmRQcmV2aW91c1VwbG9hZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFByZXZpb3VzVXBsb2FkcygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmluZ2VycHJpbnQodGhpcy5maWxlLCB0aGlzLm9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fdXJsU3RvcmFnZS5maW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc3VtZUZyb21QcmV2aW91c1VwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWVGcm9tUHJldmlvdXNVcGxvYWQocHJldmlvdXNVcGxvYWQpIHtcbiAgICAgIHRoaXMudXJsID0gcHJldmlvdXNVcGxvYWQudXBsb2FkVXJsIHx8IG51bGw7XG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBwcmV2aW91c1VwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMgfHwgbnVsbDtcbiAgICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBwcmV2aW91c1VwbG9hZC51cmxTdG9yYWdlS2V5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZTtcblxuICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IG5vIGZpbGUgb3Igc3RyZWFtIHRvIHVwbG9hZCBwcm92aWRlZFwiKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmRwb2ludCAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZFVybCkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBuZWl0aGVyIGFuIGVuZHBvaW50IG9yIGFuIHVwbG9hZCBVUkwgaXMgcHJvdmlkZWRcIikpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHJ5RGVsYXlzID0gdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlzO1xuXG4gICAgICBpZiAocmV0cnlEZWxheXMgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmV0cnlEZWxheXMpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogdGhlIGByZXRyeURlbGF5c2Agb3B0aW9uIG11c3QgZWl0aGVyIGJlIGFuIGFycmF5IG9yIG51bGxcIikpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxKSB7XG4gICAgICAgIC8vIFRlc3Qgd2hpY2ggb3B0aW9ucyBhcmUgaW5jb21wYXRpYmxlIHdpdGggcGFyYWxsZWwgdXBsb2Fkcy5cbiAgICAgICAgW1widXBsb2FkVXJsXCIsIFwidXBsb2FkU2l6ZVwiLCBcInVwbG9hZExlbmd0aERlZmVycmVkXCJdLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbk5hbWUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIF90aGlzMi5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IHVzZSB0aGUgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiIG9wdGlvbiB3aGVuIHBhcmFsbGVsVXBsb2FkcyBpcyBlbmFibGVkXCIpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KGZpbGUsIHRoaXMub3B0aW9ucykudGhlbihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgaWYgKGZpbmdlcnByaW50ID09IG51bGwpIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiTm8gZmluZ2VycHJpbnQgd2FzIGNhbGN1bGF0ZWQgbWVhbmluZyB0aGF0IHRoZSB1cGxvYWQgY2Fubm90IGJlIHN0b3JlZCBpbiB0aGUgVVJMIHN0b3JhZ2UuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDYWxjdWxhdGVkIGZpbmdlcnByaW50OiBcIi5jb25jYXQoZmluZ2VycHJpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcblxuICAgICAgICBpZiAoX3RoaXMyLl9zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9zb3VyY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5vcHRpb25zLmZpbGVSZWFkZXIub3BlbkZpbGUoZmlsZSwgX3RoaXMyLm9wdGlvbnMuY2h1bmtTaXplKTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF90aGlzMi5fc291cmNlID0gc291cmNlOyAvLyBJZiB0aGUgdXBsb2FkIHdhcyBjb25maWd1cmVkIHRvIHVzZSBtdWx0aXBsZSByZXF1ZXN0cyBvciBpZiB3ZSByZXN1bWUgZnJvbVxuICAgICAgICAvLyBhbiB1cGxvYWQgd2hpY2ggdXNlZCBtdWx0aXBsZSByZXF1ZXN0cywgd2Ugc3RhcnQgYSBwYXJhbGxlbCB1cGxvYWQuXG5cbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnBhcmFsbGVsVXBsb2FkcyA+IDEgfHwgX3RoaXMyLl9wYXJhbGxlbFVwbG9hZFVybHMgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMi5fc3RhcnRQYXJhbGxlbFVwbG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5fc3RhcnRTaW5nbGVVcGxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMi5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgdGhlIHVwbG9hZGluZyBwcm9jZWR1cmUgZm9yIGEgcGFyYWxsZWxpemVkIHVwbG9hZCwgd2hlcmUgb25lIGZpbGUgaXMgc3BsaXQgaW50b1xuICAgICAqIG11bHRpcGxlIHJlcXVlc3Qgd2hpY2ggYXJlIHJ1biBpbiBwYXJhbGxlbC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0UGFyYWxsZWxVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0UGFyYWxsZWxVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHRvdGFsU2l6ZSA9IHRoaXMuX3NpemUgPSB0aGlzLl9zb3VyY2Uuc2l6ZTtcbiAgICAgIHZhciB0b3RhbFByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkcyA9IFtdO1xuICAgICAgdmFyIHBhcnRDb3VudCA9IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyAhPSBudWxsID8gdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzLmxlbmd0aCA6IHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHM7IC8vIFRoZSBpbnB1dCBmaWxlIHdpbGwgYmUgc3BsaXQgaW50byBtdWx0aXBsZSBzbGljZXMgd2hpY2ggYXJlIHVwbG9hZGVkIGluIHNlcGFyYXRlXG4gICAgICAvLyByZXF1ZXN0cy4gSGVyZSB3ZSBnZW5lcmF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbiBmb3IgdGhlIHNsaWNlcy5cblxuICAgICAgdmFyIHBhcnRzID0gc3BsaXRTaXplSW50b1BhcnRzKHRoaXMuX3NvdXJjZS5zaXplLCBwYXJ0Q291bnQsIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyk7IC8vIENyZWF0ZSBhbiBlbXB0eSBsaXN0IGZvciBzdG9yaW5nIHRoZSB1cGxvYWQgVVJMc1xuXG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBuZXcgQXJyYXkocGFydHMubGVuZ3RoKTsgLy8gR2VuZXJhdGUgYSBwcm9taXNlIGZvciBlYWNoIHNsaWNlIHRoYXQgd2lsbCBiZSByZXNvbHZlIGlmIHRoZSByZXNwZWN0aXZlXG4gICAgICAvLyB1cGxvYWQgaXMgY29tcGxldGVkLlxuXG4gICAgICB2YXIgdXBsb2FkcyA9IHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxhc3RQYXJ0UHJvZ3Jlc3MgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9zb3VyY2Uuc2xpY2UocGFydC5zdGFydCwgcGFydC5lbmQpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBNZXJnZSB3aXRoIHRoZSB1c2VyIHN1cHBsaWVkIG9wdGlvbnMgYnV0IG92ZXJ3cml0ZSBzb21lIHZhbHVlcy5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgX3RoaXMzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgLy8gSWYgYXZhaWxhYmxlLCB0aGUgcGFydGlhbCB1cGxvYWQgc2hvdWxkIGJlIHJlc3VtZWQgZnJvbSBhIHByZXZpb3VzIFVSTC5cbiAgICAgICAgICAgICAgdXBsb2FkVXJsOiBwYXJ0LnVwbG9hZFVybCB8fCBudWxsLFxuICAgICAgICAgICAgICAvLyBXZSB0YWtlIG1hbnVhbGx5IGNhcmUgb2YgcmVzdW1pbmcgZm9yIHBhcnRpYWwgdXBsb2Fkcywgc28gdGhleSBzaG91bGRcbiAgICAgICAgICAgICAgLy8gbm90IGJlIHN0b3JlZCBpbiB0aGUgVVJMIHN0b3JhZ2UuXG4gICAgICAgICAgICAgIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogZmFsc2UsXG4gICAgICAgICAgICAgIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gdG8gbm90IGNhdXNlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICAgICAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyIHRvIGluZGljYXRlIHRoZSB0aGlzIGlzIGEgcGFydGlhbCB1cGxvYWQuXG4gICAgICAgICAgICAgIGhlYWRlcnM6IF9vYmplY3RTcHJlYWQoe30sIF90aGlzMy5vcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBcIlVwbG9hZC1Db25jYXRcIjogXCJwYXJ0aWFsXCJcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC8vIFJlamVjdCBvciByZXNvbHZlIHRoZSBwcm9taXNlIGlmIHRoZSB1cGxvYWQgZXJyb3JzIG9yIGNvbXBsZXRlcy5cbiAgICAgICAgICAgICAgb25TdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICBvbkVycm9yOiByZWplY3QsXG4gICAgICAgICAgICAgIC8vIEJhc2VkIGluIHRoZSBwcm9ncmVzcyBmb3IgdGhpcyBwYXJ0aWFsIHVwbG9hZCwgY2FsY3VsYXRlIHRoZSBwcm9ncmVzc1xuICAgICAgICAgICAgICAvLyBmb3IgdGhlIGVudGlyZSBmaW5hbCB1cGxvYWQuXG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MobmV3UGFydFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyA9IHRvdGFsUHJvZ3Jlc3MgLSBsYXN0UGFydFByb2dyZXNzICsgbmV3UGFydFByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGxhc3RQYXJ0UHJvZ3Jlc3MgPSBuZXdQYXJ0UHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICBfdGhpczMuX2VtaXRQcm9ncmVzcyh0b3RhbFByb2dyZXNzLCB0b3RhbFNpemUpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIGV2ZXJ5IHBhcnRpYWwgdXBsb2FkIGhhcyBhbiB1cGxvYWQgVVJMLCBzbyB3ZSBjYW4gYWRkXG4gICAgICAgICAgICAgIC8vIHRoZW0gdG8gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBfb25VcGxvYWRVcmxBdmFpbGFibGU6IGZ1bmN0aW9uIF9vblVwbG9hZFVybEF2YWlsYWJsZSgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJsc1tpbmRleF0gPSB1cGxvYWQudXJsOyAvLyBUZXN0IGlmIGFsbCB1cGxvYWRzIGhhdmUgcmVjZWl2ZWQgYW4gVVJMXG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHMuZmlsdGVyKGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gISF1O1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczMuX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdXBsb2FkID0gbmV3IEJhc2VVcGxvYWQodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdXBsb2FkLnN0YXJ0KCk7IC8vIFN0b3JlIHRoZSB1cGxvYWQgaW4gYW4gYXJyYXksIHNvIHdlIGNhbiBsYXRlciBhYm9ydCB0aGVtIGlmIG5lY2Vzc2FyeS5cblxuICAgICAgICAgICAgX3RoaXMzLl9wYXJhbGxlbFVwbG9hZHMucHVzaCh1cGxvYWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlcTsgLy8gV2FpdCB1bnRpbCBhbGwgcGFydGlhbCB1cGxvYWRzIGFyZSBmaW5pc2hlZCBhbmQgd2UgY2FuIHNlbmQgdGhlIFBPU1QgcmVxdWVzdCBmb3JcbiAgICAgIC8vIGNyZWF0aW5nIHRoZSBmaW5hbCB1cGxvYWQuXG5cbiAgICAgIFByb21pc2UuYWxsKHVwbG9hZHMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXEgPSBfdGhpczMuX29wZW5SZXF1ZXN0KFwiUE9TVFwiLCBfdGhpczMub3B0aW9ucy5lbmRwb2ludCk7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtQ29uY2F0XCIsIFwiZmluYWw7XCIuY29uY2F0KF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzLmpvaW4oXCIgXCIpKSk7IC8vIEFkZCBtZXRhZGF0YSBpZiB2YWx1ZXMgaGF2ZSBiZWVuIGFkZGVkXG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gZW5jb2RlTWV0YWRhdGEoX3RoaXMzLm9wdGlvbnMubWV0YWRhdGEpO1xuXG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gXCJcIikge1xuICAgICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtTWV0YWRhdGFcIiwgbWV0YWRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXMzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWRcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuZ2V0SGVhZGVyKFwiTG9jYXRpb25cIik7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICBfdGhpczMuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgTG9jYXRpb24gaGVhZGVyXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLnVybCA9IHJlc29sdmVVcmwoX3RoaXMzLm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczMudXJsKSk7XG5cbiAgICAgICAgX3RoaXMzLl9lbWl0U3VjY2VzcygpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMy5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgdGhlIHVwbG9hZGluZyBwcm9jZWR1cmUgZm9yIGEgbm9uLXBhcmFsbGVsIHVwbG9hZC4gSGVyZSB0aGUgZW50aXJlIGZpbGUgaXNcbiAgICAgKiB1cGxvYWRlZCBpbiBhIHNlcXVlbnRpYWwgbWF0dGVyLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRTaW5nbGVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U2luZ2xlVXBsb2FkKCkge1xuICAgICAgLy8gRmlyc3QsIHdlIGxvb2sgYXQgdGhlIHVwbG9hZExlbmd0aERlZmVycmVkIG9wdGlvbi5cbiAgICAgIC8vIE5leHQsIHdlIGNoZWNrIGlmIHRoZSBjYWxsZXIgaGFzIHN1cHBsaWVkIGEgbWFudWFsIHVwbG9hZCBzaXplLlxuICAgICAgLy8gRmluYWxseSwgd2UgdHJ5IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCBzaXplIGZyb20gdGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSArdGhpcy5vcHRpb25zLnVwbG9hZFNpemU7XG5cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuX3NpemUpKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IGNvbnZlcnQgYHVwbG9hZFNpemVgIG9wdGlvbiBpbnRvIGEgbnVtYmVyXCIpKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHRoaXMuX3NvdXJjZS5zaXplO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaXplID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgYXV0b21hdGljYWxseSBkZXJpdmUgdXBsb2FkJ3Mgc2l6ZSBmcm9tIGlucHV0IGFuZCBtdXN0IGJlIHNwZWNpZmllZCBtYW51YWxseSB1c2luZyB0aGUgYHVwbG9hZFNpemVgIG9wdGlvblwiKSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVzZXQgdGhlIGFib3J0ZWQgZmxhZyB3aGVuIHRoZSB1cGxvYWQgaXMgc3RhcnRlZCBvciBlbHNlIHRoZVxuICAgICAgLy8gX3BlcmZvcm1VcGxvYWQgd2lsbCBzdG9wIGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuXG4gICAgICAvLyBhYm9ydGVkIHByZXZpb3VzbHkuXG5cblxuICAgICAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlOyAvLyBUaGUgdXBsb2FkIGhhZCBiZWVuIHN0YXJ0ZWQgcHJldmlvdXNseSBhbmQgd2Ugc2hvdWxkIHJldXNlIHRoaXMgVVJMLlxuXG4gICAgICBpZiAodGhpcy51cmwgIT0gbnVsbCkge1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiUmVzdW1pbmcgdXBsb2FkIGZyb20gcHJldmlvdXMgVVJMOiBcIi5jb25jYXQodGhpcy51cmwpKTtcblxuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEEgVVJMIGhhcyBtYW51YWxseSBiZWVuIHNwZWNpZmllZCwgc28gd2UgdHJ5IHRvIHJlc3VtZVxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkVXJsICE9IG51bGwpIHtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIlJlc3VtaW5nIHVwbG9hZCBmcm9tIHByb3ZpZGVkIFVSTDogXCIuY29uY2F0KHRoaXMub3B0aW9ucy51cmwpKTtcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLm9wdGlvbnMudXBsb2FkVXJsO1xuXG4gICAgICAgIHRoaXMuX3Jlc3VtZVVwbG9hZCgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQW4gdXBsb2FkIGhhcyBub3Qgc3RhcnRlZCBmb3IgdGhlIGZpbGUgeWV0LCBzbyB3ZSBzdGFydCBhIG5ldyBvbmVcblxuXG4gICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ3JlYXRpbmcgYSBuZXcgdXBsb2FkXCIpO1xuXG4gICAgICB0aGlzLl9jcmVhdGVVcGxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnQgYW55IHJ1bm5pbmcgcmVxdWVzdCBhbmQgc3RvcCB0aGUgY3VycmVudCB1cGxvYWQuIEFmdGVyIGFib3J0IGlzIGNhbGxlZCwgbm8gZXZlbnRcbiAgICAgKiBoYW5kbGVyIHdpbGwgYmUgaW52b2tlZCBhbnltb3JlLiBZb3UgY2FuIHVzZSB0aGUgYHN0YXJ0YCBtZXRob2QgdG8gcmVzdW1lIHRoZSB1cGxvYWRcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKiBJZiBgc2hvdWxkVGVybWluYXRlYCBpcyB0cnVlLCB0aGUgYHRlcm1pbmF0ZWAgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gcmVtb3ZlIHRoZVxuICAgICAqIGN1cnJlbnQgdXBsb2FkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkVGVybWluYXRlIFRydWUgaWYgdGhlIHVwbG9hZCBzaG91bGQgYmUgZGVsZXRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIFByb21pc2Ugd2lsbCBiZSByZXNvbHZlZC9yZWplY3RlZCB3aGVuIHRoZSByZXF1ZXN0cyBmaW5pc2guXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhYm9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydChzaG91bGRUZXJtaW5hdGUsIGNiKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInR1czogdGhlIGFib3J0IGZ1bmN0aW9uIGRvZXMgbm90IGFjY2VwdCBhIGNhbGxiYWNrIHNpbmNlIHYyIGFueW1vcmU7IHBsZWFzZSB1c2UgdGhlIHJldHVybmVkIFByb21pc2UgaW5zdGVhZFwiKTtcbiAgICAgIH0gLy8gU3RvcCBhbnkgcGFyYWxsZWwgcGFydGlhbCB1cGxvYWRzLCB0aGF0IGhhdmUgYmVlbiBzdGFydGVkIGluIF9zdGFydFBhcmFsbGVsVXBsb2Fkcy5cblxuXG4gICAgICBpZiAodGhpcy5fcGFyYWxsZWxVcGxvYWRzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzLmZvckVhY2goZnVuY3Rpb24gKHVwbG9hZCkge1xuICAgICAgICAgIHVwbG9hZC5hYm9ydChzaG91bGRUZXJtaW5hdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU3RvcCBhbnkgY3VycmVudCBydW5uaW5nIHJlcXVlc3QuXG5cblxuICAgICAgaWYgKHRoaXMuX3JlcSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcblxuICAgICAgICB0aGlzLl9zb3VyY2UuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7IC8vIFN0b3AgYW55IHRpbWVvdXQgdXNlZCBmb3IgaW5pdGlhdGluZyBhIHJldHJ5LlxuXG4gICAgICBpZiAodGhpcy5fcmV0cnlUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JldHJ5VGltZW91dCk7XG4gICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2hvdWxkVGVybWluYXRlIHx8IHRoaXMudXJsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQmFzZVVwbG9hZC50ZXJtaW5hdGUodGhpcy51cmwsIHRoaXMub3B0aW9ucykgLy8gUmVtb3ZlIGVudHJ5IGZyb20gdGhlIFVSTCBzdG9yYWdlIHNpbmNlIHRoZSB1cGxvYWQgVVJMIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5fcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdEh0dHBFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgbWVzc2FnZSwgY2F1c2luZ0Vycikge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBfZXJyb3IuZGVmYXVsdChtZXNzYWdlLCBjYXVzaW5nRXJyLCByZXEsIHJlcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0RXJyb3IoZXJyKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpczsgLy8gRG8gbm90IGVtaXQgZXJyb3JzLCBlLmcuIGZyb20gYWJvcnRlZCBIVFRQIHJlcXVlc3RzLCBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuIHN0b3BwZWQuXG5cblxuICAgICAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybjsgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJldHJ5LCB3aGVuIGVuYWJsZWQsIGJlZm9yZSBzZW5kaW5nIHRoZSBlcnJvciB0byB0aGUgdXNlci5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cyAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgcmVzZXQgdGhlIGF0dGVtcHQgY291bnRlciBpZlxuICAgICAgICAvLyAtIHdlIHdlcmUgYWxyZWFkeSBhYmxlIHRvIGNvbm5lY3QgdG8gdGhlIHNlcnZlciAob2Zmc2V0ICE9IG51bGwpIGFuZFxuICAgICAgICAvLyAtIHdlIHdlcmUgYWJsZSB0byB1cGxvYWQgYSBzbWFsbCBjaHVuayBvZiBkYXRhIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgdmFyIHNob3VsZFJlc2V0RGVsYXlzID0gdGhpcy5fb2Zmc2V0ICE9IG51bGwgJiYgdGhpcy5fb2Zmc2V0ID4gdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnk7XG5cbiAgICAgICAgaWYgKHNob3VsZFJlc2V0RGVsYXlzKSB7XG4gICAgICAgICAgdGhpcy5fcmV0cnlBdHRlbXB0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRSZXRyeShlcnIsIHRoaXMuX3JldHJ5QXR0ZW1wdCwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5c1t0aGlzLl9yZXRyeUF0dGVtcHQrK107XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnkgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczUuc3RhcnQoKTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIGlmIHRoZSB1cGxvYWQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRTdWNjZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0U3VjY2VzcygpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN0b3JlZCBmaW5nZXJwcmludCBhbmQgY29ycmVzcG9uZGluZyBlbmRwb2ludC4gVGhpcyBjYXVzZXNcbiAgICAgICAgLy8gbmV3IHVwbG9hZHMgb2YgdGhlIHNhbWUgZmlsZSB0byBiZSB0cmVhdGVkIGFzIGEgZGlmZmVyZW50IGZpbGUuXG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uU3VjY2VzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiB3aGVuIGRhdGEgaGFzIGJlZW4gc2VudCB0byB0aGUgc2VydmVyLiBUaGlzXG4gICAgICogZGF0YSBtYXkgbm90IGhhdmUgYmVlbiBhY2NlcHRlZCBieSB0aGUgc2VydmVyIHlldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1NlbnQgIE51bWJlciBvZiBieXRlcyBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0UHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRQcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gYSBjaHVuayBvZiBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIGFuZCBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemUgIFNpemUgb2YgdGhlIGNodW5rIHRoYXQgd2FzIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzQWNjZXB0ZWQgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0Q2h1bmtDb21wbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdENodW5rQ29tcGxldGUoY2h1bmtTaXplLCBieXRlc0FjY2VwdGVkLCBieXRlc1RvdGFsKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNodW5rQ29tcGxldGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25DaHVua0NvbXBsZXRlKGNodW5rU2l6ZSwgYnl0ZXNBY2NlcHRlZCwgYnl0ZXNUb3RhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1cGxvYWQgdXNpbmcgdGhlIGNyZWF0aW9uIGV4dGVuc2lvbiBieSBzZW5kaW5nIGEgUE9TVFxuICAgICAqIHJlcXVlc3QgdG8gdGhlIGVuZHBvaW50LiBBZnRlciBzdWNjZXNzZnVsIGNyZWF0aW9uIHRoZSBmaWxlIHdpbGwgYmVcbiAgICAgKiB1cGxvYWRlZFxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5kcG9pbnQpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogdW5hYmxlIHRvIGNyZWF0ZSB1cGxvYWQgYmVjYXVzZSBubyBlbmRwb2ludCBpcyBwcm92aWRlZFwiKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoXCJQT1NUXCIsIHRoaXMub3B0aW9ucy5lbmRwb2ludCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1EZWZlci1MZW5ndGhcIiwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLUxlbmd0aFwiLCB0aGlzLl9zaXplKTtcbiAgICAgIH0gLy8gQWRkIG1ldGFkYXRhIGlmIHZhbHVlcyBoYXZlIGJlZW4gYWRkZWRcblxuXG4gICAgICB2YXIgbWV0YWRhdGEgPSBlbmNvZGVNZXRhZGF0YSh0aGlzLm9wdGlvbnMubWV0YWRhdGEpO1xuXG4gICAgICBpZiAobWV0YWRhdGEgIT09IFwiXCIpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1NZXRhZGF0YVwiLCBtZXRhZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbiAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9hZGRDaHVua1RvUmVxdWVzdChyZXEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IHRoaXMuX3NlbmRSZXF1ZXN0KHJlcSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShyZXMuZ2V0U3RhdHVzKCksIDIwMCkpIHtcbiAgICAgICAgICBfdGhpczYuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZFwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5nZXRIZWFkZXIoXCJMb2NhdGlvblwiKTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBMb2NhdGlvbiBoZWFkZXJcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczYudXJsID0gcmVzb2x2ZVVybChfdGhpczYub3B0aW9ucy5lbmRwb2ludCwgbG9jYXRpb24pO1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ3JlYXRlZCB1cGxvYWQgYXQgXCIuY29uY2F0KF90aGlzNi51cmwpKTtcblxuICAgICAgICBpZiAodHlwZW9mIF90aGlzNi5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgX3RoaXM2Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM2Ll9zaXplID09PSAwKSB7XG4gICAgICAgICAgLy8gTm90aGluZyB0byB1cGxvYWQgYW5kIGZpbGUgd2FzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkXG4gICAgICAgICAgX3RoaXM2Ll9lbWl0U3VjY2VzcygpO1xuXG4gICAgICAgICAgX3RoaXM2Ll9zb3VyY2UuY2xvc2UoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNi5fc2F2ZVVwbG9hZEluVXJsU3RvcmFnZSgpO1xuXG4gICAgICAgIGlmIChfdGhpczYub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24pIHtcbiAgICAgICAgICBfdGhpczYuX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczYuX29mZnNldCA9IDA7XG5cbiAgICAgICAgICBfdGhpczYuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsIFwidHVzOiBmYWlsZWQgdG8gY3JlYXRlIHVwbG9hZFwiLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogVHJ5IHRvIHJlc3VtZSBhbiBleGlzdGluZyB1cGxvYWQuIEZpcnN0IGEgSEVBRCByZXF1ZXN0IHdpbGwgYmUgc2VudFxuICAgICAqIHRvIHJldHJpZXZlIHRoZSBvZmZzZXQuIElmIHRoZSByZXF1ZXN0IGZhaWxzIGEgbmV3IHVwbG9hZCB3aWxsIGJlXG4gICAgICogY3JlYXRlZC4gSW4gdGhlIGNhc2Ugb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXN1bWVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3VtZVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoXCJIRUFEXCIsIHRoaXMudXJsKTtcblxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICB2YXIgc3RhdHVzID0gcmVzLmdldFN0YXR1cygpO1xuXG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIDIwMCkpIHtcbiAgICAgICAgICBpZiAoaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIDQwMCkpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzdG9yZWQgZmluZ2VycHJpbnQgYW5kIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnQsXG4gICAgICAgICAgICAvLyBvbiBjbGllbnQgZXJyb3JzIHNpbmNlIHRoZSBmaWxlIGNhbiBub3QgYmUgZm91bmRcbiAgICAgICAgICAgIF90aGlzNy5fcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKTtcbiAgICAgICAgICB9IC8vIElmIHRoZSB1cGxvYWQgaXMgbG9ja2VkIChpbmRpY2F0ZWQgYnkgdGhlIDQyMyBMb2NrZWQgc3RhdHVzIGNvZGUpLCB3ZVxuICAgICAgICAgIC8vIGVtaXQgYW4gZXJyb3IgaW5zdGVhZCBvZiBkaXJlY3RseSBzdGFydGluZyBhIG5ldyB1cGxvYWQuIFRoaXMgd2F5IHRoZVxuICAgICAgICAgIC8vIHJldHJ5IGxvZ2ljIGNhbiBjYXRjaCB0aGUgZXJyb3IgYW5kIHdpbGwgcmV0cnkgdGhlIHVwbG9hZC4gQW4gdXBsb2FkXG4gICAgICAgICAgLy8gaXMgdXN1YWxseSBsb2NrZWQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgYW5kIHdpbGwgYmUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYWZ0ZXJ3YXJkcy5cblxuXG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDIzKSB7XG4gICAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1cGxvYWQgaXMgY3VycmVudGx5IGxvY2tlZDsgcmV0cnkgbGF0ZXJcIik7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV90aGlzNy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhdHRlbXB0IHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWQgaWYgbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1bmFibGUgdG8gcmVzdW1lIHVwbG9hZCAobmV3IHVwbG9hZCBjYW5ub3QgYmUgY3JlYXRlZCB3aXRob3V0IGFuIGVuZHBvaW50KVwiKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWRcblxuXG4gICAgICAgICAgX3RoaXM3LnVybCA9IG51bGw7XG5cbiAgICAgICAgICBfdGhpczcuX2NyZWF0ZVVwbG9hZCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlSW50KHJlcy5nZXRIZWFkZXIoXCJVcGxvYWQtT2Zmc2V0XCIpLCAxMCk7XG5cbiAgICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KHJlcy5nZXRIZWFkZXIoXCJVcGxvYWQtTGVuZ3RoXCIpLCAxMCk7XG5cbiAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkgJiYgIV90aGlzNy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIGxlbmd0aCB2YWx1ZVwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXM3Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBfdGhpczcub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUoKTtcbiAgICAgICAgfSAvLyBVcGxvYWQgaGFzIGFscmVhZHkgYmVlbiBjb21wbGV0ZWQgYW5kIHdlIGRvIG5vdCBuZWVkIHRvIHNlbmQgYWRkaXRpb25hbFxuICAgICAgICAvLyBkYXRhIHRvIHRoZSBzZXJ2ZXJcblxuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdFByb2dyZXNzKGxlbmd0aCwgbGVuZ3RoKTtcblxuICAgICAgICAgIF90aGlzNy5fZW1pdFN1Y2Nlc3MoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICAgIF90aGlzNy5fcGVyZm9ybVVwbG9hZCgpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsIFwidHVzOiBmYWlsZWQgdG8gcmVzdW1lIHVwbG9hZFwiLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHVwbG9hZGluZyB0aGUgZmlsZSB1c2luZyBQQVRDSCByZXF1ZXN0cy4gVGhlIGZpbGUgd2lsbCBiZSBkaXZpZGVkXG4gICAgICogaW50byBjaHVua3MgYXMgc3BlY2lmaWVkIGluIHRoZSBjaHVua1NpemUgb3B0aW9uLiBEdXJpbmcgdGhlIHVwbG9hZFxuICAgICAqIHRoZSBvblByb2dyZXNzIGV2ZW50IGhhbmRsZXIgbWF5IGJlIGludm9rZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7IC8vIElmIHRoZSB1cGxvYWQgaGFzIGJlZW4gYWJvcnRlZCwgd2Ugd2lsbCBub3Qgc2VuZCB0aGUgbmV4dCBQQVRDSCByZXF1ZXN0LlxuICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgdGhlIGFib3J0IG1ldGhvZCB3YXMgY2FsbGVkIGR1cmluZyBhIGNhbGxiYWNrLCBzdWNoXG4gICAgICAvLyBhcyBvbkNodW5rQ29tcGxldGUgb3Igb25Qcm9ncmVzcy5cblxuXG4gICAgICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXE7IC8vIFNvbWUgYnJvd3NlciBhbmQgc2VydmVycyBtYXkgbm90IHN1cHBvcnQgdGhlIFBBVENIIG1ldGhvZC4gRm9yIHRob3NlXG4gICAgICAvLyBjYXNlcywgeW91IGNhbiB0ZWxsIHR1cy1qcy1jbGllbnQgdG8gdXNlIGEgUE9TVCByZXF1ZXN0IHdpdGggdGhlXG4gICAgICAvLyBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlIGhlYWRlciBmb3Igc2ltdWxhdGluZyBhIFBBVENIIHJlcXVlc3QuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcnJpZGVQYXRjaE1ldGhvZCkge1xuICAgICAgICByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdChcIlBPU1RcIiwgdGhpcy51cmwpO1xuICAgICAgICByZXEuc2V0SGVhZGVyKFwiWC1IVFRQLU1ldGhvZC1PdmVycmlkZVwiLCBcIlBBVENIXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoXCJQQVRDSFwiLCB0aGlzLnVybCk7XG4gICAgICB9XG5cbiAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtT2Zmc2V0XCIsIHRoaXMuX29mZnNldCk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QocmVxKTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHJlcy5nZXRTdGF0dXMoKSwgMjAwKSkge1xuICAgICAgICAgIF90aGlzOC5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgdXBsb2FkaW5nIGNodW5rXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM4Ll9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcyk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gRG9uJ3QgZW1pdCBhbiBlcnJvciBpZiB0aGUgdXBsb2FkIHdhcyBhYm9ydGVkIG1hbnVhbGx5XG4gICAgICAgIGlmIChfdGhpczguX2Fib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczguX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCBcInR1czogZmFpbGVkIHRvIHVwbG9hZCBjaHVuayBhdCBvZmZzZXQgXCIgKyBfdGhpczguX29mZnNldCwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfYWRkQ2h1bmt0b1JlcXVlc3QgcmVhZHMgYSBjaHVuayBmcm9tIHRoZSBzb3VyY2UgYW5kIHNlbmRzIGl0IHVzaW5nIHRoZVxuICAgICAqIHN1cHBsaWVkIHJlcXVlc3Qgb2JqZWN0LiBJdCB3aWxsIG5vdCBoYW5kbGUgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ2h1bmtUb1JlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENodW5rVG9SZXF1ZXN0KHJlcSkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9vZmZzZXQgKyB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgcmVxLnNldFByb2dyZXNzSGFuZGxlcihmdW5jdGlvbiAoYnl0ZXNTZW50KSB7XG4gICAgICAgIF90aGlzOS5fZW1pdFByb2dyZXNzKHN0YXJ0ICsgYnl0ZXNTZW50LCBfdGhpczkuX3NpemUpO1xuICAgICAgfSk7XG4gICAgICByZXEuc2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTsgLy8gVGhlIHNwZWNpZmllZCBjaHVua1NpemUgbWF5IGJlIEluZmluaXR5IG9yIHRoZSBjYWxjbHVhdGVkIGVuZCBwb3NpdGlvblxuICAgICAgLy8gbWF5IGV4Y2VlZCB0aGUgZmlsZSdzIHNpemUuIEluIGJvdGggY2FzZXMsIHdlIGxpbWl0IHRoZSBlbmQgcG9zaXRpb24gdG9cbiAgICAgIC8vIHRoZSBpbnB1dCdzIHRvdGFsIHNpemUgZm9yIHNpbXBsZXIgY2FsY3VsYXRpb25zIGFuZCBjb3JyZWN0bmVzcy5cblxuICAgICAgaWYgKChlbmQgPT09IEluZmluaXR5IHx8IGVuZCA+IHRoaXMuX3NpemUpICYmICF0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgZW5kID0gdGhpcy5fc2l6ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5zbGljZShzdGFydCwgZW5kKS50aGVuKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICAgICAgICAgIGRvbmUgPSBfcmVmMi5kb25lOyAvLyBJZiB0aGUgdXBsb2FkIGxlbmd0aCBpcyBkZWZlcnJlZCwgdGhlIHVwbG9hZCBzaXplIHdhcyBub3Qgc3BlY2lmaWVkIGR1cmluZ1xuICAgICAgICAvLyB1cGxvYWQgY3JlYXRpb24uIFNvLCBpZiB0aGUgZmlsZSByZWFkZXIgaXMgZG9uZSByZWFkaW5nLCB3ZSBrbm93IHRoZSB0b3RhbFxuICAgICAgICAvLyB1cGxvYWQgc2l6ZSBhbmQgY2FuIHRlbGwgdGhlIHR1cyBzZXJ2ZXIuXG5cbiAgICAgICAgaWYgKF90aGlzOS5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkICYmIGRvbmUpIHtcbiAgICAgICAgICBfdGhpczkuX3NpemUgPSBfdGhpczkuX29mZnNldCArICh2YWx1ZSAmJiB2YWx1ZS5zaXplID8gdmFsdWUuc2l6ZSA6IDApO1xuICAgICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtTGVuZ3RoXCIsIF90aGlzOS5fc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM5Ll9zZW5kUmVxdWVzdChyZXEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzOS5fZW1pdFByb2dyZXNzKF90aGlzOS5fb2Zmc2V0LCBfdGhpczkuX3NpemUpO1xuXG4gICAgICAgICAgcmV0dXJuIF90aGlzOS5fc2VuZFJlcXVlc3QocmVxLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfaGFuZGxlVXBsb2FkUmVzcG9uc2UgaXMgdXNlZCBieSByZXF1ZXN0cyB0aGF0IGhhdmVuIGJlZW4gc2VudCB1c2luZyBfYWRkQ2h1bmtUb1JlcXVlc3RcbiAgICAgKiBhbmQgYWxyZWFkeSBoYXZlIHJlY2VpdmVkIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVVcGxvYWRSZXNwb25zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVXBsb2FkUmVzcG9uc2UocmVxLCByZXMpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiKSwgMTApO1xuXG4gICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICB0aGlzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIG9mZnNldCB2YWx1ZVwiKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VtaXRQcm9ncmVzcyhvZmZzZXQsIHRoaXMuX3NpemUpO1xuXG4gICAgICB0aGlzLl9lbWl0Q2h1bmtDb21wbGV0ZShvZmZzZXQgLSB0aGlzLl9vZmZzZXQsIG9mZnNldCwgdGhpcy5fc2l6ZSk7XG5cbiAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcblxuICAgICAgaWYgKG9mZnNldCA9PSB0aGlzLl9zaXplKSB7XG4gICAgICAgIC8vIFlheSwgZmluYWxseSBkb25lIDopXG4gICAgICAgIHRoaXMuX2VtaXRTdWNjZXNzKCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLmNsb3NlKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZXJmb3JtVXBsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG1ldGhvZCBhbmQgVVJMLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QobWV0aG9kLCB1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLl9yZXEgPSByZXE7XG4gICAgICByZXR1cm4gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGluIHRoZSBVUkwgc3RvcmFnZSwgaWYgaXQgaGFzIGJlZW4gc2F2ZWQgYmVmb3JlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRnJvbVVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21VcmxTdG9yYWdlKCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX3VybFN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5yZW1vdmVVcGxvYWQodGhpcy5fdXJsU3RvcmFnZUtleSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMTAuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHVwbG9hZCBVUkwgdG8gdGhlIFVSTCBzdG9yYWdlLCBpZiBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhdmVVcGxvYWRJblVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7IC8vIE9ubHkgaWYgYSBmaW5nZXJwcmludCB3YXMgY2FsY3VsYXRlZCBmb3IgdGhlIGlucHV0IChpLmUuIG5vdCBhIHN0cmVhbSksIHdlIGNhbiBzdG9yZSB0aGUgdXBsb2FkIFVSTC5cblxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmcgfHwgIXRoaXMuX2ZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3JlZFVwbG9hZCA9IHtcbiAgICAgICAgc2l6ZTogdGhpcy5fc2l6ZSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMub3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBuZXcgRGF0ZSgpLnRvU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9wYXJhbGxlbFVwbG9hZHMpIHtcbiAgICAgICAgLy8gU2F2ZSBtdWx0aXBsZSBVUkxzIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQgLi4uXG4gICAgICAgIHN0b3JlZFVwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMgPSB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAuLi4gb3RoZXJ3aXNlIHdlIGp1c3Qgc2F2ZSB0aGUgb25lIGF2YWlsYWJsZSBVUkwuXG4gICAgICAgIHN0b3JlZFVwbG9hZC51cGxvYWRVcmwgPSB0aGlzLnVybDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5hZGRVcGxvYWQodGhpcy5fZmluZ2VycHJpbnQsIHN0b3JlZFVwbG9hZCkudGhlbihmdW5jdGlvbiAodXJsU3RvcmFnZUtleSkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMS5fdXJsU3RvcmFnZUtleSA9IHVybFN0b3JhZ2VLZXk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMxMS5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHJlcXVlc3Qgd2l0aCB0aGUgcHJvdmlkZWQgYm9keSB3aGlsZSBpbnZva2luZyB0aGUgb25CZWZvcmVSZXF1ZXN0XG4gICAgICogYW5kIG9uQWZ0ZXJSZXNwb25zZSBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZW5kUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VuZFJlcXVlc3QocmVxKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIHZhciBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25CZWZvcmVSZXF1ZXN0KHJlcSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXEuc2VuZChib2R5KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczEyLm9wdGlvbnMub25BZnRlclJlc3BvbnNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBfdGhpczEyLm9wdGlvbnMub25BZnRlclJlc3BvbnNlKHJlcSwgcmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ0ZXJtaW5hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVybWluYXRlKHVybCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInR1czogdGhlIHRlcm1pbmF0ZSBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgYSBjYWxsYmFjayBzaW5jZSB2MiBhbnltb3JlOyBwbGVhc2UgdXNlIHRoZSByZXR1cm5lZCBQcm9taXNlIGluc3RlYWRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXEgPSBvcGVuUmVxdWVzdChcIkRFTEVURVwiLCB1cmwsIG9wdGlvbnMpO1xuICAgICAgdmFyIHByb21pc2UgPSByZXEuc2VuZCgpO1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIC8vIEEgMjA0IHJlc3BvbnNlIGluZGljYXRlcyBhIHN1Y2Nlc3NmdWxsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcy5nZXRTdGF0dXMoKSA9PT0gMjA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IF9lcnJvci5kZWZhdWx0KFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHRlcm1pbmF0aW5nIHVwbG9hZFwiLCBudWxsLCByZXEsIHJlcyk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgX2Vycm9yLmRlZmF1bHQpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IF9lcnJvci5kZWZhdWx0KFwidHVzOiBmYWlsZWQgdG8gdGVybWluYXRlIHVwbG9hZFwiLCBlcnIsIHJlcSwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZFJldHJ5KGVyciwgMCwgb3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gLy8gSW5zdGVhZCBvZiBrZWVwaW5nIHRyYWNrIG9mIHRoZSByZXRyeSBhdHRlbXB0cywgd2UgcmVtb3ZlIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGRlbGF5c1xuICAgICAgICAvLyBhcnJheS4gSWYgdGhlIGFycmF5IGlzIGVtcHR5LCBhbGwgcmV0cnkgYXR0ZW1wdHMgYXJlIHVzZWQgdXAgYW5kIHdlIHdpbGwgYnViYmxlIHVwIHRoZSBlcnJvci5cbiAgICAgICAgLy8gV2UgcmVjdXJzaXZlbHkgY2FsbCB0aGUgdGVybWluYXRlIGZ1bmN0aW9uIHdpbGwgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgcmV0cnlEZWxheXMgYXJyYXkuXG5cblxuICAgICAgICB2YXIgZGVsYXkgPSBvcHRpb25zLnJldHJ5RGVsYXlzWzBdO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVsYXlzID0gb3B0aW9ucy5yZXRyeURlbGF5cy5zbGljZSgxKTtcblxuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICByZXRyeURlbGF5czogcmVtYWluaW5nRGVsYXlzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEJhc2VVcGxvYWQudGVybWluYXRlKHVybCwgbmV3T3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VVcGxvYWQ7XG59KCk7XG5cbmZ1bmN0aW9uIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gIHZhciBlbmNvZGVkID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG1ldGFkYXRhKSB7XG4gICAgZW5jb2RlZC5wdXNoKGtleSArIFwiIFwiICsgX2pzQmFzZS5CYXNlNjQuZW5jb2RlKG1ldGFkYXRhW2tleV0pKTtcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVkLmpvaW4oXCIsXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIHN0YXR1cyBpcyBpbiB0aGUgcmFuZ2Ugb2YgdGhlIGV4cGVjdGVkIGNhdGVnb3J5LlxuICogRm9yIGV4YW1wbGUsIG9ubHkgYSBzdGF0dXMgYmV0d2VlbiAyMDAgYW5kIDI5OSB3aWxsIHNhdGlzZnkgdGhlIGNhdGVnb3J5IDIwMC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCBjYXRlZ29yeSkge1xuICByZXR1cm4gc3RhdHVzID49IGNhdGVnb3J5ICYmIHN0YXR1cyA8IGNhdGVnb3J5ICsgMTAwO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgSFRUUCByZXF1ZXN0IHdpdGggdGhlIHNwZWNpZmllZCBtZXRob2QgYW5kIFVSTC5cbiAqIFRoZSBuZWNlc3NhcnkgaGVhZGVycyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBldmVyeSByZXF1ZXN0XG4gKiB3aWxsIGJlIGFkZGVkLCBpbmNsdWRpbmcgdGhlIHJlcXVlc3QgSUQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBvcGVuUmVxdWVzdChtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICB2YXIgcmVxID0gb3B0aW9ucy5odHRwU3RhY2suY3JlYXRlUmVxdWVzdChtZXRob2QsIHVybCk7XG4gIHJlcS5zZXRIZWFkZXIoXCJUdXMtUmVzdW1hYmxlXCIsIFwiMS4wLjBcIik7XG4gIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgIHJlcS5zZXRIZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hZGRSZXF1ZXN0SWQpIHtcbiAgICB2YXIgcmVxdWVzdElkID0gKDAsIF91dWlkLmRlZmF1bHQpKCk7XG4gICAgcmVxLnNldEhlYWRlcihcIlgtUmVxdWVzdC1JRFwiLCByZXF1ZXN0SWQpO1xuICB9XG5cbiAgcmV0dXJuIHJlcTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGJyb3dzZXIgcnVubmluZyB0aGlzIGNvZGUgaGFzIGludGVybmV0IGFjY2Vzcy5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHdheXMgcmV0dXJuIHRydWUgaW4gdGhlIG5vZGUuanMgZW52aXJvbm1lbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT25saW5lKCkge1xuICB2YXIgb25saW5lID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm5hdmlnYXRvclwiIGluIHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA9PT0gZmFsc2UpIHtcbiAgICBvbmxpbmUgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBvbmxpbmU7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBvayB0byByZXRyeSBhIHJlcXVlc3QuXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgdGhlIGVycm9yIHJldHVybmVkIGZyb20gdGhlIGxhc3QgcmVxdWVzdFxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJ5QXR0ZW1wdCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmV0cmllZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdHVzIFVwbG9hZCBvcHRpb25zXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRSZXRyeShlcnIsIHJldHJ5QXR0ZW1wdCwgb3B0aW9ucykge1xuICAvLyBXZSBvbmx5IGF0dGVtcHQgYSByZXRyeSBpZlxuICAvLyAtIHJldHJ5RGVsYXlzIG9wdGlvbiBpcyBzZXRcbiAgLy8gLSB3ZSBkaWRuJ3QgZXhjZWVkIHRoZSBtYXhpdW0gbnVtYmVyIG9mIHJldHJpZXMsIHlldCwgYW5kXG4gIC8vIC0gdGhpcyBlcnJvciB3YXMgY2F1c2VkIGJ5IGEgcmVxdWVzdCBvciBpdCdzIHJlc3BvbnNlIGFuZFxuICAvLyAtIHRoZSBlcnJvciBpcyBzZXJ2ZXIgZXJyb3IgKGkuZS4gbm8gYSBzdGF0dXMgNHh4IG9yIGEgNDA5IG9yIDQyMykgYW5kXG4gIC8vIC0gdGhlIGJyb3dzZXIgZG9lcyBub3QgaW5kaWNhdGUgdGhhdCB3ZSBhcmUgb2ZmbGluZVxuICB2YXIgc3RhdHVzID0gZXJyLm9yaWdpbmFsUmVzcG9uc2UgPyBlcnIub3JpZ2luYWxSZXNwb25zZS5nZXRTdGF0dXMoKSA6IDA7XG4gIHZhciBpc1NlcnZlckVycm9yID0gIWluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApIHx8IHN0YXR1cyA9PT0gNDA5IHx8IHN0YXR1cyA9PT0gNDIzO1xuICByZXR1cm4gb3B0aW9ucy5yZXRyeURlbGF5cyAhPSBudWxsICYmIHJldHJ5QXR0ZW1wdCA8IG9wdGlvbnMucmV0cnlEZWxheXMubGVuZ3RoICYmIGVyci5vcmlnaW5hbFJlcXVlc3QgIT0gbnVsbCAmJiBpc1NlcnZlckVycm9yICYmIGlzT25saW5lKCk7XG59XG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBsaW5rIGdpdmVuIHRoZSBvcmlnaW4gYXMgc291cmNlLiBGb3IgZXhhbXBsZSxcbiAqIGlmIGEgSFRUUCByZXF1ZXN0IHRvIGh0dHA6Ly9leGFtcGxlLmNvbS9maWxlcy8gcmV0dXJucyBhIExvY2F0aW9uXG4gKiBoZWFkZXIgd2l0aCB0aGUgdmFsdWUgL3VwbG9hZC9hYmMsIHRoZSByZXNvbHZlZCBVUkwgd2lsbCBiZTpcbiAqIGh0dHA6Ly9leGFtcGxlLmNvbS91cGxvYWQvYWJjXG4gKi9cblxuXG5mdW5jdGlvbiByZXNvbHZlVXJsKG9yaWdpbiwgbGluaykge1xuICByZXR1cm4gbmV3IF91cmxQYXJzZS5kZWZhdWx0KGxpbmssIG9yaWdpbikudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBmb3IgdGhlIHBhcnRzIGlmIGFuIHVwbG9hZFxuICogaXMgc3BsaXQgaW50byBtdWx0aXBsZSBwYXJhbGxlbCByZXF1ZXN0cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxTaXplIFRoZSBieXRlIHNpemUgb2YgdGhlIHVwbG9hZCwgd2hpY2ggd2lsbCBiZSBzcGxpdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0Q291bnQgVGhlIG51bWJlciBpbiBob3cgbWFueSBwYXJ0cyB0aGUgdXBsb2FkIHdpbGwgYmUgc3BsaXQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcmV2aW91c1VybHMgVGhlIHVwbG9hZCBVUkxzIGZvciBwcmV2aW91cyBwYXJ0cy5cbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzcGxpdFNpemVJbnRvUGFydHModG90YWxTaXplLCBwYXJ0Q291bnQsIHByZXZpb3VzVXJscykge1xuICB2YXIgcGFydFNpemUgPSBNYXRoLmZsb29yKHRvdGFsU2l6ZSAvIHBhcnRDb3VudCk7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydENvdW50OyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHtcbiAgICAgIHN0YXJ0OiBwYXJ0U2l6ZSAqIGksXG4gICAgICBlbmQ6IHBhcnRTaXplICogKGkgKyAxKVxuICAgIH0pO1xuICB9XG5cbiAgcGFydHNbcGFydENvdW50IC0gMV0uZW5kID0gdG90YWxTaXplOyAvLyBBdHRhY2ggVVJMcyBmcm9tIHByZXZpb3VzIHVwbG9hZHMsIGlmIGF2YWlsYWJsZS5cblxuICBpZiAocHJldmlvdXNVcmxzKSB7XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCwgaW5kZXgpIHtcbiAgICAgIHBhcnQudXBsb2FkVXJsID0gcHJldmlvdXNVcmxzW2luZGV4XSB8fCBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5CYXNlVXBsb2FkLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG52YXIgX2RlZmF1bHQgPSBCYXNlVXBsb2FkO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB1dWlkO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgVVVJRCB2NCBiYXNlZCBvbiByYW5kb20gbnVtYmVycy4gV2UgaW50ZW50aW9hbmxseSB1c2UgdGhlIGxlc3NcbiAqIHNlY3VyZSBNYXRoLnJhbmRvbSBmdW5jdGlvbiBoZXJlIHNpbmNlIHRoZSBtb3JlIHNlY3VyZSBjcnlwdG8uZ2V0UmFuZG9tTnVtYmVyc1xuICogaXMgbm90IGF2YWlsYWJsZSBvbiBhbGwgcGxhdGZvcm1zLlxuICogVGhpcyBpcyBub3QgYSBwcm9ibGVtIGZvciB1cyBzaW5jZSB3ZSB1c2UgdGhlIFVVSUQgb25seSBmb3IgZ2VuZXJhdGluZyBhXG4gKiByZXF1ZXN0IElELCBzbyB3ZSBjYW4gY29ycmVsYXRlIHNlcnZlciBsb2dzIHRvIGNsaWVudCBlcnJvcnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0YWtlbiBmcm9tIGZvbGxvd2luZyBzaXRlOlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2NyZWF0ZS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGdlbmVyYXRlIFVVSURcbiAqL1xuZnVuY3Rpb24gdXVpZCgpIHtcbiAgcmV0dXJuIFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgdiA9IGMgPT0gXCJ4XCIgPyByIDogciAmIDB4MyB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6W1xcXFwvXSsvXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFtcXFxcL117MSx9KT8oW1xcU1xcc10qKS9pXG4gICwgd2hpdGVzcGFjZSA9ICdbXFxcXHgwOVxcXFx4MEFcXFxceDBCXFxcXHgwQ1xcXFx4MERcXFxceDIwXFxcXHhBMFxcXFx1MTY4MFxcXFx1MTgwRVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwQVxcXFx1MjAyRlxcXFx1MjA1RlxcXFx1MzAwMFxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1RkVGRl0nXG4gICwgbGVmdCA9IG5ldyBSZWdFeHAoJ14nKyB3aGl0ZXNwYWNlICsnKycpO1xuXG4vKipcbiAqIFRyaW0gYSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gdHJpbS5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdHJpbUxlZnQoc3RyKSB7XG4gIHJldHVybiAoc3RyID8gc3RyIDogJycpLnRvU3RyaW5nKCkucmVwbGFjZShsZWZ0LCAnJyk7XG59XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgZ2xvYmFsVmFyO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gd2luZG93O1xuICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gZ2xvYmFsO1xuICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7XG4gIGVsc2UgZ2xvYmFsVmFyID0ge307XG5cbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsVmFyLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcblxuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcylcbiAgICAsIHByb3RvY29sID0gbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJydcbiAgICAsIHNsYXNoZXMgPSAhIShtYXRjaFsyXSAmJiBtYXRjaFsyXS5sZW5ndGggPj0gMilcbiAgICAsIHJlc3QgPSAgbWF0Y2hbMl0gJiYgbWF0Y2hbMl0ubGVuZ3RoID09PSAxID8gJy8nICsgbWF0Y2hbM10gOiBtYXRjaFszXTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBzbGFzaGVzOiBzbGFzaGVzLFxuICAgIHJlc3Q6IHJlc3RcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBEZWZhdWx0IHRvIGEgLyBmb3IgcGF0aG5hbWUgaWYgbm9uZSBleGlzdHMuIFRoaXMgbm9ybWFsaXplcyB0aGUgVVJMXG4gIC8vIHRvIGFsd2F5cyBoYXZlIGEgL1xuICAvL1xuICBpZiAodXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nICYmIHVybC5ob3N0bmFtZSkge1xuICAgIHVybC5wYXRobmFtZSA9ICcvJyArIHVybC5wYXRobmFtZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuIiwiLyoganNoaW50IG5vZGU6IHRydWUgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gICMgd2lsZGNhcmRcblxuICBWZXJ5IHNpbXBsZSB3aWxkY2FyZCBtYXRjaGluZywgd2hpY2ggaXMgZGVzaWduZWQgdG8gcHJvdmlkZSB0aGUgc2FtZVxuICBmdW5jdGlvbmFsaXR5IHRoYXQgaXMgZm91bmQgaW4gdGhlXG4gIFtldmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS13ZWJwbGF0Zm9ybS9ldmUpIGV2ZW50aW5nIGxpYnJhcnkuXG5cbiAgIyMgVXNhZ2VcblxuICBJdCB3b3JrcyB3aXRoIHN0cmluZ3M6XG5cbiAgPDw8IGV4YW1wbGVzL3N0cmluZ3MuanNcblxuICBBcnJheXM6XG5cbiAgPDw8IGV4YW1wbGVzL2FycmF5cy5qc1xuXG4gIE9iamVjdHMgKG1hdGNoaW5nIGFnYWluc3Qga2V5cyk6XG5cbiAgPDw8IGV4YW1wbGVzL29iamVjdHMuanNcblxuICBXaGlsZSB0aGUgbGlicmFyeSB3b3JrcyBpbiBOb2RlLCBpZiB5b3UgYXJlIGFyZSBsb29raW5nIGZvciBmaWxlLWJhc2VkXG4gIHdpbGRjYXJkIG1hdGNoaW5nIHRoZW4geW91IHNob3VsZCBoYXZlIGEgbG9vayBhdDpcblxuICA8aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2I+XG4qKi9cblxuZnVuY3Rpb24gV2lsZGNhcmRNYXRjaGVyKHRleHQsIHNlcGFyYXRvcikge1xuICB0aGlzLnRleHQgPSB0ZXh0ID0gdGV4dCB8fCAnJztcbiAgdGhpcy5oYXNXaWxkID0gfnRleHQuaW5kZXhPZignKicpO1xuICB0aGlzLnNlcGFyYXRvciA9IHNlcGFyYXRvcjtcbiAgdGhpcy5wYXJ0cyA9IHRleHQuc3BsaXQoc2VwYXJhdG9yKTtcbn1cblxuV2lsZGNhcmRNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBtYXRjaGVzID0gdHJ1ZTtcbiAgdmFyIHBhcnRzID0gdGhpcy5wYXJ0cztcbiAgdmFyIGlpO1xuICB2YXIgcGFydHNDb3VudCA9IHBhcnRzLmxlbmd0aDtcbiAgdmFyIHRlc3RQYXJ0cztcblxuICBpZiAodHlwZW9mIGlucHV0ID09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmhhc1dpbGQgJiYgdGhpcy50ZXh0ICE9IGlucHV0KSB7XG4gICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlc3RQYXJ0cyA9IChpbnB1dCB8fCAnJykuc3BsaXQodGhpcy5zZXBhcmF0b3IpO1xuICAgICAgZm9yIChpaSA9IDA7IG1hdGNoZXMgJiYgaWkgPCBwYXJ0c0NvdW50OyBpaSsrKSB7XG4gICAgICAgIGlmIChwYXJ0c1tpaV0gPT09ICcqJykgIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpaSA8IHRlc3RQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICBtYXRjaGVzID0gcGFydHNbaWldID09PSB0ZXN0UGFydHNbaWldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBtYXRjaGVzLCB0aGVuIHJldHVybiB0aGUgY29tcG9uZW50IHBhcnRzXG4gICAgICBtYXRjaGVzID0gbWF0Y2hlcyAmJiB0ZXN0UGFydHM7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBpbnB1dC5zcGxpY2UgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hdGNoZXMgPSBbXTtcblxuICAgIGZvciAoaWkgPSBpbnB1dC5sZW5ndGg7IGlpLS07ICkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goaW5wdXRbaWldKSkge1xuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoXSA9IGlucHV0W2lpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09ICdvYmplY3QnKSB7XG4gICAgbWF0Y2hlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5tYXRjaChrZXkpKSB7XG4gICAgICAgIG1hdGNoZXNba2V5XSA9IGlucHV0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRleHQsIHRlc3QsIHNlcGFyYXRvcikge1xuICB2YXIgbWF0Y2hlciA9IG5ldyBXaWxkY2FyZE1hdGNoZXIodGV4dCwgc2VwYXJhdG9yIHx8IC9bXFwvXFwuXS8pO1xuICBpZiAodHlwZW9mIHRlc3QgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaCh0ZXN0KTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNsaWVudCBsaWJyYXJ5IGZvciBjb21tdW5pY2F0aW9uIHdpdGggQ29tcGFuaW9uLiBJbnRlbmRlZCBmb3IgdXNlIGluIFVwcHkgcGx1Z2lucy5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4xMC4xXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiY29tcGFuaW9uXCIsXG4gICAgXCJwcm92aWRlclwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJuYW1lc3BhY2UtZW1pdHRlclwiOiBcIl4yLjAuMVwiLFxuICAgIFwicXMtc3RyaW5naWZ5XCI6IFwiXjEuMS4wXCIsXG4gICAgXCJ1cmwtcGFyc2VcIjogXCJeMS40LjdcIlxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoJ0F1dGhvcml6YXRpb24gcmVxdWlyZWQnKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoRXJyb3InXG4gICAgdGhpcy5pc0F1dGhFcnJvciA9IHRydWVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhFcnJvclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHFzU3RyaW5naWZ5ID0gcmVxdWlyZSgncXMtc3RyaW5naWZ5JylcbmNvbnN0IFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpXG5jb25zdCBSZXF1ZXN0Q2xpZW50ID0gcmVxdWlyZSgnLi9SZXF1ZXN0Q2xpZW50JylcbmNvbnN0IHRva2VuU3RvcmFnZSA9IHJlcXVpcmUoJy4vdG9rZW5TdG9yYWdlJylcblxuY29uc3QgX2dldE5hbWUgPSAoaWQpID0+IHtcbiAgcmV0dXJuIGlkLnNwbGl0KCctJykubWFwKChzKSA9PiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKSkuam9pbignICcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUHJvdmlkZXIgZXh0ZW5kcyBSZXF1ZXN0Q2xpZW50IHtcbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyXG4gICAgdGhpcy5pZCA9IHRoaXMucHJvdmlkZXJcbiAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdHMubmFtZSB8fCBfZ2V0TmFtZSh0aGlzLmlkKVxuICAgIHRoaXMucGx1Z2luSWQgPSB0aGlzLm9wdHMucGx1Z2luSWRcbiAgICB0aGlzLnRva2VuS2V5ID0gYGNvbXBhbmlvbi0ke3RoaXMucGx1Z2luSWR9LWF1dGgtdG9rZW5gXG4gICAgdGhpcy5jb21wYW5pb25LZXlzUGFyYW1zID0gdGhpcy5vcHRzLmNvbXBhbmlvbktleXNQYXJhbXNcbiAgICB0aGlzLnByZUF1dGhUb2tlbiA9IG51bGxcbiAgfVxuXG4gIGhlYWRlcnMgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbc3VwZXIuaGVhZGVycygpLCB0aGlzLmdldEF1dGhUb2tlbigpXSlcbiAgICAgIC50aGVuKChbaGVhZGVycywgdG9rZW5dKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0ge31cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgYXV0aEhlYWRlcnNbJ3VwcHktYXV0aC10b2tlbiddID0gdG9rZW5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbXBhbmlvbktleXNQYXJhbXMpIHtcbiAgICAgICAgICBhdXRoSGVhZGVyc1sndXBweS1jcmVkZW50aWFscy1wYXJhbXMnXSA9IGJ0b2EoXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHBhcmFtczogdGhpcy5jb21wYW5pb25LZXlzUGFyYW1zIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmhlYWRlcnMsIC4uLmF1dGhIZWFkZXJzIH1cbiAgICAgIH0pXG4gIH1cblxuICBvblJlY2VpdmVSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICByZXNwb25zZSA9IHN1cGVyLm9uUmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKVxuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMudXBweS5nZXRQbHVnaW4odGhpcy5wbHVnaW5JZClcbiAgICBjb25zdCBvbGRBdXRoZW50aWNhdGVkID0gcGx1Z2luLmdldFBsdWdpblN0YXRlKCkuYXV0aGVudGljYXRlZFxuICAgIGNvbnN0IGF1dGhlbnRpY2F0ZWQgPSBvbGRBdXRoZW50aWNhdGVkID8gcmVzcG9uc2Uuc3RhdHVzICE9PSA0MDEgOiByZXNwb25zZS5zdGF0dXMgPCA0MDBcbiAgICBwbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBhdXRoZW50aWNhdGVkIH0pXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvLyBAdG9kbyhpLm9sYXJld2FqdSkgY29uc2lkZXIgd2hldGhlciBvciBub3QgdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGV4cG9zZWRcbiAgc2V0QXV0aFRva2VuICh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnRva2VuS2V5LCB0b2tlbilcbiAgfVxuXG4gIGdldEF1dGhUb2tlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBweS5nZXRQbHVnaW4odGhpcy5wbHVnaW5JZCkuc3RvcmFnZS5nZXRJdGVtKHRoaXMudG9rZW5LZXkpXG4gIH1cblxuICBhdXRoVXJsIChxdWVyaWVzID0ge30pIHtcbiAgICBpZiAodGhpcy5wcmVBdXRoVG9rZW4pIHtcbiAgICAgIHF1ZXJpZXMudXBweVByZUF1dGhUb2tlbiA9IHRoaXMucHJlQXV0aFRva2VuXG4gICAgfVxuXG4gICAgbGV0IHN0cmlnaWZpZWRRdWVyaWVzID0gcXNTdHJpbmdpZnkocXVlcmllcylcbiAgICBzdHJpZ2lmaWVkUXVlcmllcyA9IHN0cmlnaWZpZWRRdWVyaWVzID8gYD8ke3N0cmlnaWZpZWRRdWVyaWVzfWAgOiBzdHJpZ2lmaWVkUXVlcmllc1xuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS8ke3RoaXMuaWR9L2Nvbm5lY3Qke3N0cmlnaWZpZWRRdWVyaWVzfWBcbiAgfVxuXG4gIGZpbGVVcmwgKGlkKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuaG9zdG5hbWV9LyR7dGhpcy5pZH0vZ2V0LyR7aWR9YFxuICB9XG5cbiAgZmV0Y2hQcmVBdXRoVG9rZW4gKCkge1xuICAgIGlmICghdGhpcy5jb21wYW5pb25LZXlzUGFyYW1zKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KGAke3RoaXMuaWR9L3ByZWF1dGgvYCwgeyBwYXJhbXM6IHRoaXMuY29tcGFuaW9uS2V5c1BhcmFtcyB9KVxuICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICB0aGlzLnByZUF1dGhUb2tlbiA9IHJlcy50b2tlblxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGBbQ29tcGFuaW9uQ2xpZW50XSB1bmFibGUgdG8gZmV0Y2ggcHJlQXV0aFRva2VuICR7ZXJyfWAsICd3YXJuaW5nJylcbiAgICAgIH0pXG4gIH1cblxuICBsaXN0IChkaXJlY3RvcnkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYCR7dGhpcy5pZH0vbGlzdC8ke2RpcmVjdG9yeSB8fCAnJ31gKVxuICB9XG5cbiAgbG9nb3V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYCR7dGhpcy5pZH0vbG9nb3V0YClcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gUHJvbWlzZS5hbGwoW1xuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgdGhpcy51cHB5LmdldFBsdWdpbih0aGlzLnBsdWdpbklkKS5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy50b2tlbktleSksXG4gICAgICBdKSkudGhlbigoW3Jlc3BvbnNlXSkgPT4gcmVzcG9uc2UpXG4gIH1cblxuICBzdGF0aWMgaW5pdFBsdWdpbiAocGx1Z2luLCBvcHRzLCBkZWZhdWx0T3B0cykge1xuICAgIHBsdWdpbi50eXBlID0gJ2FjcXVpcmVyJ1xuICAgIHBsdWdpbi5maWxlcyA9IFtdXG4gICAgaWYgKGRlZmF1bHRPcHRzKSB7XG4gICAgICBwbHVnaW4ub3B0cyA9IHsgLi4uZGVmYXVsdE9wdHMsIC4uLm9wdHMgfVxuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlclVybCB8fCBvcHRzLnNlcnZlclBhdHRlcm4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHNlcnZlclVybGAgYW5kIGBzZXJ2ZXJQYXR0ZXJuYCBoYXZlIGJlZW4gcmVuYW1lZCB0byBgY29tcGFuaW9uVXJsYCBhbmQgYGNvbXBhbmlvbkFsbG93ZWRIb3N0c2AgcmVzcGVjdGl2ZWx5IGluIHRoZSAwLjMwLjUgcmVsZWFzZS4gUGxlYXNlIGNvbnN1bHQgdGhlIGRvY3MgKGZvciBleGFtcGxlLCBodHRwczovL3VwcHkuaW8vZG9jcy9pbnN0YWdyYW0vIGZvciB0aGUgSW5zdGFncmFtIHBsdWdpbikgYW5kIHVzZSB0aGUgdXBkYXRlZCBvcHRpb25zLmAnKVxuICAgIH1cblxuICAgIGlmIChvcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cykge1xuICAgICAgY29uc3QgcGF0dGVybiA9IG9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzXG4gICAgICAvLyB2YWxpZGF0ZSBjb21wYW5pb25BbGxvd2VkSG9zdHMgcGFyYW1cbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkocGF0dGVybikgJiYgIShwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3BsdWdpbi5pZH06IHRoZSBvcHRpb24gXCJjb21wYW5pb25BbGxvd2VkSG9zdHNcIiBtdXN0IGJlIG9uZSBvZiBzdHJpbmcsIEFycmF5LCBSZWdFeHBgKVxuICAgICAgfVxuICAgICAgcGx1Z2luLm9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzID0gcGF0dGVyblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2VzIG5vdCBzdGFydCB3aXRoIGh0dHBzOi8vXG4gICAgICBpZiAoL14oPyFodHRwcz86XFwvXFwvKS4qJC9pLnRlc3Qob3B0cy5jb21wYW5pb25VcmwpKSB7XG4gICAgICAgIHBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cyA9IGBodHRwczovLyR7b3B0cy5jb21wYW5pb25VcmwucmVwbGFjZSgvXlxcL1xcLy8sICcnKX1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbHVnaW4ub3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMgPSBuZXcgVVJMKG9wdHMuY29tcGFuaW9uVXJsKS5vcmlnaW5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwbHVnaW4uc3RvcmFnZSA9IHBsdWdpbi5vcHRzLnN0b3JhZ2UgfHwgdG9rZW5TdG9yYWdlXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBBdXRoRXJyb3IgPSByZXF1aXJlKCcuL0F1dGhFcnJvcicpXG5jb25zdCBmZXRjaFdpdGhOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmV0Y2hXaXRoTmV0d29ya0Vycm9yJylcblxuLy8gUmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaCBzbyB3ZSBjYW4gYWx3YXlzIHNhZmVseSBhcHBlbmQgL3h5ei5cbmZ1bmN0aW9uIHN0cmlwU2xhc2ggKHVybCkge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZXF1ZXN0Q2xpZW50IHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICB0aGlzLnVwcHkgPSB1cHB5XG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIHRoaXMub25SZWNlaXZlUmVzcG9uc2UgPSB0aGlzLm9uUmVjZWl2ZVJlc3BvbnNlLmJpbmQodGhpcylcbiAgICB0aGlzLmFsbG93ZWRIZWFkZXJzID0gWydhY2NlcHQnLCAnY29udGVudC10eXBlJywgJ3VwcHktYXV0aC10b2tlbiddXG4gICAgdGhpcy5wcmVmbGlnaHREb25lID0gZmFsc2VcbiAgfVxuXG4gIGdldCBob3N0bmFtZSAoKSB7XG4gICAgY29uc3QgeyBjb21wYW5pb24gfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgY29uc3QgaG9zdCA9IHRoaXMub3B0cy5jb21wYW5pb25VcmxcbiAgICByZXR1cm4gc3RyaXBTbGFzaChjb21wYW5pb24gJiYgY29tcGFuaW9uW2hvc3RdID8gY29tcGFuaW9uW2hvc3RdIDogaG9zdClcbiAgfVxuXG4gIGdldCBkZWZhdWx0SGVhZGVycyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdVcHB5LVZlcnNpb25zJzogYEB1cHB5L2NvbXBhbmlvbi1jbGllbnQ9JHtSZXF1ZXN0Q2xpZW50LlZFUlNJT059YCxcbiAgICB9XG4gIH1cblxuICBoZWFkZXJzICgpIHtcbiAgICBjb25zdCB1c2VySGVhZGVycyA9IHRoaXMub3B0cy5jb21wYW5pb25IZWFkZXJzIHx8IHRoaXMub3B0cy5zZXJ2ZXJIZWFkZXJzIHx8IHt9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAuLi50aGlzLmRlZmF1bHRIZWFkZXJzLFxuICAgICAgLi4udXNlckhlYWRlcnMsXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRQb3N0UmVzcG9uc2VGdW5jIChza2lwKSB7XG4gICAgcmV0dXJuIChyZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uUmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9XG4gIH1cblxuICBvblJlY2VpdmVSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgY29uc3QgY29tcGFuaW9uID0gc3RhdGUuY29tcGFuaW9uIHx8IHt9XG4gICAgY29uc3QgaG9zdCA9IHRoaXMub3B0cy5jb21wYW5pb25VcmxcbiAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVyc1xuICAgIC8vIFN0b3JlIHRoZSBzZWxmLWlkZW50aWZpZWQgZG9tYWluIG5hbWUgZm9yIHRoZSBDb21wYW5pb24gaW5zdGFuY2Ugd2UganVzdCBoaXQuXG4gICAgaWYgKGhlYWRlcnMuaGFzKCdpLWFtJykgJiYgaGVhZGVycy5nZXQoJ2ktYW0nKSAhPT0gY29tcGFuaW9uW2hvc3RdKSB7XG4gICAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgICBjb21wYW5pb246IHsgLi4uY29tcGFuaW9uLCBbaG9zdF06IGhlYWRlcnMuZ2V0KCdpLWFtJykgfSxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgX2dldFVybCAodXJsKSB7XG4gICAgaWYgKC9eKGh0dHBzPzp8KVxcL1xcLy8udGVzdCh1cmwpKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS8ke3VybH1gXG4gIH1cblxuICBfanNvbiAocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgdGhyb3cgbmV3IEF1dGhFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKHJlcy5zdGF0dXMgPCAyMDAgfHwgcmVzLnN0YXR1cyA+IDMwMCkge1xuICAgICAgbGV0IGVyck1zZyA9IGBGYWlsZWQgcmVxdWVzdCB3aXRoIHN0YXR1czogJHtyZXMuc3RhdHVzfS4gJHtyZXMuc3RhdHVzVGV4dH1gXG4gICAgICByZXR1cm4gcmVzLmpzb24oKVxuICAgICAgICAudGhlbigoZXJyRGF0YSkgPT4ge1xuICAgICAgICAgIGVyck1zZyA9IGVyckRhdGEubWVzc2FnZSA/IGAke2Vyck1zZ30gbWVzc2FnZTogJHtlcnJEYXRhLm1lc3NhZ2V9YCA6IGVyck1zZ1xuICAgICAgICAgIGVyck1zZyA9IGVyckRhdGEucmVxdWVzdElkID8gYCR7ZXJyTXNnfSByZXF1ZXN0LUlkOiAke2VyckRhdGEucmVxdWVzdElkfWAgOiBlcnJNc2dcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKVxuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7IHRocm93IG5ldyBFcnJvcihlcnJNc2cpIH0pXG4gICAgfVxuICAgIHJldHVybiByZXMuanNvbigpXG4gIH1cblxuICBwcmVmbGlnaHQgKHBhdGgpIHtcbiAgICBpZiAodGhpcy5wcmVmbGlnaHREb25lKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWxsb3dlZEhlYWRlcnMuc2xpY2UoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2godGhpcy5fZ2V0VXJsKHBhdGgpLCB7XG4gICAgICBtZXRob2Q6ICdPUFRJT05TJyxcbiAgICB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmhhcygnYWNjZXNzLWNvbnRyb2wtYWxsb3ctaGVhZGVycycpKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd2VkSGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdhY2Nlc3MtY29udHJvbC1hbGxvdy1oZWFkZXJzJylcbiAgICAgICAgICAgIC5zcGxpdCgnLCcpLm1hcCgoaGVhZGVyTmFtZSkgPT4gaGVhZGVyTmFtZS50cmltKCkudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWZsaWdodERvbmUgPSB0cnVlXG4gICAgICAgIHJldHVybiB0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGBbQ29tcGFuaW9uQ2xpZW50XSB1bmFibGUgdG8gbWFrZSBwcmVmbGlnaHQgcmVxdWVzdCAke2Vycn1gLCAnd2FybmluZycpXG4gICAgICAgIHRoaXMucHJlZmxpZ2h0RG9uZSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsb3dlZEhlYWRlcnMuc2xpY2UoKVxuICAgICAgfSlcbiAgfVxuXG4gIHByZWZsaWdodEFuZEhlYWRlcnMgKHBhdGgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMucHJlZmxpZ2h0KHBhdGgpLCB0aGlzLmhlYWRlcnMoKV0pXG4gICAgICAudGhlbigoW2FsbG93ZWRIZWFkZXJzLCBoZWFkZXJzXSkgPT4ge1xuICAgICAgICAvLyBmaWx0ZXIgdG8ga2VlcCBvbmx5IGFsbG93ZWQgSGVhZGVyc1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKChoZWFkZXIpID0+IHtcbiAgICAgICAgICBpZiAoYWxsb3dlZEhlYWRlcnMuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnVwcHkubG9nKGBbQ29tcGFuaW9uQ2xpZW50XSBleGNsdWRpbmcgdW5hbGxvd2VkIGhlYWRlciAke2hlYWRlcn1gKVxuICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gaGVhZGVyc1xuICAgICAgfSlcbiAgfVxuXG4gIGdldCAocGF0aCwgc2tpcFBvc3RSZXNwb25zZSkge1xuICAgIHJldHVybiB0aGlzLnByZWZsaWdodEFuZEhlYWRlcnMocGF0aClcbiAgICAgIC50aGVuKChoZWFkZXJzKSA9PlxuICAgICAgICBmZXRjaFdpdGhOZXR3b3JrRXJyb3IodGhpcy5fZ2V0VXJsKHBhdGgpLCB7XG4gICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUgfHwgJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgfSkpXG4gICAgICAudGhlbih0aGlzLl9nZXRQb3N0UmVzcG9uc2VGdW5jKHNraXBQb3N0UmVzcG9uc2UpKVxuICAgICAgLnRoZW4oKHJlcykgPT4gdGhpcy5fanNvbihyZXMpKVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFlcnIuaXNBdXRoRXJyb3IpIHtcbiAgICAgICAgICBlcnIubWVzc2FnZSA9IGBDb3VsZCBub3QgZ2V0ICR7dGhpcy5fZ2V0VXJsKHBhdGgpfS4gJHtlcnIubWVzc2FnZX1gXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcbiAgICAgIH0pXG4gIH1cblxuICBwb3N0IChwYXRoLCBkYXRhLCBza2lwUG9zdFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmxpZ2h0QW5kSGVhZGVycyhwYXRoKVxuICAgICAgLnRoZW4oKGhlYWRlcnMpID0+XG4gICAgICAgIGZldGNoV2l0aE5ldHdvcmtFcnJvcih0aGlzLl9nZXRVcmwocGF0aCksIHtcbiAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUgfHwgJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgfSkpXG4gICAgICAudGhlbih0aGlzLl9nZXRQb3N0UmVzcG9uc2VGdW5jKHNraXBQb3N0UmVzcG9uc2UpKVxuICAgICAgLnRoZW4oKHJlcykgPT4gdGhpcy5fanNvbihyZXMpKVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFlcnIuaXNBdXRoRXJyb3IpIHtcbiAgICAgICAgICBlcnIubWVzc2FnZSA9IGBDb3VsZCBub3QgcG9zdCAke3RoaXMuX2dldFVybChwYXRoKX0uICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICB9KVxuICB9XG5cbiAgZGVsZXRlIChwYXRoLCBkYXRhLCBza2lwUG9zdFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmxpZ2h0QW5kSGVhZGVycyhwYXRoKVxuICAgICAgLnRoZW4oKGhlYWRlcnMpID0+XG4gICAgICAgIGZldGNoV2l0aE5ldHdvcmtFcnJvcihgJHt0aGlzLmhvc3RuYW1lfS8ke3BhdGh9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ2RlbGV0ZScsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlIHx8ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgYm9keTogZGF0YSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogbnVsbCxcbiAgICAgICAgfSkpXG4gICAgICAudGhlbih0aGlzLl9nZXRQb3N0UmVzcG9uc2VGdW5jKHNraXBQb3N0UmVzcG9uc2UpKVxuICAgICAgLnRoZW4oKHJlcykgPT4gdGhpcy5fanNvbihyZXMpKVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFlcnIuaXNBdXRoRXJyb3IpIHtcbiAgICAgICAgICBlcnIubWVzc2FnZSA9IGBDb3VsZCBub3QgZGVsZXRlICR7dGhpcy5fZ2V0VXJsKHBhdGgpfS4gJHtlcnIubWVzc2FnZX1gXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcbiAgICAgIH0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSZXF1ZXN0Q2xpZW50ID0gcmVxdWlyZSgnLi9SZXF1ZXN0Q2xpZW50JylcblxuY29uc3QgX2dldE5hbWUgPSAoaWQpID0+IHtcbiAgcmV0dXJuIGlkLnNwbGl0KCctJykubWFwKChzKSA9PiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKSkuam9pbignICcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2VhcmNoUHJvdmlkZXIgZXh0ZW5kcyBSZXF1ZXN0Q2xpZW50IHtcbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyXG4gICAgdGhpcy5pZCA9IHRoaXMucHJvdmlkZXJcbiAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdHMubmFtZSB8fCBfZ2V0TmFtZSh0aGlzLmlkKVxuICAgIHRoaXMucGx1Z2luSWQgPSB0aGlzLm9wdHMucGx1Z2luSWRcbiAgfVxuXG4gIGZpbGVVcmwgKGlkKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuaG9zdG5hbWV9L3NlYXJjaC8ke3RoaXMuaWR9L2dldC8ke2lkfWBcbiAgfVxuXG4gIHNlYXJjaCAodGV4dCwgcXVlcmllcykge1xuICAgIHF1ZXJpZXMgPSBxdWVyaWVzID8gYCYke3F1ZXJpZXN9YCA6ICcnXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGBzZWFyY2gvJHt0aGlzLmlkfS9saXN0P3E9JHtlbmNvZGVVUklDb21wb25lbnQodGV4dCl9JHtxdWVyaWVzfWApXG4gIH1cbn1cbiIsImNvbnN0IGVlID0gcmVxdWlyZSgnbmFtZXNwYWNlLWVtaXR0ZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFVwcHlTb2NrZXQge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLl9xdWV1ZWQgPSBbXVxuICAgIHRoaXMuaXNPcGVuID0gZmFsc2VcbiAgICB0aGlzLmVtaXR0ZXIgPSBlZSgpXG5cbiAgICB0aGlzLl9oYW5kbGVNZXNzYWdlID0gdGhpcy5faGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5lbWl0ID0gdGhpcy5lbWl0LmJpbmQodGhpcylcbiAgICB0aGlzLm9uID0gdGhpcy5vbi5iaW5kKHRoaXMpXG4gICAgdGhpcy5vbmNlID0gdGhpcy5vbmNlLmJpbmQodGhpcylcbiAgICB0aGlzLnNlbmQgPSB0aGlzLnNlbmQuYmluZCh0aGlzKVxuXG4gICAgaWYgKCFvcHRzIHx8IG9wdHMuYXV0b09wZW4gIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIG9wZW4gKCkge1xuICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLm9wdHMudGFyZ2V0KVxuXG4gICAgdGhpcy5zb2NrZXQub25vcGVuID0gKGUpID0+IHtcbiAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZVxuXG4gICAgICB3aGlsZSAodGhpcy5fcXVldWVkLmxlbmd0aCA+IDAgJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLl9xdWV1ZWRbMF1cbiAgICAgICAgdGhpcy5zZW5kKGZpcnN0LmFjdGlvbiwgZmlyc3QucGF5bG9hZClcbiAgICAgICAgdGhpcy5fcXVldWVkID0gdGhpcy5fcXVldWVkLnNsaWNlKDEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IChlKSA9PiB7XG4gICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gdGhpcy5faGFuZGxlTWVzc2FnZVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHNlbmQgKGFjdGlvbiwgcGF5bG9hZCkge1xuICAgIC8vIGF0dGFjaCB1dWlkXG5cbiAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICB0aGlzLl9xdWV1ZWQucHVzaCh7IGFjdGlvbiwgcGF5bG9hZCB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhY3Rpb24sXG4gICAgICBwYXlsb2FkLFxuICAgIH0pKVxuICB9XG5cbiAgb24gKGFjdGlvbiwgaGFuZGxlcikge1xuICAgIHRoaXMuZW1pdHRlci5vbihhY3Rpb24sIGhhbmRsZXIpXG4gIH1cblxuICBlbWl0IChhY3Rpb24sIHBheWxvYWQpIHtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChhY3Rpb24sIHBheWxvYWQpXG4gIH1cblxuICBvbmNlIChhY3Rpb24sIGhhbmRsZXIpIHtcbiAgICB0aGlzLmVtaXR0ZXIub25jZShhY3Rpb24sIGhhbmRsZXIpXG4gIH1cblxuICBfaGFuZGxlTWVzc2FnZSAoZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShlLmRhdGEpXG4gICAgICB0aGlzLmVtaXQobWVzc2FnZS5hY3Rpb24sIG1lc3NhZ2UucGF5bG9hZClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycilcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1hbmFnZXMgY29tbXVuaWNhdGlvbnMgd2l0aCBDb21wYW5pb25cbiAqL1xuXG5jb25zdCBSZXF1ZXN0Q2xpZW50ID0gcmVxdWlyZSgnLi9SZXF1ZXN0Q2xpZW50JylcbmNvbnN0IFByb3ZpZGVyID0gcmVxdWlyZSgnLi9Qcm92aWRlcicpXG5jb25zdCBTZWFyY2hQcm92aWRlciA9IHJlcXVpcmUoJy4vU2VhcmNoUHJvdmlkZXInKVxuY29uc3QgU29ja2V0ID0gcmVxdWlyZSgnLi9Tb2NrZXQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVxdWVzdENsaWVudCxcbiAgUHJvdmlkZXIsXG4gIFNlYXJjaFByb3ZpZGVyLFxuICBTb2NrZXQsXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBzZXJ2ZXMgYXMgYW4gQXN5bmMgd3JhcHBlciBmb3IgTG9jYWxTdG9yYWdlXG4gKi9cbm1vZHVsZS5leHBvcnRzLnNldEl0ZW0gPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICAgIHJlc29sdmUoKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5nZXRJdGVtID0gKGtleSkgPT4ge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpXG59XG5cbm1vZHVsZS5leHBvcnRzLnJlbW92ZUl0ZW0gPSAoa2V5KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgICByZXNvbHZlKClcbiAgfSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvY29yZVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQ29yZSBtb2R1bGUgZm9yIHRoZSBleHRlbnNpYmxlIEphdmFTY3JpcHQgZmlsZSB1cGxvYWQgd2lkZ2V0IHdpdGggc3VwcG9ydCBmb3IgZHJhZyZkcm9wLCByZXN1bWFibGUgdXBsb2FkcywgcHJldmlld3MsIHJlc3RyaWN0aW9ucywgZmlsZSBwcm9jZXNzaW5nL2VuY29kaW5nLCByZW1vdGUgcHJvdmlkZXJzIGxpa2UgSW5zdGFncmFtLCBEcm9wYm94LCBHb29nbGUgRHJpdmUsIFMzIGFuZCBtb3JlIDpkb2c6XCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMTkuMVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzXCI6IFwiMC4wLjdcIixcbiAgICBcIkB1cHB5L3N0b3JlLWRlZmF1bHRcIjogXCJmaWxlOi4uL3N0b3JlLWRlZmF1bHRcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY3VpZFwiOiBcIl4yLjEuMVwiLFxuICAgIFwibG9kYXNoLnRocm90dGxlXCI6IFwiXjQuMS4xXCIsXG4gICAgXCJtaW1lLW1hdGNoXCI6IFwiXjEuMC4yXCIsXG4gICAgXCJuYW1lc3BhY2UtZW1pdHRlclwiOiBcIl4yLjAuMVwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9XG59XG4iLCJjb25zdCBwcmVhY3QgPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgZmluZERPTUVsZW1lbnQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmluZERPTUVsZW1lbnQnKVxuXG4vKipcbiAqIERlZmVyIGEgZnJlcXVlbnQgY2FsbCB0byB0aGUgbWljcm90YXNrIHF1ZXVlLlxuICovXG5mdW5jdGlvbiBkZWJvdW5jZSAoZm4pIHtcbiAgbGV0IGNhbGxpbmcgPSBudWxsXG4gIGxldCBsYXRlc3RBcmdzID0gbnVsbFxuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBsYXRlc3RBcmdzID0gYXJnc1xuICAgIGlmICghY2FsbGluZykge1xuICAgICAgY2FsbGluZyA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjYWxsaW5nID0gbnVsbFxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IGBhcmdzYCBtYXkgYmUgZGlmZmVyZW50IGZyb20gdGhlIG1vc3RcbiAgICAgICAgLy8gcmVjZW50IHN0YXRlLCBpZiBtdWx0aXBsZSBjYWxscyBoYXBwZW5lZCBzaW5jZSB0aGlzIHRhc2tcbiAgICAgICAgLy8gd2FzIHF1ZXVlZC4gU28gd2UgdXNlIHRoZSBgbGF0ZXN0QXJnc2AsIHdoaWNoIGRlZmluaXRlbHlcbiAgICAgICAgLy8gaXMgdGhlIG1vc3QgcmVjZW50IGNhbGwuXG4gICAgICAgIHJldHVybiBmbiguLi5sYXRlc3RBcmdzKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxpbmdcbiAgfVxufVxuXG4vKipcbiAqIEJvaWxlcnBsYXRlIHRoYXQgYWxsIFBsdWdpbnMgc2hhcmUgLSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkXG4gKiBkaXJlY3RseS4gSXQgYWxzbyBzaG93cyB3aGljaCBtZXRob2RzIGZpbmFsIHBsdWdpbnMgc2hvdWxkIGltcGxlbWVudC9vdmVycmlkZSxcbiAqIHRoaXMgZGVjaWRpbmcgb24gc3RydWN0dXJlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYWluIFVwcHkgY29yZSBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3Qgd2l0aCBwbHVnaW4gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5fHN0cmluZ30gZmlsZXMgb3Igc3VjY2Vzcy9mYWlsIG1lc3NhZ2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQbHVnaW4ge1xuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHRoaXMudXBweSA9IHVwcHlcbiAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICB0aGlzLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcylcbiAgICB0aGlzLm1vdW50ID0gdGhpcy5tb3VudC5iaW5kKHRoaXMpXG4gICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnVuaW5zdGFsbCA9IHRoaXMudW5pbnN0YWxsLmJpbmQodGhpcylcbiAgfVxuXG4gIGdldFBsdWdpblN0YXRlICgpIHtcbiAgICBjb25zdCB7IHBsdWdpbnMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgcmV0dXJuIHBsdWdpbnNbdGhpcy5pZF0gfHwge31cbiAgfVxuXG4gIHNldFBsdWdpblN0YXRlICh1cGRhdGUpIHtcbiAgICBjb25zdCB7IHBsdWdpbnMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG5cbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgcGx1Z2luczoge1xuICAgICAgICAuLi5wbHVnaW5zLFxuICAgICAgICBbdGhpcy5pZF06IHtcbiAgICAgICAgICAuLi5wbHVnaW5zW3RoaXMuaWRdLFxuICAgICAgICAgIC4uLnVwZGF0ZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7IC4uLnRoaXMub3B0cywgLi4ubmV3T3B0cyB9XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyB3aXRoIG5ldyBvcHRpb25zXG4gIH1cblxuICB1cGRhdGUgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3VwZGF0ZVVJKSB7XG4gICAgICB0aGlzLl91cGRhdGVVSShzdGF0ZSlcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYWZ0ZXIgZXZlcnkgc3RhdGUgdXBkYXRlLCBhZnRlciBldmVyeXRoaW5nJ3MgbW91bnRlZC4gRGVib3VuY2VkLlxuICBhZnRlclVwZGF0ZSAoKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBwbHVnaW4gaXMgbW91bnRlZCwgd2hldGhlciBpbiBET00gb3IgaW50byBhbm90aGVyIHBsdWdpbi5cbiAgICogTmVlZGVkIGJlY2F1c2Ugc29tZXRpbWVzIHBsdWdpbnMgYXJlIG1vdW50ZWQgc2VwYXJhdGVseS9hZnRlciBgaW5zdGFsbGAsXG4gICAqIHNvIHRoaXMuZWwgYW5kIHRoaXMucGFyZW50IG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gYGluc3RhbGxgLlxuICAgKiBUaGlzIGlzIHRoZSBjYXNlIHdpdGggQHVwcHkvcmVhY3QgcGx1Z2lucywgZm9yIGV4YW1wbGUuXG4gICAqL1xuICBvbk1vdW50ICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHN1cHBsaWVkIGB0YXJnZXRgIGlzIGEgRE9NIGVsZW1lbnQgb3IgYW4gYG9iamVjdGAuXG4gICAqIElmIGl04oCZcyBhbiBvYmplY3Qg4oCUIHRhcmdldCBpcyBhIHBsdWdpbiwgYW5kIHdlIHNlYXJjaCBgcGx1Z2luc2BcbiAgICogZm9yIGEgcGx1Z2luIHdpdGggc2FtZSBuYW1lIGFuZCByZXR1cm4gaXRzIHRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB0YXJnZXRcbiAgICpcbiAgICovXG4gIG1vdW50ICh0YXJnZXQsIHBsdWdpbikge1xuICAgIGNvbnN0IGNhbGxlclBsdWdpbk5hbWUgPSBwbHVnaW4uaWRcblxuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBmaW5kRE9NRWxlbWVudCh0YXJnZXQpXG5cbiAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgdGhpcy5pc1RhcmdldERPTUVsID0gdHJ1ZVxuXG4gICAgICAvLyBBUEkgZm9yIHBsdWdpbnMgdGhhdCByZXF1aXJlIGEgc3luY2hyb25vdXMgcmVyZW5kZXIuXG4gICAgICB0aGlzLnJlcmVuZGVyID0gKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIHBsdWdpbiBjb3VsZCBiZSByZW1vdmVkLCBidXQgdGhpcy5yZXJlbmRlciBpcyBkZWJvdW5jZWQgYmVsb3csXG4gICAgICAgIC8vIHNvIGl0IGNvdWxkIHN0aWxsIGJlIGNhbGxlZCBldmVuIGFmdGVyIHVwcHkucmVtb3ZlUGx1Z2luIG9yIHVwcHkuY2xvc2VcbiAgICAgICAgLy8gaGVuY2UgdGhlIGNoZWNrXG4gICAgICAgIGlmICghdGhpcy51cHB5LmdldFBsdWdpbih0aGlzLmlkKSkgcmV0dXJuXG4gICAgICAgIHRoaXMuZWwgPSBwcmVhY3QucmVuZGVyKHRoaXMucmVuZGVyKHN0YXRlKSwgdGFyZ2V0RWxlbWVudCwgdGhpcy5lbClcbiAgICAgICAgdGhpcy5hZnRlclVwZGF0ZSgpXG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVVSSA9IGRlYm91bmNlKHRoaXMucmVyZW5kZXIpXG5cbiAgICAgIHRoaXMudXBweS5sb2coYEluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfSB0byBhIERPTSBlbGVtZW50ICcke3RhcmdldH0nYClcblxuICAgICAgLy8gY2xlYXIgZXZlcnl0aGluZyBpbnNpZGUgdGhlIHRhcmdldCBjb250YWluZXJcbiAgICAgIGlmICh0aGlzLm9wdHMucmVwbGFjZVRhcmdldENvbnRlbnQpIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5pbm5lckhUTUwgPSAnJ1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsID0gcHJlYWN0LnJlbmRlcih0aGlzLnJlbmRlcih0aGlzLnVwcHkuZ2V0U3RhdGUoKSksIHRhcmdldEVsZW1lbnQpXG5cbiAgICAgIHRoaXMub25Nb3VudCgpXG4gICAgICByZXR1cm4gdGhpcy5lbFxuICAgIH1cblxuICAgIGxldCB0YXJnZXRQbHVnaW5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgUGx1Z2luKSB7XG4gICAgICAvLyBUYXJnZXRpbmcgYSBwbHVnaW4gKmluc3RhbmNlKlxuICAgICAgdGFyZ2V0UGx1Z2luID0gdGFyZ2V0XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUYXJnZXRpbmcgYSBwbHVnaW4gdHlwZVxuICAgICAgY29uc3QgVGFyZ2V0ID0gdGFyZ2V0XG4gICAgICAvLyBGaW5kIHRoZSB0YXJnZXQgcGx1Z2luIGluc3RhbmNlLlxuICAgICAgdGhpcy51cHB5Lml0ZXJhdGVQbHVnaW5zKChwbHVnaW4pID0+IHtcbiAgICAgICAgaWYgKHBsdWdpbiBpbnN0YW5jZW9mIFRhcmdldCkge1xuICAgICAgICAgIHRhcmdldFBsdWdpbiA9IHBsdWdpblxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0YXJnZXRQbHVnaW4pIHtcbiAgICAgIHRoaXMudXBweS5sb2coYEluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfSB0byAke3RhcmdldFBsdWdpbi5pZH1gKVxuICAgICAgdGhpcy5wYXJlbnQgPSB0YXJnZXRQbHVnaW5cbiAgICAgIHRoaXMuZWwgPSB0YXJnZXRQbHVnaW4uYWRkVGFyZ2V0KHBsdWdpbilcblxuICAgICAgdGhpcy5vbk1vdW50KClcbiAgICAgIHJldHVybiB0aGlzLmVsXG4gICAgfVxuXG4gICAgdGhpcy51cHB5LmxvZyhgTm90IGluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfWApXG5cbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHRhcmdldCBvcHRpb24gZ2l2ZW4gdG8gJHtjYWxsZXJQbHVnaW5OYW1lfS5gXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1lc3NhZ2UgKz0gJyBUaGUgZ2l2ZW4gdGFyZ2V0IGlzIG5vdCBhIFBsdWdpbiBjbGFzcy4gJ1xuICAgICAgICArICdQbGVhc2UgY2hlY2sgdGhhdCB5b3VcXCdyZSBub3Qgc3BlY2lmeWluZyBhIFJlYWN0IENvbXBvbmVudCBpbnN0ZWFkIG9mIGEgcGx1Z2luLiAnXG4gICAgICAgICsgJ0lmIHlvdSBhcmUgdXNpbmcgQHVwcHkvKiBwYWNrYWdlcyBkaXJlY3RseSwgbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgMSB2ZXJzaW9uIG9mIEB1cHB5L2NvcmUgaW5zdGFsbGVkOiAnXG4gICAgICAgICsgJ3J1biBgbnBtIGxzIEB1cHB5L2NvcmVgIG9uIHRoZSBjb21tYW5kIGxpbmUgYW5kIHZlcmlmeSB0aGF0IGFsbCB0aGUgdmVyc2lvbnMgbWF0Y2ggYW5kIGFyZSBkZWR1cGVkIGNvcnJlY3RseS4nXG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgKz0gJ0lmIHlvdSBtZWFudCB0byB0YXJnZXQgYW4gSFRNTCBlbGVtZW50LCBwbGVhc2UgbWFrZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnQgZXhpc3RzLiAnXG4gICAgICAgICsgJ0NoZWNrIHRoYXQgdGhlIDxzY3JpcHQ+IHRhZyBpbml0aWFsaXppbmcgVXBweSBpcyByaWdodCBiZWZvcmUgdGhlIGNsb3NpbmcgPC9ib2R5PiB0YWcgYXQgdGhlIGVuZCBvZiB0aGUgcGFnZS4gJ1xuICAgICAgICArICcoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlcy8xMDQyKVxcblxcbidcbiAgICAgICAgKyAnSWYgeW91IG1lYW50IHRvIHRhcmdldCBhIHBsdWdpbiwgcGxlYXNlIGNvbmZpcm0gdGhhdCB5b3VyIGBpbXBvcnRgIHN0YXRlbWVudHMgb3IgYHJlcXVpcmVgIGNhbGxzIGFyZSBjb3JyZWN0LidcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgdGhyb3cgKG5ldyBFcnJvcignRXh0ZW5kIHRoZSByZW5kZXIgbWV0aG9kIHRvIGFkZCB5b3VyIHBsdWdpbiB0byBhIERPTSBlbGVtZW50JykpXG4gIH1cblxuICBhZGRUYXJnZXQgKHBsdWdpbikge1xuICAgIHRocm93IChuZXcgRXJyb3IoJ0V4dGVuZCB0aGUgYWRkVGFyZ2V0IG1ldGhvZCB0byBhZGQgeW91ciBwbHVnaW4gdG8gYW5vdGhlciBwbHVnaW5cXCdzIHRhcmdldCcpKVxuICB9XG5cbiAgdW5tb3VudCAoKSB7XG4gICAgaWYgKHRoaXMuaXNUYXJnZXRET01FbCAmJiB0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpXG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG5cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxufVxuIiwiLyogZ2xvYmFsIEFnZ3JlZ2F0ZUVycm9yICovXG5jb25zdCBUcmFuc2xhdG9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL1RyYW5zbGF0b3InKVxuY29uc3QgZWUgPSByZXF1aXJlKCduYW1lc3BhY2UtZW1pdHRlcicpXG5jb25zdCBjdWlkID0gcmVxdWlyZSgnY3VpZCcpXG5jb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJ2xvZGFzaC50aHJvdHRsZScpXG5jb25zdCBwcmV0dGllckJ5dGVzID0gcmVxdWlyZSgnQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzJylcbmNvbnN0IG1hdGNoID0gcmVxdWlyZSgnbWltZS1tYXRjaCcpXG5jb25zdCBEZWZhdWx0U3RvcmUgPSByZXF1aXJlKCdAdXBweS9zdG9yZS1kZWZhdWx0JylcbmNvbnN0IGdldEZpbGVUeXBlID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVUeXBlJylcbmNvbnN0IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVOYW1lQW5kRXh0ZW5zaW9uJylcbmNvbnN0IGdlbmVyYXRlRmlsZUlEID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dlbmVyYXRlRmlsZUlEJylcbmNvbnN0IGZpbmRJbmRleCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kSW5kZXgnKVxuY29uc3Qgc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA9IHJlcXVpcmUoJy4vc3VwcG9ydHNVcGxvYWRQcm9ncmVzcycpXG5jb25zdCB7IGp1c3RFcnJvcnNMb2dnZXIsIGRlYnVnTG9nZ2VyIH0gPSByZXF1aXJlKCcuL2xvZ2dlcnMnKVxuY29uc3QgUGx1Z2luID0gcmVxdWlyZSgnLi9QbHVnaW4nKVxuY29uc3QgeyB2ZXJzaW9uIH0gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKVxuXG4vLyBFeHBvcnRlZCBmcm9tIGhlcmUuXG5jbGFzcyBSZXN0cmljdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5pc1Jlc3RyaWN0aW9uID0gdHJ1ZVxuICB9XG59XG5cbi8qKlxuICogVXBweSBDb3JlIG1vZHVsZS5cbiAqIE1hbmFnZXMgcGx1Z2lucywgc3RhdGUgdXBkYXRlcywgYWN0cyBhcyBhbiBldmVudCBidXMsXG4gKiBhZGRzL3JlbW92ZXMgZmlsZXMgYW5kIG1ldGFkYXRhLlxuICovXG5jbGFzcyBVcHB5IHtcbiAgc3RhdGljIFZFUlNJT04gPSB2ZXJzaW9uXG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIFVwcHlcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMg4oCUIFVwcHkgb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7XG4gICAgICAgIGFkZEJ1bGtGaWxlc0ZhaWxlZDoge1xuICAgICAgICAgIDA6ICdGYWlsZWQgdG8gYWRkICV7c21hcnRfY291bnR9IGZpbGUgZHVlIHRvIGFuIGludGVybmFsIGVycm9yJyxcbiAgICAgICAgICAxOiAnRmFpbGVkIHRvIGFkZCAle3NtYXJ0X2NvdW50fSBmaWxlcyBkdWUgdG8gaW50ZXJuYWwgZXJyb3JzJyxcbiAgICAgICAgfSxcbiAgICAgICAgeW91Q2FuT25seVVwbG9hZFg6IHtcbiAgICAgICAgICAwOiAnWW91IGNhbiBvbmx5IHVwbG9hZCAle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgICAgICAxOiAnWW91IGNhbiBvbmx5IHVwbG9hZCAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgICAgIH0sXG4gICAgICAgIHlvdUhhdmVUb0F0TGVhc3RTZWxlY3RYOiB7XG4gICAgICAgICAgMDogJ1lvdSBoYXZlIHRvIHNlbGVjdCBhdCBsZWFzdCAle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgICAgICAxOiAnWW91IGhhdmUgdG8gc2VsZWN0IGF0IGxlYXN0ICV7c21hcnRfY291bnR9IGZpbGVzJyxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgYGV4Y2VlZHNTaXplMmAgc3RyaW5nIG9ubHkgY29tYmluZXMgdGhlIGBleGNlZWRzU2l6ZWAgc3RyaW5nICgle2JhY2t3YXJkc0NvbXBhdH0pIHdpdGggdGhlIHNpemUuXG4gICAgICAgIC8vIExvY2FsZXMgY2FuIG92ZXJyaWRlIGBleGNlZWRzU2l6ZTJgIHRvIHNwZWNpZnkgYSBkaWZmZXJlbnQgd29yZCBvcmRlci4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoXG4gICAgICAgIC8vIFVwcHkgMS45LnggYW5kIGJlbG93IHdoaWNoIGRpZCBhIG5haXZlIGNvbmNhdGVuYXRpb24gb2YgYGV4Y2VlZHNTaXplMiArIHNpemVgIGluc3RlYWQgb2YgdXNpbmcgYSBsb2NhbGUtc3BlY2lmaWNcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uLlxuICAgICAgICAvLyBUT0RPOiBJbiAyLjAgYGV4Y2VlZHNTaXplMmAgc2hvdWxkIGJlIHJlbW92ZWQgaW4gYW5kIGBleGNlZWRzU2l6ZWAgdXBkYXRlZCB0byB1c2Ugc3Vic3RpdHV0aW9uLlxuICAgICAgICBleGNlZWRzU2l6ZTI6ICcle2JhY2t3YXJkc0NvbXBhdH0gJXtzaXplfScsXG4gICAgICAgIGV4Y2VlZHNTaXplOiAnJXtmaWxlfSBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzaXplIG9mJyxcbiAgICAgICAgaW5mZXJpb3JTaXplOiAnVGhpcyBmaWxlIGlzIHNtYWxsZXIgdGhhbiB0aGUgYWxsb3dlZCBzaXplIG9mICV7c2l6ZX0nLFxuICAgICAgICB5b3VDYW5Pbmx5VXBsb2FkRmlsZVR5cGVzOiAnWW91IGNhbiBvbmx5IHVwbG9hZDogJXt0eXBlc30nLFxuICAgICAgICBub05ld0FscmVhZHlVcGxvYWRpbmc6ICdDYW5ub3QgYWRkIG5ldyBmaWxlczogYWxyZWFkeSB1cGxvYWRpbmcnLFxuICAgICAgICBub0R1cGxpY2F0ZXM6ICdDYW5ub3QgYWRkIHRoZSBkdXBsaWNhdGUgZmlsZSBcXCcle2ZpbGVOYW1lfVxcJywgaXQgYWxyZWFkeSBleGlzdHMnLFxuICAgICAgICBjb21wYW5pb25FcnJvcjogJ0Nvbm5lY3Rpb24gd2l0aCBDb21wYW5pb24gZmFpbGVkJyxcbiAgICAgICAgY29tcGFuaW9uVW5hdXRob3JpemVIaW50OiAnVG8gdW5hdXRob3JpemUgdG8geW91ciAle3Byb3ZpZGVyfSBhY2NvdW50LCBwbGVhc2UgZ28gdG8gJXt1cmx9JyxcbiAgICAgICAgZmFpbGVkVG9VcGxvYWQ6ICdGYWlsZWQgdG8gdXBsb2FkICV7ZmlsZX0nLFxuICAgICAgICBub0ludGVybmV0Q29ubmVjdGlvbjogJ05vIEludGVybmV0IGNvbm5lY3Rpb24nLFxuICAgICAgICBjb25uZWN0ZWRUb0ludGVybmV0OiAnQ29ubmVjdGVkIHRvIHRoZSBJbnRlcm5ldCcsXG4gICAgICAgIC8vIFN0cmluZ3MgZm9yIHJlbW90ZSBwcm92aWRlcnNcbiAgICAgICAgbm9GaWxlc0ZvdW5kOiAnWW91IGhhdmUgbm8gZmlsZXMgb3IgZm9sZGVycyBoZXJlJyxcbiAgICAgICAgc2VsZWN0WDoge1xuICAgICAgICAgIDA6ICdTZWxlY3QgJXtzbWFydF9jb3VudH0nLFxuICAgICAgICAgIDE6ICdTZWxlY3QgJXtzbWFydF9jb3VudH0nLFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RBbGxGaWxlc0Zyb21Gb2xkZXJOYW1lZDogJ1NlbGVjdCBhbGwgZmlsZXMgZnJvbSBmb2xkZXIgJXtuYW1lfScsXG4gICAgICAgIHVuc2VsZWN0QWxsRmlsZXNGcm9tRm9sZGVyTmFtZWQ6ICdVbnNlbGVjdCBhbGwgZmlsZXMgZnJvbSBmb2xkZXIgJXtuYW1lfScsXG4gICAgICAgIHNlbGVjdEZpbGVOYW1lZDogJ1NlbGVjdCBmaWxlICV7bmFtZX0nLFxuICAgICAgICB1bnNlbGVjdEZpbGVOYW1lZDogJ1Vuc2VsZWN0IGZpbGUgJXtuYW1lfScsXG4gICAgICAgIG9wZW5Gb2xkZXJOYW1lZDogJ09wZW4gZm9sZGVyICV7bmFtZX0nLFxuICAgICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgICBsb2dPdXQ6ICdMb2cgb3V0JyxcbiAgICAgICAgZmlsdGVyOiAnRmlsdGVyJyxcbiAgICAgICAgcmVzZXRGaWx0ZXI6ICdSZXNldCBmaWx0ZXInLFxuICAgICAgICBsb2FkaW5nOiAnTG9hZGluZy4uLicsXG4gICAgICAgIGF1dGhlbnRpY2F0ZVdpdGhUaXRsZTogJ1BsZWFzZSBhdXRoZW50aWNhdGUgd2l0aCAle3BsdWdpbk5hbWV9IHRvIHNlbGVjdCBmaWxlcycsXG4gICAgICAgIGF1dGhlbnRpY2F0ZVdpdGg6ICdDb25uZWN0IHRvICV7cGx1Z2luTmFtZX0nLFxuICAgICAgICBzZWFyY2hJbWFnZXM6ICdTZWFyY2ggZm9yIGltYWdlcycsXG4gICAgICAgIGVudGVyVGV4dFRvU2VhcmNoOiAnRW50ZXIgdGV4dCB0byBzZWFyY2ggZm9yIGltYWdlcycsXG4gICAgICAgIGJhY2tUb1NlYXJjaDogJ0JhY2sgdG8gU2VhcmNoJyxcbiAgICAgICAgZW1wdHlGb2xkZXJBZGRlZDogJ05vIGZpbGVzIHdlcmUgYWRkZWQgZnJvbSBlbXB0eSBmb2xkZXInLFxuICAgICAgICBmb2xkZXJBZGRlZDoge1xuICAgICAgICAgIDA6ICdBZGRlZCAle3NtYXJ0X2NvdW50fSBmaWxlIGZyb20gJXtmb2xkZXJ9JyxcbiAgICAgICAgICAxOiAnQWRkZWQgJXtzbWFydF9jb3VudH0gZmlsZXMgZnJvbSAle2ZvbGRlcn0nLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGlkOiAndXBweScsXG4gICAgICBhdXRvUHJvY2VlZDogZmFsc2UsXG4gICAgICBhbGxvd011bHRpcGxlVXBsb2FkczogdHJ1ZSxcbiAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgIHJlc3RyaWN0aW9uczoge1xuICAgICAgICBtYXhGaWxlU2l6ZTogbnVsbCxcbiAgICAgICAgbWluRmlsZVNpemU6IG51bGwsXG4gICAgICAgIG1heFRvdGFsRmlsZVNpemU6IG51bGwsXG4gICAgICAgIG1heE51bWJlck9mRmlsZXM6IG51bGwsXG4gICAgICAgIG1pbk51bWJlck9mRmlsZXM6IG51bGwsXG4gICAgICAgIGFsbG93ZWRGaWxlVHlwZXM6IG51bGwsXG4gICAgICB9LFxuICAgICAgbWV0YToge30sXG4gICAgICBvbkJlZm9yZUZpbGVBZGRlZDogKGN1cnJlbnRGaWxlKSA9PiBjdXJyZW50RmlsZSxcbiAgICAgIG9uQmVmb3JlVXBsb2FkOiAoZmlsZXMpID0+IGZpbGVzLFxuICAgICAgc3RvcmU6IERlZmF1bHRTdG9yZSgpLFxuICAgICAgbG9nZ2VyOiBqdXN0RXJyb3JzTG9nZ2VyLFxuICAgICAgaW5mb1RpbWVvdXQ6IDUwMDAsXG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIG9uZXMgc2V0IGJ5IHVzZXIsXG4gICAgLy8gbWFraW5nIHN1cmUgdG8gbWVyZ2UgcmVzdHJpY3Rpb25zIHRvb1xuICAgIHRoaXMub3B0cyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIHJlc3RyaWN0aW9uczoge1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucy5yZXN0cmljdGlvbnMsXG4gICAgICAgIC4uLihvcHRzICYmIG9wdHMucmVzdHJpY3Rpb25zKSxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBkZWJ1ZzogdHJ1ZSBmb3IgYmFja3dhcmRzLWNvbXBhdGFiaWxpdHksIHVubGVzcyBsb2dnZXIgaXMgc2V0IGluIG9wdHNcbiAgICAvLyBvcHRzIGluc3RlYWQgb2YgdGhpcy5vcHRzIHRvIGF2b2lkIGNvbXBhcmluZyBvYmplY3RzIOKAlCB3ZSBzZXQgbG9nZ2VyOiBqdXN0RXJyb3JzTG9nZ2VyIGluIGRlZmF1bHRPcHRpb25zXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5sb2dnZXIgJiYgb3B0cy5kZWJ1Zykge1xuICAgICAgdGhpcy5sb2coJ1lvdSBhcmUgdXNpbmcgYSBjdXN0b20gYGxvZ2dlcmAsIGJ1dCBhbHNvIHNldCBgZGVidWc6IHRydWVgLCB3aGljaCB1c2VzIGJ1aWx0LWluIGxvZ2dlciB0byBvdXRwdXQgbG9ncyB0byBjb25zb2xlLiBJZ25vcmluZyBgZGVidWc6IHRydWVgIGFuZCB1c2luZyB5b3VyIGN1c3RvbSBgbG9nZ2VyYC4nLCAnd2FybmluZycpXG4gICAgfSBlbHNlIGlmIChvcHRzICYmIG9wdHMuZGVidWcpIHtcbiAgICAgIHRoaXMub3B0cy5sb2dnZXIgPSBkZWJ1Z0xvZ2dlclxuICAgIH1cblxuICAgIHRoaXMubG9nKGBVc2luZyBDb3JlIHYke3RoaXMuY29uc3RydWN0b3IuVkVSU0lPTn1gKVxuXG4gICAgaWYgKHRoaXMub3B0cy5yZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlc1xuICAgICAgICAmJiB0aGlzLm9wdHMucmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMgIT09IG51bGxcbiAgICAgICAgJiYgIUFycmF5LmlzQXJyYXkodGhpcy5vcHRzLnJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzYCBtdXN0IGJlIGFuIGFycmF5JylcbiAgICB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIC8vIENvbnRhaW5lciBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHBsdWdpbnNcbiAgICB0aGlzLnBsdWdpbnMgPSB7fVxuXG4gICAgdGhpcy5nZXRTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuZ2V0UGx1Z2luID0gdGhpcy5nZXRQbHVnaW4uYmluZCh0aGlzKVxuICAgIHRoaXMuc2V0RmlsZU1ldGEgPSB0aGlzLnNldEZpbGVNZXRhLmJpbmQodGhpcylcbiAgICB0aGlzLnNldEZpbGVTdGF0ZSA9IHRoaXMuc2V0RmlsZVN0YXRlLmJpbmQodGhpcylcbiAgICB0aGlzLmxvZyA9IHRoaXMubG9nLmJpbmQodGhpcylcbiAgICB0aGlzLmluZm8gPSB0aGlzLmluZm8uYmluZCh0aGlzKVxuICAgIHRoaXMuaGlkZUluZm8gPSB0aGlzLmhpZGVJbmZvLmJpbmQodGhpcylcbiAgICB0aGlzLmFkZEZpbGUgPSB0aGlzLmFkZEZpbGUuYmluZCh0aGlzKVxuICAgIHRoaXMucmVtb3ZlRmlsZSA9IHRoaXMucmVtb3ZlRmlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5wYXVzZVJlc3VtZSA9IHRoaXMucGF1c2VSZXN1bWUuYmluZCh0aGlzKVxuICAgIHRoaXMudmFsaWRhdGVSZXN0cmljdGlvbnMgPSB0aGlzLnZhbGlkYXRlUmVzdHJpY3Rpb25zLmJpbmQodGhpcylcblxuICAgIC8vIF9fX1doeSB0aHJvdHRsZSBhdCA1MDBtcz9cbiAgICAvLyAgICAtIFdlIG11c3QgdGhyb3R0bGUgYXQgPjI1MG1zIGZvciBzdXBlcmZvY3VzIGluIERhc2hib2FyZCB0byB3b3JrIHdlbGxcbiAgICAvLyAgICAoYmVjYXVzZSBhbmltYXRpb24gdGFrZXMgMC4yNXMsIGFuZCB3ZSB3YW50IHRvIHdhaXQgZm9yIGFsbCBhbmltYXRpb25zIHRvIGJlIG92ZXIgYmVmb3JlIHJlZm9jdXNpbmcpLlxuICAgIC8vICAgIFtQcmFjdGljYWwgQ2hlY2tdOiBpZiB0aG90dGxlIGlzIGF0IDEwMG1zLCB0aGVuIGlmIHlvdSBhcmUgdXBsb2FkaW5nIGEgZmlsZSxcbiAgICAvLyAgICBhbmQgY2xpY2sgJ0FERCBNT1JFIEZJTEVTJywgLSBmb2N1cyB3b24ndCBhY3RpdmF0ZSBpbiBGaXJlZm94LlxuICAgIC8vICAgIC0gV2UgbXVzdCB0aHJvdHRsZSBhdCBhcm91bmQgPjUwMG1zIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGxhZ3MuXG4gICAgLy8gICAgW1ByYWN0aWNhbCBDaGVja10gRmlyZWZveCwgdHJ5IHRvIHVwbG9hZCBhIGJpZyBmaWxlIGZvciBhIHByb2xvbmdlZCBwZXJpb2Qgb2YgdGltZS4gTGFwdG9wIHdpbGwgc3RhcnQgdG8gaGVhdCB1cC5cbiAgICB0aGlzLmNhbGN1bGF0ZVByb2dyZXNzID0gdGhyb3R0bGUodGhpcy5jYWxjdWxhdGVQcm9ncmVzcy5iaW5kKHRoaXMpLCA1MDAsIHsgbGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IHRydWUgfSlcblxuICAgIHRoaXMudXBkYXRlT25saW5lU3RhdHVzID0gdGhpcy51cGRhdGVPbmxpbmVTdGF0dXMuYmluZCh0aGlzKVxuICAgIHRoaXMucmVzZXRQcm9ncmVzcyA9IHRoaXMucmVzZXRQcm9ncmVzcy5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLnBhdXNlQWxsID0gdGhpcy5wYXVzZUFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZXN1bWVBbGwgPSB0aGlzLnJlc3VtZUFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZXRyeUFsbCA9IHRoaXMucmV0cnlBbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuY2FuY2VsQWxsID0gdGhpcy5jYW5jZWxBbGwuYmluZCh0aGlzKVxuICAgIHRoaXMucmV0cnlVcGxvYWQgPSB0aGlzLnJldHJ5VXBsb2FkLmJpbmQodGhpcylcbiAgICB0aGlzLnVwbG9hZCA9IHRoaXMudXBsb2FkLmJpbmQodGhpcylcblxuICAgIHRoaXMuZW1pdHRlciA9IGVlKClcbiAgICB0aGlzLm9uID0gdGhpcy5vbi5iaW5kKHRoaXMpXG4gICAgdGhpcy5vZmYgPSB0aGlzLm9mZi5iaW5kKHRoaXMpXG4gICAgdGhpcy5vbmNlID0gdGhpcy5lbWl0dGVyLm9uY2UuYmluZCh0aGlzLmVtaXR0ZXIpXG4gICAgdGhpcy5lbWl0ID0gdGhpcy5lbWl0dGVyLmVtaXQuYmluZCh0aGlzLmVtaXR0ZXIpXG5cbiAgICB0aGlzLnByZVByb2Nlc3NvcnMgPSBbXVxuICAgIHRoaXMudXBsb2FkZXJzID0gW11cbiAgICB0aGlzLnBvc3RQcm9jZXNzb3JzID0gW11cblxuICAgIHRoaXMuc3RvcmUgPSB0aGlzLm9wdHMuc3RvcmVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgZmlsZXM6IHt9LFxuICAgICAgY3VycmVudFVwbG9hZHM6IHt9LFxuICAgICAgYWxsb3dOZXdVcGxvYWQ6IHRydWUsXG4gICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgdXBsb2FkUHJvZ3Jlc3M6IHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MoKSxcbiAgICAgICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICAgICAgcmVzdW1hYmxlVXBsb2FkczogZmFsc2UsXG4gICAgICB9LFxuICAgICAgdG90YWxQcm9ncmVzczogMCxcbiAgICAgIG1ldGE6IHsgLi4udGhpcy5vcHRzLm1ldGEgfSxcbiAgICAgIGluZm86IHtcbiAgICAgICAgaXNIaWRkZW46IHRydWUsXG4gICAgICAgIHR5cGU6ICdpbmZvJyxcbiAgICAgICAgbWVzc2FnZTogJycsXG4gICAgICB9LFxuICAgICAgcmVjb3ZlcmVkU3RhdGU6IG51bGwsXG4gICAgfSlcblxuICAgIHRoaXMuc3RvcmVVbnN1YnNjcmliZSA9IHRoaXMuc3RvcmUuc3Vic2NyaWJlKChwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcGF0Y2gpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnc3RhdGUtdXBkYXRlJywgcHJldlN0YXRlLCBuZXh0U3RhdGUsIHBhdGNoKVxuICAgICAgdGhpcy51cGRhdGVBbGwobmV4dFN0YXRlKVxuICAgIH0pXG5cbiAgICAvLyBFeHBvc2luZyB1cHB5IG9iamVjdCBvbiB3aW5kb3cgZm9yIGRlYnVnZ2luZyBhbmQgdGVzdGluZ1xuICAgIGlmICh0aGlzLm9wdHMuZGVidWcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvd1t0aGlzLm9wdHMuaWRdID0gdGhpc1xuICAgIH1cblxuICAgIHRoaXMuYWRkTGlzdGVuZXJzKClcblxuICAgIC8vIFJlLWVuYWJsZSBpZiB3ZeKAmWxsIG5lZWQgc29tZSBjYXBhYmlsaXRpZXMgb24gYm9vdCwgbGlrZSBpc01vYmlsZURldmljZVxuICAgIC8vIHRoaXMuX3NldENhcGFiaWxpdGllcygpXG4gIH1cblxuICAvLyBfc2V0Q2FwYWJpbGl0aWVzID0gKCkgPT4ge1xuICAvLyAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHtcbiAgLy8gICAgIGlzTW9iaWxlRGV2aWNlOiBpc01vYmlsZURldmljZSgpXG4gIC8vICAgfVxuXG4gIC8vICAgdGhpcy5zZXRTdGF0ZSh7XG4gIC8vICAgICAuLi50aGlzLmdldFN0YXRlKCkuY2FwYWJpbGl0aWVzLFxuICAvLyAgICAgY2FwYWJpbGl0aWVzXG4gIC8vICAgfSlcbiAgLy8gfVxuXG4gIG9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIub24oZXZlbnQsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvZmYgKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vZmYoZXZlbnQsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvbiBhbGwgcGx1Z2lucyBhbmQgcnVuIGB1cGRhdGVgIG9uIHRoZW0uXG4gICAqIENhbGxlZCBlYWNoIHRpbWUgc3RhdGUgY2hhbmdlcy5cbiAgICpcbiAgICovXG4gIHVwZGF0ZUFsbCAoc3RhdGUpIHtcbiAgICB0aGlzLml0ZXJhdGVQbHVnaW5zKHBsdWdpbiA9PiB7XG4gICAgICBwbHVnaW4udXBkYXRlKHN0YXRlKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBzdGF0ZSB3aXRoIGEgcGF0Y2hcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhdGNoIHtmb286ICdiYXInfVxuICAgKi9cbiAgc2V0U3RhdGUgKHBhdGNoKSB7XG4gICAgdGhpcy5zdG9yZS5zZXRTdGF0ZShwYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBnZXRTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEJhY2sgY29tcGF0IGZvciB3aGVuIHVwcHkuc3RhdGUgaXMgdXNlZCBpbnN0ZWFkIG9mIHVwcHkuZ2V0U3RhdGUoKS5cbiAgICovXG4gIGdldCBzdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0aGFuZCB0byBzZXQgc3RhdGUgZm9yIGEgc3BlY2lmaWMgZmlsZS5cbiAgICovXG4gIHNldEZpbGVTdGF0ZSAoZmlsZUlELCBzdGF0ZSkge1xuICAgIGlmICghdGhpcy5nZXRTdGF0ZSgpLmZpbGVzW2ZpbGVJRF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fu4oCZdCBzZXQgc3RhdGUgZm9yICR7ZmlsZUlEfSAodGhlIGZpbGUgY291bGQgaGF2ZSBiZWVuIHJlbW92ZWQpYClcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcywgW2ZpbGVJRF06IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzW2ZpbGVJRF0sIC4uLnN0YXRlIH0gfSxcbiAgICB9KVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMubG9jYWxlID0gdGhpcy50cmFuc2xhdG9yLmxvY2FsZVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgLi4ubmV3T3B0cyxcbiAgICAgIHJlc3RyaWN0aW9uczoge1xuICAgICAgICAuLi50aGlzLm9wdHMucmVzdHJpY3Rpb25zLFxuICAgICAgICAuLi4obmV3T3B0cyAmJiBuZXdPcHRzLnJlc3RyaWN0aW9ucyksXG4gICAgICB9LFxuICAgIH1cblxuICAgIGlmIChuZXdPcHRzLm1ldGEpIHtcbiAgICAgIHRoaXMuc2V0TWV0YShuZXdPcHRzLm1ldGEpXG4gICAgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG5cbiAgICBpZiAobmV3T3B0cy5sb2NhbGUpIHtcbiAgICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgICBwbHVnaW4uc2V0T3B0aW9ucygpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoKSAvLyBzbyB0aGF0IFVJIHJlLXJlbmRlcnMgd2l0aCBuZXcgb3B0aW9uc1xuICB9XG5cbiAgcmVzZXRQcm9ncmVzcyAoKSB7XG4gICAgY29uc3QgZGVmYXVsdFByb2dyZXNzID0ge1xuICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgIGJ5dGVzVXBsb2FkZWQ6IDAsXG4gICAgICB1cGxvYWRDb21wbGV0ZTogZmFsc2UsXG4gICAgICB1cGxvYWRTdGFydGVkOiBudWxsLFxuICAgIH1cbiAgICBjb25zdCBmaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7fVxuICAgIE9iamVjdC5rZXlzKGZpbGVzKS5mb3JFYWNoKGZpbGVJRCA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkRmlsZSA9IHsgLi4uZmlsZXNbZmlsZUlEXSB9XG4gICAgICB1cGRhdGVkRmlsZS5wcm9ncmVzcyA9IHsgLi4udXBkYXRlZEZpbGUucHJvZ3Jlc3MsIC4uLmRlZmF1bHRQcm9ncmVzcyB9XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZUlEXSA9IHVwZGF0ZWRGaWxlXG4gICAgfSlcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZmlsZXM6IHVwZGF0ZWRGaWxlcyxcbiAgICAgIHRvdGFsUHJvZ3Jlc3M6IDAsXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgncmVzZXQtcHJvZ3Jlc3MnKVxuICB9XG5cbiAgYWRkUHJlUHJvY2Vzc29yIChmbikge1xuICAgIHRoaXMucHJlUHJvY2Vzc29ycy5wdXNoKGZuKVxuICB9XG5cbiAgcmVtb3ZlUHJlUHJvY2Vzc29yIChmbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLnByZVByb2Nlc3NvcnMuaW5kZXhPZihmbilcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIHRoaXMucHJlUHJvY2Vzc29ycy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cblxuICBhZGRQb3N0UHJvY2Vzc29yIChmbikge1xuICAgIHRoaXMucG9zdFByb2Nlc3NvcnMucHVzaChmbilcbiAgfVxuXG4gIHJlbW92ZVBvc3RQcm9jZXNzb3IgKGZuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMucG9zdFByb2Nlc3NvcnMuaW5kZXhPZihmbilcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnMuc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG5cbiAgYWRkVXBsb2FkZXIgKGZuKSB7XG4gICAgdGhpcy51cGxvYWRlcnMucHVzaChmbilcbiAgfVxuXG4gIHJlbW92ZVVwbG9hZGVyIChmbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLnVwbG9hZGVycy5pbmRleE9mKGZuKVxuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgdGhpcy51cGxvYWRlcnMuc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG5cbiAgc2V0TWV0YSAoZGF0YSkge1xuICAgIGNvbnN0IHVwZGF0ZWRNZXRhID0geyAuLi50aGlzLmdldFN0YXRlKCkubWV0YSwgLi4uZGF0YSB9XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuXG4gICAgT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlSURdID0geyAuLi51cGRhdGVkRmlsZXNbZmlsZUlEXSwgbWV0YTogeyAuLi51cGRhdGVkRmlsZXNbZmlsZUlEXS5tZXRhLCAuLi5kYXRhIH0gfVxuICAgIH0pXG5cbiAgICB0aGlzLmxvZygnQWRkaW5nIG1ldGFkYXRhOicpXG4gICAgdGhpcy5sb2coZGF0YSlcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbWV0YTogdXBkYXRlZE1ldGEsXG4gICAgICBmaWxlczogdXBkYXRlZEZpbGVzLFxuICAgIH0pXG4gIH1cblxuICBzZXRGaWxlTWV0YSAoZmlsZUlELCBkYXRhKSB7XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGlmICghdXBkYXRlZEZpbGVzW2ZpbGVJRF0pIHtcbiAgICAgIHRoaXMubG9nKCdXYXMgdHJ5aW5nIHRvIHNldCBtZXRhZGF0YSBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJywgZmlsZUlEKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IG5ld01ldGEgPSB7IC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLm1ldGEsIC4uLmRhdGEgfVxuICAgIHVwZGF0ZWRGaWxlc1tmaWxlSURdID0geyAuLi51cGRhdGVkRmlsZXNbZmlsZUlEXSwgbWV0YTogbmV3TWV0YSB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzOiB1cGRhdGVkRmlsZXMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBmaWxlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCBUaGUgSUQgb2YgdGhlIGZpbGUgb2JqZWN0IHRvIHJldHVybi5cbiAgICovXG4gIGdldEZpbGUgKGZpbGVJRCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCkuZmlsZXNbZmlsZUlEXVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmlsZXMgaW4gYW4gYXJyYXkuXG4gICAqL1xuICBnZXRGaWxlcyAoKSB7XG4gICAgY29uc3QgeyBmaWxlcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbGVzKS5tYXAoKGZpbGVJRCkgPT4gZmlsZXNbZmlsZUlEXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHB1YmxpYyB3cmFwcGVyIGZvciBfY2hlY2tSZXN0cmljdGlvbnMg4oCUIGNoZWNrcyBpZiBhIGZpbGUgcGFzc2VzIGEgc2V0IG9mIHJlc3RyaWN0aW9ucy5cbiAgICogRm9yIHVzZSBpbiBVSSBwbHVpZ2lucyAobGlrZSBQcm92aWRlcnMpLCB0byBkaXNhbGxvdyBzZWxlY3RpbmcgZmlsZXMgdGhhdCB3b27igJl0IHBhc3MgcmVzdHJpY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZmlsZSBvYmplY3QgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtBcnJheX0gW2ZpbGVzXSBhcnJheSB0byBjaGVjayBtYXhOdW1iZXJPZkZpbGVzIGFuZCBtYXhUb3RhbEZpbGVTaXplXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHsgcmVzdWx0OiB0cnVlL2ZhbHNlLCByZWFzb246IHdoeSBmaWxlIGRpZG7igJl0IHBhc3MgcmVzdHJpY3Rpb25zIH1cbiAgICovXG4gIHZhbGlkYXRlUmVzdHJpY3Rpb25zIChmaWxlLCBmaWxlcykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNoZWNrUmVzdHJpY3Rpb25zKGZpbGUsIGZpbGVzKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiBlcnIubWVzc2FnZSxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgZmlsZSBwYXNzZXMgYSBzZXQgb2YgcmVzdHJpY3Rpb25zIHNldCBpbiBvcHRpb25zOiBtYXhGaWxlU2l6ZSwgbWluRmlsZVNpemUsXG4gICAqIG1heE51bWJlck9mRmlsZXMgYW5kIGFsbG93ZWRGaWxlVHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlIG9iamVjdCB0byBjaGVja1xuICAgKiBAcGFyYW0ge0FycmF5fSBbZmlsZXNdIGFycmF5IHRvIGNoZWNrIG1heE51bWJlck9mRmlsZXMgYW5kIG1heFRvdGFsRmlsZVNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoZWNrUmVzdHJpY3Rpb25zIChmaWxlLCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKSkge1xuICAgIGNvbnN0IHsgbWF4RmlsZVNpemUsIG1pbkZpbGVTaXplLCBtYXhUb3RhbEZpbGVTaXplLCBtYXhOdW1iZXJPZkZpbGVzLCBhbGxvd2VkRmlsZVR5cGVzIH0gPSB0aGlzLm9wdHMucmVzdHJpY3Rpb25zXG5cbiAgICBpZiAobWF4TnVtYmVyT2ZGaWxlcykge1xuICAgICAgaWYgKGZpbGVzLmxlbmd0aCArIDEgPiBtYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXN0cmljdGlvbkVycm9yKGAke3RoaXMuaTE4bigneW91Q2FuT25seVVwbG9hZFgnLCB7IHNtYXJ0X2NvdW50OiBtYXhOdW1iZXJPZkZpbGVzIH0pfWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ZWRGaWxlVHlwZXMpIHtcbiAgICAgIGNvbnN0IGlzQ29ycmVjdEZpbGVUeXBlID0gYWxsb3dlZEZpbGVUeXBlcy5zb21lKCh0eXBlKSA9PiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYSBtaW1lLXR5cGVcbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignLycpID4gLTEpIHtcbiAgICAgICAgICBpZiAoIWZpbGUudHlwZSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgcmV0dXJuIG1hdGNoKGZpbGUudHlwZS5yZXBsYWNlKC87Lio/JC8sICcnKSwgdHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGlzIGlzIGxpa2VseSBhbiBleHRlbnNpb25cbiAgICAgICAgaWYgKHR5cGVbMF0gPT09ICcuJyAmJiBmaWxlLmV4dGVuc2lvbikge1xuICAgICAgICAgIHJldHVybiBmaWxlLmV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpID09PSB0eXBlLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9KVxuXG4gICAgICBpZiAoIWlzQ29ycmVjdEZpbGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IGFsbG93ZWRGaWxlVHlwZXNTdHJpbmcgPSBhbGxvd2VkRmlsZVR5cGVzLmpvaW4oJywgJylcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCd5b3VDYW5Pbmx5VXBsb2FkRmlsZVR5cGVzJywgeyB0eXBlczogYWxsb3dlZEZpbGVUeXBlc1N0cmluZyB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCBjaGVjayBtYXhUb3RhbEZpbGVTaXplIGlmIHRoZSBzaXplIGlzIHVua25vd24uXG4gICAgaWYgKG1heFRvdGFsRmlsZVNpemUgJiYgZmlsZS5zaXplICE9IG51bGwpIHtcbiAgICAgIGxldCB0b3RhbEZpbGVzU2l6ZSA9IDBcbiAgICAgIHRvdGFsRmlsZXNTaXplICs9IGZpbGUuc2l6ZVxuICAgICAgZmlsZXMuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgICB0b3RhbEZpbGVzU2l6ZSArPSBmLnNpemVcbiAgICAgIH0pXG4gICAgICBpZiAodG90YWxGaWxlc1NpemUgPiBtYXhUb3RhbEZpbGVTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXN0cmljdGlvbkVycm9yKHRoaXMuaTE4bignZXhjZWVkc1NpemUyJywge1xuICAgICAgICAgIGJhY2t3YXJkc0NvbXBhdDogdGhpcy5pMThuKCdleGNlZWRzU2l6ZScpLFxuICAgICAgICAgIHNpemU6IHByZXR0aWVyQnl0ZXMobWF4VG90YWxGaWxlU2l6ZSksXG4gICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCBjaGVjayBtYXhGaWxlU2l6ZSBpZiB0aGUgc2l6ZSBpcyB1bmtub3duLlxuICAgIGlmIChtYXhGaWxlU2l6ZSAmJiBmaWxlLnNpemUgIT0gbnVsbCkge1xuICAgICAgaWYgKGZpbGUuc2l6ZSA+IG1heEZpbGVTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXN0cmljdGlvbkVycm9yKHRoaXMuaTE4bignZXhjZWVkc1NpemUyJywge1xuICAgICAgICAgIGJhY2t3YXJkc0NvbXBhdDogdGhpcy5pMThuKCdleGNlZWRzU2l6ZScpLFxuICAgICAgICAgIHNpemU6IHByZXR0aWVyQnl0ZXMobWF4RmlsZVNpemUpLFxuICAgICAgICAgIGZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgY2hlY2sgbWluRmlsZVNpemUgaWYgdGhlIHNpemUgaXMgdW5rbm93bi5cbiAgICBpZiAobWluRmlsZVNpemUgJiYgZmlsZS5zaXplICE9IG51bGwpIHtcbiAgICAgIGlmIChmaWxlLnNpemUgPCBtaW5GaWxlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ2luZmVyaW9yU2l6ZScsIHtcbiAgICAgICAgICBzaXplOiBwcmV0dGllckJ5dGVzKG1pbkZpbGVTaXplKSxcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIG1pbk51bWJlck9mRmlsZXMgcmVzdHJpY3Rpb24gaXMgcmVhY2hlZCBiZWZvcmUgdXBsb2FkaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tNaW5OdW1iZXJPZkZpbGVzIChmaWxlcykge1xuICAgIGNvbnN0IHsgbWluTnVtYmVyT2ZGaWxlcyB9ID0gdGhpcy5vcHRzLnJlc3RyaWN0aW9uc1xuICAgIGlmIChPYmplY3Qua2V5cyhmaWxlcykubGVuZ3RoIDwgbWluTnVtYmVyT2ZGaWxlcykge1xuICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IoYCR7dGhpcy5pMThuKCd5b3VIYXZlVG9BdExlYXN0U2VsZWN0WCcsIHsgc21hcnRfY291bnQ6IG1pbk51bWJlck9mRmlsZXMgfSl9YClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhbiBlcnJvciwgc2V0cyBJbmZvcm1lciBtZXNzYWdlLCB0aGVuIHRocm93cyB0aGUgZXJyb3IuXG4gICAqIEVtaXRzIGEgJ3Jlc3RyaWN0aW9uLWZhaWxlZCcgZXZlbnQgaWYgaXTigJlzIGEgcmVzdHJpY3Rpb24gZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmd9IGVyciDigJQgRXJyb3Igb2JqZWN0IG9yIHBsYWluIHN0cmluZyBtZXNzYWdlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zaG93SW5mb3JtZXI9dHJ1ZV0g4oCUIFNvbWV0aW1lcyBkZXZlbG9wZXIgbWlnaHQgd2FudCB0byBzaG93IEluZm9ybWVyIG1hbnVhbGx5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5maWxlPW51bGxdIOKAlCBGaWxlIG9iamVjdCB1c2VkIHRvIGVtaXQgdGhlIHJlc3RyaWN0aW9uIGVycm9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGhyb3dFcnI9dHJ1ZV0g4oCUIEVycm9ycyBzaG91bGRu4oCZdCBiZSB0aHJvd24sIGZvciBleGFtcGxlLCBpbiBgdXBsb2FkLWVycm9yYCBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2hvd09yTG9nRXJyb3JBbmRUaHJvdyAoZXJyLCB7IHNob3dJbmZvcm1lciA9IHRydWUsIGZpbGUgPSBudWxsLCB0aHJvd0VyciA9IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBlcnIgPT09ICdvYmplY3QnID8gZXJyLm1lc3NhZ2UgOiBlcnJcbiAgICBjb25zdCBkZXRhaWxzID0gKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmIGVyci5kZXRhaWxzKSA/IGVyci5kZXRhaWxzIDogJydcblxuICAgIC8vIFJlc3RyaWN0aW9uIGVycm9ycyBzaG91bGQgYmUgbG9nZ2VkLCBidXQgbm90IGFzIGVycm9ycyxcbiAgICAvLyBhcyB0aGV5IGFyZSBleHBlY3RlZCBhbmQgc2hvd24gaW4gdGhlIFVJLlxuICAgIGxldCBsb2dNZXNzYWdlV2l0aERldGFpbHMgPSBtZXNzYWdlXG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIGxvZ01lc3NhZ2VXaXRoRGV0YWlscyArPSBgICR7ZGV0YWlsc31gXG4gICAgfVxuICAgIGlmIChlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgdGhpcy5sb2cobG9nTWVzc2FnZVdpdGhEZXRhaWxzKVxuICAgICAgdGhpcy5lbWl0KCdyZXN0cmljdGlvbi1mYWlsZWQnLCBmaWxlLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGxvZ01lc3NhZ2VXaXRoRGV0YWlscywgJ2Vycm9yJylcbiAgICB9XG5cbiAgICAvLyBTb21ldGltZXMgaW5mb3JtZXIgaGFzIHRvIGJlIHNob3duIG1hbnVhbGx5IGJ5IHRoZSBkZXZlbG9wZXIsXG4gICAgLy8gZm9yIGV4YW1wbGUsIGluIGBvbkJlZm9yZUZpbGVBZGRlZGAuXG4gICAgaWYgKHNob3dJbmZvcm1lcikge1xuICAgICAgdGhpcy5pbmZvKHsgbWVzc2FnZSwgZGV0YWlscyB9LCAnZXJyb3InLCB0aGlzLm9wdHMuaW5mb1RpbWVvdXQpXG4gICAgfVxuXG4gICAgaWYgKHRocm93RXJyKSB7XG4gICAgICB0aHJvdyAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSlcbiAgICB9XG4gIH1cblxuICBhc3NlcnROZXdVcGxvYWRBbGxvd2VkIChmaWxlKSB7XG4gICAgY29uc3QgeyBhbGxvd05ld1VwbG9hZCB9ID0gdGhpcy5nZXRTdGF0ZSgpXG5cbiAgICBpZiAoYWxsb3dOZXdVcGxvYWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3cobmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCdub05ld0FscmVhZHlVcGxvYWRpbmcnKSksIHsgZmlsZSB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmaWxlIHN0YXRlIG9iamVjdCBiYXNlZCBvbiB1c2VyLXByb3ZpZGVkIGBhZGRGaWxlKClgIG9wdGlvbnMuXG4gICAqXG4gICAqIE5vdGUgdGhpcyBpcyBleHRyZW1lbHkgc2lkZS1lZmZlY3RmdWwgYW5kIHNob3VsZCBvbmx5IGJlIGRvbmUgd2hlbiBhIGZpbGUgc3RhdGUgb2JqZWN0IHdpbGwgYmUgYWRkZWQgdG8gc3RhdGUgaW1tZWRpYXRlbHkgYWZ0ZXJ3YXJkIVxuICAgKlxuICAgKiBUaGUgYGZpbGVzYCB2YWx1ZSBpcyBwYXNzZWQgaW4gYmVjYXVzZSBpdCBtYXkgYmUgdXBkYXRlZCBieSB0aGUgY2FsbGVyIHdpdGhvdXQgdXBkYXRpbmcgdGhlIHN0b3JlLlxuICAgKi9cbiAgY2hlY2tBbmRDcmVhdGVGaWxlU3RhdGVPYmplY3QgKGZpbGVzLCBmKSB7XG4gICAgY29uc3QgZmlsZVR5cGUgPSBnZXRGaWxlVHlwZShmKVxuICAgIGxldCBmaWxlID0gZlxuICAgIGZpbGUudHlwZSA9IGZpbGVUeXBlXG5cbiAgICBjb25zdCBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCA9IHRoaXMub3B0cy5vbkJlZm9yZUZpbGVBZGRlZChmaWxlLCBmaWxlcylcblxuICAgIGlmIChvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIERvbuKAmXQgc2hvdyBVSSBpbmZvIGZvciB0aGlzIGVycm9yLCBhcyBpdCBzaG91bGQgYmUgZG9uZSBieSB0aGUgZGV2ZWxvcGVyXG4gICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3cobmV3IFJlc3RyaWN0aW9uRXJyb3IoJ0Nhbm5vdCBhZGQgdGhlIGZpbGUgYmVjYXVzZSBvbkJlZm9yZUZpbGVBZGRlZCByZXR1cm5lZCBmYWxzZS4nKSwgeyBzaG93SW5mb3JtZXI6IGZhbHNlLCBmaWxlIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCA9PT0gJ29iamVjdCcgJiYgb25CZWZvcmVGaWxlQWRkZWRSZXN1bHQpIHtcbiAgICAgIGZpbGUgPSBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdFxuICAgIH1cblxuICAgIGxldCBmaWxlTmFtZVxuICAgIGlmIChmaWxlLm5hbWUpIHtcbiAgICAgIGZpbGVOYW1lID0gZmlsZS5uYW1lXG4gICAgfSBlbHNlIGlmIChmaWxlVHlwZS5zcGxpdCgnLycpWzBdID09PSAnaW1hZ2UnKSB7XG4gICAgICBmaWxlTmFtZSA9IGAke2ZpbGVUeXBlLnNwbGl0KCcvJylbMF19LiR7ZmlsZVR5cGUuc3BsaXQoJy8nKVsxXX1gXG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGVOYW1lID0gJ25vbmFtZSdcbiAgICB9XG4gICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uKGZpbGVOYW1lKS5leHRlbnNpb25cbiAgICBjb25zdCBpc1JlbW90ZSA9IGZpbGUuaXNSZW1vdGUgfHwgZmFsc2VcblxuICAgIGNvbnN0IGZpbGVJRCA9IGdlbmVyYXRlRmlsZUlEKGZpbGUpXG5cbiAgICBpZiAoZmlsZXNbZmlsZUlEXSAmJiAhZmlsZXNbZmlsZUlEXS5pc0dob3N0KSB7XG4gICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3cobmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCdub0R1cGxpY2F0ZXMnLCB7IGZpbGVOYW1lIH0pKSwgeyBmaWxlIH0pXG4gICAgfVxuXG4gICAgY29uc3QgbWV0YSA9IGZpbGUubWV0YSB8fCB7fVxuICAgIG1ldGEubmFtZSA9IGZpbGVOYW1lXG4gICAgbWV0YS50eXBlID0gZmlsZVR5cGVcblxuICAgIC8vIGBudWxsYCBtZWFucyB0aGUgc2l6ZSBpcyB1bmtub3duLlxuICAgIGNvbnN0IHNpemUgPSBOdW1iZXIuaXNGaW5pdGUoZmlsZS5kYXRhLnNpemUpID8gZmlsZS5kYXRhLnNpemUgOiBudWxsXG4gICAgY29uc3QgbmV3RmlsZSA9IHtcbiAgICAgIHNvdXJjZTogZmlsZS5zb3VyY2UgfHwgJycsXG4gICAgICBpZDogZmlsZUlELFxuICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICBleHRlbnNpb246IGZpbGVFeHRlbnNpb24gfHwgJycsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLnRoaXMuZ2V0U3RhdGUoKS5tZXRhLFxuICAgICAgICAuLi5tZXRhLFxuICAgICAgfSxcbiAgICAgIHR5cGU6IGZpbGVUeXBlLFxuICAgICAgZGF0YTogZmlsZS5kYXRhLFxuICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgICAgYnl0ZXNVcGxvYWRlZDogMCxcbiAgICAgICAgYnl0ZXNUb3RhbDogc2l6ZSxcbiAgICAgICAgdXBsb2FkQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICB1cGxvYWRTdGFydGVkOiBudWxsLFxuICAgICAgfSxcbiAgICAgIHNpemUsXG4gICAgICBpc1JlbW90ZSxcbiAgICAgIHJlbW90ZTogZmlsZS5yZW1vdGUgfHwgJycsXG4gICAgICBwcmV2aWV3OiBmaWxlLnByZXZpZXcsXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbGVzQXJyYXkgPSBPYmplY3Qua2V5cyhmaWxlcykubWFwKGkgPT4gZmlsZXNbaV0pXG4gICAgICB0aGlzLmNoZWNrUmVzdHJpY3Rpb25zKG5ld0ZpbGUsIGZpbGVzQXJyYXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyLCB7IGZpbGU6IG5ld0ZpbGUgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmlsZVxuICB9XG5cbiAgLy8gU2NoZWR1bGUgYW4gdXBsb2FkIGlmIGBhdXRvUHJvY2VlZGAgaXMgZW5hYmxlZC5cbiAgc3RhcnRJZkF1dG9Qcm9jZWVkICgpIHtcbiAgICBpZiAodGhpcy5vcHRzLmF1dG9Qcm9jZWVkICYmICF0aGlzLnNjaGVkdWxlZEF1dG9Qcm9jZWVkKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlZEF1dG9Qcm9jZWVkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkQXV0b1Byb2NlZWQgPSBudWxsXG4gICAgICAgIHRoaXMudXBsb2FkKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSB8fCBlcnIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSwgNClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IGZpbGUgdG8gYHN0YXRlLmZpbGVzYC4gVGhpcyB3aWxsIHJ1biBgb25CZWZvcmVGaWxlQWRkZWRgLFxuICAgKiB0cnkgdG8gZ3Vlc3MgZmlsZSB0eXBlIGluIGEgY2xldmVyIHdheSwgY2hlY2sgZmlsZSBhZ2FpbnN0IHJlc3RyaWN0aW9ucyxcbiAgICogYW5kIHN0YXJ0IGFuIHVwbG9hZCBpZiBgYXV0b1Byb2NlZWQgPT09IHRydWVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZmlsZSBvYmplY3QgdG8gYWRkXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGlkIGZvciB0aGUgYWRkZWQgZmlsZVxuICAgKi9cbiAgYWRkRmlsZSAoZmlsZSkge1xuICAgIHRoaXMuYXNzZXJ0TmV3VXBsb2FkQWxsb3dlZChmaWxlKVxuXG4gICAgY29uc3QgeyBmaWxlcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgbGV0IG5ld0ZpbGUgPSB0aGlzLmNoZWNrQW5kQ3JlYXRlRmlsZVN0YXRlT2JqZWN0KGZpbGVzLCBmaWxlKVxuXG4gICAgLy8gVXNlcnMgYXJlIGFza2VkIHRvIHJlLXNlbGVjdCByZWNvdmVyZWQgZmlsZXMgd2l0aG91dCBkYXRhLFxuICAgIC8vIGFuZCB0byBrZWVwIHRoZSBwcm9ncmVzcywgbWV0YSBhbmQgZXZlcnRoaW5nIGVsc2UsIHdlIG9ubHkgcmVwbGFjZSBzYWlkIGRhdGFcbiAgICBpZiAoZmlsZXNbbmV3RmlsZS5pZF0gJiYgZmlsZXNbbmV3RmlsZS5pZF0uaXNHaG9zdCkge1xuICAgICAgbmV3RmlsZSA9IHtcbiAgICAgICAgLi4uZmlsZXNbbmV3RmlsZS5pZF0sXG4gICAgICAgIGRhdGE6IGZpbGUuZGF0YSxcbiAgICAgICAgaXNHaG9zdDogZmFsc2UsXG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhgUmVwbGFjZWQgdGhlIGJsb2IgaW4gdGhlIHJlc3RvcmVkIGdob3N0IGZpbGU6ICR7bmV3RmlsZS5uYW1lfSwgJHtuZXdGaWxlLmlkfWApXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmaWxlczoge1xuICAgICAgICAuLi5maWxlcyxcbiAgICAgICAgW25ld0ZpbGUuaWRdOiBuZXdGaWxlLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCdmaWxlLWFkZGVkJywgbmV3RmlsZSlcbiAgICB0aGlzLmVtaXQoJ2ZpbGVzLWFkZGVkJywgW25ld0ZpbGVdKVxuICAgIHRoaXMubG9nKGBBZGRlZCBmaWxlOiAke25ld0ZpbGUubmFtZX0sICR7bmV3RmlsZS5pZH0sIG1pbWUgdHlwZTogJHtuZXdGaWxlLnR5cGV9YClcblxuICAgIHRoaXMuc3RhcnRJZkF1dG9Qcm9jZWVkKClcblxuICAgIHJldHVybiBuZXdGaWxlLmlkXG4gIH1cblxuICAvKipcbiAgICogQWRkIG11bHRpcGxlIGZpbGVzIHRvIGBzdGF0ZS5maWxlc2AuIFNlZSB0aGUgYGFkZEZpbGUoKWAgZG9jdW1lbnRhdGlvbi5cbiAgICpcbiAgICogSWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIGFkZGluZyBhIGZpbGUsIGl0IGlzIGxvZ2dlZCBhbmQgdGhlIHVzZXIgaXMgbm90aWZpZWQuXG4gICAqIFRoaXMgaXMgZ29vZCBmb3IgVUkgcGx1Z2lucywgYnV0IG5vdCBmb3IgcHJvZ3JhbW1hdGljIHVzZS5cbiAgICogUHJvZ3JhbW1hdGljIHVzZXJzIHNob3VsZCB1c3VhbGx5IHN0aWxsIHVzZSBgYWRkRmlsZSgpYCBvbiBpbmRpdmlkdWFsIGZpbGVzLlxuICAgKi9cbiAgYWRkRmlsZXMgKGZpbGVEZXNjcmlwdG9ycykge1xuICAgIHRoaXMuYXNzZXJ0TmV3VXBsb2FkQWxsb3dlZCgpXG5cbiAgICAvLyBjcmVhdGUgYSBjb3B5IG9mIHRoZSBmaWxlcyBvYmplY3Qgb25seSBvbmNlXG4gICAgY29uc3QgZmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgY29uc3QgbmV3RmlsZXMgPSBbXVxuICAgIGNvbnN0IGVycm9ycyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlRGVzY3JpcHRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBuZXdGaWxlID0gdGhpcy5jaGVja0FuZENyZWF0ZUZpbGVTdGF0ZU9iamVjdChmaWxlcywgZmlsZURlc2NyaXB0b3JzW2ldKVxuICAgICAgICAvLyBVc2VycyBhcmUgYXNrZWQgdG8gcmUtc2VsZWN0IHJlY292ZXJlZCBmaWxlcyB3aXRob3V0IGRhdGEsXG4gICAgICAgIC8vIGFuZCB0byBrZWVwIHRoZSBwcm9ncmVzcywgbWV0YSBhbmQgZXZlcnRoaW5nIGVsc2UsIHdlIG9ubHkgcmVwbGFjZSBzYWlkIGRhdGFcbiAgICAgICAgaWYgKGZpbGVzW25ld0ZpbGUuaWRdICYmIGZpbGVzW25ld0ZpbGUuaWRdLmlzR2hvc3QpIHtcbiAgICAgICAgICBuZXdGaWxlID0ge1xuICAgICAgICAgICAgLi4uZmlsZXNbbmV3RmlsZS5pZF0sXG4gICAgICAgICAgICBkYXRhOiBmaWxlRGVzY3JpcHRvcnNbaV0uZGF0YSxcbiAgICAgICAgICAgIGlzR2hvc3Q6IGZhbHNlLFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZyhgUmVwbGFjZWQgYmxvYiBpbiBhIGdob3N0IGZpbGU6ICR7bmV3RmlsZS5uYW1lfSwgJHtuZXdGaWxlLmlkfWApXG4gICAgICAgIH1cbiAgICAgICAgZmlsZXNbbmV3RmlsZS5pZF0gPSBuZXdGaWxlXG4gICAgICAgIG5ld0ZpbGVzLnB1c2gobmV3RmlsZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzIH0pXG5cbiAgICBuZXdGaWxlcy5mb3JFYWNoKChuZXdGaWxlKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2ZpbGUtYWRkZWQnLCBuZXdGaWxlKVxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ2ZpbGVzLWFkZGVkJywgbmV3RmlsZXMpXG5cbiAgICBpZiAobmV3RmlsZXMubGVuZ3RoID4gNSkge1xuICAgICAgdGhpcy5sb2coYEFkZGVkIGJhdGNoIG9mICR7bmV3RmlsZXMubGVuZ3RofSBmaWxlc2ApXG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKG5ld0ZpbGVzKS5mb3JFYWNoKGZpbGVJRCA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBBZGRlZCBmaWxlOiAke25ld0ZpbGVzW2ZpbGVJRF0ubmFtZX1cXG4gaWQ6ICR7bmV3RmlsZXNbZmlsZUlEXS5pZH1cXG4gdHlwZTogJHtuZXdGaWxlc1tmaWxlSURdLnR5cGV9YClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG5ld0ZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc3RhcnRJZkF1dG9Qcm9jZWVkKClcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBtZXNzYWdlID0gJ011bHRpcGxlIGVycm9ycyBvY2N1cnJlZCB3aGlsZSBhZGRpbmcgZmlsZXM6XFxuJ1xuICAgICAgZXJyb3JzLmZvckVhY2goKHN1YkVycm9yKSA9PiB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcbiAqICR7c3ViRXJyb3IubWVzc2FnZX1gXG4gICAgICB9KVxuXG4gICAgICB0aGlzLmluZm8oe1xuICAgICAgICBtZXNzYWdlOiB0aGlzLmkxOG4oJ2FkZEJ1bGtGaWxlc0ZhaWxlZCcsIHsgc21hcnRfY291bnQ6IGVycm9ycy5sZW5ndGggfSksXG4gICAgICAgIGRldGFpbHM6IG1lc3NhZ2UsXG4gICAgICB9LCAnZXJyb3InLCB0aGlzLm9wdHMuaW5mb1RpbWVvdXQpXG5cbiAgICAgIGlmICh0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yKGVycm9ycywgbWVzc2FnZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgICBlcnIuZXJyb3JzID0gZXJyb3JzXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUZpbGVzIChmaWxlSURzLCByZWFzb24pIHtcbiAgICBjb25zdCB7IGZpbGVzLCBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0geyAuLi5maWxlcyB9XG4gICAgY29uc3QgdXBkYXRlZFVwbG9hZHMgPSB7IC4uLmN1cnJlbnRVcGxvYWRzIH1cblxuICAgIGNvbnN0IHJlbW92ZWRGaWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICBmaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgaWYgKGZpbGVzW2ZpbGVJRF0pIHtcbiAgICAgICAgcmVtb3ZlZEZpbGVzW2ZpbGVJRF0gPSBmaWxlc1tmaWxlSURdXG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkRmlsZXNbZmlsZUlEXVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBSZW1vdmUgZmlsZXMgZnJvbSB0aGUgYGZpbGVJRHNgIGxpc3QgaW4gZWFjaCB1cGxvYWQuXG4gICAgZnVuY3Rpb24gZmlsZUlzTm90UmVtb3ZlZCAodXBsb2FkRmlsZUlEKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlZEZpbGVzW3VwbG9hZEZpbGVJRF0gPT09IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHVwZGF0ZWRVcGxvYWRzKS5mb3JFYWNoKCh1cGxvYWRJRCkgPT4ge1xuICAgICAgY29uc3QgbmV3RmlsZUlEcyA9IGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXS5maWxlSURzLmZpbHRlcihmaWxlSXNOb3RSZW1vdmVkKVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIHVwbG9hZCBpZiBubyBmaWxlcyBhcmUgYXNzb2NpYXRlZCB3aXRoIGl0IGFueW1vcmUuXG4gICAgICBpZiAobmV3RmlsZUlEcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRVcGxvYWRzW3VwbG9hZElEXVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdXBkYXRlZFVwbG9hZHNbdXBsb2FkSURdID0ge1xuICAgICAgICAuLi5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0sXG4gICAgICAgIGZpbGVJRHM6IG5ld0ZpbGVJRHMsXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IHN0YXRlVXBkYXRlID0ge1xuICAgICAgY3VycmVudFVwbG9hZHM6IHVwZGF0ZWRVcGxvYWRzLFxuICAgICAgZmlsZXM6IHVwZGF0ZWRGaWxlcyxcbiAgICB9XG5cbiAgICAvLyBJZiBhbGwgZmlsZXMgd2VyZSByZW1vdmVkIC0gYWxsb3cgbmV3IHVwbG9hZHMsXG4gICAgLy8gYW5kIGNsZWFyIHJlY292ZXJlZFN0YXRlXG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRGaWxlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBzdGF0ZVVwZGF0ZS5hbGxvd05ld1VwbG9hZCA9IHRydWVcbiAgICAgIHN0YXRlVXBkYXRlLmVycm9yID0gbnVsbFxuICAgICAgc3RhdGVVcGRhdGUucmVjb3ZlcmVkU3RhdGUgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShzdGF0ZVVwZGF0ZSlcbiAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsUHJvZ3Jlc3MoKVxuXG4gICAgY29uc3QgcmVtb3ZlZEZpbGVJRHMgPSBPYmplY3Qua2V5cyhyZW1vdmVkRmlsZXMpXG4gICAgcmVtb3ZlZEZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2ZpbGUtcmVtb3ZlZCcsIHJlbW92ZWRGaWxlc1tmaWxlSURdLCByZWFzb24pXG4gICAgfSlcblxuICAgIGlmIChyZW1vdmVkRmlsZUlEcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZlZCAke3JlbW92ZWRGaWxlSURzLmxlbmd0aH0gZmlsZXNgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZlZCBmaWxlczogJHtyZW1vdmVkRmlsZUlEcy5qb2luKCcsICcpfWApXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRmlsZSAoZmlsZUlELCByZWFzb24gPSBudWxsKSB7XG4gICAgdGhpcy5yZW1vdmVGaWxlcyhbZmlsZUlEXSwgcmVhc29uKVxuICB9XG5cbiAgcGF1c2VSZXN1bWUgKGZpbGVJRCkge1xuICAgIGlmICghdGhpcy5nZXRTdGF0ZSgpLmNhcGFiaWxpdGllcy5yZXN1bWFibGVVcGxvYWRzXG4gICAgICAgICB8fCB0aGlzLmdldEZpbGUoZmlsZUlEKS51cGxvYWRDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IHdhc1BhdXNlZCA9IHRoaXMuZ2V0RmlsZShmaWxlSUQpLmlzUGF1c2VkIHx8IGZhbHNlXG4gICAgY29uc3QgaXNQYXVzZWQgPSAhd2FzUGF1c2VkXG5cbiAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlSUQsIHtcbiAgICAgIGlzUGF1c2VkLFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ3VwbG9hZC1wYXVzZScsIGZpbGVJRCwgaXNQYXVzZWQpXG5cbiAgICByZXR1cm4gaXNQYXVzZWRcbiAgfVxuXG4gIHBhdXNlQWxsICgpIHtcbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgY29uc3QgaW5Qcm9ncmVzc1VwZGF0ZWRGaWxlcyA9IE9iamVjdC5rZXlzKHVwZGF0ZWRGaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gIXVwZGF0ZWRGaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgICAgICAgICAgICYmIHVwZGF0ZWRGaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGluUHJvZ3Jlc3NVcGRhdGVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbGUgPSB7IC4uLnVwZGF0ZWRGaWxlc1tmaWxlXSwgaXNQYXVzZWQ6IHRydWUgfVxuICAgICAgdXBkYXRlZEZpbGVzW2ZpbGVdID0gdXBkYXRlZEZpbGVcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzOiB1cGRhdGVkRmlsZXMgfSlcbiAgICB0aGlzLmVtaXQoJ3BhdXNlLWFsbCcpXG4gIH1cblxuICByZXN1bWVBbGwgKCkge1xuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBjb25zdCBpblByb2dyZXNzVXBkYXRlZEZpbGVzID0gT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhdXBkYXRlZEZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlXG4gICAgICAgICAgICAgJiYgdXBkYXRlZEZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgaW5Qcm9ncmVzc1VwZGF0ZWRGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkRmlsZSA9IHtcbiAgICAgICAgLi4udXBkYXRlZEZpbGVzW2ZpbGVdLFxuICAgICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfVxuICAgICAgdXBkYXRlZEZpbGVzW2ZpbGVdID0gdXBkYXRlZEZpbGVcbiAgICB9KVxuICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlczogdXBkYXRlZEZpbGVzIH0pXG5cbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZS1hbGwnKVxuICB9XG5cbiAgcmV0cnlBbGwgKCkge1xuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBjb25zdCBmaWxlc1RvUmV0cnkgPSBPYmplY3Qua2V5cyh1cGRhdGVkRmlsZXMpLmZpbHRlcihmaWxlID0+IHtcbiAgICAgIHJldHVybiB1cGRhdGVkRmlsZXNbZmlsZV0uZXJyb3JcbiAgICB9KVxuXG4gICAgZmlsZXNUb1JldHJ5LmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlID0ge1xuICAgICAgICAuLi51cGRhdGVkRmlsZXNbZmlsZV0sXG4gICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZV0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmaWxlczogdXBkYXRlZEZpbGVzLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgncmV0cnktYWxsJywgZmlsZXNUb1JldHJ5KVxuXG4gICAgaWYgKGZpbGVzVG9SZXRyeS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBzdWNjZXNzZnVsOiBbXSxcbiAgICAgICAgZmFpbGVkOiBbXSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkSUQgPSB0aGlzLmNyZWF0ZVVwbG9hZChmaWxlc1RvUmV0cnksIHtcbiAgICAgIGZvcmNlQWxsb3dOZXdVcGxvYWQ6IHRydWUsIC8vIGNyZWF0ZSBuZXcgdXBsb2FkIGV2ZW4gaWYgYWxsb3dOZXdVcGxvYWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5ydW5VcGxvYWQodXBsb2FkSUQpXG4gIH1cblxuICBjYW5jZWxBbGwgKCkge1xuICAgIHRoaXMuZW1pdCgnY2FuY2VsLWFsbCcpXG5cbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyhmaWxlcylcbiAgICBpZiAoZmlsZUlEcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlRmlsZXMoZmlsZUlEcywgJ2NhbmNlbC1hbGwnKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdG90YWxQcm9ncmVzczogMCxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgcmVjb3ZlcmVkU3RhdGU6IG51bGwsXG4gICAgfSlcbiAgfVxuXG4gIHJldHJ5VXBsb2FkIChmaWxlSUQpIHtcbiAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlSUQsIHtcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ3VwbG9hZC1yZXRyeScsIGZpbGVJRClcblxuICAgIGNvbnN0IHVwbG9hZElEID0gdGhpcy5jcmVhdGVVcGxvYWQoW2ZpbGVJRF0sIHtcbiAgICAgIGZvcmNlQWxsb3dOZXdVcGxvYWQ6IHRydWUsIC8vIGNyZWF0ZSBuZXcgdXBsb2FkIGV2ZW4gaWYgYWxsb3dOZXdVcGxvYWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5ydW5VcGxvYWQodXBsb2FkSUQpXG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgdGhpcy5jYW5jZWxBbGwoKVxuICB9XG5cbiAgbG9nb3V0ICgpIHtcbiAgICB0aGlzLml0ZXJhdGVQbHVnaW5zKHBsdWdpbiA9PiB7XG4gICAgICBpZiAocGx1Z2luLnByb3ZpZGVyICYmIHBsdWdpbi5wcm92aWRlci5sb2dvdXQpIHtcbiAgICAgICAgcGx1Z2luLnByb3ZpZGVyLmxvZ291dCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNhbGN1bGF0ZVByb2dyZXNzIChmaWxlLCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmdldEZpbGUoZmlsZS5pZCkpIHtcbiAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBieXRlc1RvdGFsIG1heSBiZSBudWxsIG9yIHplcm87IGluIHRoYXQgY2FzZSB3ZSBjYW4ndCBkaXZpZGUgYnkgaXRcbiAgICBjb25zdCBjYW5IYXZlUGVyY2VudGFnZSA9IE51bWJlci5pc0Zpbml0ZShkYXRhLmJ5dGVzVG90YWwpICYmIGRhdGEuYnl0ZXNUb3RhbCA+IDBcbiAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7XG4gICAgICBwcm9ncmVzczoge1xuICAgICAgICAuLi50aGlzLmdldEZpbGUoZmlsZS5pZCkucHJvZ3Jlc3MsXG4gICAgICAgIGJ5dGVzVXBsb2FkZWQ6IGRhdGEuYnl0ZXNVcGxvYWRlZCxcbiAgICAgICAgYnl0ZXNUb3RhbDogZGF0YS5ieXRlc1RvdGFsLFxuICAgICAgICBwZXJjZW50YWdlOiBjYW5IYXZlUGVyY2VudGFnZVxuICAgICAgICAgIC8vIFRPRE8oZ290by1idXMtc3RvcCkgZmxvb3JpbmcgdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgdGhlIGNob2ljZSBvZiB0aGUgVUk/XG4gICAgICAgICAgLy8gd2UgZ2V0IG1vcmUgYWNjdXJhdGUgY2FsY3VsYXRpb25zIGlmIHdlIGRvbid0IHJvdW5kIHRoaXMgYXQgYWxsLlxuICAgICAgICAgID8gTWF0aC5yb3VuZCgoZGF0YS5ieXRlc1VwbG9hZGVkIC8gZGF0YS5ieXRlc1RvdGFsKSAqIDEwMClcbiAgICAgICAgICA6IDAsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsUHJvZ3Jlc3MoKVxuICB9XG5cbiAgY2FsY3VsYXRlVG90YWxQcm9ncmVzcyAoKSB7XG4gICAgLy8gY2FsY3VsYXRlIHRvdGFsIHByb2dyZXNzLCB1c2luZyB0aGUgbnVtYmVyIG9mIGZpbGVzIGN1cnJlbnRseSB1cGxvYWRpbmcsXG4gICAgLy8gbXVsdGlwbGllZCBieSAxMDAgYW5kIHRoZSBzdW1tIG9mIGluZGl2aWR1YWwgcHJvZ3Jlc3Mgb2YgZWFjaCBmaWxlXG4gICAgY29uc3QgZmlsZXMgPSB0aGlzLmdldEZpbGVzKClcblxuICAgIGNvbnN0IGluUHJvZ3Jlc3MgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICAgICAgfHwgZmlsZS5wcm9ncmVzcy5wcmVwcm9jZXNzXG4gICAgICAgIHx8IGZpbGUucHJvZ3Jlc3MucG9zdHByb2Nlc3NcbiAgICB9KVxuXG4gICAgaWYgKGluUHJvZ3Jlc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgMClcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyB0b3RhbFByb2dyZXNzOiAwIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzaXplZEZpbGVzID0gaW5Qcm9ncmVzcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUucHJvZ3Jlc3MuYnl0ZXNUb3RhbCAhPSBudWxsKVxuICAgIGNvbnN0IHVuc2l6ZWRGaWxlcyA9IGluUHJvZ3Jlc3MuZmlsdGVyKChmaWxlKSA9PiBmaWxlLnByb2dyZXNzLmJ5dGVzVG90YWwgPT0gbnVsbClcblxuICAgIGlmIChzaXplZEZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgcHJvZ3Jlc3NNYXggPSBpblByb2dyZXNzLmxlbmd0aCAqIDEwMFxuICAgICAgY29uc3QgY3VycmVudFByb2dyZXNzID0gdW5zaXplZEZpbGVzLnJlZHVjZSgoYWNjLCBmaWxlKSA9PiB7XG4gICAgICAgIHJldHVybiBhY2MgKyBmaWxlLnByb2dyZXNzLnBlcmNlbnRhZ2VcbiAgICAgIH0sIDApXG4gICAgICBjb25zdCB0b3RhbFByb2dyZXNzID0gTWF0aC5yb3VuZCgoY3VycmVudFByb2dyZXNzIC8gcHJvZ3Jlc3NNYXgpICogMTAwKVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3MgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB0b3RhbFNpemUgPSBzaXplZEZpbGVzLnJlZHVjZSgoYWNjLCBmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gYWNjICsgZmlsZS5wcm9ncmVzcy5ieXRlc1RvdGFsXG4gICAgfSwgMClcbiAgICBjb25zdCBhdmVyYWdlU2l6ZSA9IHRvdGFsU2l6ZSAvIHNpemVkRmlsZXMubGVuZ3RoXG4gICAgdG90YWxTaXplICs9IGF2ZXJhZ2VTaXplICogdW5zaXplZEZpbGVzLmxlbmd0aFxuXG4gICAgbGV0IHVwbG9hZGVkU2l6ZSA9IDBcbiAgICBzaXplZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHVwbG9hZGVkU2l6ZSArPSBmaWxlLnByb2dyZXNzLmJ5dGVzVXBsb2FkZWRcbiAgICB9KVxuICAgIHVuc2l6ZWRGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICB1cGxvYWRlZFNpemUgKz0gKGF2ZXJhZ2VTaXplICogKGZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZSB8fCAwKSkgLyAxMDBcbiAgICB9KVxuXG4gICAgbGV0IHRvdGFsUHJvZ3Jlc3MgPSB0b3RhbFNpemUgPT09IDBcbiAgICAgID8gMFxuICAgICAgOiBNYXRoLnJvdW5kKCh1cGxvYWRlZFNpemUgLyB0b3RhbFNpemUpICogMTAwKVxuXG4gICAgLy8gaG90IGZpeCwgYmVjYXVzZTpcbiAgICAvLyB1cGxvYWRlZFNpemUgZW5kZWQgdXAgbGFyZ2VyIHRoYW4gdG90YWxTaXplLCByZXN1bHRpbmcgaW4gMTMyNSUgdG90YWxcbiAgICBpZiAodG90YWxQcm9ncmVzcyA+IDEwMCkge1xuICAgICAgdG90YWxQcm9ncmVzcyA9IDEwMFxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyB0b3RhbFByb2dyZXNzIH0pXG4gICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRvdGFsUHJvZ3Jlc3MpXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGxpc3RlbmVycyBmb3IgYWxsIGdsb2JhbCBhY3Rpb25zLCBsaWtlOlxuICAgKiBgZXJyb3JgLCBgZmlsZS1yZW1vdmVkYCwgYHVwbG9hZC1wcm9ncmVzc2BcbiAgICovXG4gIGFkZExpc3RlbmVycyAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2ZpbGVdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtyZXNwb25zZV1cbiAgICAgKi9cbiAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZXJyb3IsIGZpbGUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBsZXQgZXJyb3JNc2cgPSBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ1xuICAgICAgaWYgKGVycm9yLmRldGFpbHMpIHtcbiAgICAgICAgZXJyb3JNc2cgKz0gYCAke2Vycm9yLmRldGFpbHN9YFxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IGVycm9yTXNnIH0pXG5cbiAgICAgIGlmIChmaWxlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICAgIGVycm9yOiBlcnJvck1zZyxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIGVycm9ySGFuZGxlcilcblxuICAgIHRoaXMub24oJ3VwbG9hZC1lcnJvcicsIChmaWxlLCBlcnJvciwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGVycm9ySGFuZGxlcihlcnJvciwgZmlsZSwgcmVzcG9uc2UpXG5cbiAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgbmV3RXJyb3IuZGV0YWlscyA9IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgaWYgKGVycm9yLmRldGFpbHMpIHtcbiAgICAgICAgICBuZXdFcnJvci5kZXRhaWxzICs9IGAgJHtlcnJvci5kZXRhaWxzfWBcbiAgICAgICAgfVxuICAgICAgICBuZXdFcnJvci5tZXNzYWdlID0gdGhpcy5pMThuKCdmYWlsZWRUb1VwbG9hZCcsIHsgZmlsZTogZmlsZS5uYW1lIH0pXG4gICAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhuZXdFcnJvciwge1xuICAgICAgICAgIHRocm93RXJyOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhlcnJvciwge1xuICAgICAgICAgIHRocm93RXJyOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5vbigndXBsb2FkJywgKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yOiBudWxsIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3VwbG9hZC1zdGFydGVkJywgKGZpbGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICBwcm9ncmVzczoge1xuICAgICAgICAgIHVwbG9hZFN0YXJ0ZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgdXBsb2FkQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgIHBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgYnl0ZXNVcGxvYWRlZDogMCxcbiAgICAgICAgICBieXRlc1RvdGFsOiBmaWxlLnNpemUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCd1cGxvYWQtcHJvZ3Jlc3MnLCB0aGlzLmNhbGN1bGF0ZVByb2dyZXNzKVxuXG4gICAgdGhpcy5vbigndXBsb2FkLXN1Y2Nlc3MnLCAoZmlsZSwgdXBsb2FkUmVzcCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmdldEZpbGUoZmlsZS5pZCkpIHtcbiAgICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRQcm9ncmVzcyA9IHRoaXMuZ2V0RmlsZShmaWxlLmlkKS5wcm9ncmVzc1xuICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICBwcm9ncmVzczoge1xuICAgICAgICAgIC4uLmN1cnJlbnRQcm9ncmVzcyxcbiAgICAgICAgICBwb3N0cHJvY2VzczogdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGggPiAwID8ge1xuICAgICAgICAgICAgbW9kZTogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgIH0gOiBudWxsLFxuICAgICAgICAgIHVwbG9hZENvbXBsZXRlOiB0cnVlLFxuICAgICAgICAgIHBlcmNlbnRhZ2U6IDEwMCxcbiAgICAgICAgICBieXRlc1VwbG9hZGVkOiBjdXJyZW50UHJvZ3Jlc3MuYnl0ZXNUb3RhbCxcbiAgICAgICAgfSxcbiAgICAgICAgcmVzcG9uc2U6IHVwbG9hZFJlc3AsXG4gICAgICAgIHVwbG9hZFVSTDogdXBsb2FkUmVzcC51cGxvYWRVUkwsXG4gICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3ByZXByb2Nlc3MtcHJvZ3Jlc3MnLCAoZmlsZSwgcHJvZ3Jlc3MpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICBwcm9ncmVzczogeyAuLi50aGlzLmdldEZpbGUoZmlsZS5pZCkucHJvZ3Jlc3MsIHByZXByb2Nlc3M6IHByb2dyZXNzIH0sXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwcmVwcm9jZXNzLWNvbXBsZXRlJywgKGZpbGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgZmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgICBmaWxlc1tmaWxlLmlkXSA9IHsgLi4uZmlsZXNbZmlsZS5pZF0sIHByb2dyZXNzOiB7IC4uLmZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzIH0gfVxuICAgICAgZGVsZXRlIGZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzLnByZXByb2Nlc3NcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3Bvc3Rwcm9jZXNzLXByb2dyZXNzJywgKGZpbGUsIHByb2dyZXNzKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzLCBwb3N0cHJvY2VzczogcHJvZ3Jlc3MgfSxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3Bvc3Rwcm9jZXNzLWNvbXBsZXRlJywgKGZpbGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgZmlsZXMgPSB7XG4gICAgICAgIC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyxcbiAgICAgIH1cbiAgICAgIGZpbGVzW2ZpbGUuaWRdID0ge1xuICAgICAgICAuLi5maWxlc1tmaWxlLmlkXSxcbiAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAuLi5maWxlc1tmaWxlLmlkXS5wcm9ncmVzcyxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBmaWxlc1tmaWxlLmlkXS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgICAgLy8gVE9ETyBzaG91bGQgd2Ugc2V0IHNvbWUga2luZCBvZiBgZnVsbHlDb21wbGV0ZWAgcHJvcGVydHkgb24gdGhlIGZpbGUgb2JqZWN0XG4gICAgICAvLyBzbyBpdCdzIGVhc2llciB0byBzZWUgdGhhdCB0aGUgZmlsZSBpcyB1cGxvYWTigKZmdWxseSBjb21wbGV0ZeKApnJhdGhlciB0aGFuXG4gICAgICAvLyB3aGF0IHdlIGhhdmUgdG8gZG8gbm93IChgdXBsb2FkQ29tcGxldGUgJiYgIXBvc3Rwcm9jZXNzYClcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3Jlc3RvcmVkJywgKCkgPT4ge1xuICAgICAgLy8gRmlsZXMgbWF5IGhhdmUgY2hhbmdlZC0tZW5zdXJlIHByb2dyZXNzIGlzIHN0aWxsIGFjY3VyYXRlLlxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFByb2dyZXNzKClcbiAgICB9KVxuXG4gICAgLy8gc2hvdyBpbmZvcm1lciBpZiBvZmZsaW5lXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgKCkgPT4gdGhpcy51cGRhdGVPbmxpbmVTdGF0dXMoKSlcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgKCkgPT4gdGhpcy51cGRhdGVPbmxpbmVTdGF0dXMoKSlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVPbmxpbmVTdGF0dXMoKSwgMzAwMClcbiAgICB9XG4gIH1cblxuICB1cGRhdGVPbmxpbmVTdGF0dXMgKCkge1xuICAgIGNvbnN0IG9ubGluZVxuICAgICAgPSB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvci5vbkxpbmUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gd2luZG93Lm5hdmlnYXRvci5vbkxpbmVcbiAgICAgICAgOiB0cnVlXG4gICAgaWYgKCFvbmxpbmUpIHtcbiAgICAgIHRoaXMuZW1pdCgnaXMtb2ZmbGluZScpXG4gICAgICB0aGlzLmluZm8odGhpcy5pMThuKCdub0ludGVybmV0Q29ubmVjdGlvbicpLCAnZXJyb3InLCAwKVxuICAgICAgdGhpcy53YXNPZmZsaW5lID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ2lzLW9ubGluZScpXG4gICAgICBpZiAodGhpcy53YXNPZmZsaW5lKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnYmFjay1vbmxpbmUnKVxuICAgICAgICB0aGlzLmluZm8odGhpcy5pMThuKCdjb25uZWN0ZWRUb0ludGVybmV0JyksICdzdWNjZXNzJywgMzAwMClcbiAgICAgICAgdGhpcy53YXNPZmZsaW5lID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRJRCAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cy5pZFxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHBsdWdpbiB3aXRoIENvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gb2JqZWN0IHdpdGggb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gUGx1Z2luXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHNlbGYgZm9yIGNoYWluaW5nXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gIHVzZSAoUGx1Z2luLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBQbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCBhIHBsdWdpbiBjbGFzcywgYnV0IGdvdCAke1BsdWdpbiA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBQbHVnaW59LmBcbiAgICAgICAgKyAnIFBsZWFzZSB2ZXJpZnkgdGhhdCB0aGUgcGx1Z2luIHdhcyBpbXBvcnRlZCBhbmQgc3BlbGxlZCBjb3JyZWN0bHkuJ1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgLy8gSW5zdGFudGlhdGVcbiAgICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgY29uc3QgcGx1Z2luSWQgPSBwbHVnaW4uaWRcbiAgICB0aGlzLnBsdWdpbnNbcGx1Z2luLnR5cGVdID0gdGhpcy5wbHVnaW5zW3BsdWdpbi50eXBlXSB8fCBbXVxuXG4gICAgaWYgKCFwbHVnaW5JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIHBsdWdpbiBtdXN0IGhhdmUgYW4gaWQnKVxuICAgIH1cblxuICAgIGlmICghcGx1Z2luLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBwbHVnaW4gbXVzdCBoYXZlIGEgdHlwZScpXG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RzUGx1Z2luQWxyZWFkeSA9IHRoaXMuZ2V0UGx1Z2luKHBsdWdpbklkKVxuICAgIGlmIChleGlzdHNQbHVnaW5BbHJlYWR5KSB7XG4gICAgICBjb25zdCBtc2cgPSBgQWxyZWFkeSBmb3VuZCBhIHBsdWdpbiBuYW1lZCAnJHtleGlzdHNQbHVnaW5BbHJlYWR5LmlkfScuIGBcbiAgICAgICAgKyBgVHJpZWQgdG8gdXNlOiAnJHtwbHVnaW5JZH0nLlxcbmBcbiAgICAgICAgKyAnVXBweSBwbHVnaW5zIG11c3QgaGF2ZSB1bmlxdWUgYGlkYCBvcHRpb25zLiBTZWUgaHR0cHM6Ly91cHB5LmlvL2RvY3MvcGx1Z2lucy8jaWQuJ1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICB9XG5cbiAgICBpZiAoUGx1Z2luLlZFUlNJT04pIHtcbiAgICAgIHRoaXMubG9nKGBVc2luZyAke3BsdWdpbklkfSB2JHtQbHVnaW4uVkVSU0lPTn1gKVxuICAgIH1cblxuICAgIHRoaXMucGx1Z2luc1twbHVnaW4udHlwZV0ucHVzaChwbHVnaW4pXG4gICAgcGx1Z2luLmluc3RhbGwoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIG9uZSBQbHVnaW4gYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHBsdWdpbiBpZFxuICAgKiBAcmV0dXJucyB7b2JqZWN0fGJvb2xlYW59XG4gICAqL1xuICBnZXRQbHVnaW4gKGlkKSB7XG4gICAgbGV0IGZvdW5kUGx1Z2luID0gbnVsbFxuICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgaWYgKHBsdWdpbi5pZCA9PT0gaWQpIHtcbiAgICAgICAgZm91bmRQbHVnaW4gPSBwbHVnaW5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZm91bmRQbHVnaW5cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIGB1c2VgZCBwbHVnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgdGhhdCB3aWxsIGJlIHJ1biBvbiBlYWNoIHBsdWdpblxuICAgKi9cbiAgaXRlcmF0ZVBsdWdpbnMgKG1ldGhvZCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMucGx1Z2lucykuZm9yRWFjaChwbHVnaW5UeXBlID0+IHtcbiAgICAgIHRoaXMucGx1Z2luc1twbHVnaW5UeXBlXS5mb3JFYWNoKG1ldGhvZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVuaW5zdGFsbCBhbmQgcmVtb3ZlIGEgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdGFuY2UgVGhlIHBsdWdpbiBpbnN0YW5jZSB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVQbHVnaW4gKGluc3RhbmNlKSB7XG4gICAgdGhpcy5sb2coYFJlbW92aW5nIHBsdWdpbiAke2luc3RhbmNlLmlkfWApXG4gICAgdGhpcy5lbWl0KCdwbHVnaW4tcmVtb3ZlJywgaW5zdGFuY2UpXG5cbiAgICBpZiAoaW5zdGFuY2UudW5pbnN0YWxsKSB7XG4gICAgICBpbnN0YW5jZS51bmluc3RhbGwoKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3QgPSB0aGlzLnBsdWdpbnNbaW5zdGFuY2UudHlwZV0uc2xpY2UoKVxuICAgIC8vIGxpc3QuaW5kZXhPZiBmYWlsZWQgaGVyZSwgYmVjYXVzZSBWdWUzIGNvbnZlcnRlZCB0aGUgcGx1Z2luIGluc3RhbmNlXG4gICAgLy8gdG8gYSBQcm94eSBvYmplY3QsIHdoaWNoIGZhaWxlZCB0aGUgc3RyaWN0IGNvbXBhcmlzb24gdGVzdDpcbiAgICAvLyBvYmogIT09IG9ialByb3h5XG4gICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgobGlzdCwgaXRlbSA9PiBpdGVtLmlkID09PSBpbnN0YW5jZS5pZClcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBsaXN0LnNwbGljZShpbmRleCwgMSlcbiAgICAgIHRoaXMucGx1Z2luc1tpbnN0YW5jZS50eXBlXSA9IGxpc3RcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZSA9IHtcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgLi4uc3RhdGUucGx1Z2lucyxcbiAgICAgICAgW2luc3RhbmNlLmlkXTogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh1cGRhdGVkU3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogVW5pbnN0YWxsIGFsbCBwbHVnaW5zIGFuZCBjbG9zZSBkb3duIHRoaXMgVXBweSBpbnN0YW5jZS5cbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLmxvZyhgQ2xvc2luZyBVcHB5IGluc3RhbmNlICR7dGhpcy5vcHRzLmlkfTogcmVtb3ZpbmcgYWxsIGZpbGVzIGFuZCB1bmluc3RhbGxpbmcgcGx1Z2luc2ApXG5cbiAgICB0aGlzLnJlc2V0KClcblxuICAgIHRoaXMuc3RvcmVVbnN1YnNjcmliZSgpXG5cbiAgICB0aGlzLml0ZXJhdGVQbHVnaW5zKChwbHVnaW4pID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlUGx1Z2luKHBsdWdpbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbmZvIG1lc3NhZ2UgaW4gYHN0YXRlLmluZm9gLCBzbyB0aGF0IFVJIHBsdWdpbnMgbGlrZSBgSW5mb3JtZXJgXG4gICAqIGNhbiBkaXNwbGF5IHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG9iamVjdH0gbWVzc2FnZSBNZXNzYWdlIHRvIGJlIGRpc3BsYXllZCBieSB0aGUgaW5mb3JtZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXVxuICAgKi9cblxuICBpbmZvIChtZXNzYWdlLCB0eXBlID0gJ2luZm8nLCBkdXJhdGlvbiA9IDMwMDApIHtcbiAgICBjb25zdCBpc0NvbXBsZXhNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGluZm86IHtcbiAgICAgICAgaXNIaWRkZW46IGZhbHNlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBtZXNzYWdlOiBpc0NvbXBsZXhNZXNzYWdlID8gbWVzc2FnZS5tZXNzYWdlIDogbWVzc2FnZSxcbiAgICAgICAgZGV0YWlsczogaXNDb21wbGV4TWVzc2FnZSA/IG1lc3NhZ2UuZGV0YWlscyA6IG51bGwsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ2luZm8tdmlzaWJsZScpXG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5pbmZvVGltZW91dElEKVxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgdGhpcy5pbmZvVGltZW91dElEID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBoaWRlIHRoZSBpbmZvcm1lciBhZnRlciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kc1xuICAgIHRoaXMuaW5mb1RpbWVvdXRJRCA9IHNldFRpbWVvdXQodGhpcy5oaWRlSW5mbywgZHVyYXRpb24pXG4gIH1cblxuICBoaWRlSW5mbyAoKSB7XG4gICAgY29uc3QgbmV3SW5mbyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmluZm8sIGlzSGlkZGVuOiB0cnVlIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGluZm86IG5ld0luZm8sXG4gICAgfSlcbiAgICB0aGlzLmVtaXQoJ2luZm8taGlkZGVuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzZXMgbWVzc2FnZXMgdG8gYSBmdW5jdGlvbiwgcHJvdmlkZWQgaW4gYG9wdHMubG9nZ2VyYC5cbiAgICogSWYgYG9wdHMubG9nZ2VyOiBVcHB5LmRlYnVnTG9nZ2VyYCBvciBgb3B0cy5kZWJ1ZzogdHJ1ZWAsIGxvZ3MgdG8gdGhlIGJyb3dzZXIgY29uc29sZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBtZXNzYWdlIHRvIGxvZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG9wdGlvbmFsIGBlcnJvcmAgb3IgYHdhcm5pbmdgXG4gICAqL1xuICBsb2cgKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICBjb25zdCB7IGxvZ2dlciB9ID0gdGhpcy5vcHRzXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdlcnJvcic6IGxvZ2dlci5lcnJvcihtZXNzYWdlKTsgYnJlYWtcbiAgICAgIGNhc2UgJ3dhcm5pbmcnOiBsb2dnZXIud2FybihtZXNzYWdlKTsgYnJlYWtcbiAgICAgIGRlZmF1bHQ6IGxvZ2dlci5kZWJ1ZyhtZXNzYWdlKTsgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2Jzb2xldGUsIGV2ZW50IGxpc3RlbmVycyBhcmUgbm93IGFkZGVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIHJ1biAoKSB7XG4gICAgdGhpcy5sb2coJ0NhbGxpbmcgcnVuKCkgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS4nLCAnd2FybmluZycpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIGFuIHVwbG9hZCBieSBpdHMgSUQuXG4gICAqL1xuICByZXN0b3JlICh1cGxvYWRJRCkge1xuICAgIHRoaXMubG9nKGBDb3JlOiBhdHRlbXB0aW5nIHRvIHJlc3RvcmUgdXBsb2FkIFwiJHt1cGxvYWRJRH1cImApXG5cbiAgICBpZiAoIXRoaXMuZ2V0U3RhdGUoKS5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0pIHtcbiAgICAgIHRoaXMucmVtb3ZlVXBsb2FkKHVwbG9hZElEKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm9uZXhpc3RlbnQgdXBsb2FkJykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucnVuVXBsb2FkKHVwbG9hZElEKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiB1cGxvYWQgZm9yIGEgYnVuY2ggb2YgZmlsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZmlsZUlEcyBGaWxlIElEcyB0byBpbmNsdWRlIGluIHRoaXMgdXBsb2FkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBJRCBvZiB0aGlzIHVwbG9hZC5cbiAgICovXG4gIGNyZWF0ZVVwbG9hZCAoZmlsZUlEcywgb3B0cyA9IHt9KSB7XG4gICAgLy8gdXBweS5yZXRyeUFsbCBzZXRzIHRoaXMgdG8gdHJ1ZSDigJQgd2hlbiByZXRyeWluZyB3ZSB3YW50IHRvIGlnbm9yZSBgYWxsb3dOZXdVcGxvYWQ6IGZhbHNlYFxuICAgIGNvbnN0IHsgZm9yY2VBbGxvd05ld1VwbG9hZCA9IGZhbHNlIH0gPSBvcHRzXG5cbiAgICBjb25zdCB7IGFsbG93TmV3VXBsb2FkLCBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgaWYgKCFhbGxvd05ld1VwbG9hZCAmJiAhZm9yY2VBbGxvd05ld1VwbG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIGEgbmV3IHVwbG9hZDogYWxyZWFkeSB1cGxvYWRpbmcuJylcbiAgICB9XG5cbiAgICBjb25zdCB1cGxvYWRJRCA9IGN1aWQoKVxuXG4gICAgdGhpcy5lbWl0KCd1cGxvYWQnLCB7XG4gICAgICBpZDogdXBsb2FkSUQsXG4gICAgICBmaWxlSURzLFxuICAgIH0pXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFsbG93TmV3VXBsb2FkOiB0aGlzLm9wdHMuYWxsb3dNdWx0aXBsZVVwbG9hZHMgIT09IGZhbHNlLFxuXG4gICAgICBjdXJyZW50VXBsb2Fkczoge1xuICAgICAgICAuLi5jdXJyZW50VXBsb2FkcyxcbiAgICAgICAgW3VwbG9hZElEXToge1xuICAgICAgICAgIGZpbGVJRHMsXG4gICAgICAgICAgc3RlcDogMCxcbiAgICAgICAgICByZXN1bHQ6IHt9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHVwbG9hZElEXG4gIH1cblxuICBnZXRVcGxvYWQgKHVwbG9hZElEKSB7XG4gICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG5cbiAgICByZXR1cm4gY3VycmVudFVwbG9hZHNbdXBsb2FkSURdXG4gIH1cblxuICAvKipcbiAgICogQWRkIGRhdGEgdG8gYW4gdXBsb2FkJ3MgcmVzdWx0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVwbG9hZElEIFRoZSBJRCBvZiB0aGUgdXBsb2FkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBEYXRhIHByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSByZXN1bHQgb2JqZWN0LlxuICAgKi9cbiAgYWRkUmVzdWx0RGF0YSAodXBsb2FkSUQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuZ2V0VXBsb2FkKHVwbG9hZElEKSkge1xuICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHJlc3VsdCBmb3IgYW4gdXBsb2FkIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHt1cGxvYWRJRH1gKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGN1cnJlbnRVcGxvYWQgPSB7IC4uLmN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXSwgcmVzdWx0OiB7IC4uLmN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXS5yZXN1bHQsIC4uLmRhdGEgfSB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50VXBsb2FkczogeyAuLi5jdXJyZW50VXBsb2FkcywgW3VwbG9hZElEXTogY3VycmVudFVwbG9hZCB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIHVwbG9hZCwgZWcuIGlmIGl0IGhhcyBiZWVuIGNhbmNlbGVkIG9yIGNvbXBsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVwbG9hZElEIFRoZSBJRCBvZiB0aGUgdXBsb2FkLlxuICAgKi9cbiAgcmVtb3ZlVXBsb2FkICh1cGxvYWRJRCkge1xuICAgIGNvbnN0IGN1cnJlbnRVcGxvYWRzID0geyAuLi50aGlzLmdldFN0YXRlKCkuY3VycmVudFVwbG9hZHMgfVxuICAgIGRlbGV0ZSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY3VycmVudFVwbG9hZHMsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gYW4gdXBsb2FkLiBUaGlzIHBpY2tzIHVwIHdoZXJlIGl0IGxlZnQgb2ZmIGluIGNhc2UgdGhlIHVwbG9hZCBpcyBiZWluZyByZXN0b3JlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJ1blVwbG9hZCAodXBsb2FkSUQpIHtcbiAgICBjb25zdCB1cGxvYWREYXRhID0gdGhpcy5nZXRTdGF0ZSgpLmN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICAgIGNvbnN0IHJlc3RvcmVTdGVwID0gdXBsb2FkRGF0YS5zdGVwXG5cbiAgICBjb25zdCBzdGVwcyA9IFtcbiAgICAgIC4uLnRoaXMucHJlUHJvY2Vzc29ycyxcbiAgICAgIC4uLnRoaXMudXBsb2FkZXJzLFxuICAgICAgLi4udGhpcy5wb3N0UHJvY2Vzc29ycyxcbiAgICBdXG4gICAgbGV0IGxhc3RTdGVwID0gUHJvbWlzZS5yZXNvbHZlKClcbiAgICBzdGVwcy5mb3JFYWNoKChmbiwgc3RlcCkgPT4ge1xuICAgICAgLy8gU2tpcCB0aGlzIHN0ZXAgaWYgd2UgYXJlIHJlc3RvcmluZyBhbmQgaGF2ZSBhbHJlYWR5IGNvbXBsZXRlZCB0aGlzIHN0ZXAgYmVmb3JlLlxuICAgICAgaWYgKHN0ZXAgPCByZXN0b3JlU3RlcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGFzdFN0ZXAgPSBsYXN0U3RlcC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgICAgIGNvbnN0IGN1cnJlbnRVcGxvYWQgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICAgICAgaWYgKCFjdXJyZW50VXBsb2FkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGRhdGVkVXBsb2FkID0ge1xuICAgICAgICAgIC4uLmN1cnJlbnRVcGxvYWQsXG4gICAgICAgICAgc3RlcCxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGN1cnJlbnRVcGxvYWRzOiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50VXBsb2FkcyxcbiAgICAgICAgICAgIFt1cGxvYWRJRF06IHVwZGF0ZWRVcGxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBUT0RPIGdpdmUgdGhpcyB0aGUgYHVwZGF0ZWRVcGxvYWRgIG9iamVjdCBhcyBpdHMgb25seSBwYXJhbWV0ZXIgbWF5YmU/XG4gICAgICAgIC8vIE90aGVyd2lzZSB3aGVuIG1vcmUgbWV0YWRhdGEgbWF5IGJlIGFkZGVkIHRvIHRoZSB1cGxvYWQgdGhpcyB3b3VsZCBrZWVwIGdldHRpbmcgbW9yZSBwYXJhbWV0ZXJzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICByZXR1cm4gZm4odXBkYXRlZFVwbG9hZC5maWxlSURzLCB1cGxvYWRJRClcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgLy8gTm90IHJldHVybmluZyB0aGUgYGNhdGNoYGVkIHByb21pc2UsIGJlY2F1c2Ugd2Ugc3RpbGwgd2FudCB0byByZXR1cm4gYSByZWplY3RlZFxuICAgIC8vIHByb21pc2UgZnJvbSB0aGlzIG1ldGhvZCBpZiB0aGUgdXBsb2FkIGZhaWxlZC5cbiAgICBsYXN0U3RlcC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyLCB1cGxvYWRJRClcbiAgICAgIHRoaXMucmVtb3ZlVXBsb2FkKHVwbG9hZElEKVxuICAgIH0pXG5cbiAgICByZXR1cm4gbGFzdFN0ZXAudGhlbigoKSA9PiB7XG4gICAgICAvLyBTZXQgcmVzdWx0IGRhdGEuXG4gICAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICAgIGNvbnN0IGN1cnJlbnRVcGxvYWQgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICAgIGlmICghY3VycmVudFVwbG9hZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gTWFyayBwb3N0cHJvY2Vzc2luZyBzdGVwIGFzIGNvbXBsZXRlIGlmIG5lY2Vzc2FyeTsgdGhpcyBhZGRyZXNzZXMgYSBjYXNlIHdoZXJlIHdlIG1pZ2h0IGdldFxuICAgICAgLy8gc3R1Y2sgaW4gdGhlIHBvc3Rwcm9jZXNzaW5nIFVJIHdoaWxlIHRoZSB1cGxvYWQgaXMgZnVsbHkgY29tcGxldGUuXG4gICAgICAvLyBJZiB0aGUgcG9zdHByb2Nlc3Npbmcgc3RlcHMgZG8gbm90IGRvIGFueSB3b3JrLCB0aGV5IG1heSBub3QgZW1pdCBwb3N0cHJvY2Vzc2luZyBldmVudHMgYXRcbiAgICAgIC8vIGFsbCwgYW5kIG5ldmVyIG1hcmsgdGhlIHBvc3Rwcm9jZXNzaW5nIGFzIGNvbXBsZXRlLiBUaGlzIGlzIGZpbmUgb24gaXRzIG93biBidXQgd2VcbiAgICAgIC8vIGludHJvZHVjZWQgY29kZSBpbiB0aGUgQHVwcHkvY29yZSB1cGxvYWQtc3VjY2VzcyBoYW5kbGVyIHRvIHByZXBhcmUgcG9zdHByb2Nlc3NpbmcgcHJvZ3Jlc3NcbiAgICAgIC8vIHN0YXRlIGlmIGFueSBwb3N0cHJvY2Vzc29ycyBhcmUgcmVnaXN0ZXJlZC4gVGhhdCBpcyB0byBhdm9pZCBhIFwiZmxhc2ggb2YgY29tcGxldGVkIHN0YXRlXCJcbiAgICAgIC8vIGJlZm9yZSB0aGUgcG9zdHByb2Nlc3NpbmcgcGx1Z2lucyBjYW4gZW1pdCBldmVudHMuXG4gICAgICAvL1xuICAgICAgLy8gU28sIGp1c3QgaW4gY2FzZSBhbiB1cGxvYWQgd2l0aCBwb3N0cHJvY2Vzc2luZyBwbHVnaW5zICpoYXMqIGNvbXBsZXRlZCAqd2l0aG91dCogZW1pdHRpbmdcbiAgICAgIC8vIHBvc3Rwcm9jZXNzaW5nIGNvbXBsZXRpb24sIHdlIGRvIGl0IGluc3RlYWQuXG4gICAgICBjdXJyZW50VXBsb2FkLmZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGUoZmlsZUlEKVxuICAgICAgICBpZiAoZmlsZSAmJiBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdwb3N0cHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGZpbGVzID0gY3VycmVudFVwbG9hZC5maWxlSURzLm1hcCgoZmlsZUlEKSA9PiB0aGlzLmdldEZpbGUoZmlsZUlEKSlcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+ICFmaWxlLmVycm9yKVxuICAgICAgY29uc3QgZmFpbGVkID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiBmaWxlLmVycm9yKVxuICAgICAgdGhpcy5hZGRSZXN1bHREYXRhKHVwbG9hZElELCB7IHN1Y2Nlc3NmdWwsIGZhaWxlZCwgdXBsb2FkSUQgfSlcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIC8vIEVtaXQgY29tcGxldGlvbiBldmVudHMuXG4gICAgICAvLyBUaGlzIGlzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gdGhhdCB0aGUgYGN1cnJlbnRVcGxvYWRzYCB2YXJpYWJsZVxuICAgICAgLy8gYWx3YXlzIHJlZmVycyB0byB0aGUgbGF0ZXN0IHN0YXRlLiBJbiB0aGUgaGFuZGxlciByaWdodCBhYm92ZSBpdCByZWZlcnNcbiAgICAgIC8vIHRvIGFuIG91dGRhdGVkIG9iamVjdCB3aXRob3V0IHRoZSBgLnJlc3VsdGAgcHJvcGVydHkuXG4gICAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICAgIGlmICghY3VycmVudFVwbG9hZHNbdXBsb2FkSURdKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudFVwbG9hZCA9IGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGN1cnJlbnRVcGxvYWRcbiAgICAgIHRoaXMuZW1pdCgnY29tcGxldGUnLCByZXN1bHQpXG5cbiAgICAgIHRoaXMucmVtb3ZlVXBsb2FkKHVwbG9hZElEKVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcmVzdWx0IGZvciBhbiB1cGxvYWQgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke3VwbG9hZElEfWApXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhbiB1cGxvYWQgZm9yIGFsbCB0aGUgZmlsZXMgdGhhdCBhcmUgbm90IGN1cnJlbnRseSBiZWluZyB1cGxvYWRlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICB1cGxvYWQgKCkge1xuICAgIGlmICghdGhpcy5wbHVnaW5zLnVwbG9hZGVyKSB7XG4gICAgICB0aGlzLmxvZygnTm8gdXBsb2FkZXIgdHlwZSBwbHVnaW5zIGFyZSB1c2VkJywgJ3dhcm5pbmcnKVxuICAgIH1cblxuICAgIGxldCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGNvbnN0IG9uQmVmb3JlVXBsb2FkUmVzdWx0ID0gdGhpcy5vcHRzLm9uQmVmb3JlVXBsb2FkKGZpbGVzKVxuXG4gICAgaWYgKG9uQmVmb3JlVXBsb2FkUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm90IHN0YXJ0aW5nIHRoZSB1cGxvYWQgYmVjYXVzZSBvbkJlZm9yZVVwbG9hZCByZXR1cm5lZCBmYWxzZScpKVxuICAgIH1cblxuICAgIGlmIChvbkJlZm9yZVVwbG9hZFJlc3VsdCAmJiB0eXBlb2Ygb25CZWZvcmVVcGxvYWRSZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBmaWxlcyA9IG9uQmVmb3JlVXBsb2FkUmVzdWx0XG4gICAgICAvLyBVcGRhdGluZyBmaWxlcyBpbiBzdGF0ZSwgYmVjYXVzZSB1cGxvYWRlciBwbHVnaW5zIHJlY2VpdmUgZmlsZSBJRHMsXG4gICAgICAvLyBhbmQgdGhlbiBmZXRjaCB0aGUgYWN0dWFsIGZpbGUgb2JqZWN0IGZyb20gc3RhdGVcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBmaWxlcyxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNoZWNrTWluTnVtYmVyT2ZGaWxlcyhmaWxlcykpXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyKVxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBhcmUgY3VycmVudGx5IGFzc2lnbmVkIHRvIHVwbG9hZHNcbiAgICAgICAgY29uc3QgY3VycmVudGx5VXBsb2FkaW5nRmlsZXMgPSBPYmplY3Qua2V5cyhjdXJyZW50VXBsb2FkcylcbiAgICAgICAgICAucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBwcmV2LmNvbmNhdChjdXJyZW50VXBsb2Fkc1tjdXJyXS5maWxlSURzKSwgW10pXG5cbiAgICAgICAgY29uc3Qgd2FpdGluZ0ZpbGVJRHMgPSBbXVxuICAgICAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZShmaWxlSUQpXG4gICAgICAgICAgLy8gaWYgdGhlIGZpbGUgaGFzbid0IHN0YXJ0ZWQgdXBsb2FkaW5nIGFuZCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFzc2lnbmVkIHRvIGFuIHVwbG9hZC4uXG4gICAgICAgICAgaWYgKCghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkKSAmJiAoY3VycmVudGx5VXBsb2FkaW5nRmlsZXMuaW5kZXhPZihmaWxlSUQpID09PSAtMSkpIHtcbiAgICAgICAgICAgIHdhaXRpbmdGaWxlSURzLnB1c2goZmlsZS5pZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgdXBsb2FkSUQgPSB0aGlzLmNyZWF0ZVVwbG9hZCh3YWl0aW5nRmlsZUlEcylcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVXBsb2FkKHVwbG9hZElEKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhlcnIsIHtcbiAgICAgICAgICBzaG93SW5mb3JtZXI6IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvcmUgKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBVcHB5KG9wdHMpXG59XG5cbi8vIEV4cG9zZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbm1vZHVsZS5leHBvcnRzLlVwcHkgPSBVcHB5XG5tb2R1bGUuZXhwb3J0cy5QbHVnaW4gPSBQbHVnaW5cbm1vZHVsZS5leHBvcnRzLmRlYnVnTG9nZ2VyID0gZGVidWdMb2dnZXJcbiIsImNvbnN0IGdldFRpbWVTdGFtcCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRUaW1lU3RhbXAnKVxuXG4vLyBTd2FsbG93IGFsbCBsb2dzLCBleGNlcHQgZXJyb3JzLlxuLy8gZGVmYXVsdCBpZiBsb2dnZXIgaXMgbm90IHNldCBvciBkZWJ1ZzogZmFsc2VcbmNvbnN0IGp1c3RFcnJvcnNMb2dnZXIgPSB7XG4gIGRlYnVnOiAoLi4uYXJncykgPT4ge30sXG4gIHdhcm46ICguLi5hcmdzKSA9PiB7fSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGBbVXBweV0gWyR7Z2V0VGltZVN0YW1wKCl9XWAsIC4uLmFyZ3MpLFxufVxuXG4vLyBQcmludCBsb2dzIHRvIGNvbnNvbGUgd2l0aCBuYW1lc3BhY2UgKyB0aW1lc3RhbXAsXG4vLyBzZXQgYnkgbG9nZ2VyOiBVcHB5LmRlYnVnTG9nZ2VyIG9yIGRlYnVnOiB0cnVlXG5jb25zdCBkZWJ1Z0xvZ2dlciA9IHtcbiAgZGVidWc6ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gSUUgMTAgZG9lc27igJl0IHN1cHBvcnQgY29uc29sZS5kZWJ1Z1xuICAgIGNvbnN0IGRlYnVnID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZ1xuICAgIGRlYnVnLmNhbGwoY29uc29sZSwgYFtVcHB5XSBbJHtnZXRUaW1lU3RhbXAoKX1dYCwgLi4uYXJncylcbiAgfSxcbiAgd2FybjogKC4uLmFyZ3MpID0+IGNvbnNvbGUud2FybihgW1VwcHldIFske2dldFRpbWVTdGFtcCgpfV1gLCAuLi5hcmdzKSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGBbVXBweV0gWyR7Z2V0VGltZVN0YW1wKCl9XWAsIC4uLmFyZ3MpLFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAganVzdEVycm9yc0xvZ2dlcixcbiAgZGVidWdMb2dnZXIsXG59XG4iLCIvLyBFZGdlIDE1LnggZG9lcyBub3QgZmlyZSAncHJvZ3Jlc3MnIGV2ZW50cyBvbiB1cGxvYWRzLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlcy85NDVcbi8vIEFuZCBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjIyNDUxMC9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyAodXNlckFnZW50KSB7XG4gIC8vIEFsbG93IHBhc3NpbmcgaW4gdXNlckFnZW50IGZvciB0ZXN0c1xuICBpZiAodXNlckFnZW50ID09IG51bGwpIHtcbiAgICB1c2VyQWdlbnQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiBudWxsXG4gIH1cbiAgLy8gQXNzdW1lIGl0IHdvcmtzIGJlY2F1c2UgYmFzaWNhbGx5IGV2ZXJ5dGhpbmcgc3VwcG9ydHMgcHJvZ3Jlc3MgZXZlbnRzLlxuICBpZiAoIXVzZXJBZ2VudCkgcmV0dXJuIHRydWVcblxuICBjb25zdCBtID0gL0VkZ2VcXC8oXFxkK1xcLlxcZCspLy5leGVjKHVzZXJBZ2VudClcbiAgaWYgKCFtKSByZXR1cm4gdHJ1ZVxuXG4gIGNvbnN0IGVkZ2VWZXJzaW9uID0gbVsxXVxuICBsZXQgW21ham9yLCBtaW5vcl0gPSBlZGdlVmVyc2lvbi5zcGxpdCgnLicpXG4gIG1ham9yID0gcGFyc2VJbnQobWFqb3IsIDEwKVxuICBtaW5vciA9IHBhcnNlSW50KG1pbm9yLCAxMClcblxuICAvLyBXb3JrZWQgYmVmb3JlOlxuICAvLyBFZGdlIDQwLjE1MDYzLjAuMFxuICAvLyBNaWNyb3NvZnQgRWRnZUhUTUwgMTUuMTUwNjNcbiAgaWYgKG1ham9yIDwgMTUgfHwgKG1ham9yID09PSAxNSAmJiBtaW5vciA8IDE1MDYzKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBGaXhlZCBpbjpcbiAgLy8gTWljcm9zb2Z0IEVkZ2VIVE1MIDE4LjE4MjE4XG4gIGlmIChtYWpvciA+IDE4IHx8IChtYWpvciA9PT0gMTggJiYgbWlub3IgPj0gMTgyMTgpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIG90aGVyIHZlcnNpb25zIGRvbid0IHdvcmsuXG4gIHJldHVybiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9kYXNoYm9hcmRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlVuaXZlcnNhbCBVSSBwbHVnaW4gZm9yIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMjAuMVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiZGFzaGJvYXJkXCIsXG4gICAgXCJ1aVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzXCI6IFwiMC4wLjdcIixcbiAgICBcIkB1cHB5L2luZm9ybWVyXCI6IFwiZmlsZTouLi9pbmZvcm1lclwiLFxuICAgIFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIjogXCJmaWxlOi4uL3Byb3ZpZGVyLXZpZXdzXCIsXG4gICAgXCJAdXBweS9zdGF0dXMtYmFyXCI6IFwiZmlsZTouLi9zdGF0dXMtYmFyXCIsXG4gICAgXCJAdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yXCI6IFwiZmlsZTouLi90aHVtYm5haWwtZ2VuZXJhdG9yXCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcImNsYXNzbmFtZXNcIjogXCJeMi4yLjZcIixcbiAgICBcImN1aWRcIjogXCJeMi4xLjFcIixcbiAgICBcImlzLXNoYWxsb3ctZXF1YWxcIjogXCJeMS4wLjFcIixcbiAgICBcImxvZGFzaC5kZWJvdW5jZVwiOiBcIl40LjAuOFwiLFxuICAgIFwibG9kYXNoLnRocm90dGxlXCI6IFwiXjQuMS4xXCIsXG4gICAgXCJtZW1vaXplLW9uZVwiOiBcIl41LjAuNFwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIixcbiAgICBcInJlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbFwiOiBcIl4xLjUuMFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNsYXNzIEFkZEZpbGVzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgdHJpZ2dlckZpbGVJbnB1dENsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMuZmlsZUlucHV0LmNsaWNrKClcbiAgfVxuXG4gIHRyaWdnZXJGb2xkZXJJbnB1dENsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMuZm9sZGVySW5wdXQuY2xpY2soKVxuICB9XG5cbiAgb25GaWxlSW5wdXRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICB0aGlzLnByb3BzLmhhbmRsZUlucHV0Q2hhbmdlKGV2ZW50KVxuXG4gICAgLy8gV2UgY2xlYXIgdGhlIGlucHV0IGFmdGVyIGEgZmlsZSBpcyBzZWxlY3RlZCwgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyBjaGFuZ2UgZXZlbnQgaXMgbm90IGZpcmVkIGluIENocm9tZSBhbmQgU2FmYXJpIHdoZW4gYSBmaWxlXG4gICAgLy8gd2l0aCB0aGUgc2FtZSBuYW1lIGlzIHNlbGVjdGVkLlxuICAgIC8vIF9fX1doeSBub3QgdXNlIHZhbHVlPVwiXCIgb24gPGlucHV0Lz4gaW5zdGVhZD9cbiAgICAvLyAgICBCZWNhdXNlIGlmIHdlIHVzZSB0aGF0IG1ldGhvZCBvZiBjbGVhcmluZyB0aGUgaW5wdXQsXG4gICAgLy8gICAgQ2hyb21lIHdpbGwgbm90IHRyaWdnZXIgY2hhbmdlIGlmIHdlIGRyb3AgdGhlIHNhbWUgZmlsZSB0d2ljZSAoSXNzdWUgIzc2OCkuXG4gICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gbnVsbFxuICB9XG5cbiAgcmVuZGVyUG93ZXJlZEJ5VXBweSAoKSB7XG4gICAgY29uc3QgdXBweUJyYW5kaW5nID0gKFxuICAgICAgPHNwYW4+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvbiB1cHB5LURhc2hib2FyZC1wb3dlcmVkQnlJY29uXCIgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjExXCIgdmlld0JveD1cIjAgMCAxMSAxMVwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNy4zNjUgMTAuNWwtLjAxLTQuMDQ1aDIuNjEyTDUuNS44MDZsLTQuNDY3IDUuNjVoMi42MDRsLjAxIDQuMDQ0aDMuNzE4elwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1wb3dlcmVkQnlVcHB5XCI+VXBweTwvc3Bhbj5cbiAgICAgIDwvc3Bhbj5cbiAgICApXG5cbiAgICAvLyBTdXBwb3J0IGJvdGggdGhlIG9sZCB3b3JkLW9yZGVyLWluc2Vuc2l0aXZlIHN0cmluZyBgcG93ZXJlZEJ5YCBhbmQgdGhlIG5ldyB3b3JkLW9yZGVyLXNlbnNpdGl2ZSBzdHJpbmcgYHBvd2VyZWRCeTJgXG4gICAgY29uc3QgbGlua1RleHQgPSB0aGlzLnByb3BzLmkxOG5BcnJheSgncG93ZXJlZEJ5MicsIHtcbiAgICAgIGJhY2t3YXJkc0NvbXBhdDogdGhpcy5wcm9wcy5pMThuKCdwb3dlcmVkQnknKSxcbiAgICAgIHVwcHk6IHVwcHlCcmFuZGluZyxcbiAgICB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxhXG4gICAgICAgIHRhYkluZGV4PVwiLTFcIlxuICAgICAgICBocmVmPVwiaHR0cHM6Ly91cHB5LmlvXCJcbiAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLXBvd2VyZWRCeVwiXG4gICAgICA+XG4gICAgICAgIHtsaW5rVGV4dH1cbiAgICAgIDwvYT5cbiAgICApXG4gIH1cblxuICByZW5kZXJIaWRkZW5JbnB1dCA9IChpc0ZvbGRlciwgcmVmQ2FsbGJhY2spID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLWlucHV0XCJcbiAgICAgICAgaGlkZGVuXG4gICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgICAgd2Via2l0ZGlyZWN0b3J5PXtpc0ZvbGRlcn1cbiAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICBuYW1lPVwiZmlsZXNbXVwiXG4gICAgICAgIG11bHRpcGxlPXt0aGlzLnByb3BzLm1heE51bWJlck9mRmlsZXMgIT09IDF9XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uRmlsZUlucHV0Q2hhbmdlfVxuICAgICAgICBhY2NlcHQ9e3RoaXMucHJvcHMuYWxsb3dlZEZpbGVUeXBlc31cbiAgICAgICAgcmVmPXtyZWZDYWxsYmFja31cbiAgICAgIC8+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyTXlEZXZpY2VBY3F1aXJlciA9ICgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZFRhYlwiXG4gICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICBkYXRhLXVwcHktYWNxdWlyZXItaWQ9XCJNeURldmljZVwiXG4gICAgICA+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LURhc2hib2FyZFRhYi1idG5cIlxuICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGlja31cbiAgICAgICAgPlxuICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIGZpbGw9XCIjMjI3NUQ3XCIgLz5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0yMS45NzMgMjEuMTUySDkuODYzbC0xLjEwOC01LjA4N2gxNC40NjRsLTEuMjQ2IDUuMDg3ek05LjkzNSAxMS4zN2gzLjk1OGwuODg2IDEuNDQ0YS42NzMuNjczIDAgMCAwIC41ODUuMzE2aDYuNTA2djEuMzdIOS45MzV2LTMuMTN6bTE0Ljg5OCAzLjQ0YS43OTMuNzkzIDAgMCAwLS42MTYtLjMxaC0uOTc4di0yLjEyNmMwLS4zNzktLjI3NS0uNjEzLS42NTMtLjYxM0gxNS43NWwtLjg4Ni0xLjQ0NWEuNjczLjY3MyAwIDAgMC0uNTg1LS4zMTZIOS4yMzJjLS4zNzggMC0uNjY3LjIwOS0uNjY3LjU4N1YxNC41aC0uNzgyYS43OTMuNzkzIDAgMCAwLS42MS4zMDMuNzk1Ljc5NSAwIDAgMC0uMTU1LjY2M2wxLjQ1IDYuNjMzYy4wNzguMzYuMzk2LjYxOC43NjQuNjE4aDEzLjM1NGMuMzYgMCAuNjc0LS4yNDYuNzYtLjU5NWwxLjYzMS02LjYzNmEuNzk1Ljc5NSAwIDAgMC0uMTQ0LS42NzV6XCIgZmlsbD1cIiNGRkZcIiAvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRUYWItbmFtZVwiPnt0aGlzLnByb3BzLmkxOG4oJ215RGV2aWNlJyl9PC9kaXY+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyQnJvd3NlQnV0dG9uID0gKHRleHQsIG9uQ2xpY2tGbikgPT4ge1xuICAgIGNvbnN0IG51bWJlck9mQWNxdWlyZXJzID0gdGhpcy5wcm9wcy5hY3F1aXJlcnMubGVuZ3RoXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1icm93c2VcIlxuICAgICAgICBvbkNsaWNrPXtvbkNsaWNrRm59XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGU9e251bWJlck9mQWNxdWlyZXJzID09PSAwfVxuICAgICAgPlxuICAgICAgICB7dGV4dH1cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIC8vIFRPRE8oMi54KSByZW1vdmUgYWxsIHRoZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBnYXJiYWdlIGhlcmVcbiAgcmVuZGVyRHJvcFBhc3RlQnJvd3NlVGFnbGluZSA9ICgpID0+IHtcbiAgICBjb25zdCBudW1iZXJPZkFjcXVpcmVycyA9IHRoaXMucHJvcHMuYWNxdWlyZXJzLmxlbmd0aFxuICAgIC8vIGluIG9yZGVyIHRvIGtlZXAgdGhlIGkxOG4gQ2FtZWxDYXNlIGFuZCBvcHRpb25zIGxvd2VyIChhcyBhcmUgZGVmYXVsdHMpIHdlIHdpbGwgd2FudCB0byB0cmFuc2Zvcm0gYSBsb3dlclxuICAgIC8vIHRvIENhbWVsXG4gICAgY29uc3QgbG93ZXJGTVNlbGVjdGlvblR5cGUgPSB0aGlzLnByb3BzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZVxuICAgIGNvbnN0IGNhbWVsRk1TZWxlY3Rpb25UeXBlID0gbG93ZXJGTVNlbGVjdGlvblR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsb3dlckZNU2VsZWN0aW9uVHlwZS5zbGljZSgxKVxuXG4gICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBuZWVkIHRvIHN1cHBvcnQgYm90aCAnYnJvd3NlJyBhbmQgJ2Jyb3dzZUZpbGVzJy8nYnJvd3NlRm9sZGVycycgYXMgc3RyaW5ncyBoZXJlLlxuICAgIGxldCBicm93c2VUZXh0ID0gJ2Jyb3dzZSdcbiAgICBsZXQgYnJvd3NlRmlsZXNUZXh0ID0gJ2Jyb3dzZSdcbiAgICBsZXQgYnJvd3NlRm9sZGVyc1RleHQgPSAnYnJvd3NlJ1xuICAgIGlmIChsb3dlckZNU2VsZWN0aW9uVHlwZSA9PT0gJ2ZpbGVzJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYnJvd3NlVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlJylcbiAgICAgICAgYnJvd3NlRmlsZXNUZXh0ID0gdGhpcy5wcm9wcy5pMThuKCdicm93c2UnKVxuICAgICAgICBicm93c2VGb2xkZXJzVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlJylcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZ25vcmUsIGhvcGVmdWxseSB3ZSBjYW4gdXNlIHRoZSAnYnJvd3NlRmlsZXMnIC8gJ2Jyb3dzZUZvbGRlcnMnIHN0cmluZ3NcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGJyb3dzZUZpbGVzVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlRmlsZXMnKVxuICAgICAgYnJvd3NlRm9sZGVyc1RleHQgPSB0aGlzLnByb3BzLmkxOG4oJ2Jyb3dzZUZvbGRlcnMnKVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlLCB1c2UgdGhlICdicm93c2UnIHN0cmluZ1xuICAgIH1cblxuICAgIGNvbnN0IGJyb3dzZSA9IHRoaXMucmVuZGVyQnJvd3NlQnV0dG9uKGJyb3dzZVRleHQsIHRoaXMudHJpZ2dlckZpbGVJbnB1dENsaWNrKVxuICAgIGNvbnN0IGJyb3dzZUZpbGVzID0gdGhpcy5yZW5kZXJCcm93c2VCdXR0b24oYnJvd3NlRmlsZXNUZXh0LCB0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGljaylcbiAgICBjb25zdCBicm93c2VGb2xkZXJzID0gdGhpcy5yZW5kZXJCcm93c2VCdXR0b24oYnJvd3NlRm9sZGVyc1RleHQsIHRoaXMudHJpZ2dlckZvbGRlcklucHV0Q2xpY2spXG5cbiAgICAvLyBCZWZvcmUgdGhlIGBmaWxlTWFuYWdlclNlbGVjdGlvblR5cGVgIGZlYXR1cmUgZXhpc3RlZCwgd2UgaGFkIHR3byBwb3NzaWJsZVxuICAgIC8vIHN0cmluZ3MgaGVyZSwgYnV0IG5vdyB3ZSBoYXZlIHNpeC4gV2UgdXNlIHRoZSBuZXctc3R5bGUgc3RyaW5ncyBieSBkZWZhdWx0OlxuICAgIGxldCB0aXRsZVRleHRcbiAgICBpZiAobnVtYmVyT2ZBY3F1aXJlcnMgPiAwKSB7XG4gICAgICB0aXRsZVRleHQgPSB0aGlzLnByb3BzLmkxOG5BcnJheShgZHJvcFBhc3RlSW1wb3J0JHtjYW1lbEZNU2VsZWN0aW9uVHlwZX1gLCB7IGJyb3dzZUZpbGVzLCBicm93c2VGb2xkZXJzLCBicm93c2UgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoYGRyb3BQYXN0ZSR7Y2FtZWxGTVNlbGVjdGlvblR5cGV9YCwgeyBicm93c2VGaWxlcywgYnJvd3NlRm9sZGVycywgYnJvd3NlIH0pXG4gICAgfVxuXG4gICAgLy8gV2UgdXNlIHRoZSBvbGQtc3R5bGUgc3RyaW5ncyBpZiBhdmFpbGFibGU6IHRoaXMgaW1wbGllcyB0aGF0IHRoZSB1c2VyIGhhc1xuICAgIC8vIG1hbnVhbGx5IHNwZWNpZmllZCB0aGVtLCBzbyB0aGV5IHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGUgbmV3LXN0eWxlXG4gICAgLy8gZGVmYXVsdHMuXG4gICAgaWYgKGxvd2VyRk1TZWxlY3Rpb25UeXBlID09PSAnZmlsZXMnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobnVtYmVyT2ZBY3F1aXJlcnMgPiAwKSB7XG4gICAgICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZUltcG9ydCcsIHsgYnJvd3NlIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZScsIHsgYnJvd3NlIH0pXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZ25vcmUsIHRoZSBuZXctc3R5bGUgc3RyaW5ncyB3aWxsIGJlIHVzZWQuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZUxvY2FsRmlsZXMpIHtcbiAgICAgIHRpdGxlVGV4dCA9IHRoaXMucHJvcHMuaTE4bignaW1wb3J0RmlsZXMnKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzLXRpdGxlXCI+XG4gICAgICAgIHt0aXRsZVRleHR9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXJBY3F1aXJlciA9IChhY3F1aXJlcikgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkVGFiXCJcbiAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgIGRhdGEtdXBweS1hY3F1aXJlci1pZD17YWNxdWlyZXIuaWR9XG4gICAgICA+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LURhc2hib2FyZFRhYi1idG5cIlxuICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgIGFyaWEtY29udHJvbHM9e2B1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLSR7YWNxdWlyZXIuaWR9YH1cbiAgICAgICAgICBhcmlhLXNlbGVjdGVkPXt0aGlzLnByb3BzLmFjdGl2ZVBpY2tlclBhbmVsLmlkID09PSBhY3F1aXJlci5pZH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5zaG93UGFuZWwoYWNxdWlyZXIuaWQpfVxuICAgICAgICA+XG4gICAgICAgICAge2FjcXVpcmVyLmljb24oKX1cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkVGFiLW5hbWVcIj57YWNxdWlyZXIubmFtZX08L2Rpdj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXJBY3F1aXJlcnMgPSAoYWNxdWlyZXJzLCBkaXNhYmxlTG9jYWxGaWxlcykgPT4ge1xuICAgIC8vIEdyb3VwIGxhc3QgdHdvIGJ1dHRvbnMsIHNvIHdlIGRvbuKAmXQgZW5kIHVwIHdpdGhcbiAgICAvLyBqdXN0IG9uZSBidXR0b24gb24gYSBuZXcgbGluZVxuICAgIGNvbnN0IGFjcXVpcmVyc1dpdGhvdXRMYXN0VHdvID0gWy4uLmFjcXVpcmVyc11cbiAgICBjb25zdCBsYXN0VHdvQWNxdWlyZXJzID0gYWNxdWlyZXJzV2l0aG91dExhc3RUd28uc3BsaWNlKGFjcXVpcmVycy5sZW5ndGggLSAyLCBhY3F1aXJlcnMubGVuZ3RoKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtQWRkRmlsZXMtbGlzdFwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgIHshZGlzYWJsZUxvY2FsRmlsZXMgJiYgdGhpcy5yZW5kZXJNeURldmljZUFjcXVpcmVyKCl9XG4gICAgICAgIHthY3F1aXJlcnNXaXRob3V0TGFzdFR3by5tYXAoKGFjcXVpcmVyKSA9PiB0aGlzLnJlbmRlckFjcXVpcmVyKGFjcXVpcmVyKSl9XG4gICAgICAgIDxzcGFuIHJvbGU9XCJwcmVzZW50YXRpb25cIiBzdHlsZT1cIndoaXRlLXNwYWNlOiBub3dyYXA7XCI+XG4gICAgICAgICAge2xhc3RUd29BY3F1aXJlcnMubWFwKChhY3F1aXJlcikgPT4gdGhpcy5yZW5kZXJBY3F1aXJlcihhY3F1aXJlcikpfVxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlckhpZGRlbklucHV0KGZhbHNlLCAocmVmKSA9PiB7IHRoaXMuZmlsZUlucHV0ID0gcmVmIH0pfVxuICAgICAgICB7dGhpcy5yZW5kZXJIaWRkZW5JbnB1dCh0cnVlLCAocmVmKSA9PiB7IHRoaXMuZm9sZGVySW5wdXQgPSByZWYgfSl9XG4gICAgICAgIHt0aGlzLnJlbmRlckRyb3BQYXN0ZUJyb3dzZVRhZ2xpbmUoKX1cbiAgICAgICAge3RoaXMucHJvcHMuYWNxdWlyZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5yZW5kZXJBY3F1aXJlcnModGhpcy5wcm9wcy5hY3F1aXJlcnMsIHRoaXMucHJvcHMuZGlzYWJsZUxvY2FsRmlsZXMpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzLWluZm9cIj5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5ub3RlICYmIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtbm90ZVwiPnt0aGlzLnByb3BzLm5vdGV9PC9kaXY+fVxuICAgICAgICAgIHt0aGlzLnByb3BzLnByb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweSAmJiB0aGlzLnJlbmRlclBvd2VyZWRCeVVwcHkodGhpcy5wcm9wcyl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkRmlsZXNcbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IEFkZEZpbGVzID0gcmVxdWlyZSgnLi9BZGRGaWxlcycpXG5cbmNvbnN0IEFkZEZpbGVzUGFuZWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktRGFzaGJvYXJkLUFkZEZpbGVzUGFuZWwnLCBwcm9wcy5jbGFzc05hbWUpfVxuICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIkFkZEZpbGVzXCJcbiAgICAgIGFyaWEtaGlkZGVuPXtwcm9wcy5zaG93QWRkRmlsZXNQYW5lbH1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCIxXCI+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2FkZGluZ01vcmVGaWxlcycpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYWNrXCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbkNsaWNrPXsoZXYpID0+IHByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWwoZmFsc2UpfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2JhY2snKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IC8+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZGRGaWxlc1BhbmVsXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBGaWxlTGlzdCA9IHJlcXVpcmUoJy4vRmlsZUxpc3QnKVxuY29uc3QgQWRkRmlsZXMgPSByZXF1aXJlKCcuL0FkZEZpbGVzJylcbmNvbnN0IEFkZEZpbGVzUGFuZWwgPSByZXF1aXJlKCcuL0FkZEZpbGVzUGFuZWwnKVxuY29uc3QgUGlja2VyUGFuZWxDb250ZW50ID0gcmVxdWlyZSgnLi9QaWNrZXJQYW5lbENvbnRlbnQnKVxuY29uc3QgRWRpdG9yUGFuZWwgPSByZXF1aXJlKCcuL0VkaXRvclBhbmVsJylcbmNvbnN0IFBhbmVsVG9wQmFyID0gcmVxdWlyZSgnLi9QaWNrZXJQYW5lbFRvcEJhcicpXG5jb25zdCBGaWxlQ2FyZCA9IHJlcXVpcmUoJy4vRmlsZUNhcmQnKVxuY29uc3QgU2xpZGUgPSByZXF1aXJlKCcuL1NsaWRlJylcbmNvbnN0IGlzRHJhZ0Ryb3BTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNEcmFnRHJvcFN1cHBvcnRlZCcpXG5cbi8vIGh0dHA6Ly9kZXYuZWRlbnNwaWVrZXJtYW5uLmNvbS8yMDE2LzAyLzExL2ludHJvZHVjaW5nLWFjY2Vzc2libGUtbW9kYWwtZGlhbG9nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2hvc2gvbWljcm9tb2RhbFxuXG5jb25zdCBXSURUSF9YTCA9IDkwMFxuY29uc3QgV0lEVEhfTEcgPSA3MDBcbmNvbnN0IFdJRFRIX01EID0gNTc2XG5jb25zdCBIRUlHSFRfTUQgPSA0MDBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEYXNoYm9hcmQgKHByb3BzKSB7XG4gIGNvbnN0IG5vRmlsZXMgPSBwcm9wcy50b3RhbEZpbGVDb3VudCA9PT0gMFxuICBjb25zdCBpc1NpemVNRCA9IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTURcblxuICBjb25zdCB3cmFwcGVyQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgJ3VwcHktUm9vdCc6IHByb3BzLmlzVGFyZ2V0RE9NRWwsXG4gIH0pXG5cbiAgY29uc3QgZGFzaGJvYXJkQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgJ3VwcHktRGFzaGJvYXJkJzogdHJ1ZSxcbiAgICAndXBweS1EYXNoYm9hcmQtLWlzRGlzYWJsZWQnOiBwcm9wcy5kaXNhYmxlZCxcbiAgICAndXBweS1EYXNoYm9hcmQtLWFuaW1hdGVPcGVuQ2xvc2UnOiBwcm9wcy5hbmltYXRlT3BlbkNsb3NlLFxuICAgICd1cHB5LURhc2hib2FyZC0taXNDbG9zaW5nJzogcHJvcHMuaXNDbG9zaW5nLFxuICAgICd1cHB5LURhc2hib2FyZC0taXNEcmFnZ2luZ092ZXInOiBwcm9wcy5pc0RyYWdnaW5nT3ZlcixcbiAgICAndXBweS1EYXNoYm9hcmQtLW1vZGFsJzogIXByb3BzLmlubGluZSxcbiAgICAndXBweS1zaXplLS1tZCc6IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTUQsXG4gICAgJ3VwcHktc2l6ZS0tbGcnOiBwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX0xHLFxuICAgICd1cHB5LXNpemUtLXhsJzogcHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9YTCxcbiAgICAndXBweS1zaXplLS1oZWlnaHQtbWQnOiBwcm9wcy5jb250YWluZXJIZWlnaHQgPiBIRUlHSFRfTUQsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0FkZEZpbGVzUGFuZWxWaXNpYmxlJzogcHJvcHMuc2hvd0FkZEZpbGVzUGFuZWwsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0lubmVyV3JhcFZpc2libGUnOiBwcm9wcy5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZSxcbiAgfSlcblxuICAvLyBJbXBvcnRhbnQ6IGtlZXAgdGhlc2UgaW4gc3luYyB3aXRoIHRoZSBwZXJjZW50IHdpZHRoIHZhbHVlcyBpbiBgc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vaW5kZXguc2Nzc2AuXG4gIGxldCBpdGVtc1BlclJvdyA9IDEgLy8gbW9iaWxlXG4gIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX1hMKSB7XG4gICAgaXRlbXNQZXJSb3cgPSA1XG4gIH0gZWxzZSBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9MRykge1xuICAgIGl0ZW1zUGVyUm93ID0gNFxuICB9IGVsc2UgaWYgKHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTUQpIHtcbiAgICBpdGVtc1BlclJvdyA9IDNcbiAgfVxuXG4gIGNvbnN0IHNob3dGaWxlTGlzdCA9IHByb3BzLnNob3dTZWxlY3RlZEZpbGVzICYmICFub0ZpbGVzXG5cbiAgY29uc3QgbnVtYmVyT2ZGaWxlc0ZvclJlY292ZXJ5ID0gcHJvcHMucmVjb3ZlcmVkU3RhdGUgPyBPYmplY3Qua2V5cyhwcm9wcy5yZWNvdmVyZWRTdGF0ZS5maWxlcykubGVuZ3RoIDogbnVsbFxuICBjb25zdCBudW1iZXJPZkdob3N0cyA9IHByb3BzLmZpbGVzID8gT2JqZWN0LmtleXMocHJvcHMuZmlsZXMpLmZpbHRlcigoZmlsZUlEKSA9PiBwcm9wcy5maWxlc1tmaWxlSURdLmlzR2hvc3QpLmxlbmd0aCA6IG51bGxcblxuICBjb25zdCByZW5kZXJSZXN0b3JlZFRleHQgPSAoKSA9PiB7XG4gICAgaWYgKG51bWJlck9mR2hvc3RzID4gMCkge1xuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3JlY292ZXJlZFhGaWxlcycsIHtcbiAgICAgICAgc21hcnRfY291bnQ6IG51bWJlck9mR2hvc3RzLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMuaTE4bigncmVjb3ZlcmVkQWxsRmlsZXMnKVxuICB9XG5cbiAgY29uc3QgZGFzaGJvYXJkID0gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17ZGFzaGJvYXJkQ2xhc3NOYW1lfVxuICAgICAgZGF0YS11cHB5LXRoZW1lPXtwcm9wcy50aGVtZX1cbiAgICAgIGRhdGEtdXBweS1udW0tYWNxdWlyZXJzPXtwcm9wcy5hY3F1aXJlcnMubGVuZ3RofVxuICAgICAgZGF0YS11cHB5LWRyYWctZHJvcC1zdXBwb3J0ZWQ9eyFwcm9wcy5kaXNhYmxlTG9jYWxGaWxlcyAmJiBpc0RyYWdEcm9wU3VwcG9ydGVkKCl9XG4gICAgICBhcmlhLWhpZGRlbj17cHJvcHMuaW5saW5lID8gJ2ZhbHNlJyA6IHByb3BzLmlzSGlkZGVufVxuICAgICAgYXJpYS1kaXNhYmxlZD17cHJvcHMuZGlzYWJsZWR9XG4gICAgICBhcmlhLWxhYmVsPXshcHJvcHMuaW5saW5lID8gcHJvcHMuaTE4bignZGFzaGJvYXJkV2luZG93VGl0bGUnKSA6IHByb3BzLmkxOG4oJ2Rhc2hib2FyZFRpdGxlJyl9XG4gICAgICBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX1cbiAgICAgIG9uRHJhZ092ZXI9e3Byb3BzLmhhbmRsZURyYWdPdmVyfVxuICAgICAgb25EcmFnTGVhdmU9e3Byb3BzLmhhbmRsZURyYWdMZWF2ZX1cbiAgICAgIG9uRHJvcD17cHJvcHMuaGFuZGxlRHJvcH1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLW92ZXJsYXlcIlxuICAgICAgICB0YWJJbmRleD17LTF9XG4gICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhhbmRsZUNsaWNrT3V0c2lkZX1cbiAgICAgIC8+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtaW5uZXJcIlxuICAgICAgICBhcmlhLW1vZGFsPXshcHJvcHMuaW5saW5lICYmICd0cnVlJ31cbiAgICAgICAgcm9sZT17IXByb3BzLmlubGluZSAmJiAnZGlhbG9nJ31cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogcHJvcHMuaW5saW5lICYmIHByb3BzLndpZHRoID8gcHJvcHMud2lkdGggOiAnJyxcbiAgICAgICAgICBoZWlnaHQ6IHByb3BzLmlubGluZSAmJiBwcm9wcy5oZWlnaHQgPyBwcm9wcy5oZWlnaHQgOiAnJyxcbiAgICAgICAgfX1cbiAgICAgID5cblxuICAgICAgICB7IXByb3BzLmlubGluZSA/IChcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtY2xvc2VcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdjbG9zZU1vZGFsJyl9XG4gICAgICAgICAgICB0aXRsZT17cHJvcHMuaTE4bignY2xvc2VNb2RhbCcpfVxuICAgICAgICAgICAgb25DbGljaz17cHJvcHMuY2xvc2VNb2RhbH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApIDogbnVsbH1cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLWlubmVyV3JhcFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtZHJvcEZpbGVzSGVyZUhpbnRcIj5cbiAgICAgICAgICAgIHtwcm9wcy5pMThuKCdkcm9wSGludCcpfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAge3Nob3dGaWxlTGlzdCAmJiA8UGFuZWxUb3BCYXIgey4uLnByb3BzfSAvPn1cblxuICAgICAgICAgIHtudW1iZXJPZkZpbGVzRm9yUmVjb3ZlcnkgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnXCI+XG4gICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtc2VydmljZU1zZy1pY29uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjIxXCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDE5XCI+XG4gICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAgLTEpXCIgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTIuODU3IDEuNDNsMTAuMjM0IDE3LjA1NkExIDEgMCAwMTIyLjIzNCAyMEgxLjc2NmExIDEgMCAwMS0uODU3LTEuNTE0TDExLjE0MyAxLjQyOWExIDEgMCAwMTEuNzE0IDB6XCIgZmlsbD1cIiNGRkQzMDBcIiAvPlxuICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIiMwMDBcIiBkPVwiTTExIDZoMmwtLjMgOGgtMS40elwiIC8+XG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjMDAwXCIgY3g9XCIxMlwiIGN5PVwiMTdcIiByPVwiMVwiIC8+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgPHN0cm9uZyBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAge3Byb3BzLmkxOG4oJ3Nlc3Npb25SZXN0b3JlZCcpfVxuICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkLXNlcnZpY2VNc2ctdGV4dFwiPlxuICAgICAgICAgICAgICAgIHtyZW5kZXJSZXN0b3JlZFRleHQoKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuXG4gICAgICAgICAge3Nob3dGaWxlTGlzdCA/IChcbiAgICAgICAgICAgIDxGaWxlTGlzdFxuICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgIGl0ZW1zUGVyUm93PXtpdGVtc1BlclJvd31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IGlzU2l6ZU1EPXtpc1NpemVNRH0gLz5cbiAgICAgICAgICApfVxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLnNob3dBZGRGaWxlc1BhbmVsID8gPEFkZEZpbGVzUGFuZWwga2V5PVwiQWRkRmlsZXNcIiB7Li4ucHJvcHN9IGlzU2l6ZU1EPXtpc1NpemVNRH0gLz4gOiBudWxsfVxuICAgICAgICAgIDwvU2xpZGU+XG5cbiAgICAgICAgICA8U2xpZGU+XG4gICAgICAgICAgICB7cHJvcHMuZmlsZUNhcmRGb3IgPyA8RmlsZUNhcmQga2V5PVwiRmlsZUNhcmRcIiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1NsaWRlPlxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLmFjdGl2ZVBpY2tlclBhbmVsID8gPFBpY2tlclBhbmVsQ29udGVudCBrZXk9XCJQaWNrZXJcIiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1NsaWRlPlxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLnNob3dGaWxlRWRpdG9yID8gPEVkaXRvclBhbmVsIGtleT1cIkVkaXRvclwiIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgICAgIDwvU2xpZGU+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLXByb2dyZXNzaW5kaWNhdG9yc1wiPlxuICAgICAgICAgICAge3Byb3BzLnByb2dyZXNzaW5kaWNhdG9ycy5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZ2V0UGx1Z2luKHRhcmdldC5pZCkucmVuZGVyKHByb3BzLnN0YXRlKVxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcblxuICByZXR1cm4gKFxuICAgIC8vIFdyYXAgaXQgZm9yIFJUTCBsYW5ndWFnZSBzdXBwb3J0XG4gICAgPGRpdiBjbGFzc05hbWU9e3dyYXBwZXJDbGFzc05hbWV9IGRpcj17cHJvcHMuZGlyZWN0aW9ufT5cbiAgICAgIHtkYXNoYm9hcmR9XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcblxuZnVuY3Rpb24gRWRpdG9yUGFuZWwgKHByb3BzKSB7XG4gIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktRGFzaGJvYXJkQ29udGVudC1wYW5lbCcsIHByb3BzLmNsYXNzTmFtZSl9XG4gICAgICByb2xlPVwidGFicGFuZWxcIlxuICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIkZpbGVFZGl0b3JcIlxuICAgICAgaWQ9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLWVkaXRvclwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlXCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxldmVsPVwiMVwiPlxuICAgICAgICAgIHtwcm9wcy5pMThuQXJyYXkoJ2VkaXRpbmcnLCB7XG4gICAgICAgICAgICBmaWxlOiA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVGaWxlXCI+e2ZpbGUubWV0YSA/IGZpbGUubWV0YS5uYW1lIDogZmlsZS5uYW1lfTwvc3Bhbj4sXG4gICAgICAgICAgfSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhpZGVBbGxQYW5lbHN9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuaTE4bignZG9uZScpfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWxCb2R5XCI+XG4gICAgICAgIHtwcm9wcy5lZGl0b3JzLm1hcCgodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmdldFBsdWdpbih0YXJnZXQuaWQpLnJlbmRlcihwcm9wcy5zdGF0ZSlcbiAgICAgICAgfSl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVkaXRvclBhbmVsXG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IGdldEZpbGVUeXBlSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2dldEZpbGVUeXBlSWNvbicpXG5jb25zdCBpZ25vcmVFdmVudCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lnbm9yZUV2ZW50LmpzJylcbmNvbnN0IEZpbGVQcmV2aWV3ID0gcmVxdWlyZSgnLi4vRmlsZVByZXZpZXcnKVxuXG5jbGFzcyBGaWxlQ2FyZCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZXNbdGhpcy5wcm9wcy5maWxlQ2FyZEZvcl1cbiAgICBjb25zdCBtZXRhRmllbGRzID0gdGhpcy5nZXRNZXRhRmllbGRzKCkgfHwgW11cblxuICAgIGNvbnN0IHN0b3JlZE1ldGFEYXRhID0ge31cbiAgICBtZXRhRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICBzdG9yZWRNZXRhRGF0YVtmaWVsZC5pZF0gPSBmaWxlLm1ldGFbZmllbGQuaWRdIHx8ICcnXG4gICAgfSlcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBmb3JtU3RhdGU6IHN0b3JlZE1ldGFEYXRhLFxuICAgIH1cbiAgfVxuXG4gIHNhdmVPbkVudGVyID0gKGV2KSA9PiB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZXNbdGhpcy5wcm9wcy5maWxlQ2FyZEZvcl1cbiAgICAgIHRoaXMucHJvcHMuc2F2ZUZpbGVDYXJkKHRoaXMuc3RhdGUuZm9ybVN0YXRlLCBmaWxlLmlkKVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZU1ldGEgPSAobmV3VmFsLCBuYW1lKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmb3JtU3RhdGU6IHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZS5mb3JtU3RhdGUsXG4gICAgICAgIFtuYW1lXTogbmV3VmFsLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlU2F2ZSA9ICgpID0+IHtcbiAgICBjb25zdCBmaWxlSUQgPSB0aGlzLnByb3BzLmZpbGVDYXJkRm9yXG4gICAgdGhpcy5wcm9wcy5zYXZlRmlsZUNhcmQodGhpcy5zdGF0ZS5mb3JtU3RhdGUsIGZpbGVJRClcbiAgfVxuXG4gIGhhbmRsZUNhbmNlbCA9ICgpID0+IHtcbiAgICB0aGlzLnByb3BzLnRvZ2dsZUZpbGVDYXJkKGZhbHNlKVxuICB9XG5cbiAgcmVuZGVyTWV0YUZpZWxkcyA9ICgpID0+IHtcbiAgICBjb25zdCBtZXRhRmllbGRzID0gdGhpcy5nZXRNZXRhRmllbGRzKCkgfHwgW11cbiAgICBjb25zdCBmaWVsZENTU0NsYXNzZXMgPSB7XG4gICAgICB0ZXh0OiAndXBweS11LXJlc2V0IHVwcHktYy10ZXh0SW5wdXQgdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtaW5wdXQnLFxuICAgIH1cblxuICAgIHJldHVybiBtZXRhRmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gYHVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWlucHV0LSR7ZmllbGQuaWR9YFxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGZpZWxkc2V0IGtleT17ZmllbGQuaWR9IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWZpZWxkc2V0XCI+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWxhYmVsXCIgaHRtbEZvcj17aWR9PntmaWVsZC5uYW1lfTwvbGFiZWw+XG4gICAgICAgICAge2ZpZWxkLnJlbmRlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGZpZWxkLnJlbmRlcih7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmZvcm1TdGF0ZVtmaWVsZC5pZF0sXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiAobmV3VmFsKSA9PiB0aGlzLnVwZGF0ZU1ldGEobmV3VmFsLCBmaWVsZC5pZCksXG4gICAgICAgICAgICAgIGZpZWxkQ1NTQ2xhc3NlcyxcbiAgICAgICAgICAgIH0sIGgpXG4gICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtmaWVsZENTU0NsYXNzZXMudGV4dH1cbiAgICAgICAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgICAgICAgdHlwZT17ZmllbGQudHlwZSB8fCAndGV4dCd9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuZm9ybVN0YXRlW2ZpZWxkLmlkXX1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17ZmllbGQucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgb25LZXlVcD17dGhpcy5zYXZlT25FbnRlcn1cbiAgICAgICAgICAgICAgICBvbktleURvd249e3RoaXMuc2F2ZU9uRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25LZXlQcmVzcz17dGhpcy5zYXZlT25FbnRlcn1cbiAgICAgICAgICAgICAgICBvbklucHV0PXtldiA9PiB0aGlzLnVwZGF0ZU1ldGEoZXYudGFyZ2V0LnZhbHVlLCBmaWVsZC5pZCl9XG4gICAgICAgICAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgPC9maWVsZHNldD5cbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgZ2V0TWV0YUZpZWxkcyAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnByb3BzLm1ldGFGaWVsZHMgPT09ICdmdW5jdGlvbidcbiAgICAgID8gdGhpcy5wcm9wcy5tZXRhRmllbGRzKHRoaXMucHJvcHMuZmlsZXNbdGhpcy5wcm9wcy5maWxlQ2FyZEZvcl0pXG4gICAgICA6IHRoaXMucHJvcHMubWV0YUZpZWxkc1xuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5wcm9wcy5maWxlc1t0aGlzLnByb3BzLmZpbGVDYXJkRm9yXVxuICAgIGNvbnN0IHNob3dFZGl0QnV0dG9uID0gdGhpcy5wcm9wcy5jYW5FZGl0RmlsZShmaWxlKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCd1cHB5LURhc2hib2FyZC1GaWxlQ2FyZCcsIHRoaXMucHJvcHMuY2xhc3NOYW1lKX1cbiAgICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIkZpbGVDYXJkXCJcbiAgICAgICAgb25EcmFnT3Zlcj17aWdub3JlRXZlbnR9XG4gICAgICAgIG9uRHJhZ0xlYXZlPXtpZ25vcmVFdmVudH1cbiAgICAgICAgb25Ecm9wPXtpZ25vcmVFdmVudH1cbiAgICAgICAgb25QYXN0ZT17aWdub3JlRXZlbnR9XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlXCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxldmVsPVwiMVwiPlxuICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bkFycmF5KCdlZGl0aW5nJywge1xuICAgICAgICAgICAgICBmaWxlOiA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVGaWxlXCI+e2ZpbGUubWV0YSA/IGZpbGUubWV0YS5uYW1lIDogZmlsZS5uYW1lfTwvc3Bhbj4sXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIHRpdGxlPXt0aGlzLnByb3BzLmkxOG4oJ2ZpbmlzaEVkaXRpbmdGaWxlJyl9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZVNhdmV9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bignZG9uZScpfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWlubmVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1wcmV2aWV3XCIgc3R5bGU9e3sgYmFja2dyb3VuZENvbG9yOiBnZXRGaWxlVHlwZUljb24oZmlsZS50eXBlKS5jb2xvciB9fT5cbiAgICAgICAgICAgIDxGaWxlUHJldmlldyBmaWxlPXtmaWxlfSAvPlxuICAgICAgICAgICAge3Nob3dFZGl0QnV0dG9uXG4gICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWVkaXRcIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMucHJvcHMub3BlbkZpbGVFZGl0b3IoZmlsZSl9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuKCdlZGl0RmlsZScpfVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtaW5mb1wiPlxuICAgICAgICAgICAge3RoaXMucmVuZGVyTWV0YUZpZWxkcygpfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1hY3Rpb25zXCI+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeSB1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1hY3Rpb25zQnRuXCJcbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlU2F2ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bignc2F2ZUNoYW5nZXMnKX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLWxpbmsgdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtYWN0aW9uc0J0blwiXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNhbmNlbH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGaWxlQ2FyZFxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY29weVRvQ2xpcGJvYXJkID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvY29weVRvQ2xpcGJvYXJkJylcblxuZnVuY3Rpb24gRWRpdEJ1dHRvbiAoe1xuICBmaWxlLFxuICB1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSxcbiAgbWV0YUZpZWxkcyxcbiAgY2FuRWRpdEZpbGUsXG4gIGkxOG4sXG4gIG9uQ2xpY2ssXG59KSB7XG4gIGlmIChcbiAgICAoIXVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlICYmIG1ldGFGaWVsZHMgJiYgbWV0YUZpZWxkcy5sZW5ndGggPiAwKVxuICAgIHx8ICghdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGUgJiYgY2FuRWRpdEZpbGUoZmlsZSkpXG4gICkge1xuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1JdGVtLWFjdGlvbiB1cHB5LURhc2hib2FyZC1JdGVtLWFjdGlvbi0tZWRpdFwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBhcmlhLWxhYmVsPXtgJHtpMThuKCdlZGl0RmlsZScpfSAke2ZpbGUubWV0YS5uYW1lfWB9XG4gICAgICAgIHRpdGxlPXtpMThuKCdlZGl0RmlsZScpfVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkNsaWNrKCl9XG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMTQgMTRcIj5cbiAgICAgICAgICA8ZyBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMS41IDEwLjc5M2gyLjc5M0ExIDEgMCAwIDAgNSAxMC41TDExLjUgNGExIDEgMCAwIDAgMC0xLjQxNEw5LjcwNy43OTNhMSAxIDAgMCAwLTEuNDE0IDBsLTYuNSA2LjVBMSAxIDAgMCAwIDEuNSA4djIuNzkzem0xLTFWOEw5IDEuNWwxLjc5MyAxLjc5My02LjUgNi41SDIuNXpcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgICAgICAgICAgPHJlY3QgeD1cIjFcIiB5PVwiMTIuMjkzXCIgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjFcIiByeD1cIi41XCIgLz5cbiAgICAgICAgICAgIDxwYXRoIGZpbGxSdWxlPVwibm9uemVyb1wiIGQ9XCJNNi43OTMgMi41TDkuNSA1LjIwN2wuNzA3LS43MDdMNy41IDEuNzkzelwiIC8+XG4gICAgICAgICAgPC9nPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBSZW1vdmVCdXR0b24gKHsgaTE4biwgb25DbGljayB9KSB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uIHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uLS1yZW1vdmVcIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBhcmlhLWxhYmVsPXtpMThuKCdyZW1vdmVGaWxlJyl9XG4gICAgICB0aXRsZT17aTE4bigncmVtb3ZlRmlsZScpfVxuICAgICAgb25DbGljaz17KCkgPT4gb25DbGljaygpfVxuICAgID5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIxOFwiIHZpZXdCb3g9XCIwIDAgMTggMThcIj5cbiAgICAgICAgPHBhdGggZD1cIk05IDBDNC4wMzQgMCAwIDQuMDM0IDAgOXM0LjAzNCA5IDkgOSA5LTQuMDM0IDktOS00LjAzNC05LTktOXpcIiAvPlxuICAgICAgICA8cGF0aCBmaWxsPVwiI0ZGRlwiIGQ9XCJNMTMgMTIuMjIybC0uNzc4Ljc3OEw5IDkuNzc4IDUuNzc4IDEzIDUgMTIuMjIyIDguMjIyIDkgNSA1Ljc3OCA1Ljc3OCA1IDkgOC4yMjIgMTIuMjIyIDVsLjc3OC43NzhMOS43NzggOXpcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuY29uc3QgY29weUxpbmtUb0NsaXBib2FyZCA9IChldmVudCwgcHJvcHMpID0+IHtcbiAgY29weVRvQ2xpcGJvYXJkKHByb3BzLmZpbGUudXBsb2FkVVJMLCBwcm9wcy5pMThuKCdjb3B5TGlua1RvQ2xpcGJvYXJkRmFsbGJhY2snKSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBwcm9wcy5sb2coJ0xpbmsgY29waWVkIHRvIGNsaXBib2FyZC4nKVxuICAgICAgcHJvcHMuaW5mbyhwcm9wcy5pMThuKCdjb3B5TGlua1RvQ2xpcGJvYXJkU3VjY2VzcycpLCAnaW5mbycsIDMwMDApXG4gICAgfSlcbiAgICAuY2F0Y2gocHJvcHMubG9nKVxuICAgIC8vIGF2b2lkIGxvc2luZyBmb2N1c1xuICAgIC50aGVuKCgpID0+IGV2ZW50LnRhcmdldC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSkpXG59XG5cbmZ1bmN0aW9uIENvcHlMaW5rQnV0dG9uIChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1JdGVtLWFjdGlvbiB1cHB5LURhc2hib2FyZC1JdGVtLWFjdGlvbi0tY29weUxpbmtcIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdjb3B5TGluaycpfVxuICAgICAgdGl0bGU9e3Byb3BzLmkxOG4oJ2NvcHlMaW5rJyl9XG4gICAgICBvbkNsaWNrPXsoZXZlbnQpID0+IGNvcHlMaW5rVG9DbGlwYm9hcmQoZXZlbnQsIHByb3BzKX1cbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB2aWV3Qm94PVwiMCAwIDE0IDEyXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNy45NCA3LjcwM2EyLjYxMyAyLjYxMyAwIDAgMS0uNjI2IDIuNjgxbC0uODUyLjg1MWEyLjU5NyAyLjU5NyAwIDAgMS0xLjg0OS43NjZBMi42MTYgMi42MTYgMCAwIDEgMi43NjQgNy41NGwuODUyLS44NTJhMi41OTYgMi41OTYgMCAwIDEgMi42OS0uNjI1TDUuMjY3IDcuMDk5YTEuNDQgMS40NCAwIDAgMC0uODMzLjQwN2wtLjg1Mi44NTFhMS40NTggMS40NTggMCAwIDAgMS4wMyAyLjQ4NmMuMzkgMCAuNzU1LS4xNTIgMS4wMy0uNDI2bC44NTItLjg1MmMuMjMxLS4yMzEuMzYzLS41MjIuNDA2LS44MjRsMS4wNC0xLjAzOHptNC4yOTUtNS45MzdBMi41OTYgMi41OTYgMCAwIDAgMTAuMzg3IDFjLS42OTggMC0xLjM1NS4yNzItMS44NDkuNzY2bC0uODUyLjg1MWEyLjYxNCAyLjYxNCAwIDAgMC0uNjI0IDIuNjg4bDEuMDM2LTEuMDM2Yy4wNDEtLjMwNC4xNzMtLjYuNDA3LS44MzNsLjg1Mi0uODUyYy4yNzUtLjI3NS42NC0uNDI2IDEuMDMtLjQyNmExLjQ1OCAxLjQ1OCAwIDAgMSAxLjAzIDIuNDg2bC0uODUyLjg1MWExLjQ0MiAxLjQ0MiAwIDAgMS0uODI0LjQwNmwtMS4wNCAxLjA0YTIuNTk2IDIuNTk2IDAgMCAwIDIuNjgzLS42MjhsLjg1MS0uODVhMi42MTYgMi42MTYgMCAwIDAgMC0zLjY5N3ptLTYuODggNi44ODNhLjU3Ny41NzcgMCAwIDAgLjgyIDBsMy40NzQtMy40NzRhLjU3OS41NzkgMCAxIDAtLjgxOS0uODJMNS4zNTUgNy44M2EuNTc5LjU3OSAwIDAgMCAwIC44MTl6XCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQnV0dG9ucyAocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGZpbGUsXG4gICAgdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGUsXG4gICAgY2FuRWRpdEZpbGUsXG4gICAgbWV0YUZpZWxkcyxcbiAgICBzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdCxcbiAgICBzaG93UmVtb3ZlQnV0dG9uLFxuICAgIGkxOG4sXG4gICAgcmVtb3ZlRmlsZSxcbiAgICB0b2dnbGVGaWxlQ2FyZCxcbiAgICBvcGVuRmlsZUVkaXRvcixcbiAgICBsb2csXG4gICAgaW5mbyxcbiAgfSA9IHByb3BzXG5cbiAgY29uc3QgZWRpdEFjdGlvbiA9ICgpID0+IHtcbiAgICBpZiAobWV0YUZpZWxkcyAmJiBtZXRhRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRvZ2dsZUZpbGVDYXJkKHRydWUsIGZpbGUuaWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZW5GaWxlRWRpdG9yKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uV3JhcHBlclwiPlxuICAgICAgPEVkaXRCdXR0b25cbiAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGU9e3VwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlfVxuICAgICAgICBjYW5FZGl0RmlsZT17Y2FuRWRpdEZpbGV9XG4gICAgICAgIG1ldGFGaWVsZHM9e21ldGFGaWVsZHN9XG4gICAgICAgIG9uQ2xpY2s9e2VkaXRBY3Rpb259XG4gICAgICAvPlxuICAgICAge3Nob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0ICYmIGZpbGUudXBsb2FkVVJMID8gKFxuICAgICAgICA8Q29weUxpbmtCdXR0b25cbiAgICAgICAgICBmaWxlPXtmaWxlfVxuICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgaW5mbz17aW5mb31cbiAgICAgICAgICBsb2c9e2xvZ31cbiAgICAgICAgLz5cbiAgICAgICkgOiBudWxsfVxuICAgICAge3Nob3dSZW1vdmVCdXR0b24gPyAoXG4gICAgICAgIDxSZW1vdmVCdXR0b25cbiAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgIGluZm89e3Byb3BzLmluZm99XG4gICAgICAgICAgbG9nPXtwcm9wcy5sb2d9XG4gICAgICAgICAgb25DbGljaz17KCkgPT4gcmVtb3ZlRmlsZShmaWxlLmlkLCAncmVtb3ZlZC1ieS11c2VyJyl9XG4gICAgICAgIC8+XG4gICAgICApIDogbnVsbH1cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgcHJldHRpZXJCeXRlcyA9IHJlcXVpcmUoJ0B0cmFuc2xvYWRpdC9wcmV0dGllci1ieXRlcycpXG5jb25zdCB0cnVuY2F0ZVN0cmluZyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90cnVuY2F0ZVN0cmluZycpXG5cbmNvbnN0IHJlbmRlckFjcXVpcmVySWNvbiA9IChhY3F1aXJlciwgcHJvcHMpID0+IChcbiAgPHNwYW4gdGl0bGU9e3Byb3BzLmkxOG4oJ2ZpbGVTb3VyY2UnLCB7IG5hbWU6IGFjcXVpcmVyLm5hbWUgfSl9PlxuICAgIHthY3F1aXJlci5pY29uKCl9XG4gIDwvc3Bhbj5cbilcblxuY29uc3QgcmVuZGVyRmlsZU5hbWUgPSAocHJvcHMpID0+IHtcbiAgLy8gVGFrZSB1cCBhdCBtb3N0IDIgbGluZXMgb24gYW55IHNjcmVlblxuICBsZXQgbWF4TmFtZUxlbmd0aFxuICAvLyBGb3IgdmVyeSBzbWFsbCBtb2JpbGUgc2NyZWVuc1xuICBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPD0gMzUyKSB7XG4gICAgbWF4TmFtZUxlbmd0aCA9IDM1XG4gIC8vIEZvciByZWd1bGFyIG1vYmlsZSBzY3JlZW5zXG4gIH0gZWxzZSBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPD0gNTc2KSB7XG4gICAgbWF4TmFtZUxlbmd0aCA9IDYwXG4gIC8vIEZvciBkZXNrdG9wc1xuICB9IGVsc2Uge1xuICAgIG1heE5hbWVMZW5ndGggPSAzMFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tbmFtZVwiIHRpdGxlPXtwcm9wcy5maWxlLm1ldGEubmFtZX0+XG4gICAgICB7dHJ1bmNhdGVTdHJpbmcocHJvcHMuZmlsZS5tZXRhLm5hbWUsIG1heE5hbWVMZW5ndGgpfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IHJlbmRlckZpbGVTaXplID0gKHByb3BzKSA9PiAoXG4gIHByb3BzLmZpbGUuc2l6ZVxuICAgICYmIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tc3RhdHVzU2l6ZVwiPlxuICAgICAge3ByZXR0aWVyQnl0ZXMocHJvcHMuZmlsZS5zaXplKX1cbiAgICA8L2Rpdj5cbiAgICApXG4pXG5cbmNvbnN0IFJlU2VsZWN0QnV0dG9uID0gKHByb3BzKSA9PiAoXG4gIHByb3BzLmZpbGUuaXNHaG9zdFxuICAgICYmIChcbiAgICAgIDxzcGFuPlxuICAgICAgICB7JyBcXHUyMDIyICd9XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LURhc2hib2FyZC1JdGVtLXJlU2VsZWN0XCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbkNsaWNrPXtwcm9wcy50b2dnbGVBZGRGaWxlc1BhbmVsfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ3JlU2VsZWN0Jyl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9zcGFuPlxuICAgIClcbilcblxuY29uc3QgRXJyb3JCdXR0b24gPSAoeyBmaWxlLCBvbkNsaWNrIH0pID0+IHtcbiAgaWYgKGZpbGUuZXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPHNwYW5cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1lcnJvckRldGFpbHNcIlxuICAgICAgICBhcmlhLWxhYmVsPXtmaWxlLmVycm9yfVxuICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwiYm90dG9tXCJcbiAgICAgICAgZGF0YS1taWNyb3RpcC1zaXplPVwibWVkaXVtXCJcbiAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICAgICAgPlxuICAgICAgICA/XG4gICAgICA8L3NwYW4+XG4gICAgKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRmlsZUluZm8gKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLWZpbGVJbmZvXCIgZGF0YS11cHB5LWZpbGUtc291cmNlPXtwcm9wcy5maWxlLnNvdXJjZX0+XG4gICAgICB7cmVuZGVyRmlsZU5hbWUocHJvcHMpfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXN0YXR1c1wiPlxuICAgICAgICB7cmVuZGVyRmlsZVNpemUocHJvcHMpfVxuICAgICAgICB7UmVTZWxlY3RCdXR0b24ocHJvcHMpfVxuICAgICAgICA8RXJyb3JCdXR0b25cbiAgICAgICAgICBmaWxlPXtwcm9wcy5maWxlfVxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgIGFsZXJ0KHByb3BzLmZpbGUuZXJyb3IpXG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBGaWxlUHJldmlldyA9IHJlcXVpcmUoJy4uLy4uL0ZpbGVQcmV2aWV3JylcbmNvbnN0IGdldEZpbGVUeXBlSWNvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2dldEZpbGVUeXBlSWNvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRmlsZVByZXZpZXdBbmRMaW5rIChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJldmlld0lubmVyV3JhcFwiXG4gICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IGdldEZpbGVUeXBlSWNvbihwcm9wcy5maWxlLnR5cGUpLmNvbG9yIH19XG4gICAgPlxuICAgICAge1xuICAgICAgICBwcm9wcy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdFxuICAgICAgICAmJiBwcm9wcy5maWxlLnVwbG9hZFVSTFxuICAgICAgICAgICYmIChcbiAgICAgICAgICA8YVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3TGlua1wiXG4gICAgICAgICAgICBocmVmPXtwcm9wcy5maWxlLnVwbG9hZFVSTH1cbiAgICAgICAgICAgIHJlbD1cIm5vcmVmZXJyZXIgbm9vcGVuZXJcIlxuICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmZpbGUubWV0YS5uYW1lfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgKVxuICAgICAgfVxuICAgICAgPEZpbGVQcmV2aWV3IGZpbGU9e3Byb3BzLmZpbGV9IC8+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gb25QYXVzZVJlc3VtZUNhbmNlbFJldHJ5IChwcm9wcykge1xuICBpZiAocHJvcHMuaXNVcGxvYWRlZCkgcmV0dXJuXG5cbiAgaWYgKHByb3BzLmVycm9yICYmICFwcm9wcy5oaWRlUmV0cnlCdXR0b24pIHtcbiAgICBwcm9wcy5yZXRyeVVwbG9hZChwcm9wcy5maWxlLmlkKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb3BzLnJlc3VtYWJsZVVwbG9hZHMgJiYgIXByb3BzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbikge1xuICAgIHByb3BzLnBhdXNlVXBsb2FkKHByb3BzLmZpbGUuaWQpXG4gIH0gZWxzZSBpZiAocHJvcHMuaW5kaXZpZHVhbENhbmNlbGxhdGlvbiAmJiAhcHJvcHMuaGlkZUNhbmNlbEJ1dHRvbikge1xuICAgIHByb3BzLmNhbmNlbFVwbG9hZChwcm9wcy5maWxlLmlkKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2dyZXNzSW5kaWNhdG9yVGl0bGUgKHByb3BzKSB7XG4gIGlmIChwcm9wcy5pc1VwbG9hZGVkKSB7XG4gICAgcmV0dXJuIHByb3BzLmkxOG4oJ3VwbG9hZENvbXBsZXRlJylcbiAgfVxuXG4gIGlmIChwcm9wcy5lcnJvcikge1xuICAgIHJldHVybiBwcm9wcy5pMThuKCdyZXRyeVVwbG9hZCcpXG4gIH1cblxuICBpZiAocHJvcHMucmVzdW1hYmxlVXBsb2Fkcykge1xuICAgIGlmIChwcm9wcy5maWxlLmlzUGF1c2VkKSB7XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigncmVzdW1lVXBsb2FkJylcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzLmkxOG4oJ3BhdXNlVXBsb2FkJylcbiAgfSBpZiAocHJvcHMuaW5kaXZpZHVhbENhbmNlbGxhdGlvbikge1xuICAgIHJldHVybiBwcm9wcy5pMThuKCdjYW5jZWxVcGxvYWQnKVxuICB9XG5cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIFByb2dyZXNzSW5kaWNhdG9yQnV0dG9uIChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc1wiPlxuICAgICAgPGJ1dHRvblxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0luZGljYXRvclwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBhcmlhLWxhYmVsPXtwcm9ncmVzc0luZGljYXRvclRpdGxlKHByb3BzKX1cbiAgICAgICAgdGl0bGU9e3Byb2dyZXNzSW5kaWNhdG9yVGl0bGUocHJvcHMpfVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBvblBhdXNlUmVzdW1lQ2FuY2VsUmV0cnkocHJvcHMpfVxuICAgICAgPlxuICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5mdW5jdGlvbiBQcm9ncmVzc0NpcmNsZUNvbnRhaW5lciAoeyBjaGlsZHJlbiB9KSB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgIHdpZHRoPVwiNzBcIlxuICAgICAgaGVpZ2h0PVwiNzBcIlxuICAgICAgdmlld0JveD1cIjAgMCAzNiAzNlwiXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvbiB1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tY2lyY2xlXCJcbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gUHJvZ3Jlc3NDaXJjbGUgKHsgcHJvZ3Jlc3MgfSkge1xuICAvLyBjaXJjbGUgbGVuZ3RoIGVxdWFscyAyICogUEkgKiBSXG4gIGNvbnN0IGNpcmNsZUxlbmd0aCA9IDIgKiBNYXRoLlBJICogMTVcblxuICByZXR1cm4gKFxuICAgIDxnPlxuICAgICAgPGNpcmNsZVxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tYmdcIlxuICAgICAgICByPVwiMTVcIlxuICAgICAgICBjeD1cIjE4XCJcbiAgICAgICAgY3k9XCIxOFwiXG4gICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIlxuICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAvPlxuICAgICAgPGNpcmNsZVxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tcHJvZ3Jlc3NcIlxuICAgICAgICByPVwiMTVcIlxuICAgICAgICBjeD1cIjE4XCJcbiAgICAgICAgY3k9XCIxOFwiXG4gICAgICAgIHRyYW5zZm9ybT1cInJvdGF0ZSgtOTAsIDE4LCAxOClcIlxuICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIlxuICAgICAgICBzdHJva2UtZGFzaGFycmF5PXtjaXJjbGVMZW5ndGh9XG4gICAgICAgIHN0cm9rZS1kYXNob2Zmc2V0PXtjaXJjbGVMZW5ndGggLSAoKGNpcmNsZUxlbmd0aCAvIDEwMCkgKiBwcm9ncmVzcyl9XG4gICAgICAvPlxuICAgIDwvZz5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEZpbGVQcm9ncmVzcyAocHJvcHMpIHtcbiAgLy8gTm90aGluZyBpZiB1cGxvYWQgaGFzIG5vdCBzdGFydGVkXG4gIGlmICghcHJvcHMuZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEdyZWVuIGNoZWNrbWFyayB3aGVuIGNvbXBsZXRlXG4gIGlmIChwcm9wcy5pc1VwbG9hZGVkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJbmRpY2F0b3JcIj5cbiAgICAgICAgICA8UHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICAgICAgICA8Y2lyY2xlIHI9XCIxNVwiIGN4PVwiMThcIiBjeT1cIjE4XCIgZmlsbD1cIiMxYmIyNDBcIiAvPlxuICAgICAgICAgICAgPHBvbHlnb24gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0ljb24tLWNoZWNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsIDMpXCIgcG9pbnRzPVwiMTQgMjIuNSA3IDE1LjI0NTcwNjUgOC45OTk4NTg1NyAxMy4xNzMyODE1IDE0IDE4LjM1NDcxMDQgMjIuOTcyOTg4MyA5IDI1IDExLjEwMDU2MzRcIiAvPlxuICAgICAgICAgIDwvUHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgaWYgKHByb3BzLnJlY292ZXJlZFN0YXRlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBSZXRyeSBidXR0b24gZm9yIGVycm9yXG4gIGlmIChwcm9wcy5lcnJvciAmJiAhcHJvcHMuaGlkZVJldHJ5QnV0dG9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxQcm9ncmVzc0luZGljYXRvckJ1dHRvbiB7Li4ucHJvcHN9PlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb24gdXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0ljb24tLXJldHJ5XCIgd2lkdGg9XCIyOFwiIGhlaWdodD1cIjMxXCIgdmlld0JveD1cIjAgMCAxNiAxOVwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTYgMTFhOCA4IDAgMSAxLTgtOHYyYTYgNiAwIDEgMCA2IDZoMnpcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNy45IDNIMTB2Mkg3Ljl6XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTguNTM2LjVsMy41MzUgMy41MzYtMS40MTQgMS40MTRMNy4xMiAxLjkxNHpcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTAuNjU3IDIuNjIxbDEuNDE0IDEuNDE1TDguNTM2IDcuNTcgNy4xMiA2LjE1N3pcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvUHJvZ3Jlc3NJbmRpY2F0b3JCdXR0b24+XG4gICAgKVxuICB9XG5cbiAgLy8gUGF1c2UvcmVzdW1lIGJ1dHRvbiBmb3IgcmVzdW1hYmxlIHVwbG9hZHNcbiAgaWYgKHByb3BzLnJlc3VtYWJsZVVwbG9hZHMgJiYgIXByb3BzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbikge1xuICAgIHJldHVybiAoXG4gICAgICA8UHJvZ3Jlc3NJbmRpY2F0b3JCdXR0b24gey4uLnByb3BzfT5cbiAgICAgICAgPFByb2dyZXNzQ2lyY2xlQ29udGFpbmVyPlxuICAgICAgICAgIDxQcm9ncmVzc0NpcmNsZSBwcm9ncmVzcz17cHJvcHMuZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlfSAvPlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByb3BzLmZpbGUuaXNQYXVzZWRcbiAgICAgICAgICAgICAgPyA8cG9seWdvbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tcGxheVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgzLCAzKVwiIHBvaW50cz1cIjEyIDIwIDEyIDEwIDIwIDE1XCIgLz5cbiAgICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgICAgPGcgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0ljb24tLXBhdXNlXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDE0LjUsIDEzKVwiPlxuICAgICAgICAgICAgICAgICAgPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMlwiIGhlaWdodD1cIjEwXCIgcng9XCIwXCIgLz5cbiAgICAgICAgICAgICAgICAgIDxyZWN0IHg9XCI1XCIgeT1cIjBcIiB3aWR0aD1cIjJcIiBoZWlnaHQ9XCIxMFwiIHJ4PVwiMFwiIC8+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICA8L1Byb2dyZXNzQ2lyY2xlQ29udGFpbmVyPlxuICAgICAgPC9Qcm9ncmVzc0luZGljYXRvckJ1dHRvbj5cbiAgICApXG4gIH1cblxuICAvLyBDYW5jZWwgYnV0dG9uIGZvciBub24tcmVzdW1hYmxlIHVwbG9hZHMgaWYgaW5kaXZpZHVhbENhbmNlbGxhdGlvbiBpcyBzdXBwb3J0ZWQgKG5vdCBidW5kbGVkKVxuICBpZiAoIXByb3BzLnJlc3VtYWJsZVVwbG9hZHMgJiYgcHJvcHMuaW5kaXZpZHVhbENhbmNlbGxhdGlvbiAmJiAhcHJvcHMuaGlkZUNhbmNlbEJ1dHRvbikge1xuICAgIHJldHVybiAoXG4gICAgICA8UHJvZ3Jlc3NJbmRpY2F0b3JCdXR0b24gey4uLnByb3BzfT5cbiAgICAgICAgPFByb2dyZXNzQ2lyY2xlQ29udGFpbmVyPlxuICAgICAgICAgIDxQcm9ncmVzc0NpcmNsZSBwcm9ncmVzcz17cHJvcHMuZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlfSAvPlxuICAgICAgICAgIDxwb2x5Z29uIGNsYXNzTmFtZT1cImNhbmNlbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyLCAyKVwiIHBvaW50cz1cIjE5Ljg4NTY1MTYgMTEuMDYyNSAxNiAxNC45NDgxNTE2IDEyLjEwMTk3MzcgMTEuMDYyNSAxMS4wNjI1IDEyLjExNDM0ODQgMTQuOTQ4MTUxNiAxNiAxMS4wNjI1IDE5Ljg5ODAyNjMgMTIuMTAxOTczNyAyMC45Mzc1IDE2IDE3LjA1MTg0ODQgMTkuODg1NjUxNiAyMC45Mzc1IDIwLjkzNzUgMTkuODk4MDI2MyAxNy4wNTE4NDg0IDE2IDIwLjkzNzUgMTJcIiAvPlxuICAgICAgICA8L1Byb2dyZXNzQ2lyY2xlQ29udGFpbmVyPlxuICAgICAgPC9Qcm9ncmVzc0luZGljYXRvckJ1dHRvbj5cbiAgICApXG4gIH1cblxuICAvLyBKdXN0IHByb2dyZXNzIHdoZW4gYnV0dG9ucyBhcmUgZGlzYWJsZWRcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0luZGljYXRvclwiPlxuICAgICAgICA8UHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICAgICAgPFByb2dyZXNzQ2lyY2xlIHByb2dyZXNzPXtwcm9wcy5maWxlLnByb2dyZXNzLnBlcmNlbnRhZ2V9IC8+XG4gICAgICAgIDwvUHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdpcy1zaGFsbG93LWVxdWFsJylcbmNvbnN0IEZpbGVQcmV2aWV3QW5kTGluayA9IHJlcXVpcmUoJy4vRmlsZVByZXZpZXdBbmRMaW5rJylcbmNvbnN0IEZpbGVQcm9ncmVzcyA9IHJlcXVpcmUoJy4vRmlsZVByb2dyZXNzJylcbmNvbnN0IEZpbGVJbmZvID0gcmVxdWlyZSgnLi9GaWxlSW5mbycpXG5jb25zdCBCdXR0b25zID0gcmVxdWlyZSgnLi9CdXR0b25zJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGaWxlSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzKSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVcbiAgICBpZiAoIWZpbGUucHJldmlldykge1xuICAgICAgdGhpcy5wcm9wcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgLy8gVmlydHVhbExpc3QgbW91bnRzIEZpbGVJdGVtcyBhZ2FpbiBhbmQgdGhleSBlbWl0IGB0aHVtYm5haWw6cmVxdWVzdGBcbiAgLy8gT3RoZXJ3aXNlIHRodW1ibmFpbHMgYXJlIGJyb2tlbiBvciBtaXNzaW5nIGFmdGVyIEdvbGRlbiBSZXRyaWV2ZXIgcmVzdG9yZXMgZmlsZXNcbiAgY29tcG9uZW50RGlkVXBkYXRlICgpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5wcm9wcy5maWxlXG4gICAgaWYgKCFmaWxlLnByZXZpZXcpIHtcbiAgICAgIHRoaXMucHJvcHMuaGFuZGxlUmVxdWVzdFRodW1ibmFpbChmaWxlKVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5wcm9wcy5maWxlXG4gICAgaWYgKCFmaWxlLnByZXZpZXcpIHtcbiAgICAgIHRoaXMucHJvcHMuaGFuZGxlQ2FuY2VsVGh1bWJuYWlsKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5wcm9wcy5maWxlXG5cbiAgICBjb25zdCBpc1Byb2Nlc3NpbmcgPSBmaWxlLnByb2dyZXNzLnByZXByb2Nlc3MgfHwgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIGNvbnN0IGlzVXBsb2FkZWQgPSBmaWxlLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlICYmICFpc1Byb2Nlc3NpbmcgJiYgIWZpbGUuZXJyb3JcbiAgICBjb25zdCB1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSA9IGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCB8fCBpc1Byb2Nlc3NpbmdcbiAgICBjb25zdCB1cGxvYWRJblByb2dyZXNzID0gKGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCAmJiAhZmlsZS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZSkgfHwgaXNQcm9jZXNzaW5nXG4gICAgY29uc3QgZXJyb3IgPSBmaWxlLmVycm9yIHx8IGZhbHNlXG5cbiAgICAvLyBGaWxlIHRoYXQgR29sZGVuIFJldHJpZXZlciB3YXMgYWJsZSB0byBwYXJ0bHkgcmVzdG9yZSAob25seSBtZXRhLCBub3QgYmxvYiksXG4gICAgLy8gdXNlcnMgc3RpbGwgbmVlZCB0byByZS1hZGQgaXQsIHNvIGl04oCZcyBhIGdob3N0XG4gICAgY29uc3QgaXNHaG9zdCA9IGZpbGUuaXNHaG9zdFxuXG4gICAgbGV0IHNob3dSZW1vdmVCdXR0b24gPSB0aGlzLnByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb25cbiAgICAgID8gIWlzVXBsb2FkZWRcbiAgICAgIDogIXVwbG9hZEluUHJvZ3Jlc3MgJiYgIWlzVXBsb2FkZWRcblxuICAgIGlmIChpc1VwbG9hZGVkICYmIHRoaXMucHJvcHMuc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGUpIHtcbiAgICAgIHNob3dSZW1vdmVCdXR0b24gPSB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgZGFzaGJvYXJkSXRlbUNsYXNzID0gY2xhc3NOYW1lcyh7XG4gICAgICAndXBweS1EYXNoYm9hcmQtSXRlbSc6IHRydWUsXG4gICAgICAnaXMtaW5wcm9ncmVzcyc6IHVwbG9hZEluUHJvZ3Jlc3MgJiYgIXRoaXMucHJvcHMucmVjb3ZlcmVkU3RhdGUsXG4gICAgICAnaXMtcHJvY2Vzc2luZyc6IGlzUHJvY2Vzc2luZyxcbiAgICAgICdpcy1jb21wbGV0ZSc6IGlzVXBsb2FkZWQsXG4gICAgICAnaXMtZXJyb3InOiAhIWVycm9yLFxuICAgICAgJ2lzLXJlc3VtYWJsZSc6IHRoaXMucHJvcHMucmVzdW1hYmxlVXBsb2FkcyxcbiAgICAgICdpcy1ub0luZGl2aWR1YWxDYW5jZWxsYXRpb24nOiAhdGhpcy5wcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uLFxuICAgICAgJ2lzLWdob3N0JzogaXNHaG9zdCxcbiAgICB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtkYXNoYm9hcmRJdGVtQ2xhc3N9XG4gICAgICAgIGlkPXtgdXBweV8ke2ZpbGUuaWR9YH1cbiAgICAgICAgcm9sZT17dGhpcy5wcm9wcy5yb2xlfVxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJldmlld1wiPlxuICAgICAgICAgIDxGaWxlUHJldmlld0FuZExpbmtcbiAgICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgICBzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdD17dGhpcy5wcm9wcy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxGaWxlUHJvZ3Jlc3NcbiAgICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgICBlcnJvcj17ZXJyb3J9XG4gICAgICAgICAgICBpc1VwbG9hZGVkPXtpc1VwbG9hZGVkfVxuICAgICAgICAgICAgaGlkZVJldHJ5QnV0dG9uPXt0aGlzLnByb3BzLmhpZGVSZXRyeUJ1dHRvbn1cbiAgICAgICAgICAgIGhpZGVDYW5jZWxCdXR0b249e3RoaXMucHJvcHMuaGlkZUNhbmNlbEJ1dHRvbn1cbiAgICAgICAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbj17dGhpcy5wcm9wcy5oaWRlUGF1c2VSZXN1bWVCdXR0b259XG4gICAgICAgICAgICByZWNvdmVyZWRTdGF0ZT17dGhpcy5wcm9wcy5yZWNvdmVyZWRTdGF0ZX1cbiAgICAgICAgICAgIHNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlPXt0aGlzLnByb3BzLnNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlfVxuICAgICAgICAgICAgcmVzdW1hYmxlVXBsb2Fkcz17dGhpcy5wcm9wcy5yZXN1bWFibGVVcGxvYWRzfVxuICAgICAgICAgICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbj17dGhpcy5wcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9ufVxuICAgICAgICAgICAgcGF1c2VVcGxvYWQ9e3RoaXMucHJvcHMucGF1c2VVcGxvYWR9XG4gICAgICAgICAgICBjYW5jZWxVcGxvYWQ9e3RoaXMucHJvcHMuY2FuY2VsVXBsb2FkfVxuICAgICAgICAgICAgcmV0cnlVcGxvYWQ9e3RoaXMucHJvcHMucmV0cnlVcGxvYWR9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnByb3BzLmkxOG59XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLWZpbGVJbmZvQW5kQnV0dG9uc1wiPlxuICAgICAgICAgIDxGaWxlSW5mb1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIGlkPXt0aGlzLnByb3BzLmlkfVxuICAgICAgICAgICAgYWNxdWlyZXJzPXt0aGlzLnByb3BzLmFjcXVpcmVyc31cbiAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoPXt0aGlzLnByb3BzLmNvbnRhaW5lcldpZHRofVxuICAgICAgICAgICAgaTE4bj17dGhpcy5wcm9wcy5pMThufVxuICAgICAgICAgICAgdG9nZ2xlQWRkRmlsZXNQYW5lbD17dGhpcy5wcm9wcy50b2dnbGVBZGRGaWxlc1BhbmVsfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEJ1dHRvbnNcbiAgICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgICBtZXRhRmllbGRzPXt0aGlzLnByb3BzLm1ldGFGaWVsZHN9XG4gICAgICAgICAgICBzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdD17dGhpcy5wcm9wcy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdH1cbiAgICAgICAgICAgIHNob3dSZW1vdmVCdXR0b249e3Nob3dSZW1vdmVCdXR0b259XG4gICAgICAgICAgICBjYW5FZGl0RmlsZT17dGhpcy5wcm9wcy5jYW5FZGl0RmlsZX1cbiAgICAgICAgICAgIHVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlPXt1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZX1cbiAgICAgICAgICAgIHJlbW92ZUZpbGU9e3RoaXMucHJvcHMucmVtb3ZlRmlsZX1cbiAgICAgICAgICAgIHRvZ2dsZUZpbGVDYXJkPXt0aGlzLnByb3BzLnRvZ2dsZUZpbGVDYXJkfVxuICAgICAgICAgICAgb3BlbkZpbGVFZGl0b3I9e3RoaXMucHJvcHMub3BlbkZpbGVFZGl0b3J9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnByb3BzLmkxOG59XG4gICAgICAgICAgICBsb2c9e3RoaXMucHJvcHMubG9nfVxuICAgICAgICAgICAgaW5mbz17dGhpcy5wcm9wcy5pbmZvfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG4iLCJjb25zdCBGaWxlSXRlbSA9IHJlcXVpcmUoJy4vRmlsZUl0ZW0vaW5kZXguanMnKVxuY29uc3QgVmlydHVhbExpc3QgPSByZXF1aXJlKCcuL1ZpcnR1YWxMaXN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gY2h1bmtzIChsaXN0LCBzaXplKSB7XG4gIGNvbnN0IGNodW5rZWQgPSBbXVxuICBsZXQgY3VycmVudENodW5rID0gW11cbiAgbGlzdC5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRDaHVuay5sZW5ndGggPCBzaXplKSB7XG4gICAgICBjdXJyZW50Q2h1bmsucHVzaChpdGVtKVxuICAgIH0gZWxzZSB7XG4gICAgICBjaHVua2VkLnB1c2goY3VycmVudENodW5rKVxuICAgICAgY3VycmVudENodW5rID0gW2l0ZW1dXG4gICAgfVxuICB9KVxuICBpZiAoY3VycmVudENodW5rLmxlbmd0aCkgY2h1bmtlZC5wdXNoKGN1cnJlbnRDaHVuaylcbiAgcmV0dXJuIGNodW5rZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qgbm9GaWxlcyA9IHByb3BzLnRvdGFsRmlsZUNvdW50ID09PSAwXG4gIGNvbnN0IGRhc2hib2FyZEZpbGVzQ2xhc3MgPSBjbGFzc05hbWVzKFxuICAgICd1cHB5LURhc2hib2FyZC1maWxlcycsXG4gICAgeyAndXBweS1EYXNoYm9hcmQtZmlsZXMtLW5vRmlsZXMnOiBub0ZpbGVzIH1cbiAgKVxuXG4gIC8vIEl0J3Mgbm90IGdyZWF0IHRoYXQgdGhpcyBpcyBoYXJkY29kZWQhXG4gIC8vIEl0J3MgRVNQRUNJQUxMWSBub3QgZ3JlYXQgdGhhdCB0aGlzIGlzIGNoZWNraW5nIGFnYWluc3QgYGl0ZW1zUGVyUm93YCFcbiAgY29uc3Qgcm93SGVpZ2h0ID0gcHJvcHMuaXRlbXNQZXJSb3cgPT09IDFcbiAgICAvLyBNb2JpbGVcbiAgICA/IDcxXG4gICAgLy8gMTkwcHggaGVpZ2h0ICsgMiAqIDVweCBtYXJnaW5cbiAgICA6IDIwMFxuXG4gIGNvbnN0IGZpbGVQcm9wcyA9IHtcbiAgICAvLyBGSVhNRSBUaGlzIGlzIGNvbmZ1c2luZywgaXQncyBhY3R1YWxseSB0aGUgRGFzaGJvYXJkJ3MgcGx1Z2luIElEXG4gICAgaWQ6IHByb3BzLmlkLFxuICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBjb250ZXh0XG4gICAgaTE4bjogcHJvcHMuaTE4bixcbiAgICBsb2c6IHByb3BzLmxvZyxcbiAgICBpbmZvOiBwcm9wcy5pbmZvLFxuICAgIC8vIGZlYXR1cmVzXG4gICAgYWNxdWlyZXJzOiBwcm9wcy5hY3F1aXJlcnMsXG4gICAgcmVzdW1hYmxlVXBsb2FkczogcHJvcHMucmVzdW1hYmxlVXBsb2FkcyxcbiAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uOiBwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uLFxuICAgIC8vIHZpc3VhbCBvcHRpb25zXG4gICAgaGlkZVJldHJ5QnV0dG9uOiBwcm9wcy5oaWRlUmV0cnlCdXR0b24sXG4gICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiBwcm9wcy5oaWRlUGF1c2VSZXN1bWVCdXR0b24sXG4gICAgaGlkZUNhbmNlbEJ1dHRvbjogcHJvcHMuaGlkZUNhbmNlbEJ1dHRvbixcbiAgICBzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdDogcHJvcHMuc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQsXG4gICAgc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGU6IHByb3BzLnNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlLFxuICAgIGlzV2lkZTogcHJvcHMuaXNXaWRlLFxuICAgIG1ldGFGaWVsZHM6IHByb3BzLm1ldGFGaWVsZHMsXG4gICAgcmVjb3ZlcmVkU3RhdGU6IHByb3BzLnJlY292ZXJlZFN0YXRlLFxuICAgIC8vIGNhbGxiYWNrc1xuICAgIHJldHJ5VXBsb2FkOiBwcm9wcy5yZXRyeVVwbG9hZCxcbiAgICBwYXVzZVVwbG9hZDogcHJvcHMucGF1c2VVcGxvYWQsXG4gICAgY2FuY2VsVXBsb2FkOiBwcm9wcy5jYW5jZWxVcGxvYWQsXG4gICAgdG9nZ2xlRmlsZUNhcmQ6IHByb3BzLnRvZ2dsZUZpbGVDYXJkLFxuICAgIHJlbW92ZUZpbGU6IHByb3BzLnJlbW92ZUZpbGUsXG4gICAgaGFuZGxlUmVxdWVzdFRodW1ibmFpbDogcHJvcHMuaGFuZGxlUmVxdWVzdFRodW1ibmFpbCxcbiAgICBoYW5kbGVDYW5jZWxUaHVtYm5haWw6IHByb3BzLmhhbmRsZUNhbmNlbFRodW1ibmFpbCxcbiAgfVxuXG4gIGNvbnN0IHNvcnRCeUdob3N0Q29tZXNGaXJzdCA9IChmaWxlMSwgZmlsZTIpID0+IHtcbiAgICByZXR1cm4gcHJvcHMuZmlsZXNbZmlsZTJdLmlzR2hvc3QgLSBwcm9wcy5maWxlc1tmaWxlMV0uaXNHaG9zdFxuICB9XG5cbiAgLy8gU29ydCBmaWxlcyBieSBmaWxlLmlzR2hvc3QsIGdob3N0IGZpbGVzIGZpcnN0LCBvbmx5IGlmIHJlY292ZXJlZFN0YXRlIGlzIHByZXNlbnRcbiAgY29uc3QgZmlsZXMgPSBPYmplY3Qua2V5cyhwcm9wcy5maWxlcylcbiAgaWYgKHByb3BzLnJlY292ZXJlZFN0YXRlKSBmaWxlcy5zb3J0KHNvcnRCeUdob3N0Q29tZXNGaXJzdClcbiAgY29uc3Qgcm93cyA9IGNodW5rcyhmaWxlcywgcHJvcHMuaXRlbXNQZXJSb3cpXG5cbiAgZnVuY3Rpb24gcmVuZGVyUm93IChyb3cpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gVGhlIGByb2xlPVwicHJlc2VudGF0aW9uYCBhdHRyaWJ1dGUgZW5zdXJlcyB0aGF0IHRoZSBsaXN0IGl0ZW1zIGFyZSBwcm9wZXJseSBhc3NvY2lhdGVkIHdpdGggdGhlIGBWaXJ0dWFsTGlzdGAgZWxlbWVudFxuICAgICAgLy8gV2UgdXNlIHRoZSBmaXJzdCBmaWxlIElEIGFzIHRoZSBrZXnigJR0aGlzIHNob3VsZCBub3QgY2hhbmdlIGFjcm9zcyBzY3JvbGwgcmVyZW5kZXJzXG4gICAgICA8ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBrZXk9e3Jvd1swXX0+XG4gICAgICAgIHtyb3cubWFwKChmaWxlSUQpID0+IChcbiAgICAgICAgICA8RmlsZUl0ZW1cbiAgICAgICAgICAgIGtleT17ZmlsZUlEfVxuICAgICAgICAgICAgey4uLmZpbGVQcm9wc31cbiAgICAgICAgICAgIHJvbGU9XCJsaXN0aXRlbVwiXG4gICAgICAgICAgICBvcGVuRmlsZUVkaXRvcj17cHJvcHMub3BlbkZpbGVFZGl0b3J9XG4gICAgICAgICAgICBjYW5FZGl0RmlsZT17cHJvcHMuY2FuRWRpdEZpbGV9XG4gICAgICAgICAgICB0b2dnbGVBZGRGaWxlc1BhbmVsPXtwcm9wcy50b2dnbGVBZGRGaWxlc1BhbmVsfVxuICAgICAgICAgICAgZmlsZT17cHJvcHMuZmlsZXNbZmlsZUlEXX1cbiAgICAgICAgICAvPlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFZpcnR1YWxMaXN0XG4gICAgICBjbGFzcz17ZGFzaGJvYXJkRmlsZXNDbGFzc31cbiAgICAgIHJvbGU9XCJsaXN0XCJcbiAgICAgIGRhdGE9e3Jvd3N9XG4gICAgICByZW5kZXJSb3c9e3JlbmRlclJvd31cbiAgICAgIHJvd0hlaWdodD17cm93SGVpZ2h0fVxuICAgIC8+XG4gIClcbn1cbiIsImNvbnN0IGdldEZpbGVUeXBlSWNvbiA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldEZpbGVUeXBlSWNvbicpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRmlsZVByZXZpZXcgKHByb3BzKSB7XG4gIGNvbnN0IGZpbGUgPSBwcm9wcy5maWxlXG5cbiAgaWYgKGZpbGUucHJldmlldykge1xuICAgIHJldHVybiAoXG4gICAgICA8aW1nXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJldmlld0ltZ1wiXG4gICAgICAgIGFsdD17ZmlsZS5uYW1lfVxuICAgICAgICBzcmM9e2ZpbGUucHJldmlld31cbiAgICAgIC8+XG4gICAgKVxuICB9XG5cbiAgY29uc3QgeyBjb2xvciwgaWNvbiB9ID0gZ2V0RmlsZVR5cGVJY29uKGZpbGUudHlwZSlcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SWNvbldyYXBcIj5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJldmlld0ljb25cIiBzdHlsZT17eyBjb2xvciB9fT57aWNvbn08L3NwYW4+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SWNvbkJnXCIgd2lkdGg9XCI1OFwiIGhlaWdodD1cIjc2XCIgdmlld0JveD1cIjAgMCA1OCA3NlwiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI0ZGRlwiIHdpZHRoPVwiNThcIiBoZWlnaHQ9XCI3NlwiIHJ4PVwiM1wiIGZpbGxSdWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3QgaWdub3JlRXZlbnQgPSByZXF1aXJlKCcuLi91dGlscy9pZ25vcmVFdmVudC5qcycpXG5cbmZ1bmN0aW9uIFBpY2tlclBhbmVsQ29udGVudCAocHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktRGFzaGJvYXJkQ29udGVudC1wYW5lbCcsIHByb3BzLmNsYXNzTmFtZSl9XG4gICAgICByb2xlPVwidGFicGFuZWxcIlxuICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIlBpY2tlclBhbmVsXCJcbiAgICAgIGlkPXtgdXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsLS0ke3Byb3BzLmFjdGl2ZVBpY2tlclBhbmVsLmlkfWB9XG4gICAgICBvbkRyYWdPdmVyPXtpZ25vcmVFdmVudH1cbiAgICAgIG9uRHJhZ0xlYXZlPXtpZ25vcmVFdmVudH1cbiAgICAgIG9uRHJvcD17aWdub3JlRXZlbnR9XG4gICAgICBvblBhc3RlPXtpZ25vcmVFdmVudH1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCIxXCI+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2ltcG9ydEZyb20nLCB7IG5hbWU6IHByb3BzLmFjdGl2ZVBpY2tlclBhbmVsLm5hbWUgfSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhpZGVBbGxQYW5lbHN9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuaTE4bignZG9uZScpfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWxCb2R5XCI+XG4gICAgICAgIHtwcm9wcy5nZXRQbHVnaW4ocHJvcHMuYWN0aXZlUGlja2VyUGFuZWwuaWQpLnJlbmRlcihwcm9wcy5zdGF0ZSl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBpY2tlclBhbmVsQ29udGVudFxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jb25zdCB1cGxvYWRTdGF0ZXMgPSB7XG4gIFNUQVRFX0VSUk9SOiAnZXJyb3InLFxuICBTVEFURV9XQUlUSU5HOiAnd2FpdGluZycsXG4gIFNUQVRFX1BSRVBST0NFU1NJTkc6ICdwcmVwcm9jZXNzaW5nJyxcbiAgU1RBVEVfVVBMT0FESU5HOiAndXBsb2FkaW5nJyxcbiAgU1RBVEVfUE9TVFBST0NFU1NJTkc6ICdwb3N0cHJvY2Vzc2luZycsXG4gIFNUQVRFX0NPTVBMRVRFOiAnY29tcGxldGUnLFxuICBTVEFURV9QQVVTRUQ6ICdwYXVzZWQnLFxufVxuXG5mdW5jdGlvbiBnZXRVcGxvYWRpbmdTdGF0ZSAoaXNBbGxFcnJvcmVkLCBpc0FsbENvbXBsZXRlLCBpc0FsbFBhdXNlZCwgZmlsZXMgPSB7fSkge1xuICBpZiAoaXNBbGxFcnJvcmVkKSB7XG4gICAgcmV0dXJuIHVwbG9hZFN0YXRlcy5TVEFURV9FUlJPUlxuICB9XG5cbiAgaWYgKGlzQWxsQ29tcGxldGUpIHtcbiAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX0NPTVBMRVRFXG4gIH1cblxuICBpZiAoaXNBbGxQYXVzZWQpIHtcbiAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX1BBVVNFRFxuICB9XG5cbiAgbGV0IHN0YXRlID0gdXBsb2FkU3RhdGVzLlNUQVRFX1dBSVRJTkdcbiAgY29uc3QgZmlsZUlEcyA9IE9iamVjdC5rZXlzKGZpbGVzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVJRHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9ncmVzcyA9IGZpbGVzW2ZpbGVJRHNbaV1dLnByb2dyZXNzXG4gICAgLy8gSWYgQU5ZIGZpbGVzIGFyZSBiZWluZyB1cGxvYWRlZCByaWdodCBub3csIHNob3cgdGhlIHVwbG9hZGluZyBzdGF0ZS5cbiAgICBpZiAocHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCAmJiAhcHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiB1cGxvYWRTdGF0ZXMuU1RBVEVfVVBMT0FESU5HXG4gICAgfVxuICAgIC8vIElmIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgQU5EIHBvc3Rwcm9jZXNzZWQgYXQgdGhpcyB0aW1lLCB3ZSBzaG93IHRoZVxuICAgIC8vIHByZXByb2Nlc3Mgc3RhdGUuIElmIGFueSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQgd2Ugc2hvdyB1cGxvYWRpbmcuXG4gICAgaWYgKHByb2dyZXNzLnByZXByb2Nlc3MgJiYgc3RhdGUgIT09IHVwbG9hZFN0YXRlcy5TVEFURV9VUExPQURJTkcpIHtcbiAgICAgIHN0YXRlID0gdXBsb2FkU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkdcbiAgICB9XG4gICAgLy8gSWYgTk8gZmlsZXMgYXJlIGJlaW5nIHByZXByb2Nlc3NlZCBvciB1cGxvYWRlZCByaWdodCBub3csIGJ1dCBzb21lIGZpbGVzIGFyZVxuICAgIC8vIGJlaW5nIHBvc3Rwcm9jZXNzZWQsIHNob3cgdGhlIHBvc3Rwcm9jZXNzIHN0YXRlLlxuICAgIGlmIChwcm9ncmVzcy5wb3N0cHJvY2VzcyAmJiBzdGF0ZSAhPT0gdXBsb2FkU3RhdGVzLlNUQVRFX1VQTE9BRElORyAmJiBzdGF0ZSAhPT0gdXBsb2FkU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkcpIHtcbiAgICAgIHN0YXRlID0gdXBsb2FkU3RhdGVzLlNUQVRFX1BPU1RQUk9DRVNTSU5HXG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZVxufVxuXG5mdW5jdGlvbiBVcGxvYWRTdGF0dXMgKHByb3BzKSB7XG4gIGNvbnN0IHVwbG9hZGluZ1N0YXRlID0gZ2V0VXBsb2FkaW5nU3RhdGUoXG4gICAgcHJvcHMuaXNBbGxFcnJvcmVkLFxuICAgIHByb3BzLmlzQWxsQ29tcGxldGUsXG4gICAgcHJvcHMuaXNBbGxQYXVzZWQsXG4gICAgcHJvcHMuZmlsZXNcbiAgKVxuXG4gIHN3aXRjaCAodXBsb2FkaW5nU3RhdGUpIHtcbiAgICBjYXNlICd1cGxvYWRpbmcnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3VwbG9hZGluZ1hGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLmluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcy5sZW5ndGggfSlcbiAgICBjYXNlICdwcmVwcm9jZXNzaW5nJzpcbiAgICBjYXNlICdwb3N0cHJvY2Vzc2luZyc6XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigncHJvY2Vzc2luZ1hGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLnByb2Nlc3NpbmdGaWxlcy5sZW5ndGggfSlcbiAgICBjYXNlICdwYXVzZWQnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3VwbG9hZFBhdXNlZCcpXG4gICAgY2FzZSAnd2FpdGluZyc6XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigneEZpbGVzU2VsZWN0ZWQnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5uZXdGaWxlcy5sZW5ndGggfSlcbiAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigndXBsb2FkQ29tcGxldGUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIFBhbmVsVG9wQmFyIChwcm9wcykge1xuICBsZXQgYWxsb3dOZXdVcGxvYWQgPSBwcm9wcy5hbGxvd05ld1VwbG9hZFxuICAvLyBUT0RPIG1heWJlIHRoaXMgc2hvdWxkIGJlIGRvbmUgaW4gLi4vaW5kZXguanMsIHRoZW4ganVzdCBwYXNzIHRoYXQgZG93biBhcyBgYWxsb3dOZXdVcGxvYWRgXG4gIGlmIChhbGxvd05ld1VwbG9hZCAmJiBwcm9wcy5tYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgYWxsb3dOZXdVcGxvYWQgPSBwcm9wcy50b3RhbEZpbGVDb3VudCA8IHByb3BzLm1heE51bWJlck9mRmlsZXNcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFyXCI+XG4gICAgICB7IXByb3BzLmlzQWxsQ29tcGxldGUgJiYgIXByb3BzLmhpZGVDYW5jZWxCdXR0b24gPyAoXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17cHJvcHMuY2FuY2VsQWxsfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2NhbmNlbCcpfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICkgOiAoXG4gICAgICAgIDxkaXYgLz5cbiAgICAgICl9XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlXCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxldmVsPVwiMVwiPlxuICAgICAgICA8VXBsb2FkU3RhdHVzIHsuLi5wcm9wc30gLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7YWxsb3dOZXdVcGxvYWQgPyAoXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYWRkTW9yZVwiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignYWRkTW9yZUZpbGVzJyl9XG4gICAgICAgICAgdGl0bGU9e3Byb3BzLmkxOG4oJ2FkZE1vcmVGaWxlcycpfVxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWwodHJ1ZSl9XG4gICAgICAgID5cbiAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjE1XCIgaGVpZ2h0PVwiMTVcIiB2aWV3Qm94PVwiMCAwIDE1IDE1XCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTggNi41aDZhLjUuNSAwIDAgMSAuNS41di41YS41LjUgMCAwIDEtLjUuNUg4djZhLjUuNSAwIDAgMS0uNS41SDdhLjUuNSAwIDAgMS0uNS0uNVY4aC02YS41LjUgMCAwIDEtLjUtLjVWN2EuNS41IDAgMCAxIC41LS41aDZ2LTZBLjUuNSAwIDAgMSA3IDBoLjVhLjUuNSAwIDAgMSAuNS41djZ6XCIgLz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYWRkTW9yZUNhcHRpb25cIj57cHJvcHMuaTE4bignYWRkTW9yZScpfTwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFuZWxUb3BCYXJcbiIsImNvbnN0IHsgY2xvbmVFbGVtZW50LCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5cbmNvbnN0IHRyYW5zaXRpb25OYW1lID0gJ3VwcHktdHJhbnNpdGlvbi1zbGlkZURvd25VcCdcbmNvbnN0IGR1cmF0aW9uID0gMjUwXG5cbi8qKlxuICogVmVydGljYWwgc2xpZGUgdHJhbnNpdGlvbi5cbiAqXG4gKiBUaGlzIGNhbiB0YWtlIGEgX3NpbmdsZV8gY2hpbGQgY29tcG9uZW50LCB3aGljaCBfbXVzdF8gYWNjZXB0IGEgYGNsYXNzTmFtZWAgcHJvcC5cbiAqXG4gKiBDdXJyZW50bHkgdGhpcyBpcyBzcGVjaWZpYyB0byB0aGUgYHVwcHktdHJhbnNpdGlvbi1zbGlkZURvd25VcGAgdHJhbnNpdGlvbixcbiAqIGJ1dCBpdCBzaG91bGQgYmUgc2ltcGxlIHRvIGV4dGVuZCB0aGlzIGZvciBhbnkgdHlwZSBvZiBzaW5nbGUtZWxlbWVudFxuICogdHJhbnNpdGlvbiBieSBzZXR0aW5nIHRoZSBDU1MgbmFtZSBhbmQgZHVyYXRpb24gYXMgcHJvcHMuXG4gKi9cbmNsYXNzIFNsaWRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY2FjaGVkQ2hpbGRyZW46IG51bGwsXG4gICAgICBjbGFzc05hbWU6ICcnLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUgKG5leHRQcm9wcykge1xuICAgIGNvbnN0IHsgY2FjaGVkQ2hpbGRyZW4gfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBjaGlsZCA9IG5leHRQcm9wcy5jaGlsZHJlblswXVxuXG4gICAgaWYgKGNhY2hlZENoaWxkcmVuID09PSBjaGlsZCkgcmV0dXJuXG5cbiAgICBjb25zdCBwYXRjaCA9IHtcbiAgICAgIGNhY2hlZENoaWxkcmVuOiBjaGlsZCxcbiAgICB9XG5cbiAgICAvLyBFbnRlciB0cmFuc2l0aW9uXG4gICAgaWYgKGNoaWxkICYmICFjYWNoZWRDaGlsZHJlbikge1xuICAgICAgcGF0Y2guY2xhc3NOYW1lID0gYCR7dHJhbnNpdGlvbk5hbWV9LWVudGVyYFxuXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lKVxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubGVhdmVUaW1lb3V0KVxuICAgICAgdGhpcy5sZWF2ZVRpbWVvdXQgPSB1bmRlZmluZWRcblxuICAgICAgdGhpcy5hbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIC8vIEZvcmNlIGl0IHRvIHJlbmRlciBiZWZvcmUgd2UgYWRkIHRoZSBhY3RpdmUgY2xhc3NcbiAgICAgICAgdGhpcy5iYXNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBgJHt0cmFuc2l0aW9uTmFtZX0tZW50ZXIgJHt0cmFuc2l0aW9uTmFtZX0tZW50ZXItYWN0aXZlYCxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmVudGVyVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjbGFzc05hbWU6ICcnIH0pXG4gICAgICAgIH0sIGR1cmF0aW9uKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBMZWF2ZSB0cmFuc2l0aW9uXG4gICAgaWYgKGNhY2hlZENoaWxkcmVuICYmICFjaGlsZCAmJiB0aGlzLmxlYXZlVGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXRjaC5jYWNoZWRDaGlsZHJlbiA9IGNhY2hlZENoaWxkcmVuXG4gICAgICBwYXRjaC5jbGFzc05hbWUgPSBgJHt0cmFuc2l0aW9uTmFtZX0tbGVhdmVgXG5cbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5lbnRlclRpbWVvdXQpXG4gICAgICB0aGlzLmVudGVyVGltZW91dCA9IHVuZGVmaW5lZFxuICAgICAgdGhpcy5hbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGNsYXNzTmFtZTogYCR7dHJhbnNpdGlvbk5hbWV9LWxlYXZlICR7dHJhbnNpdGlvbk5hbWV9LWxlYXZlLWFjdGl2ZWAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5sZWF2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNhY2hlZENoaWxkcmVuOiBudWxsLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnJyxcbiAgICAgICAgICB9KVxuICAgICAgICB9LCBkdXJhdGlvbilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShwYXRjaClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgeyBjYWNoZWRDaGlsZHJlbiwgY2xhc3NOYW1lIH0gPSB0aGlzLnN0YXRlXG5cbiAgICBpZiAoIWNhY2hlZENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2FjaGVkQ2hpbGRyZW4sIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhjbGFzc05hbWUsIGNhY2hlZENoaWxkcmVuLmF0dHJpYnV0ZXMuY2xhc3NOYW1lKSxcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVcbiIsIi8qKlxuICogQWRhcHRlZCBmcm9tIHByZWFjdC12aXJ0dWFsLWxpc3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0LXZpcnR1YWwtbGlzdFxuICpcbiAqIMKpIDIwMTYgSmFzb24gTWlsbGVyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBBZGFwdGF0aW9uczpcbiAqIC0gQWRkZWQgcm9sZT1wcmVzZW50YXRpb24gdG8gaGVscGVyIGVsZW1lbnRzXG4gKiAtIFR3ZWFrZWQgc3R5bGVzIGZvciBVcHB5J3MgRGFzaGJvYXJkIHVzZSBjYXNlXG4gKi9cblxuY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IFNUWUxFX0lOTkVSID0ge1xuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgLy8gRGlzYWJsZWQgZm9yIG91ciB1c2UgY2FzZTogdGhlIHdyYXBwZXIgZWxlbWVudHMgYXJvdW5kIEZpbGVMaXN0IGFscmVhZHkgZGVhbCB3aXRoIG92ZXJmbG93LFxuICAvLyBhbmQgdGhpcyBhZGRpdGlvbmFsIHByb3BlcnR5IHdvdWxkIGhpZGUgdGhpbmdzIHRoYXQgd2Ugd2FudCB0byBzaG93LlxuICAvL1xuICAvLyBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHdpZHRoOiAnMTAwJScsXG4gIG1pbkhlaWdodDogJzEwMCUnLFxufVxuXG5jb25zdCBTVFlMRV9DT05URU5UID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgdG9wOiAwLFxuICBsZWZ0OiAwLFxuICAvLyBCZWNhdXNlIHRoZSBgdG9wYCB2YWx1ZSBnZXRzIHNldCB0byBzb21lIG9mZnNldCwgdGhpcyBgaGVpZ2h0YCBiZWluZyAxMDAlIHdvdWxkIG1ha2UgdGhlIHNjcm9sbGJhclxuICAvLyBzdHJldGNoIGZhciBiZXlvbmQgdGhlIGNvbnRlbnQuIEZvciBvdXIgdXNlIGNhc2UsIHRoZSBjb250ZW50IGRpdiBhY3R1YWxseSBjYW4gZ2V0IGl0cyBoZWlnaHQgZnJvbVxuICAvLyB0aGUgZWxlbWVudHMgaW5zaWRlIGl0LCBzbyB3ZSBkb24ndCBuZWVkIHRvIHNwZWNpZnkgYSBgaGVpZ2h0YCBwcm9wZXJ0eSBhdCBhbGwuXG4gIC8vXG4gIC8vIGhlaWdodDogJzEwMCUnLFxuICB3aWR0aDogJzEwMCUnLFxuICBvdmVyZmxvdzogJ3Zpc2libGUnLFxufVxuXG5jbGFzcyBWaXJ0dWFsTGlzdCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgLy8gVGhlIGN1cnJlbnRseSBmb2N1c2VkIG5vZGUsIHVzZWQgdG8gcmV0YWluIGZvY3VzIHdoZW4gdGhlIHZpc2libGUgcm93cyBjaGFuZ2UuXG4gICAgLy8gVG8gYXZvaWQgdXBkYXRlIGxvb3BzLCB0aGlzIHNob3VsZCBub3QgY2F1c2Ugc3RhdGUgdXBkYXRlcywgc28gaXQncyBrZXB0IGFzIGEgcGxhaW4gcHJvcGVydHkuXG4gICAgdGhpcy5mb2N1c0VsZW1lbnQgPSBudWxsXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgIH1cbiAgfVxuXG4gIHJlc2l6ZSAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaGVpZ2h0ICE9PSB0aGlzLmJhc2Uub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmJhc2Uub2Zmc2V0SGVpZ2h0LFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgdGhpcy5yZXNpemUoKVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgb2Zmc2V0OiB0aGlzLmJhc2Uuc2Nyb2xsVG9wLFxuICAgIH0pXG4gICAgaWYgKHRoaXMucHJvcHMuc3luYykge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVwZGF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuYmFzZS5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5mb2N1c0VsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlICgpIHtcbiAgICAvLyBNYWludGFpbiBmb2N1cyB3aGVuIHJvd3MgYXJlIGFkZGVkIGFuZCByZW1vdmVkLlxuICAgIGlmICh0aGlzLmZvY3VzRWxlbWVudCAmJiB0aGlzLmZvY3VzRWxlbWVudC5wYXJlbnROb2RlXG4gICAgICAgICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMuZm9jdXNFbGVtZW50KSB7XG4gICAgICB0aGlzLmZvY3VzRWxlbWVudC5mb2N1cygpXG4gICAgfVxuICAgIHRoaXMuZm9jdXNFbGVtZW50ID0gbnVsbFxuICAgIHRoaXMucmVzaXplKClcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLnJlc2l6ZSgpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSlcbiAgfVxuXG4gIHJlbmRlciAoe1xuICAgIGRhdGEsXG4gICAgcm93SGVpZ2h0LFxuICAgIHJlbmRlclJvdyxcbiAgICBvdmVyc2NhbkNvdW50ID0gMTAsXG4gICAgc3luYyxcbiAgICAuLi5wcm9wc1xuICB9KSB7XG4gICAgY29uc3QgeyBvZmZzZXQsIGhlaWdodCB9ID0gdGhpcy5zdGF0ZVxuICAgIC8vIGZpcnN0IHZpc2libGUgcm93IGluZGV4XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5mbG9vcihvZmZzZXQgLyByb3dIZWlnaHQpXG5cbiAgICAvLyBhY3R1YWwgbnVtYmVyIG9mIHZpc2libGUgcm93cyAod2l0aG91dCBvdmVyc2NhbilcbiAgICBsZXQgdmlzaWJsZVJvd0NvdW50ID0gTWF0aC5mbG9vcihoZWlnaHQgLyByb3dIZWlnaHQpXG5cbiAgICAvLyBPdmVyc2NhbjogcmVuZGVyIGJsb2NrcyBvZiByb3dzIG1vZHVsbyBhbiBvdmVyc2NhbiByb3cgY291bnRcbiAgICAvLyBUaGlzIGRyYW1hdGljYWxseSByZWR1Y2VzIERPTSB3cml0ZXMgZHVyaW5nIHNjcm9sbGluZ1xuICAgIGlmIChvdmVyc2NhbkNvdW50KSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0IC0gKHN0YXJ0ICUgb3ZlcnNjYW5Db3VudCkpXG4gICAgICB2aXNpYmxlUm93Q291bnQgKz0gb3ZlcnNjYW5Db3VudFxuICAgIH1cblxuICAgIC8vIGxhc3QgdmlzaWJsZSArIG92ZXJzY2FuIHJvdyBpbmRleCArIHBhZGRpbmcgdG8gYWxsb3cga2V5Ym9hcmQgZm9jdXMgdG8gdHJhdmVsIHBhc3QgdGhlIHZpc2libGUgYXJlYVxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgdmlzaWJsZVJvd0NvdW50ICsgNFxuXG4gICAgLy8gZGF0YSBzbGljZSBjdXJyZW50bHkgaW4gdmlld3BvcnQgcGx1cyBvdmVyc2NhbiBpdGVtc1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRhdGEuc2xpY2Uoc3RhcnQsIGVuZClcblxuICAgIGNvbnN0IHN0eWxlSW5uZXIgPSB7IC4uLlNUWUxFX0lOTkVSLCBoZWlnaHQ6IGRhdGEubGVuZ3RoICogcm93SGVpZ2h0IH1cbiAgICBjb25zdCBzdHlsZUNvbnRlbnQgPSB7IC4uLlNUWUxFX0NPTlRFTlQsIHRvcDogc3RhcnQgKiByb3dIZWlnaHQgfVxuXG4gICAgLy8gVGhlIGByb2xlPVwicHJlc2VudGF0aW9uXCJgIGF0dHJpYnV0ZXMgZW5zdXJlIHRoYXQgdGhlc2Ugd3JhcHBlciBlbGVtZW50cyBhcmUgbm90IHRyZWF0ZWQgYXMgbGlzdFxuICAgIC8vIGl0ZW1zIGJ5IGFjY2Vzc2liaWxpdHkgYW5kIG91dGxpbmUgdG9vbHMuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgb25TY3JvbGw9e3RoaXMuaGFuZGxlU2Nyb2xsfSB7Li4ucHJvcHN9PlxuICAgICAgICA8ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBzdHlsZT17c3R5bGVJbm5lcn0+XG4gICAgICAgICAgPGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgc3R5bGU9e3N0eWxlQ29udGVudH0+XG4gICAgICAgICAgICB7c2VsZWN0aW9uLm1hcChyZW5kZXJSb3cpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxMaXN0XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBUcmFuc2xhdG9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL1RyYW5zbGF0b3InKVxuY29uc3QgRGFzaGJvYXJkVUkgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvRGFzaGJvYXJkJylcbmNvbnN0IFN0YXR1c0JhciA9IHJlcXVpcmUoJ0B1cHB5L3N0YXR1cy1iYXInKVxuY29uc3QgSW5mb3JtZXIgPSByZXF1aXJlKCdAdXBweS9pbmZvcm1lcicpXG5jb25zdCBUaHVtYm5haWxHZW5lcmF0b3IgPSByZXF1aXJlKCdAdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yJylcbmNvbnN0IGZpbmRBbGxET01FbGVtZW50cyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kQWxsRE9NRWxlbWVudHMnKVxuY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcbmNvbnN0IGdldERyb3BwZWRGaWxlcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXREcm9wcGVkRmlsZXMnKVxuY29uc3QgZ2V0VGV4dERpcmVjdGlvbiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRUZXh0RGlyZWN0aW9uJylcbmNvbnN0IHRyYXBGb2N1cyA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhcEZvY3VzJylcbmNvbnN0IGN1aWQgPSByZXF1aXJlKCdjdWlkJylcbmNvbnN0IFJlc2l6ZU9ic2VydmVyID0gcmVxdWlyZSgncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJykuZGVmYXVsdCB8fCByZXF1aXJlKCdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnKVxuY29uc3QgY3JlYXRlU3VwZXJGb2N1cyA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlU3VwZXJGb2N1cycpXG5jb25zdCBtZW1vaXplID0gcmVxdWlyZSgnbWVtb2l6ZS1vbmUnKS5kZWZhdWx0IHx8IHJlcXVpcmUoJ21lbW9pemUtb25lJylcbmNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UUyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9GT0NVU0FCTEVfRUxFTUVOVFMnKVxuXG5jb25zdCBUQUJfS0VZID0gOVxuY29uc3QgRVNDX0tFWSA9IDI3XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb21pc2UgKCkge1xuICBjb25zdCBvID0ge31cbiAgby5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG8ucmVzb2x2ZSA9IHJlc29sdmVcbiAgICBvLnJlamVjdCA9IHJlamVjdFxuICB9KVxuICByZXR1cm4gb1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGlja2VySWNvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzBcIiBoZWlnaHQ9XCIzMFwiIHZpZXdCb3g9XCIwIDAgMzAgMzBcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTUgMzBjOC4yODQgMCAxNS02LjcxNiAxNS0xNSAwLTguMjg0LTYuNzE2LTE1LTE1LTE1QzYuNzE2IDAgMCA2LjcxNiAwIDE1YzAgOC4yODQgNi43MTYgMTUgMTUgMTV6bTQuMjU4LTEyLjY3NnY2Ljg0NmgtOC40MjZ2LTYuODQ2SDUuMjA0bDkuODItMTIuMzY0IDkuODIgMTIuMzY0SDE5LjI2elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuLyoqXG4gKiBEYXNoYm9hcmQgVUkgd2l0aCBwcmV2aWV3cywgbWV0YWRhdGEgZWRpdGluZywgdGFicyBmb3IgdmFyaW91cyBzZXJ2aWNlcyBhbmQgbW9yZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERhc2hib2FyZCBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdEYXNoYm9hcmQnXG4gICAgdGhpcy50aXRsZSA9ICdEYXNoYm9hcmQnXG4gICAgdGhpcy50eXBlID0gJ29yY2hlc3RyYXRvcidcbiAgICB0aGlzLm1vZGFsTmFtZSA9IGB1cHB5LURhc2hib2FyZC0ke2N1aWQoKX1gXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7XG4gICAgICAgIGNsb3NlTW9kYWw6ICdDbG9zZSBNb2RhbCcsXG4gICAgICAgIGltcG9ydEZyb206ICdJbXBvcnQgZnJvbSAle25hbWV9JyxcbiAgICAgICAgYWRkaW5nTW9yZUZpbGVzOiAnQWRkaW5nIG1vcmUgZmlsZXMnLFxuICAgICAgICBhZGRNb3JlRmlsZXM6ICdBZGQgbW9yZSBmaWxlcycsXG4gICAgICAgIGRhc2hib2FyZFdpbmRvd1RpdGxlOiAnRmlsZSBVcGxvYWRlciBXaW5kb3cgKFByZXNzIGVzY2FwZSB0byBjbG9zZSknLFxuICAgICAgICBkYXNoYm9hcmRUaXRsZTogJ0ZpbGUgVXBsb2FkZXInLFxuICAgICAgICBjb3B5TGlua1RvQ2xpcGJvYXJkU3VjY2VzczogJ0xpbmsgY29waWVkIHRvIGNsaXBib2FyZCcsXG4gICAgICAgIGNvcHlMaW5rVG9DbGlwYm9hcmRGYWxsYmFjazogJ0NvcHkgdGhlIFVSTCBiZWxvdycsXG4gICAgICAgIGNvcHlMaW5rOiAnQ29weSBsaW5rJyxcbiAgICAgICAgZmlsZVNvdXJjZTogJ0ZpbGUgc291cmNlOiAle25hbWV9JyxcbiAgICAgICAgZG9uZTogJ0RvbmUnLFxuICAgICAgICBiYWNrOiAnQmFjaycsXG4gICAgICAgIGFkZE1vcmU6ICdBZGQgbW9yZScsXG4gICAgICAgIHJlbW92ZUZpbGU6ICdSZW1vdmUgZmlsZScsXG4gICAgICAgIGVkaXRGaWxlOiAnRWRpdCBmaWxlJyxcbiAgICAgICAgZWRpdGluZzogJ0VkaXRpbmcgJXtmaWxlfScsXG4gICAgICAgIGZpbmlzaEVkaXRpbmdGaWxlOiAnRmluaXNoIGVkaXRpbmcgZmlsZScsXG4gICAgICAgIHNhdmVDaGFuZ2VzOiAnU2F2ZSBjaGFuZ2VzJyxcbiAgICAgICAgY2FuY2VsOiAnQ2FuY2VsJyxcbiAgICAgICAgbXlEZXZpY2U6ICdNeSBEZXZpY2UnLFxuICAgICAgICBkcm9wUGFzdGVGaWxlczogJ0Ryb3AgZmlsZXMgaGVyZSBvciAle2Jyb3dzZUZpbGVzfScsXG4gICAgICAgIGRyb3BQYXN0ZUZvbGRlcnM6ICdEcm9wIGZpbGVzIGhlcmUgb3IgJXticm93c2VGb2xkZXJzfScsXG4gICAgICAgIGRyb3BQYXN0ZUJvdGg6ICdEcm9wIGZpbGVzIGhlcmUsICV7YnJvd3NlRmlsZXN9IG9yICV7YnJvd3NlRm9sZGVyc30nLFxuICAgICAgICBkcm9wUGFzdGVJbXBvcnRGaWxlczogJ0Ryb3AgZmlsZXMgaGVyZSwgJXticm93c2VGaWxlc30gb3IgaW1wb3J0IGZyb206JyxcbiAgICAgICAgZHJvcFBhc3RlSW1wb3J0Rm9sZGVyczogJ0Ryb3AgZmlsZXMgaGVyZSwgJXticm93c2VGb2xkZXJzfSBvciBpbXBvcnQgZnJvbTonLFxuICAgICAgICBkcm9wUGFzdGVJbXBvcnRCb3RoOiAnRHJvcCBmaWxlcyBoZXJlLCAle2Jyb3dzZUZpbGVzfSwgJXticm93c2VGb2xkZXJzfSBvciBpbXBvcnQgZnJvbTonLFxuICAgICAgICBpbXBvcnRGaWxlczogJ0ltcG9ydCBmaWxlcyBmcm9tOicsXG4gICAgICAgIGRyb3BIaW50OiAnRHJvcCB5b3VyIGZpbGVzIGhlcmUnLFxuICAgICAgICBicm93c2VGaWxlczogJ2Jyb3dzZSBmaWxlcycsXG4gICAgICAgIGJyb3dzZUZvbGRlcnM6ICdicm93c2UgZm9sZGVycycsXG4gICAgICAgIHVwbG9hZENvbXBsZXRlOiAnVXBsb2FkIGNvbXBsZXRlJyxcbiAgICAgICAgdXBsb2FkUGF1c2VkOiAnVXBsb2FkIHBhdXNlZCcsXG4gICAgICAgIHJlc3VtZVVwbG9hZDogJ1Jlc3VtZSB1cGxvYWQnLFxuICAgICAgICBwYXVzZVVwbG9hZDogJ1BhdXNlIHVwbG9hZCcsXG4gICAgICAgIHJldHJ5VXBsb2FkOiAnUmV0cnkgdXBsb2FkJyxcbiAgICAgICAgY2FuY2VsVXBsb2FkOiAnQ2FuY2VsIHVwbG9hZCcsXG4gICAgICAgIHhGaWxlc1NlbGVjdGVkOiB7XG4gICAgICAgICAgMDogJyV7c21hcnRfY291bnR9IGZpbGUgc2VsZWN0ZWQnLFxuICAgICAgICAgIDE6ICcle3NtYXJ0X2NvdW50fSBmaWxlcyBzZWxlY3RlZCcsXG4gICAgICAgIH0sXG4gICAgICAgIHVwbG9hZGluZ1hGaWxlczoge1xuICAgICAgICAgIDA6ICdVcGxvYWRpbmcgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1VwbG9hZGluZyAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3NpbmdYRmlsZXM6IHtcbiAgICAgICAgICAwOiAnUHJvY2Vzc2luZyAle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgICAgICAxOiAnUHJvY2Vzc2luZyAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgICAgIH0sXG4gICAgICAgIHJlY292ZXJlZFhGaWxlczoge1xuICAgICAgICAgIDA6ICdXZSBjb3VsZCBub3QgZnVsbHkgcmVjb3ZlciAxIGZpbGUuIFBsZWFzZSByZS1zZWxlY3QgaXQgYW5kIHJlc3VtZSB0aGUgdXBsb2FkLicsXG4gICAgICAgICAgMTogJ1dlIGNvdWxkIG5vdCBmdWxseSByZWNvdmVyICV7c21hcnRfY291bnR9IGZpbGVzLiBQbGVhc2UgcmUtc2VsZWN0IHRoZW0gYW5kIHJlc3VtZSB0aGUgdXBsb2FkLicsXG4gICAgICAgIH0sXG4gICAgICAgIHJlY292ZXJlZEFsbEZpbGVzOiAnV2UgcmVzdG9yZWQgYWxsIGZpbGVzLiBZb3UgY2FuIG5vdyByZXN1bWUgdGhlIHVwbG9hZC4nLFxuICAgICAgICBzZXNzaW9uUmVzdG9yZWQ6ICdTZXNzaW9uIHJlc3RvcmVkJyxcbiAgICAgICAgcmVTZWxlY3Q6ICdSZS1zZWxlY3QnLFxuICAgICAgICAvLyBUaGUgZGVmYXVsdCBgcG93ZXJlZEJ5MmAgc3RyaW5nIG9ubHkgY29tYmluZXMgdGhlIGBwb3dlcmVkQnlgIHN0cmluZyAoJXtiYWNrd2FyZHNDb21wYXR9KSB3aXRoIHRoZSBzaXplLlxuICAgICAgICAvLyBMb2NhbGVzIGNhbiBvdmVycmlkZSBgcG93ZXJlZEJ5MmAgdG8gc3BlY2lmeSBhIGRpZmZlcmVudCB3b3JkIG9yZGVyLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGhcbiAgICAgICAgLy8gVXBweSAxLjkueCBhbmQgYmVsb3cgd2hpY2ggZGlkIGEgbmFpdmUgY29uY2F0ZW5hdGlvbiBvZiBgcG93ZXJlZEJ5MiArIHNpemVgIGluc3RlYWQgb2YgdXNpbmcgYSBsb2NhbGUtc3BlY2lmaWNcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uLlxuICAgICAgICAvLyBUT0RPOiBJbiAyLjAgYHBvd2VyZWRCeTJgIHNob3VsZCBiZSByZW1vdmVkIGluIGFuZCBgcG93ZXJlZEJ5YCB1cGRhdGVkIHRvIHVzZSBzdWJzdGl0dXRpb24uXG4gICAgICAgIHBvd2VyZWRCeTI6ICcle2JhY2t3YXJkc0NvbXBhdH0gJXt1cHB5fScsXG4gICAgICAgIHBvd2VyZWRCeTogJ1Bvd2VyZWQgYnknLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB0YXJnZXQ6ICdib2R5JyxcbiAgICAgIG1ldGFGaWVsZHM6IFtdLFxuICAgICAgdHJpZ2dlcjogJyN1cHB5LXNlbGVjdC1maWxlcycsXG4gICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAgd2lkdGg6IDc1MCxcbiAgICAgIGhlaWdodDogNTUwLFxuICAgICAgdGh1bWJuYWlsV2lkdGg6IDI4MCxcbiAgICAgIHRodW1ibmFpbFR5cGU6ICdpbWFnZS9qcGVnJyxcbiAgICAgIHdhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHRQaWNrZXJJY29uLFxuICAgICAgc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQ6IHRydWUsXG4gICAgICBzaG93UHJvZ3Jlc3NEZXRhaWxzOiBmYWxzZSxcbiAgICAgIGhpZGVVcGxvYWRCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZUNhbmNlbEJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlUmV0cnlCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVQcm9ncmVzc0FmdGVyRmluaXNoOiBmYWxzZSxcbiAgICAgIGRvbmVCdXR0b25IYW5kbGVyOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5yZXNldCgpXG4gICAgICAgIHRoaXMucmVxdWVzdENsb3NlTW9kYWwoKVxuICAgICAgfSxcbiAgICAgIG5vdGU6IG51bGwsXG4gICAgICBjbG9zZU1vZGFsT25DbGlja091dHNpZGU6IGZhbHNlLFxuICAgICAgY2xvc2VBZnRlckZpbmlzaDogZmFsc2UsXG4gICAgICBkaXNhYmxlU3RhdHVzQmFyOiBmYWxzZSxcbiAgICAgIGRpc2FibGVJbmZvcm1lcjogZmFsc2UsXG4gICAgICBkaXNhYmxlVGh1bWJuYWlsR2VuZXJhdG9yOiBmYWxzZSxcbiAgICAgIGRpc2FibGVQYWdlU2Nyb2xsV2hlbk1vZGFsT3BlbjogdHJ1ZSxcbiAgICAgIGFuaW1hdGVPcGVuQ2xvc2U6IHRydWUsXG4gICAgICBmaWxlTWFuYWdlclNlbGVjdGlvblR5cGU6ICdmaWxlcycsXG4gICAgICBwcm91ZGx5RGlzcGxheVBvd2VyZWRCeVVwcHk6IHRydWUsXG4gICAgICBvblJlcXVlc3RDbG9zZU1vZGFsOiAoKSA9PiB0aGlzLmNsb3NlTW9kYWwoKSxcbiAgICAgIHNob3dTZWxlY3RlZEZpbGVzOiB0cnVlLFxuICAgICAgc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGU6IGZhbHNlLFxuICAgICAgYnJvd3NlckJhY2tCdXR0b25DbG9zZTogZmFsc2UsXG4gICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgIGF1dG9PcGVuRmlsZUVkaXRvcjogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICBkaXNhYmxlTG9jYWxGaWxlczogZmFsc2UsXG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIG9uZXMgc2V0IGJ5IHVzZXJcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgdGhpcy5zdXBlckZvY3VzID0gY3JlYXRlU3VwZXJGb2N1cygpXG4gICAgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSA9IGZhbHNlXG5cbiAgICAvLyBUaW1lb3V0c1xuICAgIHRoaXMubWFrZURhc2hib2FyZEluc2lkZXNWaXNpYmxlQW55d2F5VGltZW91dCA9IG51bGxcbiAgICB0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0ID0gbnVsbFxuICB9XG5cbiAgc2V0T3B0aW9ucyA9IChuZXdPcHRzKSA9PiB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgPSAoKSA9PiB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLmkxOG5BcnJheSA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICByZW1vdmVUYXJnZXQgPSAocGx1Z2luKSA9PiB7XG4gICAgY29uc3QgcGx1Z2luU3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICAvLyBmaWx0ZXIgb3V0IHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmVcbiAgICBjb25zdCBuZXdUYXJnZXRzID0gcGx1Z2luU3RhdGUudGFyZ2V0cy5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC5pZCAhPT0gcGx1Z2luLmlkKVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICB0YXJnZXRzOiBuZXdUYXJnZXRzLFxuICAgIH0pXG4gIH1cblxuICBhZGRUYXJnZXQgPSAocGx1Z2luKSA9PiB7XG4gICAgY29uc3QgY2FsbGVyUGx1Z2luSWQgPSBwbHVnaW4uaWQgfHwgcGx1Z2luLmNvbnN0cnVjdG9yLm5hbWVcbiAgICBjb25zdCBjYWxsZXJQbHVnaW5OYW1lID0gcGx1Z2luLnRpdGxlIHx8IGNhbGxlclBsdWdpbklkXG4gICAgY29uc3QgY2FsbGVyUGx1Z2luVHlwZSA9IHBsdWdpbi50eXBlXG5cbiAgICBpZiAoY2FsbGVyUGx1Z2luVHlwZSAhPT0gJ2FjcXVpcmVyJ1xuICAgICAgICAmJiBjYWxsZXJQbHVnaW5UeXBlICE9PSAncHJvZ3Jlc3NpbmRpY2F0b3InXG4gICAgICAgICYmIGNhbGxlclBsdWdpblR5cGUgIT09ICdlZGl0b3InKSB7XG4gICAgICBjb25zdCBtc2cgPSAnRGFzaGJvYXJkOiBjYW4gb25seSBiZSB0YXJnZXRlZCBieSBwbHVnaW5zIG9mIHR5cGVzOiBhY3F1aXJlciwgcHJvZ3Jlc3NpbmRpY2F0b3IsIGVkaXRvcidcbiAgICAgIHRoaXMudXBweS5sb2cobXNnLCAnZXJyb3InKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0ge1xuICAgICAgaWQ6IGNhbGxlclBsdWdpbklkLFxuICAgICAgbmFtZTogY2FsbGVyUGx1Z2luTmFtZSxcbiAgICAgIHR5cGU6IGNhbGxlclBsdWdpblR5cGUsXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBuZXdUYXJnZXRzID0gc3RhdGUudGFyZ2V0cy5zbGljZSgpXG4gICAgbmV3VGFyZ2V0cy5wdXNoKHRhcmdldClcblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgdGFyZ2V0czogbmV3VGFyZ2V0cyxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXMuZWxcbiAgfVxuXG4gIGhpZGVBbGxQYW5lbHMgPSAoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlID0ge1xuICAgICAgYWN0aXZlUGlja2VyUGFuZWw6IGZhbHNlLFxuICAgICAgc2hvd0FkZEZpbGVzUGFuZWw6IGZhbHNlLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6IG51bGwsXG4gICAgICBmaWxlQ2FyZEZvcjogbnVsbCxcbiAgICAgIHNob3dGaWxlRWRpdG9yOiBmYWxzZSxcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKGN1cnJlbnQuYWN0aXZlUGlja2VyUGFuZWwgPT09IHVwZGF0ZS5hY3RpdmVQaWNrZXJQYW5lbFxuICAgICAgICAmJiBjdXJyZW50LnNob3dBZGRGaWxlc1BhbmVsID09PSB1cGRhdGUuc2hvd0FkZEZpbGVzUGFuZWxcbiAgICAgICAgJiYgY3VycmVudC5zaG93RmlsZUVkaXRvciA9PT0gdXBkYXRlLnNob3dGaWxlRWRpdG9yXG4gICAgICAgICYmIGN1cnJlbnQuYWN0aXZlT3ZlcmxheVR5cGUgPT09IHVwZGF0ZS5hY3RpdmVPdmVybGF5VHlwZSkge1xuICAgICAgLy8gYXZvaWQgZG9pbmcgYSBzdGF0ZSB1cGRhdGUgaWYgbm90aGluZyBjaGFuZ2VkXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHVwZGF0ZSlcbiAgfVxuXG4gIHNob3dQYW5lbCA9IChpZCkgPT4ge1xuICAgIGNvbnN0IHsgdGFyZ2V0cyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICBjb25zdCBhY3RpdmVQaWNrZXJQYW5lbCA9IHRhcmdldHMuZmlsdGVyKCh0YXJnZXQpID0+IHtcbiAgICAgIHJldHVybiB0YXJnZXQudHlwZSA9PT0gJ2FjcXVpcmVyJyAmJiB0YXJnZXQuaWQgPT09IGlkXG4gICAgfSlbMF1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgYWN0aXZlUGlja2VyUGFuZWwsXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogJ1BpY2tlclBhbmVsJyxcbiAgICB9KVxuICB9XG5cbiAgY2FuRWRpdEZpbGUgPSAoZmlsZSkgPT4ge1xuICAgIGNvbnN0IHsgdGFyZ2V0cyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgZWRpdG9ycyA9IHRoaXMuX2dldEVkaXRvcnModGFyZ2V0cylcblxuICAgIHJldHVybiBlZGl0b3JzLnNvbWUoKHRhcmdldCkgPT4gKFxuICAgICAgdGhpcy51cHB5LmdldFBsdWdpbih0YXJnZXQuaWQpLmNhbkVkaXRGaWxlKGZpbGUpXG4gICAgKSlcbiAgfVxuXG4gIG9wZW5GaWxlRWRpdG9yID0gKGZpbGUpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldHMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGVkaXRvcnMgPSB0aGlzLl9nZXRFZGl0b3JzKHRhcmdldHMpXG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIHNob3dGaWxlRWRpdG9yOiB0cnVlLFxuICAgICAgZmlsZUNhcmRGb3I6IGZpbGUuaWQgfHwgbnVsbCxcbiAgICAgIGFjdGl2ZU92ZXJsYXlUeXBlOiAnRmlsZUVkaXRvcicsXG4gICAgfSlcblxuICAgIGVkaXRvcnMuZm9yRWFjaCgoZWRpdG9yKSA9PiB7XG4gICAgICB0aGlzLnVwcHkuZ2V0UGx1Z2luKGVkaXRvci5pZCkuc2VsZWN0RmlsZShmaWxlKVxuICAgIH0pXG4gIH1cblxuICBvcGVuTW9kYWwgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVQcm9taXNlKClcbiAgICAvLyBzYXZlIHNjcm9sbCBwb3NpdGlvblxuICAgIHRoaXMuc2F2ZWRTY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIC8vIHNhdmUgYWN0aXZlIGVsZW1lbnQsIHNvIHdlIGNhbiByZXN0b3JlIGZvY3VzIHdoZW4gbW9kYWwgaXMgY2xvc2VkXG4gICAgdGhpcy5zYXZlZEFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVQYWdlU2Nyb2xsV2hlbk1vZGFsT3Blbikge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCd1cHB5LURhc2hib2FyZC1pc0ZpeGVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmFuaW1hdGVPcGVuQ2xvc2UgJiYgdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmlzQ2xvc2luZykge1xuICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgaXNIaWRkZW46IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc0hpZGRlbjogZmFsc2UsXG4gICAgICB9KVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5icm93c2VyQmFja0J1dHRvbkNsb3NlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJyb3dzZXJIaXN0b3J5KClcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgRVNDIGFuZCBUQUIga2V5cyBpbiBtb2RhbCBkaWFsb2dcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duSW5Nb2RhbClcblxuICAgIHRoaXMudXBweS5lbWl0KCdkYXNoYm9hcmQ6bW9kYWwtb3BlbicpXG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgY2xvc2VNb2RhbCA9IChvcHRzID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtYW51YWxDbG9zZSA9IHRydWUsIC8vIFdoZXRoZXIgdGhlIG1vZGFsIGlzIGJlaW5nIGNsb3NlZCBieSB0aGUgdXNlciAoYHRydWVgKSBvciBieSBvdGhlciBtZWFucyAoZS5nLiBicm93c2VyIGJhY2sgYnV0dG9uKVxuICAgIH0gPSBvcHRzXG5cbiAgICBjb25zdCB7IGlzSGlkZGVuLCBpc0Nsb3NpbmcgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmIChpc0hpZGRlbiB8fCBpc0Nsb3NpbmcpIHtcbiAgICAgIC8vIHNob3J0LWNpcmN1aXQgaWYgYW5pbWF0aW9uIGlzIG9uZ29pbmdcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gY3JlYXRlUHJvbWlzZSgpXG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVQYWdlU2Nyb2xsV2hlbk1vZGFsT3Blbikge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd1cHB5LURhc2hib2FyZC1pc0ZpeGVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmFuaW1hdGVPcGVuQ2xvc2UpIHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc0Nsb3Npbmc6IHRydWUsXG4gICAgICB9KVxuICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgaXNIaWRkZW46IHRydWUsXG4gICAgICAgICAgaXNDbG9zaW5nOiBmYWxzZSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnN1cGVyRm9jdXMuY2FuY2VsKClcbiAgICAgICAgdGhpcy5zYXZlZEFjdGl2ZUVsZW1lbnQuZm9jdXMoKVxuXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBoYW5kbGVyLCBmYWxzZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGlzSGlkZGVuOiB0cnVlLFxuICAgICAgfSlcblxuICAgICAgdGhpcy5zdXBlckZvY3VzLmNhbmNlbCgpXG4gICAgICB0aGlzLnNhdmVkQWN0aXZlRWxlbWVudC5mb2N1cygpXG5cbiAgICAgIHJlc29sdmUoKVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBFU0MgYW5kIFRBQiBrZXlzIGluIG1vZGFsIGRpYWxvZ1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25Jbk1vZGFsKVxuXG4gICAgaWYgKG1hbnVhbENsb3NlKSB7XG4gICAgICBpZiAodGhpcy5vcHRzLmJyb3dzZXJCYWNrQnV0dG9uQ2xvc2UpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGxhdGVzdCBlbnRyeSBpbiB0aGUgaGlzdG9yeSBzdGF0ZSBpcyBvdXIgbW9kYWwgbmFtZVxuICAgICAgICBpZiAoaGlzdG9yeS5zdGF0ZSAmJiBoaXN0b3J5LnN0YXRlW3RoaXMubW9kYWxOYW1lXSkge1xuICAgICAgICAgIC8vIEdvIGJhY2sgaW4gaGlzdG9yeSB0byBjbGVhciBvdXQgdGhlIGVudHJ5IHdlIGNyZWF0ZWQgKHVsdGltYXRlbHkgY2xvc2luZyB0aGUgbW9kYWwpXG4gICAgICAgICAgaGlzdG9yeS5nbygtMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBweS5lbWl0KCdkYXNoYm9hcmQ6bW9kYWwtY2xvc2VkJylcblxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBpc01vZGFsT3BlbiA9ICgpID0+IHtcbiAgICByZXR1cm4gIXRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5pc0hpZGRlbiB8fCBmYWxzZVxuICB9XG5cbiAgcmVxdWVzdENsb3NlTW9kYWwgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMub3B0cy5vblJlcXVlc3RDbG9zZU1vZGFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRzLm9uUmVxdWVzdENsb3NlTW9kYWwoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9zZU1vZGFsKClcbiAgfVxuXG4gIHNldERhcmtNb2RlQ2FwYWJpbGl0eSA9IChpc0RhcmtNb2RlT24pID0+IHtcbiAgICBjb25zdCB7IGNhcGFiaWxpdGllcyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgIC4uLmNhcGFiaWxpdGllcyxcbiAgICAgICAgZGFya01vZGU6IGlzRGFya01vZGVPbixcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZVN5c3RlbURhcmtNb2RlQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgaXNEYXJrTW9kZU9uTm93ID0gZXZlbnQubWF0Y2hlc1xuICAgIHRoaXMudXBweS5sb2coYFtEYXNoYm9hcmRdIERhcmsgbW9kZSBpcyAke2lzRGFya01vZGVPbk5vdyA/ICdvbicgOiAnb2ZmJ31gKVxuICAgIHRoaXMuc2V0RGFya01vZGVDYXBhYmlsaXR5KGlzRGFya01vZGVPbk5vdylcbiAgfVxuXG4gIHRvZ2dsZUZpbGVDYXJkID0gKHNob3csIGZpbGVJRCkgPT4ge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgaWYgKHNob3cpIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCdkYXNoYm9hcmQ6ZmlsZS1lZGl0LXN0YXJ0JywgZmlsZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ2Rhc2hib2FyZDpmaWxlLWVkaXQtY29tcGxldGUnLCBmaWxlKVxuICAgIH1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgZmlsZUNhcmRGb3I6IHNob3cgPyBmaWxlSUQgOiBudWxsLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6IHNob3cgPyAnRmlsZUNhcmQnIDogbnVsbCxcbiAgICB9KVxuICB9XG5cbiAgdG9nZ2xlQWRkRmlsZXNQYW5lbCA9IChzaG93KSA9PiB7XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBzaG93QWRkRmlsZXNQYW5lbDogc2hvdyxcbiAgICAgIGFjdGl2ZU92ZXJsYXlUeXBlOiBzaG93ID8gJ0FkZEZpbGVzJyA6IG51bGwsXG4gICAgfSlcbiAgfVxuXG4gIGFkZEZpbGVzID0gKGZpbGVzKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWxlcy5tYXAoKGZpbGUpID0+ICh7XG4gICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbWV0YToge1xuICAgICAgICAvLyBwYXRoIG9mIHRoZSBmaWxlIHJlbGF0aXZlIHRvIHRoZSBhbmNlc3RvciBkaXJlY3RvcnkgdGhlIHVzZXIgc2VsZWN0ZWQuXG4gICAgICAgIC8vIGUuZy4gJ2RvY3MvT2xkIFByYWd1ZS9haXJibmIucGRmJ1xuICAgICAgICByZWxhdGl2ZVBhdGg6IGZpbGUucmVsYXRpdmVQYXRoIHx8IG51bGwsXG4gICAgICB9LFxuICAgIH0pKVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBweS5hZGRGaWxlcyhkZXNjcmlwdG9ycylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgIH1cbiAgfVxuXG4gIC8vIF9fX1doeSBtYWtlIGluc2lkZXMgb2YgRGFzaGJvYXJkIGludmlzaWJsZSB1bnRpbCBmaXJzdCBSZXNpemVPYnNlcnZlciBldmVudCBpcyBlbWl0dGVkP1xuICAvLyAgICBSZXNpemVPYmVyc2VydmVyIGRvZXNuJ3QgZW1pdCB0aGUgZmlyc3QgcmVzaXplIGV2ZW50IGZhc3QgZW5vdWdoLCB1c2VycyBjYW4gc2VlIHRoZSBqdW1wIGZyb20gb25lIC51cHB5LXNpemUtLSB0byBhbm90aGVyIChlLmcuIGluIFNhZmFyaSlcbiAgLy8gX19fV2h5IG5vdCBhcHBseSB2aXNpYmlsaXR5IHByb3BlcnR5IHRvIC51cHB5LURhc2hib2FyZC1pbm5lcj9cbiAgLy8gICAgQmVjYXVzZSBpZGVhbGx5LCBhY2MgdG8gc3BlY3MsIFJlc2l6ZU9ic2VydmVyIHNob3VsZCBzZWUgaW52aXNpYmxlIGVsZW1lbnRzIGFzIG9mIHdpZHRoIDAuIFNvIGV2ZW4gdGhvdWdoIGFwcGx5aW5nIGludmlzaWJpbGl0eSB0byAudXBweS1EYXNoYm9hcmQtaW5uZXIgd29ya3Mgbm93LCBpdCBtYXkgbm90IHdvcmsgaW4gdGhlIGZ1dHVyZS5cbiAgc3RhcnRMaXN0ZW5pbmdUb1Jlc2l6ZSA9ICgpID0+IHtcbiAgICAvLyBXYXRjaCBmb3IgRGFzaGJvYXJkIGNvbnRhaW5lciAoYC51cHB5LURhc2hib2FyZC1pbm5lcmApIHJlc2l6ZVxuICAgIC8vIGFuZCB1cGRhdGUgY29udGFpbmVyV2lkdGgvY29udGFpbmVySGVpZ2h0IGluIHBsdWdpbiBzdGF0ZSBhY2NvcmRpbmdseS5cbiAgICAvLyBFbWl0cyBmaXJzdCBldmVudCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgY29uc3QgdXBweURhc2hib2FyZElubmVyRWwgPSBlbnRyaWVzWzBdXG5cbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdXBweURhc2hib2FyZElubmVyRWwuY29udGVudFJlY3RcblxuICAgICAgdGhpcy51cHB5LmxvZyhgW0Rhc2hib2FyZF0gcmVzaXplZDogJHt3aWR0aH0gLyAke2hlaWdodH1gLCAnZGVidWcnKVxuXG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGU6IHRydWUsXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnVwcHktRGFzaGJvYXJkLWlubmVyJykpXG5cbiAgICAvLyBJZiBSZXNpemVPYnNlcnZlciBmYWlscyB0byBlbWl0IGFuIGV2ZW50IHRlbGxpbmcgdXMgd2hhdCBzaXplIHRvIHVzZSAtIGRlZmF1bHQgdG8gdGhlIG1vYmlsZSB2aWV3XG4gICAgdGhpcy5tYWtlRGFzaGJvYXJkSW5zaWRlc1Zpc2libGVBbnl3YXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgY29uc3QgaXNNb2RhbEFuZENsb3NlZCA9ICF0aGlzLm9wdHMuaW5saW5lICYmIHBsdWdpblN0YXRlLmlzSGlkZGVuXG4gICAgICBpZiAoXG4gICAgICAgIC8vIGlmIFJlc2l6ZU9ic2VydmVyIGhhc24ndCB5ZXQgZmlyZWQsXG4gICAgICAgICFwbHVnaW5TdGF0ZS5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZVxuICAgICAgICAvLyBhbmQgaXQncyBub3QgZHVlIHRvIHRoZSBtb2RhbCBiZWluZyBjbG9zZWRcbiAgICAgICAgJiYgIWlzTW9kYWxBbmRDbG9zZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLnVwcHkubG9nKFwiW0Rhc2hib2FyZF0gcmVzaXplIGV2ZW50IGRpZG4ndCBmaXJlIG9uIHRpbWU6IGRlZmF1bHRlZCB0byBtb2JpbGUgbGF5b3V0XCIsICdkZWJ1ZycpXG5cbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgMTAwMClcbiAgfVxuXG4gIHN0b3BMaXN0ZW5pbmdUb1Jlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubWFrZURhc2hib2FyZEluc2lkZXNWaXNpYmxlQW55d2F5VGltZW91dClcbiAgfVxuXG4gIC8vIFJlY29yZHMgd2hldGhlciB3ZSBoYXZlIGJlZW4gaW50ZXJhY3Rpbmcgd2l0aCB1cHB5IHJpZ2h0IG5vdywgd2hpY2ggaXMgdGhlbiB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHN0YXRlIHVwZGF0ZXMgc2hvdWxkIHRyaWdnZXIgYSByZWZvY3VzaW5nLlxuICByZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSA9IChldmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmVsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkgPSBmYWxzZVxuICAgICAgLy8gX19fV2h5IHJ1biB0aGlzLnN1cGVyRm9jdXMuY2FuY2VsIGhlcmUgd2hlbiBpdCBhbHJlYWR5IHJ1bnMgaW4gc3VwZXJGb2N1c09uRWFjaFVwZGF0ZT9cbiAgICAgIC8vICAgIEJlY2F1c2Ugc3VwZXJGb2N1cyBpcyBkZWJvdW5jZWQsIHdoZW4gd2UgbW92ZSBmcm9tIFVwcHkgdG8gc29tZSBvdGhlciBlbGVtZW50IG9uIHRoZSBwYWdlLFxuICAgICAgLy8gICAgcHJldmlvdXNseSBydW4gc3VwZXJGb2N1cyBzb21ldGltZXMgaGl0cyBhbmQgbW92ZXMgZm9jdXMgYmFjayB0byBVcHB5LlxuICAgICAgdGhpcy5zdXBlckZvY3VzLmNhbmNlbCgpXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZUFsbEZvY3VzYWJsZUVsZW1lbnRzID0gKGRpc2FibGUpID0+IHtcbiAgICBjb25zdCBmb2N1c2FibGVOb2RlcyA9IHRvQXJyYXkodGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUykpXG4gICAgaWYgKGRpc2FibGUpIHtcbiAgICAgIGZvY3VzYWJsZU5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgLy8gc2F2ZSBwcmV2aW91cyB0YWJpbmRleCBpbiBhIGRhdGEtYXR0cmlidXRlLCB0byByZXN0b3JlIHdoZW4gZW5hYmxpbmdcbiAgICAgICAgY29uc3QgY3VycmVudFRhYkluZGV4ID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JylcbiAgICAgICAgaWYgKGN1cnJlbnRUYWJJbmRleCkge1xuICAgICAgICAgIG5vZGUuZGF0YXNldC5pbmVydFRhYmluZGV4ID0gY3VycmVudFRhYkluZGV4XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvY3VzYWJsZU5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCdpbmVydFRhYmluZGV4JyBpbiBub2RlLmRhdGFzZXQpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCBub2RlLmRhdGFzZXQuaW5lcnRUYWJpbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLmRhc2hib2FyZElzRGlzYWJsZWQgPSBkaXNhYmxlXG4gIH1cblxuICB1cGRhdGVCcm93c2VySGlzdG9yeSA9ICgpID0+IHtcbiAgICAvLyBFbnN1cmUgaGlzdG9yeSBzdGF0ZSBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gb3VyIG1vZGFsIG5hbWUgdG8gYXZvaWQgZG91YmxlLXB1c2hpbmdcbiAgICBpZiAoIWhpc3Rvcnkuc3RhdGUgfHwgIWhpc3Rvcnkuc3RhdGVbdGhpcy5tb2RhbE5hbWVdKSB7XG4gICAgICAvLyBQdXNoIHRvIGhpc3Rvcnkgc28gdGhhdCB0aGUgcGFnZSBpcyBub3QgbG9zdCBvbiBicm93c2VyIGJhY2sgYnV0dG9uIHByZXNzXG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7XG4gICAgICAgIC4uLmhpc3Rvcnkuc3RhdGUsXG4gICAgICAgIFt0aGlzLm1vZGFsTmFtZV06IHRydWUsXG4gICAgICB9LCAnJylcbiAgICB9XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGJhY2sgYnV0dG9uIHByZXNzZXNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmhhbmRsZVBvcFN0YXRlLCBmYWxzZSlcbiAgfVxuXG4gIGhhbmRsZVBvcFN0YXRlID0gKGV2ZW50KSA9PiB7XG4gICAgLy8gQ2xvc2UgdGhlIG1vZGFsIGlmIHRoZSBoaXN0b3J5IHN0YXRlIG5vIGxvbmdlciBjb250YWlucyBvdXIgbW9kYWwgbmFtZVxuICAgIGlmICh0aGlzLmlzTW9kYWxPcGVuKCkgJiYgKCFldmVudC5zdGF0ZSB8fCAhZXZlbnQuc3RhdGVbdGhpcy5tb2RhbE5hbWVdKSkge1xuICAgICAgdGhpcy5jbG9zZU1vZGFsKHsgbWFudWFsQ2xvc2U6IGZhbHNlIH0pXG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGUgYnJvd3NlciBiYWNrIGJ1dHRvbiBpcyBwcmVzc2VkIGFuZCB1cHB5IGlzIG5vdyB0aGUgbGF0ZXN0IGVudHJ5IGluIHRoZSBoaXN0b3J5IGJ1dCB0aGUgbW9kYWwgaXMgY2xvc2VkLCBmaXggdGhlIGhpc3RvcnkgYnkgcmVtb3ZpbmcgdGhlIHVwcHkgaGlzdG9yeSBlbnRyeVxuICAgIC8vIFRoaXMgb2NjdXJzIHdoZW4gYW5vdGhlciBlbnRyeSBpcyBhZGRlZCBpbnRvIHRoZSBoaXN0b3J5IHN0YXRlIHdoaWxlIHRoZSBtb2RhbCBpcyBvcGVuLCBhbmQgdGhlbiB0aGUgbW9kYWwgZ2V0cyBtYW51YWxseSBjbG9zZWRcbiAgICAvLyBTb2x2ZXMgUFIgIzU3NSAoaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvcHVsbC81NzUpXG4gICAgaWYgKCF0aGlzLmlzTW9kYWxPcGVuKCkgJiYgZXZlbnQuc3RhdGUgJiYgZXZlbnQuc3RhdGVbdGhpcy5tb2RhbE5hbWVdKSB7XG4gICAgICBoaXN0b3J5LmdvKC0xKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUtleURvd25Jbk1vZGFsID0gKGV2ZW50KSA9PiB7XG4gICAgLy8gY2xvc2UgbW9kYWwgb24gZXNjIGtleSBwcmVzc1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NfS0VZKSB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsKGV2ZW50KVxuICAgIC8vIHRyYXAgZm9jdXMgb24gdGFiIGtleSBwcmVzc1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBUQUJfS0VZKSB0cmFwRm9jdXMuZm9yTW9kYWwoZXZlbnQsIHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5hY3RpdmVPdmVybGF5VHlwZSwgdGhpcy5lbClcbiAgfVxuXG4gIGhhbmRsZUNsaWNrT3V0c2lkZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5vcHRzLmNsb3NlTW9kYWxPbkNsaWNrT3V0c2lkZSkgdGhpcy5yZXF1ZXN0Q2xvc2VNb2RhbCgpXG4gIH1cblxuICBoYW5kbGVQYXN0ZSA9IChldmVudCkgPT4ge1xuICAgIC8vIDEuIExldCBhbnkgYWNxdWlyZXIgcGx1Z2luIChVcmwvV2ViY2FtL2V0Yy4pIGhhbmRsZSBwYXN0ZXMgdG8gdGhlIHJvb3RcbiAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgaWYgKHBsdWdpbi50eXBlID09PSAnYWNxdWlyZXInKSB7XG4gICAgICAgIC8vIEV2ZXJ5IFBsdWdpbiB3aXRoIC50eXBlIGFjcXVpcmVyIGNhbiBkZWZpbmUgaGFuZGxlUm9vdFBhc3RlKGV2ZW50KVxuICAgICAgICBwbHVnaW4uaGFuZGxlUm9vdFBhc3RlICYmIHBsdWdpbi5oYW5kbGVSb290UGFzdGUoZXZlbnQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIDIuIEFkZCBhbGwgZHJvcHBlZCBmaWxlc1xuICAgIGNvbnN0IGZpbGVzID0gdG9BcnJheShldmVudC5jbGlwYm9hcmREYXRhLmZpbGVzKVxuICAgIHRoaXMuYWRkRmlsZXMoZmlsZXMpXG4gIH1cblxuICBoYW5kbGVJbnB1dENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBjb25zdCBmaWxlcyA9IHRvQXJyYXkoZXZlbnQudGFyZ2V0LmZpbGVzKVxuICAgIHRoaXMuYWRkRmlsZXMoZmlsZXMpXG4gIH1cblxuICBoYW5kbGVEcmFnT3ZlciA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKHRoaXMub3B0cy5kaXNhYmxlZCB8fCB0aGlzLm9wdHMuZGlzYWJsZUxvY2FsRmlsZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDEuIEFkZCBhIHNtYWxsICgrKSBpY29uIG9uIGRyb3BcbiAgICAvLyAoYW5kIHByZXZlbnQgYnJvd3NlcnMgZnJvbSBpbnRlcnByZXRpbmcgdGhpcyBhcyBmaWxlcyBiZWluZyBfbW92ZWRfIGludG8gdGhlIGJyb3dzZXIsIGh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlcy8xOTc4KVxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknXG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgaXNEcmFnZ2luZ092ZXI6IHRydWUgfSlcbiAgfVxuXG4gIGhhbmRsZURyYWdMZWF2ZSA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKHRoaXMub3B0cy5kaXNhYmxlZCB8fCB0aGlzLm9wdHMuZGlzYWJsZUxvY2FsRmlsZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0KVxuICAgIC8vIFRpbWVvdXQgYWdhaW5zdCBmbGlja2VyaW5nLCB0aGlzIHNvbHV0aW9uIGlzIHRha2VuIGZyb20gZHJhZy1kcm9wIGxpYnJhcnkuIFNvbHV0aW9uIHdpdGggJ3BvaW50ZXItZXZlbnRzOiBub25lJyBkaWRuJ3Qgd29yayBhY3Jvc3MgYnJvd3NlcnMuXG4gICAgdGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7IGlzRHJhZ2dpbmdPdmVyOiBmYWxzZSB9KVxuICAgIH0sIDUwKVxuICB9XG5cbiAgaGFuZGxlRHJvcCA9IChldmVudCwgZHJvcENhdGVnb3J5KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVkIHx8IHRoaXMub3B0cy5kaXNhYmxlTG9jYWxGaWxlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVtb3ZlRHJhZ092ZXJDbGFzc1RpbWVvdXQpXG5cbiAgICAvLyAyLiBSZW1vdmUgZHJhZ292ZXIgY2xhc3NcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgaXNEcmFnZ2luZ092ZXI6IGZhbHNlIH0pXG5cbiAgICAvLyAzLiBMZXQgYW55IGFjcXVpcmVyIHBsdWdpbiAoVXJsL1dlYmNhbS9ldGMuKSBoYW5kbGUgZHJvcHMgdG8gdGhlIHJvb3RcbiAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgaWYgKHBsdWdpbi50eXBlID09PSAnYWNxdWlyZXInKSB7XG4gICAgICAgIC8vIEV2ZXJ5IFBsdWdpbiB3aXRoIC50eXBlIGFjcXVpcmVyIGNhbiBkZWZpbmUgaGFuZGxlUm9vdERyb3AoZXZlbnQpXG4gICAgICAgIHBsdWdpbi5oYW5kbGVSb290RHJvcCAmJiBwbHVnaW4uaGFuZGxlUm9vdERyb3AoZXZlbnQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIDQuIEFkZCBhbGwgZHJvcHBlZCBmaWxlc1xuICAgIGxldCBleGVjdXRlZERyb3BFcnJvck9uY2UgPSBmYWxzZVxuICAgIGNvbnN0IGxvZ0Ryb3BFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhlcnJvciwgJ2Vycm9yJylcblxuICAgICAgLy8gSW4gcHJhY3RpY2UgYWxsIGRyb3AgZXJyb3JzIGFyZSBtb3N0IGxpa2VseSB0aGUgc2FtZSwgc28gbGV0J3MganVzdCBzaG93IG9uZSB0byBhdm9pZCBvdmVyd2hlbG1pbmcgdGhlIHVzZXJcbiAgICAgIGlmICghZXhlY3V0ZWREcm9wRXJyb3JPbmNlKSB7XG4gICAgICAgIHRoaXMudXBweS5pbmZvKGVycm9yLm1lc3NhZ2UsICdlcnJvcicpXG4gICAgICAgIGV4ZWN1dGVkRHJvcEVycm9yT25jZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXREcm9wcGVkRmlsZXMoZXZlbnQuZGF0YVRyYW5zZmVyLCB7IGxvZ0Ryb3BFcnJvciB9KVxuICAgICAgLnRoZW4oKGZpbGVzKSA9PiB7XG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZygnW0Rhc2hib2FyZF0gRmlsZXMgd2VyZSBkcm9wcGVkJylcbiAgICAgICAgICB0aGlzLmFkZEZpbGVzKGZpbGVzKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgaGFuZGxlUmVxdWVzdFRodW1ibmFpbCA9IChmaWxlKSA9PiB7XG4gICAgaWYgKCF0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6cmVxdWVzdCcsIGZpbGUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdlIGNhbmNlbCB0aHVtYm5haWwgcmVxdWVzdHMgd2hlbiBhIGZpbGUgaXRlbSBjb21wb25lbnQgdW5tb3VudHMgdG8gYXZvaWQgY2xvZ2dpbmcgdXAgdGhlIHF1ZXVlIHdoZW4gdGhlIHVzZXIgc2Nyb2xscyBwYXN0IG1hbnkgZWxlbWVudHMuXG4gICAqL1xuICBoYW5kbGVDYW5jZWxUaHVtYm5haWwgPSAoZmlsZSkgPT4ge1xuICAgIGlmICghdGhpcy5vcHRzLndhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkKSB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgndGh1bWJuYWlsOmNhbmNlbCcsIGZpbGUpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlS2V5RG93bkluSW5saW5lID0gKGV2ZW50KSA9PiB7XG4gICAgLy8gVHJhcCBmb2N1cyBvbiB0YWIga2V5IHByZXNzLlxuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBUQUJfS0VZKSB0cmFwRm9jdXMuZm9ySW5saW5lKGV2ZW50LCB0aGlzLmdldFBsdWdpblN0YXRlKCkuYWN0aXZlT3ZlcmxheVR5cGUsIHRoaXMuZWwpXG4gIH1cblxuICAvLyBfX19XaHkgZG8gd2UgbGlzdGVuIHRvIHRoZSAncGFzdGUnIGV2ZW50IG9uIGEgZG9jdW1lbnQgaW5zdGVhZCBvZiBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX0gcHJvcCwgb3IgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScpP1xuICAvLyAgICBCZWNhdXNlIChhdCBsZWFzdCkgQ2hyb21lIGRvZXNuJ3QgaGFuZGxlIHBhc3RlIGlmIGZvY3VzIGlzIG9uIHNvbWUgYnV0dG9uLCBlLmcuICdNeSBEZXZpY2UnLlxuICAvLyAgICA9PiBUaGVyZWZvcmUsIHRoZSBiZXN0IG9wdGlvbiBpcyB0byBsaXN0ZW4gdG8gYWxsICdwYXN0ZScgZXZlbnRzLCBhbmQgb25seSByZWFjdCB0byB0aGVtIHdoZW4gd2UgYXJlIGZvY3VzZWQgb24gb3VyIHBhcnRpY3VsYXIgVXBweSBpbnN0YW5jZS5cbiAgLy8gX19fV2h5IGRvIHdlIHN0aWxsIG5lZWQgb25QYXN0ZT17cHJvcHMuaGFuZGxlUGFzdGV9IGZvciB0aGUgRGFzaGJvYXJkVWk/XG4gIC8vICAgIEJlY2F1c2UgaWYgd2UgY2xpY2sgb24gdGhlICdEcm9wIGZpbGVzIGhlcmUnIGNhcHRpb24gZS5nLiwgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIHdpbGwgYmUgJ2JvZHknLiBXaGljaCBtZWFucyBvdXIgc3RhbmRhcmQgZGV0ZXJtaW5hdGlvbiBvZiB3aGV0aGVyIHdlJ3JlIHBhc3RpbmcgaW50byBvdXIgVXBweSBpbnN0YW5jZSB3b24ndCB3b3JrLlxuICAvLyAgICA9PiBUaGVyZWZvcmUsIHdlIG5lZWQgYSB0cmFkaXRpb25hbCBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX0gaGFuZGxlciB0b28uXG4gIGhhbmRsZVBhc3RlT25Cb2R5ID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgaXNGb2N1c0luT3ZlcmxheSA9IHRoaXMuZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICBpZiAoaXNGb2N1c0luT3ZlcmxheSkge1xuICAgICAgdGhpcy5oYW5kbGVQYXN0ZShldmVudClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDb21wbGV0ZSA9ICh7IGZhaWxlZCB9KSA9PiB7XG4gICAgaWYgKHRoaXMub3B0cy5jbG9zZUFmdGVyRmluaXNoICYmIGZhaWxlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEFsbCB1cGxvYWRzIGFyZSBkb25lXG4gICAgICB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsKClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDYW5jZWxSZXN0b3JlID0gKCkgPT4ge1xuICAgIHRoaXMudXBweS5lbWl0KCdyZXN0b3JlLWNhbmNlbGVkJylcbiAgfVxuXG4gIF9vcGVuRmlsZUVkaXRvcldoZW5GaWxlc0FkZGVkID0gKGZpbGVzKSA9PiB7XG4gICAgY29uc3QgZmlyc3RGaWxlID0gZmlsZXNbMF1cbiAgICBpZiAodGhpcy5jYW5FZGl0RmlsZShmaXJzdEZpbGUpKSB7XG4gICAgICB0aGlzLm9wZW5GaWxlRWRpdG9yKGZpcnN0RmlsZSlcbiAgICB9XG4gIH1cblxuICBpbml0RXZlbnRzID0gKCkgPT4ge1xuICAgIC8vIE1vZGFsIG9wZW4gYnV0dG9uXG4gICAgaWYgKHRoaXMub3B0cy50cmlnZ2VyICYmICF0aGlzLm9wdHMuaW5saW5lKSB7XG4gICAgICBjb25zdCBzaG93TW9kYWxUcmlnZ2VyID0gZmluZEFsbERPTUVsZW1lbnRzKHRoaXMub3B0cy50cmlnZ2VyKVxuICAgICAgaWYgKHNob3dNb2RhbFRyaWdnZXIpIHtcbiAgICAgICAgc2hvd01vZGFsVHJpZ2dlci5mb3JFYWNoKHRyaWdnZXIgPT4gdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub3Blbk1vZGFsKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coJ0Rhc2hib2FyZCBtb2RhbCB0cmlnZ2VyIG5vdCBmb3VuZC4gTWFrZSBzdXJlIGB0cmlnZ2VyYCBpcyBzZXQgaW4gRGFzaGJvYXJkIG9wdGlvbnMsIHVubGVzcyB5b3UgYXJlIHBsYW5uaW5nIHRvIGNhbGwgYGRhc2hib2FyZC5vcGVuTW9kYWwoKWAgbWV0aG9kIHlvdXJzZWxmJywgJ3dhcm5pbmcnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhcnRMaXN0ZW5pbmdUb1Jlc2l6ZSgpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCB0aGlzLmhhbmRsZVBhc3RlT25Cb2R5KVxuXG4gICAgdGhpcy51cHB5Lm9uKCdwbHVnaW4tcmVtb3ZlJywgdGhpcy5yZW1vdmVUYXJnZXQpXG4gICAgdGhpcy51cHB5Lm9uKCdmaWxlLWFkZGVkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vbignZGFzaGJvYXJkOm1vZGFsLWNsb3NlZCcsIHRoaXMuaGlkZUFsbFBhbmVscylcbiAgICB0aGlzLnVwcHkub24oJ2ZpbGUtZWRpdG9yOmNvbXBsZXRlJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vbignY29tcGxldGUnLCB0aGlzLmhhbmRsZUNvbXBsZXRlKVxuXG4gICAgLy8gX19fV2h5IGZpcmUgb24gY2FwdHVyZT9cbiAgICAvLyAgICBCZWNhdXNlIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkgbmVlZHMgdG8gY2hhbmdlIGJlZm9yZSBvblVwZGF0ZSgpIGZpcmVzLlxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSwgdHJ1ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucmVjb3JkSWZGb2N1c2VkT25VcHB5UmVjZW50bHksIHRydWUpXG5cbiAgICBpZiAodGhpcy5vcHRzLmlubGluZSkge1xuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duSW5JbmxpbmUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5hdXRvT3BlbkZpbGVFZGl0b3IpIHtcbiAgICAgIHRoaXMudXBweS5vbignZmlsZXMtYWRkZWQnLCB0aGlzLl9vcGVuRmlsZUVkaXRvcldoZW5GaWxlc0FkZGVkKVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUV2ZW50cyA9ICgpID0+IHtcbiAgICBjb25zdCBzaG93TW9kYWxUcmlnZ2VyID0gZmluZEFsbERPTUVsZW1lbnRzKHRoaXMub3B0cy50cmlnZ2VyKVxuICAgIGlmICghdGhpcy5vcHRzLmlubGluZSAmJiBzaG93TW9kYWxUcmlnZ2VyKSB7XG4gICAgICBzaG93TW9kYWxUcmlnZ2VyLmZvckVhY2godHJpZ2dlciA9PiB0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vcGVuTW9kYWwpKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvUmVzaXplKClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGVPbkJvZHkpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmhhbmRsZVBvcFN0YXRlLCBmYWxzZSlcbiAgICB0aGlzLnVwcHkub2ZmKCdwbHVnaW4tcmVtb3ZlJywgdGhpcy5yZW1vdmVUYXJnZXQpXG4gICAgdGhpcy51cHB5Lm9mZignZmlsZS1hZGRlZCcsIHRoaXMuaGlkZUFsbFBhbmVscylcbiAgICB0aGlzLnVwcHkub2ZmKCdkYXNoYm9hcmQ6bW9kYWwtY2xvc2VkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vZmYoJ2ZpbGUtZWRpdG9yOmNvbXBsZXRlJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vZmYoJ2NvbXBsZXRlJywgdGhpcy5oYW5kbGVDb21wbGV0ZSlcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucmVjb3JkSWZGb2N1c2VkT25VcHB5UmVjZW50bHkpXG5cbiAgICBpZiAodGhpcy5vcHRzLmlubGluZSkge1xuICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duSW5JbmxpbmUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5hdXRvT3BlbkZpbGVFZGl0b3IpIHtcbiAgICAgIHRoaXMudXBweS5vZmYoJ2ZpbGVzLWFkZGVkJywgdGhpcy5fb3BlbkZpbGVFZGl0b3JXaGVuRmlsZXNBZGRlZClcbiAgICB9XG4gIH1cblxuICBzdXBlckZvY3VzT25FYWNoVXBkYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGlzRm9jdXNJblVwcHkgPSB0aGlzLmVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG4gICAgLy8gV2hlbiBmb2N1cyBpcyBsb3N0IG9uIHRoZSBwYWdlICg9PSBmb2N1cyBpcyBvbiBib2R5IGZvciBtb3N0IGJyb3dzZXJzLCBvciBmb2N1cyBpcyBudWxsIGZvciBJRTExKVxuICAgIGNvbnN0IGlzRm9jdXNOb3doZXJlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBudWxsXG4gICAgY29uc3QgaXNJbmZvcm1lckhpZGRlbiA9IHRoaXMudXBweS5nZXRTdGF0ZSgpLmluZm8uaXNIaWRkZW5cbiAgICBjb25zdCBpc01vZGFsID0gIXRoaXMub3B0cy5pbmxpbmVcblxuICAgIGlmIChcbiAgICAgIC8vIElmIHVwZGF0ZSBpcyBjb25uZWN0ZWQgdG8gc2hvd2luZyB0aGUgSW5mb3JtZXIgLSBsZXQgdGhlIHNjcmVlbiByZWFkZXIgY2FsbWx5IHJlYWQgaXQuXG4gICAgICBpc0luZm9ybWVySGlkZGVuXG4gICAgICAmJiAoXG4gICAgICAgIC8vIElmIHdlIGFyZSBpbiBhIG1vZGFsIC0gYWx3YXlzIHN1cGVyZm9jdXMgd2l0aG91dCBjb25jZXJuIGZvciBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGFnZSAodXNlciBpcyB1bmxpa2VseSB0byB3YW50IHRvIGludGVyYWN0IHdpdGggdGhlIHJlc3Qgb2YgdGhlIHBhZ2UpXG4gICAgICAgIGlzTW9kYWxcbiAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgaW5zaWRlIG9mIFVwcHksIG9yXG4gICAgICAgIHx8IGlzRm9jdXNJblVwcHlcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBmb2N1c2VkIG9uIGFueXRoaW5nIEJVVCB3ZSBoYXZlIGFscmVhZHksIGF0IGxlYXN0IG9uY2UsIGZvY3VzZWQgb24gdXBweVxuICAgICAgICAvLyAgIDEuIFdlIGZvY3VzIHdoZW4gaXNGb2N1c05vd2hlcmUsIGJlY2F1c2Ugd2hlbiB0aGUgZWxlbWVudCB3ZSB3ZXJlIGZvY3VzZWQgb24gZGlzYXBwZWFycyAoZS5nLiBhbiBvdmVybGF5KSwgLSBmb2N1cyBnZXRzIGxvc3QuIElmIHVzZXIgaXMgdHlwaW5nIHNvbWV0aGluZyBzb21ld2hlcmUgZWxzZSBvbiB0aGUgcGFnZSwgLSBmb2N1cyB3b24ndCBiZSAnbm93aGVyZScuXG4gICAgICAgIC8vICAgMi4gV2Ugb25seSBmb2N1cyB3aGVuIGZvY3VzIGlzIG5vd2hlcmUgQU5EIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHksIHRvIGF2b2lkIGZvY3VzIGp1bXBzIGlmIHdlIGRvIHNvbWV0aGluZyBlbHNlIG9uIHRoZSBwYWdlLlxuICAgICAgICAvLyAgIFtQcmFjdGljYWwgY2hlY2tdIFdpdGhvdXQgJyYmIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHknLCBpbiBTYWZhcmksIGluIGlubGluZSBtb2RlLCB3aGVuIGZpbGUgaXMgdXBsb2FkaW5nLCAtIG5hdmlnYXRlIHZpYSB0YWIgdG8gdGhlIGNoZWNrYm94LCB0cnkgdG8gcHJlc3Mgc3BhY2UgbXVsdGlwbGUgdGltZXMuIEZvY3VzIHdpbGwganVtcCB0byBVcHB5LlxuICAgICAgICB8fCAoaXNGb2N1c05vd2hlcmUgJiYgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSlcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMuc3VwZXJGb2N1cyh0aGlzLmVsLCB0aGlzLmdldFBsdWdpblN0YXRlKCkuYWN0aXZlT3ZlcmxheVR5cGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3VwZXJGb2N1cy5jYW5jZWwoKVxuICAgIH1cbiAgfVxuXG4gIGFmdGVyVXBkYXRlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZWQgJiYgIXRoaXMuZGFzaGJvYXJkSXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlQWxsRm9jdXNhYmxlRWxlbWVudHModHJ1ZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVkICYmIHRoaXMuZGFzaGJvYXJkSXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlQWxsRm9jdXNhYmxlRWxlbWVudHMoZmFsc2UpXG4gICAgfVxuXG4gICAgdGhpcy5zdXBlckZvY3VzT25FYWNoVXBkYXRlKClcbiAgfVxuXG4gIGNhbmNlbFVwbG9hZCA9IChmaWxlSUQpID0+IHtcbiAgICB0aGlzLnVwcHkucmVtb3ZlRmlsZShmaWxlSUQpXG4gIH1cblxuICBzYXZlRmlsZUNhcmQgPSAobWV0YSwgZmlsZUlEKSA9PiB7XG4gICAgdGhpcy51cHB5LnNldEZpbGVNZXRhKGZpbGVJRCwgbWV0YSlcbiAgICB0aGlzLnRvZ2dsZUZpbGVDYXJkKGZhbHNlLCBmaWxlSUQpXG4gIH1cblxuICBfYXR0YWNoUmVuZGVyRnVuY3Rpb25Ub1RhcmdldCA9ICh0YXJnZXQpID0+IHtcbiAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRhcmdldC5pZClcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaWNvbjogcGx1Z2luLmljb24gfHwgdGhpcy5vcHRzLmRlZmF1bHRQaWNrZXJJY29uLFxuICAgICAgcmVuZGVyOiBwbHVnaW4ucmVuZGVyLFxuICAgIH1cbiAgfVxuXG4gIF9pc1RhcmdldFN1cHBvcnRlZCA9ICh0YXJnZXQpID0+IHtcbiAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRhcmdldC5pZClcbiAgICAvLyBJZiB0aGUgcGx1Z2luIGRvZXMgbm90IHByb3ZpZGUgYSBgc3VwcG9ydGVkYCBjaGVjaywgYXNzdW1lIHRoZSBwbHVnaW4gd29ya3MgZXZlcnl3aGVyZS5cbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pc1N1cHBvcnRlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbi5pc1N1cHBvcnRlZCgpXG4gIH1cblxuICBfZ2V0QWNxdWlyZXJzID0gbWVtb2l6ZSgodGFyZ2V0cykgPT4ge1xuICAgIHJldHVybiB0YXJnZXRzXG4gICAgICAuZmlsdGVyKHRhcmdldCA9PiB0YXJnZXQudHlwZSA9PT0gJ2FjcXVpcmVyJyAmJiB0aGlzLl9pc1RhcmdldFN1cHBvcnRlZCh0YXJnZXQpKVxuICAgICAgLm1hcCh0aGlzLl9hdHRhY2hSZW5kZXJGdW5jdGlvblRvVGFyZ2V0KVxuICB9KVxuXG4gIF9nZXRQcm9ncmVzc0luZGljYXRvcnMgPSBtZW1vaXplKCh0YXJnZXRzKSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldHNcbiAgICAgIC5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC50eXBlID09PSAncHJvZ3Jlc3NpbmRpY2F0b3InKVxuICAgICAgLm1hcCh0aGlzLl9hdHRhY2hSZW5kZXJGdW5jdGlvblRvVGFyZ2V0KVxuICB9KVxuXG4gIF9nZXRFZGl0b3JzID0gbWVtb2l6ZSgodGFyZ2V0cykgPT4ge1xuICAgIHJldHVybiB0YXJnZXRzXG4gICAgICAuZmlsdGVyKHRhcmdldCA9PiB0YXJnZXQudHlwZSA9PT0gJ2VkaXRvcicpXG4gICAgICAubWFwKHRoaXMuX2F0dGFjaFJlbmRlckZ1bmN0aW9uVG9UYXJnZXQpXG4gIH0pXG5cbiAgcmVuZGVyID0gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgcGx1Z2luU3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCB7IGZpbGVzLCBjYXBhYmlsaXRpZXMsIGFsbG93TmV3VXBsb2FkIH0gPSBzdGF0ZVxuXG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIENvcmUsIHRvIHNoYXJlIGJldHdlZW4gU3RhdHVzIEJhciBhbmQgRGFzaGJvYXJkXG4gICAgLy8gKGFuZCBhbnkgb3RoZXIgcGx1Z2luIHRoYXQgbWlnaHQgbmVlZCBpdCwgdG9vKVxuICAgIGNvbnN0IG5ld0ZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGNvbnN0IHVwbG9hZFN0YXJ0ZWRGaWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGNvbnN0IHBhdXNlZEZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGVzW2ZpbGVdLmlzUGF1c2VkXG4gICAgfSlcblxuICAgIGNvbnN0IGNvbXBsZXRlRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGVcbiAgICB9KVxuXG4gICAgY29uc3QgZXJyb3JlZEZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGVzW2ZpbGVdLmVycm9yXG4gICAgfSlcblxuICAgIGNvbnN0IGluUHJvZ3Jlc3NGaWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhZmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGVcbiAgICAgICAgICAgICAmJiBmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGNvbnN0IGluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcyA9IGluUHJvZ3Jlc3NGaWxlcy5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhZmlsZXNbZmlsZV0uaXNQYXVzZWRcbiAgICB9KVxuXG4gICAgY29uc3QgcHJvY2Vzc2luZ0ZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGVzW2ZpbGVdLnByb2dyZXNzLnByZXByb2Nlc3MgfHwgZmlsZXNbZmlsZV0ucHJvZ3Jlc3MucG9zdHByb2Nlc3NcbiAgICB9KVxuXG4gICAgY29uc3QgaXNVcGxvYWRTdGFydGVkID0gdXBsb2FkU3RhcnRlZEZpbGVzLmxlbmd0aCA+IDBcblxuICAgIGNvbnN0IGlzQWxsQ29tcGxldGUgPSBzdGF0ZS50b3RhbFByb2dyZXNzID09PSAxMDBcbiAgICAgICYmIGNvbXBsZXRlRmlsZXMubGVuZ3RoID09PSBPYmplY3Qua2V5cyhmaWxlcykubGVuZ3RoXG4gICAgICAmJiBwcm9jZXNzaW5nRmlsZXMubGVuZ3RoID09PSAwXG5cbiAgICBjb25zdCBpc0FsbEVycm9yZWQgPSBpc1VwbG9hZFN0YXJ0ZWRcbiAgICAgICYmIGVycm9yZWRGaWxlcy5sZW5ndGggPT09IHVwbG9hZFN0YXJ0ZWRGaWxlcy5sZW5ndGhcblxuICAgIGNvbnN0IGlzQWxsUGF1c2VkID0gaW5Qcm9ncmVzc0ZpbGVzLmxlbmd0aCAhPT0gMFxuICAgICAgJiYgcGF1c2VkRmlsZXMubGVuZ3RoID09PSBpblByb2dyZXNzRmlsZXMubGVuZ3RoXG5cbiAgICBjb25zdCBhY3F1aXJlcnMgPSB0aGlzLl9nZXRBY3F1aXJlcnMocGx1Z2luU3RhdGUudGFyZ2V0cylcbiAgICBjb25zdCBwcm9ncmVzc2luZGljYXRvcnMgPSB0aGlzLl9nZXRQcm9ncmVzc0luZGljYXRvcnMocGx1Z2luU3RhdGUudGFyZ2V0cylcbiAgICBjb25zdCBlZGl0b3JzID0gdGhpcy5fZ2V0RWRpdG9ycyhwbHVnaW5TdGF0ZS50YXJnZXRzKVxuXG4gICAgbGV0IHRoZW1lXG4gICAgaWYgKHRoaXMub3B0cy50aGVtZSA9PT0gJ2F1dG8nKSB7XG4gICAgICB0aGVtZSA9IGNhcGFiaWxpdGllcy5kYXJrTW9kZSA/ICdkYXJrJyA6ICdsaWdodCdcbiAgICB9IGVsc2Uge1xuICAgICAgdGhlbWUgPSB0aGlzLm9wdHMudGhlbWVcbiAgICB9XG5cbiAgICBpZiAoWydmaWxlcycsICdmb2xkZXJzJywgJ2JvdGgnXS5pbmRleE9mKHRoaXMub3B0cy5maWxlTWFuYWdlclNlbGVjdGlvblR5cGUpIDwgMCkge1xuICAgICAgdGhpcy5vcHRzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZSA9ICdmaWxlcydcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuc3VwcG9ydGVkIG9wdGlvbiBmb3IgXCJmaWxlTWFuYWdlclNlbGVjdGlvblR5cGVcIi4gVXNpbmcgZGVmYXVsdCBvZiBcIiR7dGhpcy5vcHRzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZX1cIi5gKVxuICAgIH1cblxuICAgIHJldHVybiBEYXNoYm9hcmRVSSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGlzSGlkZGVuOiBwbHVnaW5TdGF0ZS5pc0hpZGRlbixcbiAgICAgIGZpbGVzLFxuICAgICAgbmV3RmlsZXMsXG4gICAgICB1cGxvYWRTdGFydGVkRmlsZXMsXG4gICAgICBjb21wbGV0ZUZpbGVzLFxuICAgICAgZXJyb3JlZEZpbGVzLFxuICAgICAgaW5Qcm9ncmVzc0ZpbGVzLFxuICAgICAgaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzLFxuICAgICAgcHJvY2Vzc2luZ0ZpbGVzLFxuICAgICAgaXNVcGxvYWRTdGFydGVkLFxuICAgICAgaXNBbGxDb21wbGV0ZSxcbiAgICAgIGlzQWxsRXJyb3JlZCxcbiAgICAgIGlzQWxsUGF1c2VkLFxuICAgICAgdG90YWxGaWxlQ291bnQ6IE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGgsXG4gICAgICB0b3RhbFByb2dyZXNzOiBzdGF0ZS50b3RhbFByb2dyZXNzLFxuICAgICAgYWxsb3dOZXdVcGxvYWQsXG4gICAgICBhY3F1aXJlcnMsXG4gICAgICB0aGVtZSxcbiAgICAgIGRpc2FibGVkOiB0aGlzLm9wdHMuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlTG9jYWxGaWxlczogdGhpcy5vcHRzLmRpc2FibGVMb2NhbEZpbGVzLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLm9wdHMuZGlyZWN0aW9uLFxuICAgICAgYWN0aXZlUGlja2VyUGFuZWw6IHBsdWdpblN0YXRlLmFjdGl2ZVBpY2tlclBhbmVsLFxuICAgICAgc2hvd0ZpbGVFZGl0b3I6IHBsdWdpblN0YXRlLnNob3dGaWxlRWRpdG9yLFxuICAgICAgZGlzYWJsZUFsbEZvY3VzYWJsZUVsZW1lbnRzOiB0aGlzLmRpc2FibGVBbGxGb2N1c2FibGVFbGVtZW50cyxcbiAgICAgIGFuaW1hdGVPcGVuQ2xvc2U6IHRoaXMub3B0cy5hbmltYXRlT3BlbkNsb3NlLFxuICAgICAgaXNDbG9zaW5nOiBwbHVnaW5TdGF0ZS5pc0Nsb3NpbmcsXG4gICAgICBnZXRQbHVnaW46IHRoaXMudXBweS5nZXRQbHVnaW4sXG4gICAgICBwcm9ncmVzc2luZGljYXRvcnMsXG4gICAgICBlZGl0b3JzLFxuICAgICAgYXV0b1Byb2NlZWQ6IHRoaXMudXBweS5vcHRzLmF1dG9Qcm9jZWVkLFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBjbG9zZU1vZGFsOiB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsLFxuICAgICAgaGFuZGxlQ2xpY2tPdXRzaWRlOiB0aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSxcbiAgICAgIGhhbmRsZUlucHV0Q2hhbmdlOiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlLFxuICAgICAgaGFuZGxlUGFzdGU6IHRoaXMuaGFuZGxlUGFzdGUsXG4gICAgICBpbmxpbmU6IHRoaXMub3B0cy5pbmxpbmUsXG4gICAgICBzaG93UGFuZWw6IHRoaXMuc2hvd1BhbmVsLFxuICAgICAgaGlkZUFsbFBhbmVsczogdGhpcy5oaWRlQWxsUGFuZWxzLFxuICAgICAgbG9nOiB0aGlzLnVwcHkubG9nLFxuICAgICAgaTE4bjogdGhpcy5pMThuLFxuICAgICAgaTE4bkFycmF5OiB0aGlzLmkxOG5BcnJheSxcbiAgICAgIHJlbW92ZUZpbGU6IHRoaXMudXBweS5yZW1vdmVGaWxlLFxuICAgICAgdXBweTogdGhpcy51cHB5LFxuICAgICAgaW5mbzogdGhpcy51cHB5LmluZm8sXG4gICAgICBub3RlOiB0aGlzLm9wdHMubm90ZSxcbiAgICAgIHJlY292ZXJlZFN0YXRlOiBzdGF0ZS5yZWNvdmVyZWRTdGF0ZSxcbiAgICAgIG1ldGFGaWVsZHM6IHBsdWdpblN0YXRlLm1ldGFGaWVsZHMsXG4gICAgICByZXN1bWFibGVVcGxvYWRzOiBjYXBhYmlsaXRpZXMucmVzdW1hYmxlVXBsb2FkcyB8fCBmYWxzZSxcbiAgICAgIGluZGl2aWR1YWxDYW5jZWxsYXRpb246IGNhcGFiaWxpdGllcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uLFxuICAgICAgaXNNb2JpbGVEZXZpY2U6IGNhcGFiaWxpdGllcy5pc01vYmlsZURldmljZSxcbiAgICAgIHBhdXNlVXBsb2FkOiB0aGlzLnVwcHkucGF1c2VSZXN1bWUsXG4gICAgICByZXRyeVVwbG9hZDogdGhpcy51cHB5LnJldHJ5VXBsb2FkLFxuICAgICAgY2FuY2VsVXBsb2FkOiB0aGlzLmNhbmNlbFVwbG9hZCxcbiAgICAgIGNhbmNlbEFsbDogdGhpcy51cHB5LmNhbmNlbEFsbCxcbiAgICAgIGZpbGVDYXJkRm9yOiBwbHVnaW5TdGF0ZS5maWxlQ2FyZEZvcixcbiAgICAgIHRvZ2dsZUZpbGVDYXJkOiB0aGlzLnRvZ2dsZUZpbGVDYXJkLFxuICAgICAgdG9nZ2xlQWRkRmlsZXNQYW5lbDogdGhpcy50b2dnbGVBZGRGaWxlc1BhbmVsLFxuICAgICAgc2hvd0FkZEZpbGVzUGFuZWw6IHBsdWdpblN0YXRlLnNob3dBZGRGaWxlc1BhbmVsLFxuICAgICAgc2F2ZUZpbGVDYXJkOiB0aGlzLnNhdmVGaWxlQ2FyZCxcbiAgICAgIG9wZW5GaWxlRWRpdG9yOiB0aGlzLm9wZW5GaWxlRWRpdG9yLFxuICAgICAgY2FuRWRpdEZpbGU6IHRoaXMuY2FuRWRpdEZpbGUsXG4gICAgICB3aWR0aDogdGhpcy5vcHRzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLm9wdHMuaGVpZ2h0LFxuICAgICAgc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQ6IHRoaXMub3B0cy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdCxcbiAgICAgIGZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZTogdGhpcy5vcHRzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZSxcbiAgICAgIHByb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweTogdGhpcy5vcHRzLnByb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweSxcbiAgICAgIGhpZGVDYW5jZWxCdXR0b246IHRoaXMub3B0cy5oaWRlQ2FuY2VsQnV0dG9uLFxuICAgICAgaGlkZVJldHJ5QnV0dG9uOiB0aGlzLm9wdHMuaGlkZVJldHJ5QnV0dG9uLFxuICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uLFxuICAgICAgc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGU6IHRoaXMub3B0cy5zaG93UmVtb3ZlQnV0dG9uQWZ0ZXJDb21wbGV0ZSxcbiAgICAgIGNvbnRhaW5lcldpZHRoOiBwbHVnaW5TdGF0ZS5jb250YWluZXJXaWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodDogcGx1Z2luU3RhdGUuY29udGFpbmVySGVpZ2h0LFxuICAgICAgYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGU6IHBsdWdpblN0YXRlLmFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlLFxuICAgICAgaXNUYXJnZXRET01FbDogdGhpcy5pc1RhcmdldERPTUVsLFxuICAgICAgcGFyZW50RWxlbWVudDogdGhpcy5lbCxcbiAgICAgIGFsbG93ZWRGaWxlVHlwZXM6IHRoaXMudXBweS5vcHRzLnJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzLFxuICAgICAgbWF4TnVtYmVyT2ZGaWxlczogdGhpcy51cHB5Lm9wdHMucmVzdHJpY3Rpb25zLm1heE51bWJlck9mRmlsZXMsXG4gICAgICBzaG93U2VsZWN0ZWRGaWxlczogdGhpcy5vcHRzLnNob3dTZWxlY3RlZEZpbGVzLFxuICAgICAgaGFuZGxlQ2FuY2VsUmVzdG9yZTogdGhpcy5oYW5kbGVDYW5jZWxSZXN0b3JlLFxuICAgICAgaGFuZGxlUmVxdWVzdFRodW1ibmFpbDogdGhpcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsLFxuICAgICAgaGFuZGxlQ2FuY2VsVGh1bWJuYWlsOiB0aGlzLmhhbmRsZUNhbmNlbFRodW1ibmFpbCxcbiAgICAgIC8vIGRyYWcgcHJvcHNcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBwbHVnaW5TdGF0ZS5pc0RyYWdnaW5nT3ZlcixcbiAgICAgIGhhbmRsZURyYWdPdmVyOiB0aGlzLmhhbmRsZURyYWdPdmVyLFxuICAgICAgaGFuZGxlRHJhZ0xlYXZlOiB0aGlzLmhhbmRsZURyYWdMZWF2ZSxcbiAgICAgIGhhbmRsZURyb3A6IHRoaXMuaGFuZGxlRHJvcCxcbiAgICB9KVxuICB9XG5cbiAgZGlzY292ZXJQcm92aWRlclBsdWdpbnMgPSAoKSA9PiB7XG4gICAgdGhpcy51cHB5Lml0ZXJhdGVQbHVnaW5zKChwbHVnaW4pID0+IHtcbiAgICAgIGlmIChwbHVnaW4gJiYgIXBsdWdpbi50YXJnZXQgJiYgcGx1Z2luLm9wdHMgJiYgcGx1Z2luLm9wdHMudGFyZ2V0ID09PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuYWRkVGFyZ2V0KHBsdWdpbilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgLy8gU2V0IHRoZSB0ZXh0IGRpcmVjdGlvbiBpZiB0aGUgcGFnZSBoYXMgbm90IGRlZmluZWQgb25lLlxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsXG4gICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0VGV4dERpcmVjdGlvbihlbGVtZW50KVxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICBlbGVtZW50LmRpciA9ICdsdHInXG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbCA9ICgpID0+IHtcbiAgICAvLyBTZXQgZGVmYXVsdCBzdGF0ZSBmb3IgRGFzaGJvYXJkXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgIGZpbGVDYXJkRm9yOiBudWxsLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6IG51bGwsXG4gICAgICBzaG93QWRkRmlsZXNQYW5lbDogZmFsc2UsXG4gICAgICBhY3RpdmVQaWNrZXJQYW5lbDogZmFsc2UsXG4gICAgICBzaG93RmlsZUVkaXRvcjogZmFsc2UsXG4gICAgICBtZXRhRmllbGRzOiB0aGlzLm9wdHMubWV0YUZpZWxkcyxcbiAgICAgIHRhcmdldHM6IFtdLFxuICAgICAgLy8gV2UnbGwgbWFrZSB0aGVtIHZpc2libGUgb25jZSAuY29udGFpbmVyV2lkdGggaXMgZGV0ZXJtaW5lZFxuICAgICAgYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGU6IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZ092ZXI6IGZhbHNlLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IGlubGluZSwgY2xvc2VBZnRlckZpbmlzaCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKGlubGluZSAmJiBjbG9zZUFmdGVyRmluaXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tEYXNoYm9hcmRdIGBjbG9zZUFmdGVyRmluaXNoOiB0cnVlYCBjYW5ub3QgYmUgdXNlZCBvbiBhbiBpbmxpbmUgRGFzaGJvYXJkLCBiZWNhdXNlIGFuIGlubGluZSBEYXNoYm9hcmQgY2Fubm90IGJlIGNsb3NlZCBhdCBhbGwuIEVpdGhlciBzZXQgYGlubGluZTogZmFsc2VgLCBvciBkaXNhYmxlIHRoZSBgY2xvc2VBZnRlckZpbmlzaGAgb3B0aW9uLicpXG4gICAgfVxuXG4gICAgY29uc3QgeyBhbGxvd011bHRpcGxlVXBsb2FkcyB9ID0gdGhpcy51cHB5Lm9wdHNcbiAgICBpZiAoYWxsb3dNdWx0aXBsZVVwbG9hZHMgJiYgY2xvc2VBZnRlckZpbmlzaCkge1xuICAgICAgdGhpcy51cHB5LmxvZygnW0Rhc2hib2FyZF0gV2hlbiB1c2luZyBgY2xvc2VBZnRlckZpbmlzaGAsIHdlIHJlY29tbWVuZGVkIHNldHRpbmcgdGhlIGBhbGxvd011bHRpcGxlVXBsb2Fkc2Agb3B0aW9uIHRvIGBmYWxzZWAgaW4gdGhlIFVwcHkgY29uc3RydWN0b3IuIFNlZSBodHRwczovL3VwcHkuaW8vZG9jcy91cHB5LyNhbGxvd011bHRpcGxlVXBsb2Fkcy10cnVlJywgJ3dhcm5pbmcnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLm9wdHNcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG5cbiAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5vcHRzLnBsdWdpbnMgfHwgW11cbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbklEKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHBsdWdpbklEKVxuICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICBwbHVnaW4ubW91bnQodGhpcywgcGx1Z2luKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlU3RhdHVzQmFyKSB7XG4gICAgICB0aGlzLnVwcHkudXNlKFN0YXR1c0Jhciwge1xuICAgICAgICBpZDogYCR7dGhpcy5pZH06U3RhdHVzQmFyYCxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICBoaWRlVXBsb2FkQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVVwbG9hZEJ1dHRvbixcbiAgICAgICAgaGlkZVJldHJ5QnV0dG9uOiB0aGlzLm9wdHMuaGlkZVJldHJ5QnV0dG9uLFxuICAgICAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b246IHRoaXMub3B0cy5oaWRlUGF1c2VSZXN1bWVCdXR0b24sXG4gICAgICAgIGhpZGVDYW5jZWxCdXR0b246IHRoaXMub3B0cy5oaWRlQ2FuY2VsQnV0dG9uLFxuICAgICAgICBzaG93UHJvZ3Jlc3NEZXRhaWxzOiB0aGlzLm9wdHMuc2hvd1Byb2dyZXNzRGV0YWlscyxcbiAgICAgICAgaGlkZUFmdGVyRmluaXNoOiB0aGlzLm9wdHMuaGlkZVByb2dyZXNzQWZ0ZXJGaW5pc2gsXG4gICAgICAgIGxvY2FsZTogdGhpcy5vcHRzLmxvY2FsZSxcbiAgICAgICAgZG9uZUJ1dHRvbkhhbmRsZXI6IHRoaXMub3B0cy5kb25lQnV0dG9uSGFuZGxlcixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZUluZm9ybWVyKSB7XG4gICAgICB0aGlzLnVwcHkudXNlKEluZm9ybWVyLCB7XG4gICAgICAgIGlkOiBgJHt0aGlzLmlkfTpJbmZvcm1lcmAsXG4gICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVRodW1ibmFpbEdlbmVyYXRvcikge1xuICAgICAgdGhpcy51cHB5LnVzZShUaHVtYm5haWxHZW5lcmF0b3IsIHtcbiAgICAgICAgaWQ6IGAke3RoaXMuaWR9OlRodW1ibmFpbEdlbmVyYXRvcmAsXG4gICAgICAgIHRodW1ibmFpbFdpZHRoOiB0aGlzLm9wdHMudGh1bWJuYWlsV2lkdGgsXG4gICAgICAgIHRodW1ibmFpbFR5cGU6IHRoaXMub3B0cy50aHVtYm5haWxUeXBlLFxuICAgICAgICB3YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZDogdGhpcy5vcHRzLndhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkLFxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBibG9jayBvbiB0aHVtYm5haWxzLCB3ZSBjYW4gbGF6aWx5IGdlbmVyYXRlIHRoZW1cbiAgICAgICAgbGF6eTogIXRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gRGFyayBNb2RlIC8gdGhlbWVcbiAgICB0aGlzLmRhcmtNb2RlTWVkaWFRdWVyeSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubWF0Y2hNZWRpYSlcbiAgICAgID8gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKVxuICAgICAgOiBudWxsXG5cbiAgICBjb25zdCBpc0RhcmtNb2RlT25Gcm9tVGhlU3RhcnQgPSB0aGlzLmRhcmtNb2RlTWVkaWFRdWVyeSA/IHRoaXMuZGFya01vZGVNZWRpYVF1ZXJ5Lm1hdGNoZXMgOiBmYWxzZVxuICAgIHRoaXMudXBweS5sb2coYFtEYXNoYm9hcmRdIERhcmsgbW9kZSBpcyAke2lzRGFya01vZGVPbkZyb21UaGVTdGFydCA/ICdvbicgOiAnb2ZmJ31gKVxuICAgIHRoaXMuc2V0RGFya01vZGVDYXBhYmlsaXR5KGlzRGFya01vZGVPbkZyb21UaGVTdGFydClcblxuICAgIGlmICh0aGlzLm9wdHMudGhlbWUgPT09ICdhdXRvJykge1xuICAgICAgdGhpcy5kYXJrTW9kZU1lZGlhUXVlcnkuYWRkTGlzdGVuZXIodGhpcy5oYW5kbGVTeXN0ZW1EYXJrTW9kZUNoYW5nZSlcbiAgICB9XG5cbiAgICB0aGlzLmRpc2NvdmVyUHJvdmlkZXJQbHVnaW5zKClcbiAgICB0aGlzLmluaXRFdmVudHMoKVxuICB9XG5cbiAgdW5pbnN0YWxsID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVJbmZvcm1lcikge1xuICAgICAgY29uc3QgaW5mb3JtZXIgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OkluZm9ybWVyYClcbiAgICAgIC8vIENoZWNraW5nIGlmIHRoaXMgcGx1Z2luIGV4aXN0cywgaW4gY2FzZSBpdCB3YXMgcmVtb3ZlZCBieSB1cHB5LWNvcmVcbiAgICAgIC8vIGJlZm9yZSB0aGUgRGFzaGJvYXJkIHdhcy5cbiAgICAgIGlmIChpbmZvcm1lcikgdGhpcy51cHB5LnJlbW92ZVBsdWdpbihpbmZvcm1lcilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlU3RhdHVzQmFyKSB7XG4gICAgICBjb25zdCBzdGF0dXNCYXIgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OlN0YXR1c0JhcmApXG4gICAgICBpZiAoc3RhdHVzQmFyKSB0aGlzLnVwcHkucmVtb3ZlUGx1Z2luKHN0YXR1c0JhcilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlVGh1bWJuYWlsR2VuZXJhdG9yKSB7XG4gICAgICBjb25zdCB0aHVtYm5haWwgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OlRodW1ibmFpbEdlbmVyYXRvcmApXG4gICAgICBpZiAodGh1bWJuYWlsKSB0aGlzLnVwcHkucmVtb3ZlUGx1Z2luKHRodW1ibmFpbClcbiAgICB9XG5cbiAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5vcHRzLnBsdWdpbnMgfHwgW11cbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbklEKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHBsdWdpbklEKVxuICAgICAgaWYgKHBsdWdpbikgcGx1Z2luLnVubW91bnQoKVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5vcHRzLnRoZW1lID09PSAnYXV0bycpIHtcbiAgICAgIHRoaXMuZGFya01vZGVNZWRpYVF1ZXJ5LnJlbW92ZUxpc3RlbmVyKHRoaXMuaGFuZGxlU3lzdGVtRGFya01vZGVDaGFuZ2UpXG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50KClcbiAgICB0aGlzLnJlbW92ZUV2ZW50cygpXG4gIH1cbn1cbiIsIi8qKlxuICogQ29waWVzIHRleHQgdG8gY2xpcGJvYXJkIGJ5IGNyZWF0aW5nIGFuIGFsbW9zdCBpbnZpc2libGUgdGV4dGFyZWEsXG4gKiBhZGRpbmcgdGV4dCB0aGVyZSwgdGhlbiBydW5uaW5nIGV4ZWNDb21tYW5kKCdjb3B5JykuXG4gKiBGYWxscyBiYWNrIHRvIHByb21wdCgpIHdoZW4gdGhlIGVhc3kgd2F5IGZhaWxzIChoZWxsbywgU2FmYXJpISlcbiAqIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzA4MTAzMjJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFRvQ29weVxuICogQHBhcmFtIHtzdHJpbmd9IGZhbGxiYWNrU3RyaW5nXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQgKHRleHRUb0NvcHksIGZhbGxiYWNrU3RyaW5nKSB7XG4gIGZhbGxiYWNrU3RyaW5nID0gZmFsbGJhY2tTdHJpbmcgfHwgJ0NvcHkgdGhlIFVSTCBiZWxvdydcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCB0ZXh0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICB0ZXh0QXJlYS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgd2lkdGg6ICcyZW0nLFxuICAgICAgaGVpZ2h0OiAnMmVtJyxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgIGJveFNoYWRvdzogJ25vbmUnLFxuICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcbiAgICB9KVxuXG4gICAgdGV4dEFyZWEudmFsdWUgPSB0ZXh0VG9Db3B5XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXh0QXJlYSlcbiAgICB0ZXh0QXJlYS5zZWxlY3QoKVxuXG4gICAgY29uc3QgbWFnaWNDb3B5RmFpbGVkID0gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0QXJlYSlcbiAgICAgIHdpbmRvdy5wcm9tcHQoZmFsbGJhY2tTdHJpbmcsIHRleHRUb0NvcHkpXG4gICAgICByZXNvbHZlKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3VjY2Vzc2Z1bCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5JylcbiAgICAgIGlmICghc3VjY2Vzc2Z1bCkge1xuICAgICAgICByZXR1cm4gbWFnaWNDb3B5RmFpbGVkKCdjb3B5IGNvbW1hbmQgdW5hdmFpbGFibGUnKVxuICAgICAgfVxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0QXJlYSlcbiAgICAgIHJldHVybiByZXNvbHZlKClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpXG4gICAgICByZXR1cm4gbWFnaWNDb3B5RmFpbGVkKGVycilcbiAgICB9XG4gIH0pXG59XG4iLCJjb25zdCBkZWJvdW5jZSA9IHJlcXVpcmUoJ2xvZGFzaC5kZWJvdW5jZScpXG5jb25zdCBGT0NVU0FCTEVfRUxFTUVOVFMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvRk9DVVNBQkxFX0VMRU1FTlRTJylcbmNvbnN0IGdldEFjdGl2ZU92ZXJsYXlFbCA9IHJlcXVpcmUoJy4vZ2V0QWN0aXZlT3ZlcmxheUVsJylcblxuLypcbiAgRm9jdXNlcyBvbiBzb21lIGVsZW1lbnQgaW4gdGhlIGN1cnJlbnRseSB0b3Btb3N0IG92ZXJsYXkuXG5cbiAgMS4gSWYgdGhlcmUgYXJlIHNvbWUgW2RhdGEtdXBweS1zdXBlci1mb2N1c2FibGVdIGVsZW1lbnRzIHJlbmRlcmVkIGFscmVhZHkgLSBmb2N1c2VzIG9uIHRoZSBmaXJzdCBzdXBlcmZvY3VzYWJsZSBlbGVtZW50LCBhbmQgbGVhdmVzIGZvY3VzIHVwIHRvIHRoZSBjb250cm9sIG9mIGEgdXNlciAodW50aWwgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCBkaXNhcHBlYXJzIGZyb20gdGhlIHNjcmVlbiBbd2hpY2ggY2FuIGhhcHBlbiB3aGVuIG92ZXJsYXkgY2hhbmdlcywgb3IsIGUuZy4sIHdoZW4gd2UgY2xpY2sgb24gYSBmb2xkZXIgaW4gZ29vZ2xlZHJpdmVdKS5cbiAgMi4gSWYgdGhlcmUgYXJlIG5vIFtkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXSBlbGVtZW50cyB5ZXQgKG9yIGV2ZXIpIC0gZm9jdXNlcyBvbiB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQsIGJ1dCBzd2l0Y2hlcyBmb2N1cyBpZiBzdXBlcmZvY3VzYWJsZSBlbGVtZW50cyBhcHBlYXIgb24gbmV4dCByZW5kZXIuXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVTdXBlckZvY3VzICgpIHtcbiAgbGV0IGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCA9IGZhbHNlXG5cbiAgY29uc3Qgc3VwZXJGb2N1cyA9IChkYXNoYm9hcmRFbCwgYWN0aXZlT3ZlcmxheVR5cGUpID0+IHtcbiAgICBjb25zdCBvdmVybGF5RWwgPSBnZXRBY3RpdmVPdmVybGF5RWwoZGFzaGJvYXJkRWwsIGFjdGl2ZU92ZXJsYXlUeXBlKVxuXG4gICAgY29uc3QgaXNGb2N1c0luT3ZlcmxheSA9IG92ZXJsYXlFbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIC8vIElmIGZvY3VzIGlzIGFscmVhZHkgaW4gdGhlIHRvcG1vc3Qgb3ZlcmxheSwgQU5EIG9uIGxhc3QgdXBkYXRlIHdlIGZvY3VzZWQgb24gdGhlIHN1cGVyZm9jdXNhYmxlIGVsZW1lbnQgLSB0aGVuIGxlYXZlIGZvY3VzIHVwIHRvIHRoZSB1c2VyLlxuICAgIC8vIFtQcmFjdGljYWwgY2hlY2tdIHdpdGhvdXQgdGhpcyBsaW5lLCB0eXBpbmcgaW4gdGhlIHNlYXJjaCBpbnB1dCBpbiBnb29nbGVkcml2ZSBvdmVybGF5IHdvbid0IHdvcmsuXG4gICAgaWYgKGlzRm9jdXNJbk92ZXJsYXkgJiYgbGFzdEZvY3VzV2FzT25TdXBlckZvY3VzYWJsZUVsKSByZXR1cm5cblxuICAgIGNvbnN0IHN1cGVyRm9jdXNhYmxlRWwgPSBvdmVybGF5RWwucXVlcnlTZWxlY3RvcignW2RhdGEtdXBweS1zdXBlci1mb2N1c2FibGVdJylcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbiB0aGUgdG9wbW9zdCBvdmVybGF5LCBBTkQgdGhlcmUgYXJlIG5vIHN1cGVyIGZvY3VzYWJsZSBlbGVtZW50cyB5ZXQsIC0gbGVhdmUgZm9jdXMgdXAgdG8gdGhlIHVzZXIuXG4gICAgLy8gW1ByYWN0aWNhbCBjaGVja10gd2l0aG91dCB0aGlzIGxpbmUsIGlmIHlvdSBhcmUgaW4gYW4gZW1wdHkgZm9sZGVyIGluIGdvb2dsZSBkcml2ZSwgYW5kIHNvbWV0aGluZydzIHVwbG9hZGluZyBpbiB0aGUgYmcsIC0gZm9jdXMgd2lsbCBiZSBqdW1waW5nIHRvIERvbmUgYWxsIHRoZSB0aW1lLlxuICAgIGlmIChpc0ZvY3VzSW5PdmVybGF5ICYmICFzdXBlckZvY3VzYWJsZUVsKSByZXR1cm5cblxuICAgIGlmIChzdXBlckZvY3VzYWJsZUVsKSB7XG4gICAgICBzdXBlckZvY3VzYWJsZUVsLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KVxuICAgICAgbGFzdEZvY3VzV2FzT25TdXBlckZvY3VzYWJsZUVsID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXJzdEVsID0gb3ZlcmxheUVsLnF1ZXJ5U2VsZWN0b3IoRk9DVVNBQkxFX0VMRU1FTlRTKVxuICAgICAgZmlyc3RFbCAmJiBmaXJzdEVsLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KVxuICAgICAgbGFzdEZvY3VzV2FzT25TdXBlckZvY3VzYWJsZUVsID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBfX19XaHkgZG8gd2UgbmVlZCB0byBkZWJvdW5jZT9cbiAgLy8gICAgMS4gVG8gZGVhbCB3aXRoIGFuaW1hdGlvbnM6IG92ZXJsYXkgY2hhbmdlcyB2aWEgYW5pbWF0aW9ucywgd2hpY2ggcmVzdWx0cyBpbiB0aGUgRE9NIHVwZGF0aW5nIEFGVEVSIHBsdWdpbi51cGRhdGUoKSBhbHJlYWR5IGV4ZWN1dGVkLlxuICAvLyAgICBbUHJhY3RpY2FsIGNoZWNrXSB3aXRob3V0IGRlYm91bmNlLCBpZiB3ZSBvcGVuIHRoZSBVcmwgb3ZlcmxheSwgYW5kIGNsaWNrICdEb25lJywgRGFzaGJvYXJkIHdvbid0IGdldCBmb2N1c2VkIGFnYWluLlxuICAvLyAgICBbUHJhY3RpY2FsIGNoZWNrXSBpZiB3ZSBkZWxheSAyNTBtcyBpbnN0ZWFkIG9mIDI2MG1zIC0gSUUxMSB3b24ndCBnZXQgZm9jdXNlZCBpbiBzYW1lIHNpdHVhdGlvbi5cbiAgLy8gICAgMi4gUGVyZm9ybWFuY2U6IHRoZXJlIGNhbiBiZSBtYW55IHN0YXRlIHVwZGF0ZSgpcyBpbiBhIHNlY29uZCwgYW5kIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHRpbWUuXG4gIHJldHVybiBkZWJvdW5jZShzdXBlckZvY3VzLCAyNjApXG59XG4iLCIvKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBlaXRoZXIgZGFzaGJvYXJkIGVsZW1lbnQsIG9yIHRoZSBvdmVybGF5IHRoYXQncyBtb3N0IG9uIHRvcFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEFjdGl2ZU92ZXJsYXlFbCAoZGFzaGJvYXJkRWwsIGFjdGl2ZU92ZXJsYXlUeXBlKSB7XG4gIGlmIChhY3RpdmVPdmVybGF5VHlwZSkge1xuICAgIGNvbnN0IG92ZXJsYXlFbCA9IGRhc2hib2FyZEVsLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXVwcHktcGFuZWx0eXBlPVwiJHthY3RpdmVPdmVybGF5VHlwZX1cIl1gKVxuICAgIC8vIGlmIGFuIG92ZXJsYXkgaXMgYWxyZWFkeSBtb3VudGVkXG4gICAgaWYgKG92ZXJsYXlFbCkgcmV0dXJuIG92ZXJsYXlFbFxuICB9XG4gIHJldHVybiBkYXNoYm9hcmRFbFxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBpY29uSW1hZ2UgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiMjVcIiB2aWV3Qm94PVwiMCAwIDI1IDI1XCI+XG4gICAgICA8ZyBmaWxsPVwiIzY4NkRFMFwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTUgN3YxMGgxNVY3SDV6bTAtMWgxNWExIDEgMCAwIDEgMSAxdjEwYTEgMSAwIDAgMS0xIDFINWExIDEgMCAwIDEtMS0xVjdhMSAxIDAgMCAxIDEtMXpcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTYuMzUgMTcuMTcybDQuOTk0LTUuMDI2YS41LjUgMCAwIDEgLjcwNyAwbDIuMTYgMi4xNiAzLjUwNS0zLjUwNWEuNS41IDAgMCAxIC43MDcgMGwyLjMzNiAyLjMxLS43MDcuNzItMS45ODMtMS45Ny0zLjUwNSAzLjUwNWEuNS41IDAgMCAxLS43MDcgMGwtMi4xNi0yLjE1OS0zLjkzOCAzLjkzOS0xLjQwOS4wMjZ6XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjcuNVwiIGN5PVwiOS41XCIgcj1cIjEuNVwiIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvbkF1ZGlvICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiMjVcIiB2aWV3Qm94PVwiMCAwIDI1IDI1XCI+XG4gICAgICA8cGF0aCBkPVwiTTkuNSAxOC42NGMwIDEuMTQtMS4xNDUgMi0yLjUgMnMtMi41LS44Ni0yLjUtMmMwLTEuMTQgMS4xNDUtMiAyLjUtMiAuNTU3IDAgMS4wNzkuMTQ1IDEuNS4zOTZWNy4yNWEuNS41IDAgMCAxIC4zNzktLjQ4NWw5LTIuMjVBLjUuNSAwIDAgMSAxOC41IDV2MTEuNjRjMCAxLjE0LTEuMTQ1IDItMi41IDJzLTIuNS0uODYtMi41LTJjMC0xLjE0IDEuMTQ1LTIgMi41LTIgLjU1NyAwIDEuMDc5LjE0NSAxLjUuMzk2VjguNjdsLTggMnY3Ljk3em04LTExdi0ybC04IDJ2Mmw4LTJ6TTcgMTkuNjRjLjg1NSAwIDEuNS0uNDg0IDEuNS0xcy0uNjQ1LTEtMS41LTEtMS41LjQ4NC0xLjUgMSAuNjQ1IDEgMS41IDF6bTktMmMuODU1IDAgMS41LS40ODQgMS41LTFzLS42NDUtMS0xLjUtMS0xLjUuNDg0LTEuNSAxIC42NDUgMSAxLjUgMXpcIiBmaWxsPVwiIzA0OUJDRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblZpZGVvICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiMjVcIiB2aWV3Qm94PVwiMCAwIDI1IDI1XCI+XG4gICAgICA8cGF0aCBkPVwiTTE2IDExLjgzNGw0LjQ4Ni0yLjY5MUExIDEgMCAwIDEgMjIgMTB2NmExIDEgMCAwIDEtMS41MTQuODU3TDE2IDE0LjE2N1YxN2ExIDEgMCAwIDEtMSAxSDVhMSAxIDAgMCAxLTEtMVY5YTEgMSAwIDAgMSAxLTFoMTBhMSAxIDAgMCAxIDEgMXYyLjgzNHpNMTUgOUg1djhoMTBWOXptMSA0bDUgM3YtNmwtNSAzelwiIGZpbGw9XCIjMTlBRjY3XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uUERGICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiMjVcIiB2aWV3Qm94PVwiMCAwIDI1IDI1XCI+XG4gICAgICA8cGF0aCBkPVwiTTkuNzY2IDguMjk1Yy0uNjkxLTEuODQzLS41MzktMy40MDEuNzQ3LTMuNzI2IDEuNjQzLS40MTQgMi41MDUuOTM4IDIuMzkgMy4yOTktLjAzOS43OS0uMTk0IDEuNjYyLS41MzcgMy4xNDguMzI0LjQ5LjY2Ljk2NyAxLjA1NSAxLjUxLjE3LjIzMS4zODIuNDg4LjYyOS43NTcgMS44NjYtLjEyOCAzLjY1My4xMTQgNC45MTguNjU1IDEuNDg3LjYzNSAyLjE5MiAxLjY4NSAxLjYxNCAyLjg0LS41NjYgMS4xMzMtMS44MzkgMS4wODQtMy40MTYuMjQ5LTEuMTQxLS42MDQtMi40NTctMS42MzQtMy41MS0yLjcwN2ExMy40NjcgMTMuNDY3IDAgMCAwLTIuMjM4LjQyNmMtMS4zOTIgNC4wNTEtNC41MzQgNi40NTMtNS43MDcgNC41NzItLjk4Ni0xLjU4IDEuMzgtNC4yMDYgNC45MTQtNS4zNzUuMDk3LS4zMjIuMTg1LS42NTYuMjY0LTEuMDAxLjA4LS4zNTMuMzA2LTEuMzEuNDA3LTEuNzM3LS42NzgtMS4wNTktMS4yLTIuMDMxLTEuNTMtMi45MXptMi4wOTggNC44N2MtLjAzMy4xNDQtLjA2OC4yODctLjEwNC40MjdsLjAzMy0uMDEtLjAxMi4wMzhhMTQuMDY1IDE0LjA2NSAwIDAgMSAxLjAyLS4xOTdsLS4wMzItLjAzMy4wNTItLjAwNGE3LjkwMiA3LjkwMiAwIDAgMS0uMjA4LS4yNzFjLS4xOTctLjI3LS4zOC0uNTI2LS41NTUtLjc3NWwtLjAwNi4wMjgtLjAwMi0uMDAzYy0uMDc2LjMyMy0uMTQ4LjYzMi0uMTg2Ljh6bTUuNzcgMi45NzhjMS4xNDMuNjA1IDEuODMyLjYzMiAyLjA1NC4xODcuMjYtLjUxOS0uMDg3LTEuMDM0LTEuMTEzLTEuNDczLS45MTEtLjM5LTIuMTc1LS42MDgtMy41NS0uNjA4Ljg0NS43NjYgMS43ODcgMS40NTkgMi42MDkgMS44OTR6TTYuNTU5IDE4Ljc4OWMuMTQuMjIzLjY5My4xNiAxLjQyNS0uNDEzLjgyNy0uNjQ4IDEuNjEtMS43NDcgMi4yMDgtMy4yMDYtMi41NjMgMS4wNjQtNC4xMDIgMi44NjctMy42MzMgMy42MnptNS4zNDUtMTAuOTdjLjA4OC0xLjc5My0uMzUxLTIuNDgtMS4xNDYtMi4yOC0uNDczLjExOS0uNTY0IDEuMDUtLjA1NiAyLjQwNS4yMTMuNTY2LjUyIDEuMTg4LjkwOCAxLjg1OS4xOC0uODU4LjI2OC0xLjQ1My4yOTQtMS45ODR6XCIgZmlsbD1cIiNFMjUxNEFcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25BcmNoaXZlICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk0xMC40NSAyLjA1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjRhLjUuNSAwIDAgMS0uNS41aC0xLjA1YS41LjUgMCAwIDEtLjUtLjVWMi41NWEuNS41IDAgMCAxIC41LS41em0yLjA1IDEuMDI0aDEuMDVhLjUuNSAwIDAgMSAuNS41VjMuNmEuNS41IDAgMCAxLS41LjVIMTIuNWEuNS41IDAgMCAxLS41LS41di0uMDI1YS41LjUgMCAwIDEgLjUtLjV2LS4wMDF6TTEwLjQ1IDBoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNWEuNS41IDAgMCAxLS41LjVoLTEuMDVhLjUuNSAwIDAgMS0uNS0uNVYuNWEuNS41IDAgMCAxIC41LS41em0yLjA1IDEuMDI1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjRhLjUuNSAwIDAgMS0uNS41SDEyLjVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNGEuNS41IDAgMCAxIC41LS41em0tMi4wNSAzLjA3NGgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI1YS41LjUgMCAwIDEtLjUuNWgtMS4wNWEuNS41IDAgMCAxLS41LS41di0uMDI1YS41LjUgMCAwIDEgLjUtLjV6bTIuMDUgMS4wMjVoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNGEuNS41IDAgMCAxLS41LjVIMTIuNWEuNS41IDAgMCAxLS41LS41di0uMDI0YS41LjUgMCAwIDEgLjUtLjV6bS0yLjA1IDEuMDI0aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjVhLjUuNSAwIDAgMS0uNS41aC0xLjA1YS41LjUgMCAwIDEtLjUtLjV2LS4wMjVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI1YS41LjUgMCAwIDEtLjUuNUgxMi41YS41LjUgMCAwIDEtLjUtLjV2LS4wMjVhLjUuNSAwIDAgMSAuNS0uNXptLTIuMDUgMS4wMjVoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNWEuNS41IDAgMCAxLS41LjVoLTEuMDVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNWEuNS41IDAgMCAxIC41LS41em0yLjA1IDEuMDI1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjRhLjUuNSAwIDAgMS0uNS41SDEyLjVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNGEuNS41IDAgMCAxIC41LS41em0tMS42NTYgMy4wNzRsLS44MiA1Ljk0NmMuNTIuMzAyIDEuMTc0LjQ1OCAxLjk3Ni40NTguODAzIDAgMS40NTUtLjE1NiAxLjk3NS0uNDU4bC0uODItNS45NDZoLTIuMzExem0wLTEuMDI1aDIuMzEyYy41MTIgMCAuOTQ2LjM3OCAxLjAxNS44ODVsLjgyIDUuOTQ2Yy4wNTYuNDEyLS4xNDIuODE3LS41MDEgMS4wMjYtLjY4Ni4zOTgtMS41MTUuNTk3LTIuNDkuNTk3LS45NzQgMC0xLjgwNC0uMTk5LTIuNDktLjU5N2ExLjAyNSAxLjAyNSAwIDAgMS0uNS0xLjAyNmwuODE5LTUuOTQ2Yy4wNy0uNTA3LjUwMy0uODg1IDEuMDE1LS44ODV6bS41NDUgNi42YS41LjUgMCAwIDEtLjM5Ny0uNTYxbC4xNDMtLjk5OWEuNS41IDAgMCAxIC40OTUtLjQyOWguNzRhLjUuNSAwIDAgMSAuNDk1LjQzbC4xNDMuOTk4YS41LjUgMCAwIDEtLjM5Ny41NjFjLS40MDQuMDgtLjgxOS4wOC0xLjIyMiAwelwiIGZpbGw9XCIjMDBDNDY5XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uRmlsZSAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPGcgZmlsbD1cIiNBN0FGQjdcIiBmaWxsUnVsZT1cIm5vbnplcm9cIj5cbiAgICAgICAgPHBhdGggZD1cIk01LjUgMjJhLjUuNSAwIDAgMS0uNS0uNXYtMThhLjUuNSAwIDAgMSAuNS0uNWgxMC43MTlhLjUuNSAwIDAgMSAuMzY3LjE2bDMuMjgxIDMuNTU2YS41LjUgMCAwIDEgLjEzMy4zMzlWMjEuNWEuNS41IDAgMCAxLS41LjVoLTE0em0uNS0xaDEzVjcuMjVMMTYgNEg2djE3elwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMTUgNHYzYTEgMSAwIDAgMCAxIDFoM1Y3aC0zVjRoLTF6XCIgLz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uVGV4dCAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk00LjUgN2gxM2EuNS41IDAgMSAxIDAgMWgtMTNhLjUuNSAwIDAgMSAwLTF6bTAgM2gxNWEuNS41IDAgMSAxIDAgMWgtMTVhLjUuNSAwIDEgMSAwLTF6bTAgM2gxNWEuNS41IDAgMSAxIDAgMWgtMTVhLjUuNSAwIDEgMSAwLTF6bTAgM2gxMGEuNS41IDAgMSAxIDAgMWgtMTBhLjUuNSAwIDEgMSAwLTF6XCIgZmlsbD1cIiM1QTVFNjlcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0SWNvbkJ5TWltZSAoZmlsZVR5cGUpIHtcbiAgY29uc3QgZGVmYXVsdENob2ljZSA9IHtcbiAgICBjb2xvcjogJyM4Mzg5OTknLFxuICAgIGljb246IGljb25GaWxlKCksXG4gIH1cblxuICBpZiAoIWZpbGVUeXBlKSByZXR1cm4gZGVmYXVsdENob2ljZVxuXG4gIGNvbnN0IGZpbGVUeXBlR2VuZXJhbCA9IGZpbGVUeXBlLnNwbGl0KCcvJylbMF1cbiAgY29uc3QgZmlsZVR5cGVTcGVjaWZpYyA9IGZpbGVUeXBlLnNwbGl0KCcvJylbMV1cblxuICAvLyBUZXh0XG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyM1YTVlNjknLFxuICAgICAgaWNvbjogaWNvblRleHQoKSxcbiAgICB9XG4gIH1cblxuICAvLyBJbWFnZVxuICBpZiAoZmlsZVR5cGVHZW5lcmFsID09PSAnaW1hZ2UnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnIzY4NmRlMCcsXG4gICAgICBpY29uOiBpY29uSW1hZ2UoKSxcbiAgICB9XG4gIH1cblxuICAvLyBBdWRpb1xuICBpZiAoZmlsZVR5cGVHZW5lcmFsID09PSAnYXVkaW8nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnIzA2OGRiYicsXG4gICAgICBpY29uOiBpY29uQXVkaW8oKSxcbiAgICB9XG4gIH1cblxuICAvLyBWaWRlb1xuICBpZiAoZmlsZVR5cGVHZW5lcmFsID09PSAndmlkZW8nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnIzE5YWY2NycsXG4gICAgICBpY29uOiBpY29uVmlkZW8oKSxcbiAgICB9XG4gIH1cblxuICAvLyBQREZcbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBmaWxlVHlwZVNwZWNpZmljID09PSAncGRmJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyNlMjUxNDknLFxuICAgICAgaWNvbjogaWNvblBERigpLFxuICAgIH1cbiAgfVxuXG4gIC8vIEFyY2hpdmVcbiAgY29uc3QgYXJjaGl2ZVR5cGVzID0gWyd6aXAnLCAneC03ei1jb21wcmVzc2VkJywgJ3gtcmFyLWNvbXByZXNzZWQnLCAneC10YXInLCAneC1nemlwJywgJ3gtYXBwbGUtZGlza2ltYWdlJ11cbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBhcmNoaXZlVHlwZXMuaW5kZXhPZihmaWxlVHlwZVNwZWNpZmljKSAhPT0gLTEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICcjMDBDNDY5JyxcbiAgICAgIGljb246IGljb25BcmNoaXZlKCksXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRDaG9pY2Vcbn1cbiIsIi8vIGlnbm9yZSBkcm9wL3Bhc3RlIGV2ZW50cyBpZiB0aGV5IGFyZSBub3QgaW4gaW5wdXQgb3IgdGV4dGFyZWEg4oCUXG4vLyBvdGhlcndpc2Ugd2hlbiBVcmwgcGx1Z2luIGFkZHMgZHJvcC9wYXN0ZSBsaXN0ZW5lcnMgdG8gdGhpcy5lbCxcbi8vIGRyYWdpbmcgVUkgZWxlbWVudHMgb3IgcGFzdGluZyBhbnl0aGluZyBpbnRvIGFueSBmaWVsZCB0cmlnZ2VycyB0aG9zZSBldmVudHMg4oCUXG4vLyBVcmwgdHJlYXRzIHRoZW0gYXMgVVJMcyB0aGF0IG5lZWQgdG8gYmUgaW1wb3J0ZWRcblxuZnVuY3Rpb24gaWdub3JlRXZlbnQgKGV2KSB7XG4gIGNvbnN0IHRhZ05hbWUgPSBldi50YXJnZXQudGFnTmFtZVxuICBpZiAodGFnTmFtZSA9PT0gJ0lOUFVUJ1xuICAgICAgfHwgdGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgcmV0dXJuXG4gIH1cbiAgZXYucHJldmVudERlZmF1bHQoKVxuICBldi5zdG9wUHJvcGFnYXRpb24oKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlnbm9yZUV2ZW50XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RvQXJyYXknKVxuY29uc3QgZ2V0QWN0aXZlT3ZlcmxheUVsID0gcmVxdWlyZSgnLi9nZXRBY3RpdmVPdmVybGF5RWwnKVxuY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0ZPQ1VTQUJMRV9FTEVNRU5UUycpXG5cbmZ1bmN0aW9uIGZvY3VzT25GaXJzdE5vZGUgKGV2ZW50LCBub2Rlcykge1xuICBjb25zdCBub2RlID0gbm9kZXNbMF1cbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmZvY3VzKClcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cbn1cblxuZnVuY3Rpb24gZm9jdXNPbkxhc3ROb2RlIChldmVudCwgbm9kZXMpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdXG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5mb2N1cygpXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG59XG5cbi8vIF9fX1doeSBub3QganVzdCB1c2UgKGZvY3VzZWRJdGVtSW5kZXggPT09IC0xKT9cbi8vICAgIEZpcmVmb3ggdGhpbmtzIDx1bD4gaXMgZm9jdXNhYmxlLCBidXQgd2UgZG9uJ3QgaGF2ZSA8dWw+cyBpbiBvdXIgRk9DVVNBQkxFX0VMRU1FTlRTLiBXaGljaCBtZWFucyB0aGF0IGlmIHdlIHRhYiBpbnRvIHRoZSA8dWw+LCBjb2RlIHdpbGwgdGhpbmsgdGhhdCB3ZSBhcmUgbm90IGluIHRoZSBhY3RpdmUgb3ZlcmxheSwgYW5kIHdlIHNob3VsZCBmb2N1c09uRmlyc3ROb2RlKCkgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgb3ZlcmxheSFcbi8vICAgIFtQcmFjdGljYWwgY2hlY2tdIGlmIHdlIHVzZSAoZm9jdXNlZEl0ZW1JbmRleCA9PT0gLTEpLCBpbnN0YWdyYW0gcHJvdmlkZXIgaW4gZmlyZWZveCB3aWxsIG5ldmVyIGdldCBmb2N1cyBvbiBpdHMgcGljcyBpbiB0aGUgPHVsPi5cbmZ1bmN0aW9uIGlzRm9jdXNJbk92ZXJsYXkgKGFjdGl2ZU92ZXJsYXlFbCkge1xuICByZXR1cm4gYWN0aXZlT3ZlcmxheUVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG59XG5cbmZ1bmN0aW9uIHRyYXBGb2N1cyAoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbCkge1xuICBjb25zdCBhY3RpdmVPdmVybGF5RWwgPSBnZXRBY3RpdmVPdmVybGF5RWwoZGFzaGJvYXJkRWwsIGFjdGl2ZU92ZXJsYXlUeXBlKVxuICBjb25zdCBmb2N1c2FibGVOb2RlcyA9IHRvQXJyYXkoYWN0aXZlT3ZlcmxheUVsLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKSlcblxuICBjb25zdCBmb2N1c2VkSXRlbUluZGV4ID0gZm9jdXNhYmxlTm9kZXMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuXG4gIC8vIElmIHdlIHByZXNzZWQgdGFiLCBhbmQgZm9jdXMgaXMgbm90IHlldCB3aXRoaW4gdGhlIGN1cnJlbnQgb3ZlcmxheSAtIGZvY3VzIG9uIHRoZSBmaXJzdCBlbGVtZW50IHdpdGhpbiB0aGUgY3VycmVudCBvdmVybGF5LlxuICAvLyBUaGlzIGlzIGEgc2FmZXR5IG1lYXN1cmUgKGZvciB3aGVuIHVzZXIgcmV0dXJucyBmcm9tIGFub3RoZXIgdGFiIGUuZy4pLCBtb3N0IHBsdWdpbnMgd2lsbCB0cnkgdG8gZm9jdXMgb24gc29tZSBpbXBvcnRhbnQgZWxlbWVudCBhcyBpdCBsb2Fkcy5cbiAgaWYgKCFpc0ZvY3VzSW5PdmVybGF5KGFjdGl2ZU92ZXJsYXlFbCkpIHtcbiAgICBmb2N1c09uRmlyc3ROb2RlKGV2ZW50LCBmb2N1c2FibGVOb2RlcylcbiAgLy8gSWYgd2UgcHJlc3NlZCBzaGlmdCArIHRhYiwgYW5kIHdlJ3JlIG9uIHRoZSBmaXJzdCBlbGVtZW50IG9mIGEgbW9kYWxcbiAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSAwKSB7XG4gICAgZm9jdXNPbkxhc3ROb2RlKGV2ZW50LCBmb2N1c2FibGVOb2RlcylcbiAgLy8gSWYgd2UgcHJlc3NlZCB0YWIsIGFuZCB3ZSdyZSBvbiB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBtb2RhbFxuICB9IGVsc2UgaWYgKCFldmVudC5zaGlmdEtleSAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSBmb2N1c2FibGVOb2Rlcy5sZW5ndGggLSAxKSB7XG4gICAgZm9jdXNPbkZpcnN0Tm9kZShldmVudCwgZm9jdXNhYmxlTm9kZXMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFRyYXBzIGZvY3VzIGluc2lkZSBvZiB0aGUgY3VycmVudGx5IG9wZW4gb3ZlcmxheSAoZS5nLiBEYXNoYm9hcmQsIG9yIGUuZy4gSW5zdGFncmFtKSwgbmV2ZXIgbGV0cyBmb2N1cyBkaXNhcHBlYXIgZnJvbSB0aGUgbW9kYWwuXG4gIGZvck1vZGFsOiAoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbCkgPT4ge1xuICAgIHRyYXBGb2N1cyhldmVudCwgYWN0aXZlT3ZlcmxheVR5cGUsIGRhc2hib2FyZEVsKVxuICB9LFxuXG4gIC8vIFRyYXBzIGZvY3VzIGluc2lkZSBvZiB0aGUgY3VycmVudGx5IG9wZW4gb3ZlcmxheSwgdW5sZXNzIG92ZXJsYXkgaXMgbnVsbCAtIHRoZW4gbGV0IHRoZSB1c2VyIHRhYiBhd2F5LlxuICBmb3JJbmxpbmU6IChldmVudCwgYWN0aXZlT3ZlcmxheVR5cGUsIGRhc2hib2FyZEVsKSA9PiB7XG4gICAgLy8gX19fV2hlbiB3ZSdyZSBpbiB0aGUgYmFyZSAnRHJvcCBmaWxlcyBoZXJlLCBwYXN0ZSwgYnJvd3NlIG9yIGltcG9ydCBmcm9tJyBzY3JlZW5cbiAgICBpZiAoYWN0aXZlT3ZlcmxheVR5cGUgPT09IG51bGwpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgYW5kIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgaXQsIHVzZXIgY2FuIHRhYiBhd2F5IGZyb20gVXBweSB0byBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGFnZVxuICAgIC8vIF9fX1doZW4gdGhlcmUgaXMgc29tZSBvdmVybGF5IHdpdGggJ0RvbmUnIGJ1dHRvblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmFwIHRoZSBmb2N1cyBpbnNpZGUgdGhpcyBvdmVybGF5IVxuICAgICAgLy8gVXNlciBjYW4gY2xvc2UgdGhlIG92ZXJsYXkgKGNsaWNrICdEb25lJykgaWYgdGhleSB3YW50IHRvIHRyYXZlbCBhd2F5IGZyb20gVXBweS5cbiAgICAgIHRyYXBGb2N1cyhldmVudCwgYWN0aXZlT3ZlcmxheVR5cGUsIGRhc2hib2FyZEVsKVxuICAgIH1cbiAgfSxcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvZHJvcGJveFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSW1wb3J0IGZpbGVzIGZyb20gRHJvcGJveCwgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjUuMVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImRyb3Bib3hcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3Byb3ZpZGVyLXZpZXdzXCI6IFwiZmlsZTouLi9wcm92aWRlci12aWV3c1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEcm9wYm94IGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0Ryb3Bib3gnXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0Ryb3Bib3gnXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiMwRDI0ODFcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTExIDhsNSAzLjE4NS01IDMuMTg2LTUtMy4xODZMMTEgOHptMTAgMGw1IDMuMTg1LTUgMy4xODYtNS0zLjE4NkwyMSA4ek02IDE3LjU1Nmw1LTMuMTg1IDUgMy4xODUtNSAzLjE4Ni01LTMuMTg2em0xNS0zLjE4NWw1IDMuMTg1LTUgMy4xODYtNS0zLjE4NiA1LTMuMTg1em0tMTAgNy40MzJsNS0zLjE4NSA1IDMuMTg1LTUgMy4xODYtNS0zLjE4NnpcIiBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ2Ryb3Bib3gnLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWQsXG4gICAgfSlcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2ZhY2Vib29rXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJJbXBvcnQgZmlsZXMgZnJvbSBGYWNlYm9vaywgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjIuMVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImZhY2Vib29rXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlclZpZXdzIH0gPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmFjZWJvb2sgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnRmFjZWJvb2snXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0ZhY2Vib29rJ1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiBmaWxsPVwiIzNDNUE5OVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNy44NDIgMjZ2LTguNjY3aDIuNjUzbC4zOTgtMy4zNzdoLTMuMDUxdi0yLjE1N2MwLS45NzguMjQ4LTEuNjQ0IDEuNTI3LTEuNjQ0SDIxVjcuMTMyQTE5LjkxNCAxOS45MTQgMCAwIDAgMTguNjIzIDdjLTIuMzUyIDAtMy45NjMgMS41NzQtMy45NjMgNC40NjV2Mi40OUgxMnYzLjM3OGgyLjY2VjI2aDMuMTgyelwiIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBQcm92aWRlcih1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIGNvbXBhbmlvbktleXNQYXJhbXM6IHRoaXMub3B0cy5jb21wYW5pb25LZXlzUGFyYW1zLFxuICAgICAgY29tcGFuaW9uQ29va2llc1J1bGU6IHRoaXMub3B0cy5jb21wYW5pb25Db29raWVzUnVsZSxcbiAgICAgIHByb3ZpZGVyOiAnZmFjZWJvb2snLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWQsXG4gICAgfSlcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIGNvbnN0IHZpZXdPcHRpb25zID0ge31cbiAgICBpZiAodGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmZpbGVzLmxlbmd0aCAmJiAhdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmZvbGRlcnMubGVuZ3RoKSB7XG4gICAgICB2aWV3T3B0aW9ucy52aWV3VHlwZSA9ICdncmlkJ1xuICAgICAgdmlld09wdGlvbnMuc2hvd0ZpbHRlciA9IGZhbHNlXG4gICAgICB2aWV3T3B0aW9ucy5zaG93VGl0bGVzID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUsIHZpZXdPcHRpb25zKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2Zvcm1cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNvbm5lY3QgVXBweSB0byBhbiBleGlzdGluZyBIVE1MIDxmb3JtPi5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4zLjMwXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiZm9ybVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJnZXQtZm9ybS1kYXRhXCI6IFwiXjIuMC4wXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBmaW5kRE9NRWxlbWVudCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kRE9NRWxlbWVudCcpXG5jb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RvQXJyYXknKVxuLy8gUm9sbHVwIHVzZXMgZ2V0LWZvcm0tZGF0YSdzIEVTIG1vZHVsZXMgYnVpbGQsIGFuZCByb2xsdXAtcGx1Z2luLWNvbW1vbmpzIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZXMgYC5kZWZhdWx0YC5cbi8vIFNvLCBpZiB3ZSBhcmUgYmVpbmcgYnVpbHQgdXNpbmcgcm9sbHVwLCB0aGlzIHJlcXVpcmUoKSB3b24ndCBoYXZlIGEgYC5kZWZhdWx0YCBwcm9wZXJ0eS5cbmNvbnN0IGdldEZvcm1EYXRhID0gcmVxdWlyZSgnZ2V0LWZvcm0tZGF0YScpLmRlZmF1bHQgfHwgcmVxdWlyZSgnZ2V0LWZvcm0tZGF0YScpXG5cbi8qKlxuICogRm9ybVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZvcm0gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ2FjcXVpcmVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0Zvcm0nXG4gICAgdGhpcy50aXRsZSA9ICdGb3JtJ1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgcmVzdWx0TmFtZTogJ3VwcHlSZXN1bHQnLFxuICAgICAgZ2V0TWV0YUZyb21Gb3JtOiB0cnVlLFxuICAgICAgYWRkUmVzdWx0VG9Gb3JtOiB0cnVlLFxuICAgICAgbXVsdGlwbGVSZXN1bHRzOiBmYWxzZSxcbiAgICAgIHN1Ym1pdE9uU3VjY2VzczogZmFsc2UsXG4gICAgICB0cmlnZ2VyVXBsb2FkT25TdWJtaXQ6IGZhbHNlLFxuICAgIH1cblxuICAgIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmhhbmRsZUZvcm1TdWJtaXQgPSB0aGlzLmhhbmRsZUZvcm1TdWJtaXQuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlVXBsb2FkU3RhcnQgPSB0aGlzLmhhbmRsZVVwbG9hZFN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZVN1Y2Nlc3MgPSB0aGlzLmhhbmRsZVN1Y2Nlc3MuYmluZCh0aGlzKVxuICAgIHRoaXMuYWRkUmVzdWx0VG9Gb3JtID0gdGhpcy5hZGRSZXN1bHRUb0Zvcm0uYmluZCh0aGlzKVxuICAgIHRoaXMuZ2V0TWV0YUZyb21Gb3JtID0gdGhpcy5nZXRNZXRhRnJvbUZvcm0uYmluZCh0aGlzKVxuICB9XG5cbiAgaGFuZGxlVXBsb2FkU3RhcnQgKCkge1xuICAgIGlmICh0aGlzLm9wdHMuZ2V0TWV0YUZyb21Gb3JtKSB7XG4gICAgICB0aGlzLmdldE1ldGFGcm9tRm9ybSgpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU3VjY2VzcyAocmVzdWx0KSB7XG4gICAgaWYgKHRoaXMub3B0cy5hZGRSZXN1bHRUb0Zvcm0pIHtcbiAgICAgIHRoaXMuYWRkUmVzdWx0VG9Gb3JtKHJlc3VsdClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLnN1Ym1pdE9uU3VjY2Vzcykge1xuICAgICAgdGhpcy5mb3JtLnN1Ym1pdCgpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9ybVN1Ym1pdCAoZXYpIHtcbiAgICBpZiAodGhpcy5vcHRzLnRyaWdnZXJVcGxvYWRPblN1Ym1pdCkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgICAgY29uc3QgZWxlbWVudHMgPSB0b0FycmF5KGV2LnRhcmdldC5lbGVtZW50cylcbiAgICAgIGNvbnN0IGRpc2FibGVkQnlVcHB5ID0gW11cbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzQnV0dG9uID0gZWwudGFnTmFtZSA9PT0gJ0JVVFRPTicgfHwgKGVsLnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgZWwudHlwZSA9PT0gJ3N1Ym1pdCcpXG4gICAgICAgIGlmIChpc0J1dHRvbiAmJiAhZWwuZGlzYWJsZWQpIHtcbiAgICAgICAgICBlbC5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgICBkaXNhYmxlZEJ5VXBweS5wdXNoKGVsKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy51cHB5LnVwbG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBkaXNhYmxlZEJ5VXBweS5mb3JFYWNoKChidXR0b24pID0+IHtcbiAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICBkaXNhYmxlZEJ5VXBweS5mb3JFYWNoKChidXR0b24pID0+IHtcbiAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSB8fCBlcnIpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGFkZFJlc3VsdFRvRm9ybSAocmVzdWx0KSB7XG4gICAgdGhpcy51cHB5LmxvZygnW0Zvcm1dIEFkZGluZyByZXN1bHQgdG8gdGhlIG9yaWdpbmFsIGZvcm06JylcbiAgICB0aGlzLnVwcHkubG9nKHJlc3VsdClcblxuICAgIGxldCByZXN1bHRJbnB1dCA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yKGBbbmFtZT1cIiR7dGhpcy5vcHRzLnJlc3VsdE5hbWV9XCJdYClcbiAgICBpZiAocmVzdWx0SW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLm9wdHMubXVsdGlwbGVSZXN1bHRzKSB7XG4gICAgICAgIC8vIEFwcGVuZCBuZXcgcmVzdWx0IHRvIHRoZSBwcmV2aW91cyByZXN1bHQgYXJyYXkuXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyByZXN1bHQgaXMgZW1wdHksIG9yIG5vdCBhbiBhcnJheSxcbiAgICAgICAgLy8gc2V0IGl0IHRvIGFuIGVtcHR5IGFycmF5LlxuICAgICAgICBsZXQgdXBkYXRlZFJlc3VsdFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHVwZGF0ZWRSZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdElucHV0LnZhbHVlKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBOb3RoaW5nLCBzaW5jZSB3ZSBjaGVjayBmb3IgYXJyYXkgYmVsb3cgYW55d2F5XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodXBkYXRlZFJlc3VsdCkpIHtcbiAgICAgICAgICB1cGRhdGVkUmVzdWx0ID0gW11cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkUmVzdWx0LnB1c2gocmVzdWx0KVxuICAgICAgICByZXN1bHRJbnB1dC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRSZXN1bHQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXBsYWNlIGV4aXN0aW5nIHJlc3VsdCB3aXRoIHRoZSBuZXdlciByZXN1bHQgb24gYGNvbXBsZXRlYCBldmVudC5cbiAgICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBub3QgaWRlYWwsIHNpbmNlIHlvdSBtb3N0IGxpa2VseSB3YW50IHRvIGFsd2F5cyBrZWVwXG4gICAgICAgIC8vIGFsbCByZXN1bHRzIGluIHRoZSBpbnB1dC4gVGhpcyBpcyBrZXB0IGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eSB1bnRpbCAyLjAuXG4gICAgICAgIHJlc3VsdElucHV0LnZhbHVlID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmVzdWx0SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgcmVzdWx0SW5wdXQubmFtZSA9IHRoaXMub3B0cy5yZXN1bHROYW1lXG4gICAgcmVzdWx0SW5wdXQudHlwZSA9ICdoaWRkZW4nXG5cbiAgICBpZiAodGhpcy5vcHRzLm11bHRpcGxlUmVzdWx0cykge1xuICAgICAgLy8gV3JhcCByZXN1bHQgaW4gYW4gYXJyYXkgc28gd2UgY2FuIGhhdmUgbXVsdGlwbGUgcmVzdWx0c1xuICAgICAgcmVzdWx0SW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeShbcmVzdWx0XSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzdWx0IGlzIGFuIG9iamVjdCwga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkgdW50aWwgMi4wXG4gICAgICByZXN1bHRJbnB1dC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICB9XG5cbiAgICB0aGlzLmZvcm0uYXBwZW5kQ2hpbGQocmVzdWx0SW5wdXQpXG4gIH1cblxuICBnZXRNZXRhRnJvbUZvcm0gKCkge1xuICAgIGNvbnN0IGZvcm1NZXRhID0gZ2V0Rm9ybURhdGEodGhpcy5mb3JtKVxuICAgIC8vIFdlIHdhbnQgdG8gZXhjbHVkZSBtZXRhIHRoZSB0aGUgRm9ybSBwbHVnaW4gaXRzZWxmIGhhcyBhZGRlZFxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXMvMTYzN1xuICAgIGRlbGV0ZSBmb3JtTWV0YVt0aGlzLm9wdHMucmVzdWx0TmFtZV1cbiAgICB0aGlzLnVwcHkuc2V0TWV0YShmb3JtTWV0YSlcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMuZm9ybSA9IGZpbmRET01FbGVtZW50KHRoaXMub3B0cy50YXJnZXQpXG4gICAgaWYgKCF0aGlzLmZvcm0gfHwgdGhpcy5mb3JtLm5vZGVOYW1lICE9PSAnRk9STScpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ0Zvcm0gcGx1Z2luIHJlcXVpcmVzIGEgPGZvcm0+IHRhcmdldCBlbGVtZW50IHBhc3NlZCBpbiBvcHRpb25zIHRvIG9wZXJhdGUsIG5vbmUgd2FzIGZvdW5kJywgJ2Vycm9yJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCB0aGlzLmhhbmRsZUZvcm1TdWJtaXQpXG4gICAgdGhpcy51cHB5Lm9uKCd1cGxvYWQnLCB0aGlzLmhhbmRsZVVwbG9hZFN0YXJ0KVxuICAgIHRoaXMudXBweS5vbignY29tcGxldGUnLCB0aGlzLmhhbmRsZVN1Y2Nlc3MpXG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMuZm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKCdzdWJtaXQnLCB0aGlzLmhhbmRsZUZvcm1TdWJtaXQpXG4gICAgdGhpcy51cHB5Lm9mZigndXBsb2FkJywgdGhpcy5oYW5kbGVVcGxvYWRTdGFydClcbiAgICB0aGlzLnVwcHkub2ZmKCdjb21wbGV0ZScsIHRoaXMuaGFuZGxlU3VjY2VzcylcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9nb29nbGUtZHJpdmVcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBHb29nbGUgRHJpdmUgcGx1Z2luIGZvciBVcHB5IGxldHMgdXNlcnMgaW1wb3J0IGZpbGVzIGZyb20gdGhlaXIgR29vZ2xlIERyaXZlIGFjY291bnRcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS43LjFcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcImdvb2dsZSBkcml2ZVwiLFxuICAgIFwiY2xvdWQgc3RvcmFnZVwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3Byb3ZpZGVyLXZpZXdzXCI6IFwiZmlsZTouLi9wcm92aWRlci12aWV3c1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQcm92aWRlclZpZXdzIH0gPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRHJpdmVQcm92aWRlclZpZXdzIGV4dGVuZHMgUHJvdmlkZXJWaWV3cyB7XG4gIHRvZ2dsZUNoZWNrYm94IChlLCBmaWxlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgLy8gU2hhcmVkIERyaXZlcyBhcmVuJ3Qgc2VsZWN0YWJsZTsgZm9yIGFsbCBlbHNlLCBkZWZlciB0byB0aGUgYmFzZSBQcm92aWRlclZpZXcuXG4gICAgLy8gQHRvZG8gaXNUZWFtRHJpdmUgaXMgbGVmdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gV2Ugc2hvdWxkIHJlbW92ZSBpdCBpbiB0aGUgbmV4dFxuICAgIC8vIG1ham9yIHJlbGVhc2UuXG4gICAgaWYgKCFmaWxlLmN1c3RvbS5pc1RlYW1Ecml2ZSAmJiAhZmlsZS5jdXN0b20uaXNTaGFyZWREcml2ZSkge1xuICAgICAgc3VwZXIudG9nZ2xlQ2hlY2tib3goZSwgZmlsZSlcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgRHJpdmVQcm92aWRlclZpZXdzID0gcmVxdWlyZSgnLi9Ecml2ZVByb3ZpZGVyVmlld3MnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEdvb2dsZURyaXZlIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0dvb2dsZURyaXZlJ1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0dvb2dsZSBEcml2ZSdcbiAgICBQcm92aWRlci5pbml0UGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnR29vZ2xlIERyaXZlJ1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIGZpbGw9XCIjNDI4NUY0XCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMC4zMjQgMjMuM2wzLTUuMUgyNWwtMyA1LjFIMTAuMzI0ek0xMyAxOC4ybC0zIDUuMS0zLTUuMSA1LjgzOS05LjkyNCAyLjk5OSA1LjFMMTMgMTguMnptMTEuODM4LS4yNzZoLTZMMTMgOGg2bDUuODQgOS45MjRoLS4wMDJ6XCIgZmlsbD1cIiNGRkZcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICApXG5cbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKHVwcHksIHtcbiAgICAgIGNvbXBhbmlvblVybDogdGhpcy5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgIGNvbXBhbmlvbkhlYWRlcnM6IHRoaXMub3B0cy5jb21wYW5pb25IZWFkZXJzIHx8IHRoaXMub3B0cy5zZXJ2ZXJIZWFkZXJzLFxuICAgICAgY29tcGFuaW9uS2V5c1BhcmFtczogdGhpcy5vcHRzLmNvbXBhbmlvbktleXNQYXJhbXMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgICAgcHJvdmlkZXI6ICdkcml2ZScsXG4gICAgICBwbHVnaW5JZDogdGhpcy5pZCxcbiAgICB9KVxuXG4gICAgdGhpcy5vbkZpcnN0UmVuZGVyID0gdGhpcy5vbkZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldyA9IG5ldyBEcml2ZVByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgfSlcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldy50ZWFyRG93bigpXG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxuXG4gIG9uRmlyc3RSZW5kZXIgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnByb3ZpZGVyLmZldGNoUHJlQXV0aFRva2VuKCksXG4gICAgICB0aGlzLnZpZXcuZ2V0Rm9sZGVyKCdyb290JywgJy8nKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2luZm9ybWVyXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIG5vdGlmaWNhdGlvbiBhbmQgZXJyb3IgcG9wLXVwIGJhciBmb3IgVXBweS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS42LjVcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInN0eWxlXCI6IFwiZGlzdC9zdHlsZS5taW4uY3NzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcIm5vdGlmaWNhdGlvblwiLFxuICAgIFwiYmFyXCIsXG4gICAgXCJ1aVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG4vKipcbiAqIEluZm9ybWVyXG4gKiBTaG93cyByYWQgbWVzc2FnZSBidWJibGVzXG4gKiB1c2VkIGxpa2UgdGhpczogYHVwcHkuaW5mbygnaGVsbG8gd29ybGQnLCAnaW5mbycsIDUwMDApYFxuICogb3IgZm9yIGVycm9yczogYHVwcHkuaW5mbygnRXJyb3IgdXBsb2FkaW5nIGltZy5qcGcnLCAnZXJyb3InLCA1MDAwKWBcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSW5mb3JtZXIgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ3Byb2dyZXNzaW5kaWNhdG9yJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0luZm9ybWVyJ1xuICAgIHRoaXMudGl0bGUgPSAnSW5mb3JtZXInXG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fVxuICAgIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG4gIH1cblxuICByZW5kZXIgPSAoc3RhdGUpID0+IHtcbiAgICBjb25zdCB7IGlzSGlkZGVuLCBtZXNzYWdlLCBkZXRhaWxzIH0gPSBzdGF0ZS5pbmZvXG5cbiAgICBmdW5jdGlvbiBkaXNwbGF5RXJyb3JBbGVydCAoKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgJHttZXNzYWdlfSBcXG5cXG4gJHtkZXRhaWxzfWBcbiAgICAgIGFsZXJ0KGVycm9yTWVzc2FnZSlcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZU92ZXIgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy51cHB5LmluZm9UaW1lb3V0SUQpXG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMudXBweS5pbmZvVGltZW91dElEID0gc2V0VGltZW91dCh0aGlzLnVwcHkuaGlkZUluZm8sIDIwMDApXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweSB1cHB5LUluZm9ybWVyXCJcbiAgICAgICAgYXJpYS1oaWRkZW49e2lzSGlkZGVufVxuICAgICAgPlxuICAgICAgICA8cCByb2xlPVwiYWxlcnRcIj5cbiAgICAgICAgICB7bWVzc2FnZX1cbiAgICAgICAgICB7JyAnfVxuICAgICAgICAgIHtkZXRhaWxzICYmIChcbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2RldGFpbHN9XG4gICAgICAgICAgICAgIGRhdGEtbWljcm90aXAtcG9zaXRpb249XCJ0b3AtbGVmdFwiXG4gICAgICAgICAgICAgIGRhdGEtbWljcm90aXAtc2l6ZT1cIm1lZGl1bVwiXG4gICAgICAgICAgICAgIHJvbGU9XCJ0b29sdGlwXCJcbiAgICAgICAgICAgICAgb25DbGljaz17ZGlzcGxheUVycm9yQWxlcnR9XG4gICAgICAgICAgICAgIG9uTW91c2VPdmVyPXtoYW5kbGVNb3VzZU92ZXJ9XG4gICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17aGFuZGxlTW91c2VMZWF2ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgP1xuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvcD5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvaW5zdGFncmFtXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJJbXBvcnQgcGhvdG9zIGFuZCB2aWRlb3MgZnJvbSBJbnN0YWdyYW0sIGludG8gVXBweS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS41LjFcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJpbnN0YWdyYW1cIixcbiAgICBcInByb3ZpZGVyXCIsXG4gICAgXCJwaG90b3NcIixcbiAgICBcInZpZGVvc1wiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29tcGFuaW9uLWNsaWVudFwiOiBcImZpbGU6Li4vY29tcGFuaW9uLWNsaWVudFwiLFxuICAgIFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIjogXCJmaWxlOi4uL3Byb3ZpZGVyLXZpZXdzXCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcInByZWFjdFwiOiBcIjguMi45XCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCB7IFByb3ZpZGVyIH0gPSByZXF1aXJlKCdAdXBweS9jb21wYW5pb24tY2xpZW50JylcbmNvbnN0IHsgUHJvdmlkZXJWaWV3cyB9ID0gcmVxdWlyZSgnQHVwcHkvcHJvdmlkZXItdmlld3MnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEluc3RhZ3JhbSBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdJbnN0YWdyYW0nXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0luc3RhZ3JhbSdcbiAgICB0aGlzLmljb24gPSAoKSA9PiAoXG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxyZWN0IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJJY29uQmdcIiBmaWxsPVwiI0UxMzA2Q1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTYgOC42MjJjMi40MDMgMCAyLjY4OC4wMDkgMy42MzcuMDUyLjg3Ny4wNCAxLjM1NC4xODcgMS42Ny4zMS4zOTIuMTQ0Ljc0NS4zNzQgMS4wMzYuNjczLjI5OS4yOS41MjkuNjQ0LjY3MyAxLjAzNS4xMjMuMzE3LjI3Ljc5NC4zMSAxLjY3MS4wNDMuOTUuMDUyIDEuMjM0LjA1MiAzLjYzN3MtLjAwOSAyLjY4OC0uMDUyIDMuNjM3Yy0uMDQuODc3LS4xODcgMS4zNTQtLjMxIDEuNjcxYTIuOTggMi45OCAwIDAgMS0xLjcwOCAxLjcwOGMtLjMxNy4xMjMtLjc5NC4yNy0xLjY3MS4zMS0uOTUuMDQzLTEuMjM0LjA1My0zLjYzNy4wNTNzLTIuNjg4LS4wMS0zLjYzNy0uMDUzYy0uODc3LS4wNC0xLjM1NC0uMTg3LTEuNjcxLS4zMWEyLjc4OCAyLjc4OCAwIDAgMS0xLjAzNS0uNjczIDIuNzg4IDIuNzg4IDAgMCAxLS42NzMtMS4wMzVjLS4xMjMtLjMxNy0uMjctLjc5NC0uMzEtMS42NzEtLjA0My0uOTQ5LS4wNTItMS4yMzQtLjA1Mi0zLjYzN3MuMDA5LTIuNjg4LjA1Mi0zLjYzN2MuMDQtLjg3Ny4xODctMS4zNTQuMzEtMS42Ny4xNDQtLjM5Mi4zNzQtLjc0NS42NzMtMS4wMzYuMjktLjI5OS42NDQtLjUyOSAxLjAzNS0uNjczLjMxNy0uMTIzLjc5NC0uMjcgMS42NzEtLjMxLjk1LS4wNDMgMS4yMzQtLjA1MiAzLjYzNy0uMDUyek0xNiA3Yy0yLjQ0NCAwLTIuNzUuMDEtMy43MS4wNTQtLjk1OS4wNDQtMS42MTMuMTk2LTIuMTg1LjQxOS0uNi4yMjUtMS4xNDUuNTgtMS41OTQgMS4wMzgtLjQ1OC40NS0uODEzLjk5My0xLjAzOSAxLjU5NC0uMjIyLjU3Mi0uMzc0IDEuMjI2LS40MTggMi4xODRDNy4wMSAxMy4yNSA3IDEzLjU1NiA3IDE2cy4wMSAyLjc1LjA1NCAzLjcxYy4wNDQuOTU5LjE5NiAxLjYxMy40MTkgMi4xODUuMjI2LjYuNTggMS4xNDUgMS4wMzggMS41OTQuNDUuNDU4Ljk5My44MTMgMS41OTQgMS4wMzguNTcyLjIyMyAxLjIyNy4zNzUgMi4xODQuNDE5Ljk2LjA0NCAxLjI2Ny4wNTQgMy43MTEuMDU0czIuNzUtLjAxIDMuNzEtLjA1NGMuOTU5LS4wNDQgMS42MTMtLjE5NiAyLjE4NS0uNDE5YTQuNjAyIDQuNjAyIDAgMCAwIDIuNjMyLTIuNjMyYy4yMjMtLjU3Mi4zNzUtMS4yMjYuNDE5LTIuMTg0LjA0NC0uOTYuMDU0LTEuMjY3LjA1NC0zLjcxMXMtLjAxLTIuNzUtLjA1NC0zLjcxYy0uMDQ0LS45NTktLjE5Ni0xLjYxMy0uNDE5LTIuMTg1QTQuNDEyIDQuNDEyIDAgMCAwIDIzLjQ5IDguNTFhNC40MTIgNC40MTIgMCAwIDAtMS41OTQtMS4wMzljLS41NzItLjIyMi0xLjIyNi0uMzc0LTIuMTg0LS40MThDMTguNzUgNy4wMSAxOC40NDQgNyAxNiA3em0wIDQuNWE0LjUgNC41IDAgMSAwIDAgOSA0LjUgNC41IDAgMCAwIDAtOXptMCA3LjQyMWEyLjkyMSAyLjkyMSAwIDEgMSAwLTUuODQyIDIuOTIxIDIuOTIxIDAgMCAxIDAgNS44NDJ6bTQuODc1LTYuNjcxYTEuMTI1IDEuMTI1IDAgMSAxIDAtMi4yNSAxLjEyNSAxLjEyNSAwIDAgMSAwIDIuMjV6XCIgZmlsbD1cIiNGRkZcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICApXG5cbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKHVwcHksIHtcbiAgICAgIGNvbXBhbmlvblVybDogdGhpcy5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgIGNvbXBhbmlvbkhlYWRlcnM6IHRoaXMub3B0cy5jb21wYW5pb25IZWFkZXJzIHx8IHRoaXMub3B0cy5zZXJ2ZXJIZWFkZXJzLFxuICAgICAgY29tcGFuaW9uS2V5c1BhcmFtczogdGhpcy5vcHRzLmNvbXBhbmlvbktleXNQYXJhbXMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgICAgcHJvdmlkZXI6ICdpbnN0YWdyYW0nLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWQsXG4gICAgfSlcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIHZpZXdUeXBlOiAnZ3JpZCcsXG4gICAgICBzaG93VGl0bGVzOiBmYWxzZSxcbiAgICAgIHNob3dGaWx0ZXI6IGZhbHNlLFxuICAgICAgc2hvd0JyZWFkY3J1bWJzOiBmYWxzZSxcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoJ3JlY2VudCcpLFxuICAgIF0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvb25lZHJpdmVcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkltcG9ydCBmaWxlcyBmcm9tIE9uZURyaXZlLCBpbnRvIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMi4xXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwib25lZHJpdmVcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3Byb3ZpZGVyLXZpZXdzXCI6IFwiZmlsZTouLi9wcm92aWRlci12aWV3c1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBPbmVEcml2ZSBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdPbmVEcml2ZSdcbiAgICBQcm92aWRlci5pbml0UGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnT25lRHJpdmUnXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIGZpbGw9XCIjMDI2MkMwXCIgLz5cbiAgICAgICAgICA8ZyBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0yNC4xNTcgMjJzMS40OTItLjIwNSAxLjc5LTEuNjU1YTIuNjI0IDIuNjI0IDAgMCAwIC4wMy0uODc4Yy0uMjItMS42NC0xLjk4OC0yLjAxLTEuOTg4LTIuMDFzLjMwNy0xLjc2NS0xLjMxMi0yLjY5Yy0xLjYyLS45MjUtMy4xIDAtMy4xIDBTMTguNzExIDEzIDE2LjM2NiAxM2MtMy4wMTYgMC0zLjUxOSAzLjQ0OC0zLjUxOSAzLjQ0OFMxMCAxNi42MTggMTAgMTkuMTRjMCAyLjUyMyAyLjU5NyAyLjg2IDIuNTk3IDIuODZoMTEuNTZ6XCIgLz5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNOS40MjEgMTkuMjQ2YzAtMi4xOTcgMS42MDYtMy4xNTkgMi44NzEtMy40NzIuNDQtMS40NzcgMS42NTQtMy40MzkgNC4xMzUtMy40MzlIMTYuNDQ1YzEuNzIxIDAgMi43OS44MjMgMy4zNjggMS40NzZhMy45OSAzLjk5IDAgMCAxIDEuMTQ3LS4xNzFoLjAxbC4wMy4wMDJDMjEuMDE3IDEzLjUgMjAuNjkxIDEwIDE2Ljc1NyAxMGMtMi42OSAwLTMuNjM5IDIuMzQ1LTMuNjM5IDIuMzQ1cy0xLjk1LTEuNDgyLTMuOTU1LjU2N2MtMS4wMjggMS4wNTItLjc5IDIuNjY5LS43OSAyLjY2OVM2IDE1LjgyNCA2IDE4LjQxMkM2IDIwLjc1NyA4LjQ1MiAyMSA4LjQ1MiAyMWgxLjM3MmEzLjc3IDMuNzcgMCAwIDEtLjQwMy0xLjc1NHpcIiAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBQcm92aWRlcih1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ29uZWRyaXZlJyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgfSlcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldy50ZWFyRG93bigpXG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxuXG4gIG9uRmlyc3RSZW5kZXIgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnByb3ZpZGVyLmZldGNoUHJlQXV0aFRva2VuKCksXG4gICAgICB0aGlzLnZpZXcuZ2V0Rm9sZGVyKCksXG4gICAgXSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnJlbmRlcihzdGF0ZSlcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9wcm92aWRlci12aWV3c1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVmlldyBsaWJyYXJ5IGZvciBVcHB5IHJlbW90ZSBwcm92aWRlciBwbHVnaW5zLlwiLFxuICBcInZlcnNpb25cIjogXCIxLjEyLjJcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInN0eWxlXCI6IFwiZGlzdC9zdHlsZS5taW4uY3NzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJjbGFzc25hbWVzXCI6IFwiXjIuMi42XCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG4vLyBUT0RPIHVzZSBGcmFnbWVudCB3aGVuIHVwZ3JhZGluZyB0byBwcmVhY3QgWFxuY29uc3QgQnJlYWRjcnVtYiA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzcGFuPlxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0XCJcbiAgICAgICAgb25DbGljaz17cHJvcHMuZ2V0Rm9sZGVyfVxuICAgICAgPlxuICAgICAgICB7cHJvcHMudGl0bGV9XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIHshcHJvcHMuaXNMYXN0ID8gJyAvICcgOiAnJ31cbiAgICA8L3NwYW4+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYnJlYWRjcnVtYnNcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1icmVhZGNydW1ic0ljb25cIj57cHJvcHMuYnJlYWRjcnVtYnNJY29ufTwvZGl2PlxuICAgICAge1xuICAgICAgICBwcm9wcy5kaXJlY3Rvcmllcy5tYXAoKGRpcmVjdG9yeSwgaSkgPT4gKFxuICAgICAgICAgIDxCcmVhZGNydW1iXG4gICAgICAgICAgICBrZXk9e2RpcmVjdG9yeS5pZH1cbiAgICAgICAgICAgIGdldEZvbGRlcj17KCkgPT4gcHJvcHMuZ2V0Rm9sZGVyKGRpcmVjdG9yeS5pZCl9XG4gICAgICAgICAgICB0aXRsZT17aSA9PT0gMCA/IHByb3BzLnRpdGxlIDogZGlyZWN0b3J5LnRpdGxlfVxuICAgICAgICAgICAgaXNMYXN0PXtpICsgMSA9PT0gcHJvcHMuZGlyZWN0b3JpZXMubGVuZ3RofVxuICAgICAgICAgIC8+XG4gICAgICAgICkpXG4gICAgICB9XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IEZpbHRlciA9IHJlcXVpcmUoJy4vRmlsdGVyJylcbmNvbnN0IEl0ZW1MaXN0ID0gcmVxdWlyZSgnLi9JdGVtTGlzdCcpXG5jb25zdCBGb290ZXJBY3Rpb25zID0gcmVxdWlyZSgnLi9Gb290ZXJBY3Rpb25zJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3QgQnJvd3NlciA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgY3VycmVudFNlbGVjdGlvbixcbiAgICBmb2xkZXJzLFxuICAgIGZpbGVzLFxuICAgIHVwcHlGaWxlcyxcbiAgICBmaWx0ZXJJdGVtcyxcbiAgICBmaWx0ZXJJbnB1dCxcbiAgfSA9IHByb3BzXG5cbiAgbGV0IGZpbHRlcmVkRm9sZGVycyA9IGZvbGRlcnNcbiAgbGV0IGZpbHRlcmVkRmlsZXMgPSBmaWxlc1xuXG4gIGlmIChmaWx0ZXJJbnB1dCAhPT0gJycpIHtcbiAgICBmaWx0ZXJlZEZvbGRlcnMgPSBmaWx0ZXJJdGVtcyhmb2xkZXJzKVxuICAgIGZpbHRlcmVkRmlsZXMgPSBmaWx0ZXJJdGVtcyhmaWxlcylcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGVkID0gY3VycmVudFNlbGVjdGlvbi5sZW5ndGhcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCd1cHB5LVByb3ZpZGVyQnJvd3NlcicsIGB1cHB5LVByb3ZpZGVyQnJvd3Nlci12aWV3VHlwZS0tJHtwcm9wcy52aWV3VHlwZX1gKX0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJCcm93c2VyLWhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1Qcm92aWRlckJyb3dzZXItaGVhZGVyQmFyJywgIXByb3BzLnNob3dCcmVhZGNydW1icyAmJiAndXBweS1Qcm92aWRlckJyb3dzZXItaGVhZGVyQmFyLS1zaW1wbGUnKX0+XG4gICAgICAgICAge3Byb3BzLmhlYWRlckNvbXBvbmVudH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIHtwcm9wcy5zaG93RmlsdGVyICYmIDxGaWx0ZXIgey4uLnByb3BzfSAvPn1cbiAgICAgIDxJdGVtTGlzdFxuICAgICAgICBjb2x1bW5zPXtbe1xuICAgICAgICAgIG5hbWU6ICdOYW1lJyxcbiAgICAgICAgICBrZXk6ICd0aXRsZScsXG4gICAgICAgIH1dfVxuICAgICAgICBmb2xkZXJzPXtmaWx0ZXJlZEZvbGRlcnN9XG4gICAgICAgIGZpbGVzPXtmaWx0ZXJlZEZpbGVzfVxuICAgICAgICBzb3J0QnlUaXRsZT17cHJvcHMuc29ydEJ5VGl0bGV9XG4gICAgICAgIHNvcnRCeURhdGU9e3Byb3BzLnNvcnRCeURhdGV9XG4gICAgICAgIGlzQ2hlY2tlZD17cHJvcHMuaXNDaGVja2VkfVxuICAgICAgICBoYW5kbGVGb2xkZXJDbGljaz17cHJvcHMuZ2V0TmV4dEZvbGRlcn1cbiAgICAgICAgdG9nZ2xlQ2hlY2tib3g9e3Byb3BzLnRvZ2dsZUNoZWNrYm94fVxuICAgICAgICBoYW5kbGVTY3JvbGw9e3Byb3BzLmhhbmRsZVNjcm9sbH1cbiAgICAgICAgdGl0bGU9e3Byb3BzLnRpdGxlfVxuICAgICAgICBzaG93VGl0bGVzPXtwcm9wcy5zaG93VGl0bGVzfVxuICAgICAgICBpMThuPXtwcm9wcy5pMThufVxuICAgICAgICB2aWV3VHlwZT17cHJvcHMudmlld1R5cGV9XG4gICAgICAgIHZhbGlkYXRlUmVzdHJpY3Rpb25zPXtwcm9wcy52YWxpZGF0ZVJlc3RyaWN0aW9uc31cbiAgICAgICAgdXBweUZpbGVzPXt1cHB5RmlsZXN9XG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb249e2N1cnJlbnRTZWxlY3Rpb259XG4gICAgICAvPlxuICAgICAge3NlbGVjdGVkID4gMCAmJiA8Rm9vdGVyQWN0aW9ucyBzZWxlY3RlZD17c2VsZWN0ZWR9IHsuLi5wcm9wc30gLz59XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VyXG4iLCJjb25zdCB7IENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDbG9zZVdyYXBwZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgdGhpcy5wcm9wcy5vblVubW91bnQoKVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlblswXVxuICB9XG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGaWx0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnByZXZlbnRFbnRlclByZXNzID0gdGhpcy5wcmV2ZW50RW50ZXJQcmVzcy5iaW5kKHRoaXMpXG4gIH1cblxuICBwcmV2ZW50RW50ZXJQcmVzcyAoZXYpIHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1zZWFyY2hcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VyLXNlYXJjaElucHV0XCJcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3RoaXMucHJvcHMuaTE4bignZmlsdGVyJyl9XG4gICAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5pMThuKCdmaWx0ZXInKX1cbiAgICAgICAgICBvbktleVVwPXt0aGlzLnByZXZlbnRFbnRlclByZXNzfVxuICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5wcmV2ZW50RW50ZXJQcmVzc31cbiAgICAgICAgICBvbktleVByZXNzPXt0aGlzLnByZXZlbnRFbnRlclByZXNzfVxuICAgICAgICAgIG9uSW5wdXQ9eyhlKSA9PiB0aGlzLnByb3BzLmZpbHRlclF1ZXJ5KGUpfVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnByb3BzLmZpbHRlcklucHV0fVxuICAgICAgICAvPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb24gdXBweS1Qcm92aWRlckJyb3dzZXItc2VhcmNoSWNvblwiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIxMlwiIHZpZXdCb3g9XCIwIDAgMTIgMTJcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTguNjM4IDcuOTlsMy4xNzIgMy4xNzJhLjQ5Mi40OTIgMCAxIDEtLjY5Ny42OTdMNy45MSA4LjY1NmE0Ljk3NyA0Ljk3NyAwIDAgMS0yLjk4My45ODNDMi4yMDYgOS42MzkgMCA3LjQ4MSAwIDQuODE5IDAgMi4xNTggMi4yMDYgMCA0LjkyNyAwYzIuNzIxIDAgNC45MjcgMi4xNTggNC45MjcgNC44MmE0Ljc0IDQuNzQgMCAwIDEtMS4yMTYgMy4xN3ptLTMuNzEuNjg1YzIuMTc2IDAgMy45NC0xLjcyNiAzLjk0LTMuODU2IDAtMi4xMjktMS43NjQtMy44NTUtMy45NC0zLjg1NUMyLjc1Ljk2NC45ODQgMi42OS45ODQgNC44MTljMCAyLjEzIDEuNzY1IDMuODU2IDMuOTQyIDMuODU2elwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICB7dGhpcy5wcm9wcy5maWx0ZXJJbnB1dCAmJiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VyLXNlYXJjaENsb3NlXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5pMThuKCdyZXNldEZpbHRlcicpfVxuICAgICAgICAgICAgdGl0bGU9e3RoaXMucHJvcHMuaTE4bigncmVzZXRGaWx0ZXInKX1cbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMuZmlsdGVyUXVlcnl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgdmlld0JveD1cIjAgMCAxOSAxOVwiPlxuICAgICAgICAgICAgICA8cGF0aCBkPVwiTTE3LjMxOCAxNy4yMzJMOS45NCA5Ljg1NCA5LjU4NiA5LjVsLS4zNTQuMzU0LTcuMzc4IDcuMzc4aC43MDdsLS42Mi0uNjJ2LjcwNkw5LjMxOCA5Ljk0bC4zNTQtLjM1NC0uMzU0LS4zNTRMMS45NCAxLjg1NHYuNzA3bC42Mi0uNjJoLS43MDZsNy4zNzggNy4zNzguMzU0LjM1NC4zNTQtLjM1NCA3LjM3OC03LjM3OGgtLjcwN2wuNjIyLjYydi0uNzA2TDkuODU0IDkuMjMybC0uMzU0LjM1NC4zNTQuMzU0IDcuMzc4IDcuMzc4LjcwOC0uNzA3LTcuMzgtNy4zNzh2LjcwOGw3LjM4LTcuMzguMzUzLS4zNTMtLjM1My0uMzUzLS42MjItLjYyMi0uMzUzLS4zNTMtLjM1NC4zNTItNy4zNzggNy4zOGguNzA4TDIuNTYgMS4yMyAyLjIwOC44OGwtLjM1My4zNTMtLjYyMi42Mi0uMzUzLjM1NS4zNTIuMzUzIDcuMzggNy4zOHYtLjcwOGwtNy4zOCA3LjM4LS4zNTMuMzUzLjM1Mi4zNTMuNjIyLjYyMi4zNTMuMzUzLjM1NC0uMzUzIDcuMzgtNy4zOGgtLjcwOGw3LjM4IDcuMzh6XCIgLz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1mb290ZXJcIj5cbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1jLWJ0bi1wcmltYXJ5XCIgb25DbGljaz17cHJvcHMuZG9uZX0+XG4gICAgICAgIHtwcm9wcy5pMThuKCdzZWxlY3RYJywge1xuICAgICAgICAgIHNtYXJ0X2NvdW50OiBwcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgfSl9XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1jLWJ0bi1saW5rXCIgb25DbGljaz17cHJvcHMuY2FuY2VsfT5cbiAgICAgICAge3Byb3BzLmkxOG4oJ2NhbmNlbCcpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuLy8gaXQgY291bGQgYmUgYSA8bGk+PGJ1dHRvbiBjbGFzcz1cImZha2UtY2hlY2tib3hcIi8+IDxidXR0b24vPjwvbGk+XG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxsaSBjbGFzc05hbWU9e3Byb3BzLmNsYXNzTmFtZX0gdGl0bGU9e3Byb3BzLmlzRGlzYWJsZWQgPyBwcm9wcy5yZXN0cmljdGlvblJlYXNvbiA6IG51bGx9PlxuICAgICAgPGRpdiBhcmlhLWhpZGRlbiBjbGFzc05hbWU9e2B1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tZmFrZUNoZWNrYm94ICR7cHJvcHMuaXNDaGVja2VkID8gJ3VwcHktUHJvdmlkZXJCcm93c2VySXRlbS1mYWtlQ2hlY2tib3gtLWlzLWNoZWNrZWQnIDogJyd9YH0gLz5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0taW5uZXJcIlxuICAgICAgICBvbkNsaWNrPXtwcm9wcy50b2dnbGVDaGVja2JveH1cbiAgICAgICAgcm9sZT1cIm9wdGlvblwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmlzQ2hlY2tlZCA/IHByb3BzLmkxOG4oJ3Vuc2VsZWN0RmlsZU5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KSA6IHByb3BzLmkxOG4oJ3NlbGVjdEZpbGVOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSl9XG4gICAgICAgIGFyaWEtc2VsZWN0ZWQ9e3Byb3BzLmlzQ2hlY2tlZH1cbiAgICAgICAgYXJpYS1kaXNhYmxlZD17cHJvcHMuaXNEaXNhYmxlZH1cbiAgICAgICAgZGlzYWJsZWQ9e3Byb3BzLmlzRGlzYWJsZWR9XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgID5cbiAgICAgICAge3Byb3BzLml0ZW1JY29uRWx9XG4gICAgICAgIHtwcm9wcy5zaG93VGl0bGVzICYmIHByb3BzLnRpdGxlfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9saT5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBGaWxlSWNvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9ezExfSBoZWlnaHQ9ezE0LjV9IHZpZXdCb3g9XCIwIDAgNDQgNThcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMjcuNDM3LjUxN2ExIDEgMCAwIDAtLjA5NC4wM0g0LjI1QzIuMDM3LjU0OC4yMTcgMi4zNjguMjE3IDQuNTh2NDguNDA1YzAgMi4yMTIgMS44MiA0LjAzIDQuMDMgNC4wM0gzOS4wM2MyLjIxIDAgNC4wMy0xLjgxOCA0LjAzLTQuMDNWMTUuNjFhMSAxIDAgMCAwLS4wMy0uMjggMSAxIDAgMCAwIDAtLjA5MyAxIDEgMCAwIDAtLjAzLS4wMzIgMSAxIDAgMCAwIDAtLjAzIDEgMSAwIDAgMC0uMDMyLS4wNjMgMSAxIDAgMCAwLS4wMy0uMDYzIDEgMSAwIDAgMC0uMDMyIDAgMSAxIDAgMCAwLS4wMy0uMDYzIDEgMSAwIDAgMC0uMDMyLS4wMyAxIDEgMCAwIDAtLjAzLS4wNjMgMSAxIDAgMCAwLS4wNjMtLjA2MmwtMTQuNTkzLTE0YTEgMSAwIDAgMC0uMDYyLS4wNjJBMSAxIDAgMCAwIDI4IC43MDhhMSAxIDAgMCAwLS4zNzQtLjE1NyAxIDEgMCAwIDAtLjE1NiAwIDEgMSAwIDAgMC0uMDMtLjAzbC0uMDAzLS4wMDN6TTQuMjUgMi41NDdoMjIuMjE4djkuOTdjMCAyLjIxIDEuODIgNC4wMyA0LjAzIDQuMDNoMTAuNTY0djM2LjQzOGEyLjAyIDIuMDIgMCAwIDEtMi4wMzIgMi4wMzJINC4yNWMtMS4xMyAwLTIuMDMyLS45LTIuMDMyLTIuMDMyVjQuNThjMC0xLjEzLjkwMi0yLjAzMiAyLjAzLTIuMDMyem0yNC4yMTggMS4zNDVsMTAuMzc1IDkuOTM3Ljc1LjcxOEgzMC41Yy0xLjEzIDAtMi4wMzItLjktMi4wMzItMi4wM1YzLjg5elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gRm9sZGVySWNvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgc3R5bGU9e3sgbWluV2lkdGg6IDE2LCBtYXJnaW5SaWdodDogMyB9fSB2aWV3Qm94PVwiMCAwIDI3Ni4xNTcgMjc2LjE1N1wiPlxuICAgICAgPHBhdGggZD1cIk0yNzMuMDggMTAxLjM3OGMtMy4zLTQuNjUtOC44Ni03LjMyLTE1LjI1NC03LjMyaC0yNC4zNFY2Ny41OWMwLTEwLjItOC4zLTE4LjUtMTguNS0xOC41aC04NS4zMjJjLTMuNjMgMC05LjI5NS0yLjg3NS0xMS40MzYtNS44MDVsLTYuMzg2LTguNzM1Yy00Ljk4Mi02LjgxNC0xNS4xMDQtMTEuOTU0LTIzLjU0Ni0xMS45NTRINTguNzNjLTkuMjkyIDAtMTguNjM4IDYuNjA4LTIxLjczNyAxNS4zNzJsLTIuMDMzIDUuNzUyYy0uOTU4IDIuNzEtNC43MiA1LjM3LTcuNTk2IDUuMzdIMTguNUM4LjMgNDkuMDkgMCA1Ny4zOSAwIDY3LjU5djE2Ny4wN2MwIC44ODYuMTYgMS43My40NDMgMi41Mi4xNTIgMy4zMDYgMS4xOCA2LjQyNCAzLjA1MyA5LjA2NCAzLjMgNC42NTIgOC44NiA3LjMyIDE1LjI1NSA3LjMyaDE4OC40ODdjMTEuMzk1IDAgMjMuMjctOC40MjUgMjcuMDM1LTE5LjE4bDQwLjY3Ny0xMTYuMTg4YzIuMTEtNi4wMzUgMS40My0xMi4xNjQtMS44Ny0xNi44MTZ6TTE4LjUgNjQuMDg4aDguODY0YzkuMjk1IDAgMTguNjQtNi42MDcgMjEuNzM4LTE1LjM3bDIuMDMyLTUuNzVjLjk2LTIuNzEyIDQuNzIyLTUuMzczIDcuNTk3LTUuMzczaDI5LjU2NWMzLjYzIDAgOS4yOTUgMi44NzYgMTEuNDM3IDUuODA2bDYuMzg2IDguNzM1YzQuOTgyIDYuODE1IDE1LjEwNCAxMS45NTQgMjMuNTQ2IDExLjk1NGg4NS4zMjJjMS44OTggMCAzLjUgMS42MDIgMy41IDMuNXYyNi40N0g2OS4zNGMtMTEuMzk1IDAtMjMuMjcgOC40MjMtMjcuMDM1IDE5LjE3OEwxNSAxOTEuMjNWNjcuNTljMC0xLjg5OCAxLjYwMy0zLjUgMy41LTMuNXptMjQyLjI5IDQ5LjE1bC00MC42NzYgMTE2LjE4OGMtMS42NzQgNC43OC03LjgxMiA5LjEzNS0xMi44NzcgOS4xMzVIMTguNzVjLTEuNDQ3IDAtMi41NzYtLjM3Mi0zLjAyLS45OTctLjQ0Mi0uNjI1LS40MjItMS44MTQuMDU3LTMuMThsNDAuNjc3LTExNi4xOWMxLjY3NC00Ljc4IDcuODEyLTkuMTM0IDEyLjg3Ny05LjEzNGgxODguNDg3YzEuNDQ4IDAgMi41NzcuMzcyIDMuMDIuOTk3LjQ0My42MjUuNDIzIDEuODE0LS4wNTYgMy4xOHpcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIFZpZGVvSWNvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHN0eWxlPXt7IHdpZHRoOiAxNiwgbWFyZ2luUmlnaHQ6IDQgfX0gdmlld0JveD1cIjAgMCA1OCA1OFwiPlxuICAgICAgPHBhdGggZD1cIk0zNi41MzcgMjguMTU2bC0xMS03YTEuMDA1IDEuMDA1IDAgMCAwLTEuMDItLjAzM0MyNC4yIDIxLjMgMjQgMjEuNjM1IDI0IDIydjE0YTEgMSAwIDAgMCAxLjUzNy44NDRsMTEtN2ExLjAwMiAxLjAwMiAwIDAgMCAwLTEuNjg4ek0yNiAzNC4xOFYyMy44MkwzNC4xMzcgMjkgMjYgMzQuMTh6XCIgLz5cbiAgICAgIDxwYXRoIGQ9XCJNNTcgNkgxYTEgMSAwIDAgMC0xIDF2NDRhMSAxIDAgMCAwIDEgMWg1NmExIDEgMCAwIDAgMS0xVjdhMSAxIDAgMCAwLTEtMXpNMTAgMjhIMnYtOWg4djl6bS04IDJoOHY5SDJ2LTl6bTEwIDEwVjhoMzR2NDJIMTJWNDB6bTQ0LTEyaC04di05aDh2OXptLTggMmg4djloLTh2LTl6bTgtMjJ2OWgtOFY4aDh6TTIgOGg4djlIMlY4em0wIDQydi05aDh2OUgyem01NCAwaC04di05aDh2OXpcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIGlmIChwcm9wcy5pdGVtSWNvblN0cmluZyA9PT0gbnVsbCkgcmV0dXJuXG5cbiAgc3dpdGNoIChwcm9wcy5pdGVtSWNvblN0cmluZykge1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgcmV0dXJuIDxGaWxlSWNvbiAvPlxuICAgIGNhc2UgJ2ZvbGRlcic6XG4gICAgICByZXR1cm4gPEZvbGRlckljb24gLz5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgICByZXR1cm4gPFZpZGVvSWNvbiAvPlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gPGltZyBzcmM9e3Byb3BzLml0ZW1JY29uU3RyaW5nfSAvPlxuICB9XG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IGdldEFyaWFMYWJlbE9mQ2hlY2tib3ggPSAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdmb2xkZXInKSB7XG4gICAgaWYgKHByb3BzLmlzQ2hlY2tlZCkge1xuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3Vuc2VsZWN0QWxsRmlsZXNGcm9tRm9sZGVyTmFtZWQnLCB7IG5hbWU6IHByb3BzLnRpdGxlIH0pXG4gICAgfVxuICAgIHJldHVybiBwcm9wcy5pMThuKCdzZWxlY3RBbGxGaWxlc0Zyb21Gb2xkZXJOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSlcbiAgfVxuICBpZiAocHJvcHMuaXNDaGVja2VkKSB7XG4gICAgcmV0dXJuIHByb3BzLmkxOG4oJ3Vuc2VsZWN0RmlsZU5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KVxuICB9XG4gIHJldHVybiBwcm9wcy5pMThuKCdzZWxlY3RGaWxlTmFtZWQnLCB7IG5hbWU6IHByb3BzLnRpdGxlIH0pXG59XG5cbi8vIGlmIGZvbGRlcjpcbi8vICAgKyBjaGVja2JveCAoc2VsZWN0cyBhbGwgZmlsZXMgZnJvbSBmb2xkZXIpXG4vLyAgICsgZm9sZGVyIG5hbWUgKG9wZW5zIGZvbGRlcilcbi8vIGlmIGZpbGU6XG4vLyAgICsgY2hlY2tib3ggKHNlbGVjdHMgZmlsZSlcbi8vICAgKyBmaWxlIG5hbWUgKHNlbGVjdHMgZmlsZSlcbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGxpIGNsYXNzTmFtZT17cHJvcHMuY2xhc3NOYW1lfSB0aXRsZT17cHJvcHMuaXNEaXNhYmxlZCA/IHByb3BzLnJlc3RyaWN0aW9uUmVhc29uIDogbnVsbH0+XG4gICAgICB7IXByb3BzLmlzQ2hlY2tib3hEaXNhYmxlZCA/IChcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT17YHVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tZmFrZUNoZWNrYm94ICR7cHJvcHMuaXNDaGVja2VkID8gJ3VwcHktUHJvdmlkZXJCcm93c2VySXRlbS1mYWtlQ2hlY2tib3gtLWlzLWNoZWNrZWQnIDogJyd9YH1cbiAgICAgICAgICBvbkNsaWNrPXtwcm9wcy50b2dnbGVDaGVja2JveH1cbiAgICAgICAgICAvLyBmb3IgdGhlIDxsYWJlbC8+XG4gICAgICAgICAgaWQ9e3Byb3BzLmlkfVxuICAgICAgICAgIHJvbGU9XCJvcHRpb25cIlxuICAgICAgICAgIGFyaWEtbGFiZWw9e2dldEFyaWFMYWJlbE9mQ2hlY2tib3gocHJvcHMpfVxuICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9e3Byb3BzLmlzQ2hlY2tlZH1cbiAgICAgICAgICBhcmlhLWRpc2FibGVkPXtwcm9wcy5pc0Rpc2FibGVkfVxuICAgICAgICAgIGRpc2FibGVkPXtwcm9wcy5pc0Rpc2FibGVkfVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgLz5cbiAgICAgICkgOiBudWxsfVxuXG4gICAgICB7cHJvcHMudHlwZSA9PT0gJ2ZpbGUnID8gKFxuICAgICAgICAvLyBsYWJlbCBmb3IgYSBjaGVja2JveFxuICAgICAgICA8bGFiZWwgaHRtbEZvcj17cHJvcHMuaWR9IGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0taW5uZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pY29uV3JhcFwiPlxuICAgICAgICAgICAge3Byb3BzLml0ZW1JY29uRWx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3Byb3BzLnNob3dUaXRsZXMgJiYgcHJvcHMudGl0bGV9XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICApIDogKFxuICAgICAgICAvLyBidXR0b24gdG8gb3BlbiBhIGZvbGRlclxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pbm5lclwiXG4gICAgICAgICAgb25DbGljaz17cHJvcHMuaGFuZGxlRm9sZGVyQ2xpY2t9XG4gICAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignb3BlbkZvbGRlck5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWljb25XcmFwXCI+XG4gICAgICAgICAgICB7cHJvcHMuaXRlbUljb25FbH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7cHJvcHMuc2hvd1RpdGxlcyAmJiA8c3Bhbj57cHJvcHMudGl0bGV9PC9zcGFuPn1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApfVxuICAgIDwvbGk+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IEl0ZW1JY29uID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0l0ZW1JY29uJylcbmNvbnN0IEdyaWRMaSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9HcmlkTGknKVxuY29uc3QgTGlzdExpID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0xpc3RMaScpXG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGl0ZW1JY29uU3RyaW5nID0gcHJvcHMuZ2V0SXRlbUljb24oKVxuXG4gIGNvbnN0IGNsYXNzTmFtZSA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktUHJvdmlkZXJCcm93c2VySXRlbScsXG4gICAgeyAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLS1zZWxlY3RlZCc6IHByb3BzLmlzQ2hlY2tlZCB9LFxuICAgIHsgJ3VwcHktUHJvdmlkZXJCcm93c2VySXRlbS0tZGlzYWJsZWQnOiBwcm9wcy5pc0Rpc2FibGVkIH0sXG4gICAgeyAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLS1ub1ByZXZpZXcnOiBpdGVtSWNvblN0cmluZyA9PT0gJ3ZpZGVvJyB9XG4gIClcblxuICBjb25zdCBpdGVtSWNvbkVsID0gPEl0ZW1JY29uIGl0ZW1JY29uU3RyaW5nPXtpdGVtSWNvblN0cmluZ30gLz5cblxuICBzd2l0Y2ggKHByb3BzLnZpZXdUeXBlKSB7XG4gICAgY2FzZSAnZ3JpZCc6XG4gICAgICByZXR1cm4gPEdyaWRMaSB7Li4ucHJvcHN9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBpdGVtSWNvbkVsPXtpdGVtSWNvbkVsfSAvPlxuICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgcmV0dXJuIDxMaXN0TGkgey4uLnByb3BzfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gaXRlbUljb25FbD17aXRlbUljb25FbH0gLz5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBzdWNoIHR5cGUgJHtwcm9wcy52aWV3VHlwZX1gKVxuICB9XG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCByZW1vdGVGaWxlT2JqVG9Mb2NhbCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9yZW1vdGVGaWxlT2JqVG9Mb2NhbCcpXG5jb25zdCBJdGVtID0gcmVxdWlyZSgnLi9JdGVtL2luZGV4JylcblxuLy8gSG9wZWZ1bGx5IHRoaXMgbmFtZSB3aWxsIG5vdCBiZSB1c2VkIGJ5IEdvb2dsZVxuY29uc3QgVklSVFVBTF9TSEFSRURfRElSID0gJ3NoYXJlZC13aXRoLW1lJ1xuXG5jb25zdCBnZXRTaGFyZWRQcm9wcyA9IChmaWxlT3JGb2xkZXIsIHByb3BzKSA9PiAoe1xuICBpZDogZmlsZU9yRm9sZGVyLmlkLFxuICB0aXRsZTogZmlsZU9yRm9sZGVyLm5hbWUsXG4gIGdldEl0ZW1JY29uOiAoKSA9PiBmaWxlT3JGb2xkZXIuaWNvbixcbiAgaXNDaGVja2VkOiBwcm9wcy5pc0NoZWNrZWQoZmlsZU9yRm9sZGVyKSxcbiAgdG9nZ2xlQ2hlY2tib3g6IChlKSA9PiBwcm9wcy50b2dnbGVDaGVja2JveChlLCBmaWxlT3JGb2xkZXIpLFxuICBjb2x1bW5zOiBwcm9wcy5jb2x1bW5zLFxuICBzaG93VGl0bGVzOiBwcm9wcy5zaG93VGl0bGVzLFxuICB2aWV3VHlwZTogcHJvcHMudmlld1R5cGUsXG4gIGkxOG46IHByb3BzLmkxOG4sXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGZvbGRlcnMsIGZpbGVzLCBoYW5kbGVTY3JvbGwsIGlzQ2hlY2tlZCB9ID0gcHJvcHNcblxuICBpZiAoIWZvbGRlcnMubGVuZ3RoICYmICFmaWxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWVtcHR5XCI+e3Byb3BzLmkxOG4oJ25vRmlsZXNGb3VuZCcpfTwvZGl2PlxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJCcm93c2VyLWJvZHlcIj5cbiAgICAgIDx1bFxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1saXN0XCJcbiAgICAgICAgb25TY3JvbGw9e2hhbmRsZVNjcm9sbH1cbiAgICAgICAgcm9sZT1cImxpc3Rib3hcIlxuICAgICAgICAvLyBtYWtpbmcgPHVsPiBub3QgZm9jdXNhYmxlIGZvciBmaXJlZm94XG4gICAgICAgIHRhYkluZGV4PVwiLTFcIlxuICAgICAgPlxuICAgICAgICB7Zm9sZGVycy5tYXAoZm9sZGVyID0+IHtcbiAgICAgICAgICByZXR1cm4gSXRlbSh7XG4gICAgICAgICAgICAuLi5nZXRTaGFyZWRQcm9wcyhmb2xkZXIsIHByb3BzKSxcbiAgICAgICAgICAgIHR5cGU6ICdmb2xkZXInLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogaXNDaGVja2VkKGZvbGRlcikgPyBpc0NoZWNrZWQoZm9sZGVyKS5sb2FkaW5nIDogZmFsc2UsXG4gICAgICAgICAgICBpc0NoZWNrYm94RGlzYWJsZWQ6IGZvbGRlci5pZCA9PT0gVklSVFVBTF9TSEFSRURfRElSLFxuICAgICAgICAgICAgaGFuZGxlRm9sZGVyQ2xpY2s6ICgpID0+IHByb3BzLmhhbmRsZUZvbGRlckNsaWNrKGZvbGRlciksXG4gICAgICAgICAgfSlcbiAgICAgICAgfSl9XG4gICAgICAgIHtmaWxlcy5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGVSZXN0cmljdGlvbnMgPSBwcm9wcy52YWxpZGF0ZVJlc3RyaWN0aW9ucyhcbiAgICAgICAgICAgIHJlbW90ZUZpbGVPYmpUb0xvY2FsKGZpbGUpLFxuICAgICAgICAgICAgWy4uLnByb3BzLnVwcHlGaWxlcywgLi4ucHJvcHMuY3VycmVudFNlbGVjdGlvbl1cbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3Qgc2hhcmVkUHJvcHMgPSBnZXRTaGFyZWRQcm9wcyhmaWxlLCBwcm9wcylcbiAgICAgICAgICBjb25zdCByZXN0cmljdGlvblJlYXNvbiA9IHZhbGlkYXRlUmVzdHJpY3Rpb25zLnJlYXNvblxuXG4gICAgICAgICAgcmV0dXJuIEl0ZW0oe1xuICAgICAgICAgICAgLi4uc2hhcmVkUHJvcHMsXG4gICAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgICAgICBpc0Rpc2FibGVkOiAhdmFsaWRhdGVSZXN0cmljdGlvbnMucmVzdWx0ICYmICFzaGFyZWRQcm9wcy5pc0NoZWNrZWQsXG4gICAgICAgICAgICByZXN0cmljdGlvblJlYXNvbixcbiAgICAgICAgICB9KVxuICAgICAgICB9KX1cbiAgICAgIDwvdWw+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItbG9hZGluZ1wiPlxuICAgICAgPHNwYW4+e3Byb3BzLmkxOG4oJ2xvYWRpbmcnKX08L3NwYW4+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jbGFzcyBBdXRoVmlldyBleHRlbmRzIENvbXBvbmVudCB7XG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgcGx1Z2luTmFtZUNvbXBvbmVudCA9IChcbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYXV0aFRpdGxlTmFtZVwiPlxuICAgICAgICB7dGhpcy5wcm9wcy5wbHVnaW5OYW1lfVxuICAgICAgICA8YnIgLz5cbiAgICAgIDwvc3Bhbj5cbiAgICApXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1hdXRoXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1hdXRoSWNvblwiPnt0aGlzLnByb3BzLnBsdWdpbkljb24oKX08L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWF1dGhUaXRsZVwiPlxuICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG5BcnJheSgnYXV0aGVudGljYXRlV2l0aFRpdGxlJywgeyBwbHVnaW5OYW1lOiBwbHVnaW5OYW1lQ29tcG9uZW50IH0pfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeSB1cHB5LVByb3ZpZGVyLWF1dGhCdG5cIlxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMuaGFuZGxlQXV0aH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgID5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuQXJyYXkoJ2F1dGhlbnRpY2F0ZVdpdGgnLCB7IHBsdWdpbk5hbWU6IHRoaXMucHJvcHMucGx1Z2luTmFtZSB9KX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoVmlld1xuIiwiY29uc3QgVXNlciA9IHJlcXVpcmUoJy4vVXNlcicpXG5jb25zdCBCcmVhZGNydW1icyA9IHJlcXVpcmUoJy4uL0JyZWFkY3J1bWJzJylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgY29tcG9uZW50cyA9IFtdXG4gIGlmIChwcm9wcy5zaG93QnJlYWRjcnVtYnMpIHtcbiAgICBjb21wb25lbnRzLnB1c2goQnJlYWRjcnVtYnMoe1xuICAgICAgZ2V0Rm9sZGVyOiBwcm9wcy5nZXRGb2xkZXIsXG4gICAgICBkaXJlY3RvcmllczogcHJvcHMuZGlyZWN0b3JpZXMsXG4gICAgICBicmVhZGNydW1ic0ljb246IHByb3BzLnBsdWdpbkljb24gJiYgcHJvcHMucGx1Z2luSWNvbigpLFxuICAgICAgdGl0bGU6IHByb3BzLnRpdGxlLFxuICAgIH0pKVxuICB9XG5cbiAgY29tcG9uZW50cy5wdXNoKFVzZXIoe1xuICAgIGxvZ291dDogcHJvcHMubG9nb3V0LFxuICAgIHVzZXJuYW1lOiBwcm9wcy51c2VybmFtZSxcbiAgICBpMThuOiBwcm9wcy5pMThuLFxuICB9KSlcblxuICByZXR1cm4gY29tcG9uZW50c1xufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgQXV0aFZpZXcgPSByZXF1aXJlKCcuL0F1dGhWaWV3JylcbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vSGVhZGVyJylcbmNvbnN0IEJyb3dzZXIgPSByZXF1aXJlKCcuLi9Ccm93c2VyJylcbmNvbnN0IExvYWRlclZpZXcgPSByZXF1aXJlKCcuLi9Mb2FkZXInKVxuY29uc3QgZ2VuZXJhdGVGaWxlSUQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2VuZXJhdGVGaWxlSUQnKVxuY29uc3QgZ2V0RmlsZVR5cGUgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RmlsZVR5cGUnKVxuY29uc3QgZmluZEluZGV4ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZpbmRJbmRleCcpXG5jb25zdCBpc1ByZXZpZXdTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNQcmV2aWV3U3VwcG9ydGVkJylcbmNvbnN0IFNoYXJlZEhhbmRsZXIgPSByZXF1aXJlKCcuLi9TaGFyZWRIYW5kbGVyJylcbmNvbnN0IENsb3NlV3JhcHBlciA9IHJlcXVpcmUoJy4uL0Nsb3NlV3JhcHBlcicpXG5cbi8vIGxvY2F0aW9uLm9yaWdpbiBkb2VzIG5vdCBleGlzdCBpbiBJRVxuZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgaWYgKCdvcmlnaW4nIGluIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLm9yaWdpbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcbiAgfVxuICByZXR1cm4gYCR7bG9jYXRpb24ucHJvdG9jb2x9Ly8ke2xvY2F0aW9uLmhvc3RuYW1lfSR7bG9jYXRpb24ucG9ydCA/IGA6JHtsb2NhdGlvbi5wb3J0fWAgOiAnJ31gXG59XG5cbi8qKlxuICogQ2xhc3MgdG8gZWFzaWx5IGdlbmVyYXRlIGdlbmVyaWMgdmlld3MgZm9yIFByb3ZpZGVyIHBsdWdpbnNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQcm92aWRlclZpZXcge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbiBpbnN0YW5jZSBvZiB0aGUgcGx1Z2luXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocGx1Z2luLCBvcHRzKSB7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlclxuICAgIHRoaXMuX3NoYXJlZEhhbmRsZXIgPSBuZXcgU2hhcmVkSGFuZGxlcihwbHVnaW4pXG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB2aWV3VHlwZTogJ2xpc3QnLFxuICAgICAgc2hvd1RpdGxlczogdHJ1ZSxcbiAgICAgIHNob3dGaWx0ZXI6IHRydWUsXG4gICAgICBzaG93QnJlYWRjcnVtYnM6IHRydWUsXG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIG9uZXMgc2V0IGJ5IHVzZXJcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIC8vIExvZ2ljXG4gICAgdGhpcy5hZGRGaWxlID0gdGhpcy5hZGRGaWxlLmJpbmQodGhpcylcbiAgICB0aGlzLmZpbHRlclF1ZXJ5ID0gdGhpcy5maWx0ZXJRdWVyeS5iaW5kKHRoaXMpXG4gICAgdGhpcy5nZXRGb2xkZXIgPSB0aGlzLmdldEZvbGRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5nZXROZXh0Rm9sZGVyID0gdGhpcy5nZXROZXh0Rm9sZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLmxvZ291dCA9IHRoaXMubG9nb3V0LmJpbmQodGhpcylcbiAgICB0aGlzLnByZUZpcnN0UmVuZGVyID0gdGhpcy5wcmVGaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVBdXRoID0gdGhpcy5oYW5kbGVBdXRoLmJpbmQodGhpcylcbiAgICB0aGlzLnNvcnRCeVRpdGxlID0gdGhpcy5zb3J0QnlUaXRsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5zb3J0QnlEYXRlID0gdGhpcy5zb3J0QnlEYXRlLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUVycm9yID0gdGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVTY3JvbGwgPSB0aGlzLmhhbmRsZVNjcm9sbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5saXN0QWxsRmlsZXMgPSB0aGlzLmxpc3RBbGxGaWxlcy5iaW5kKHRoaXMpXG4gICAgdGhpcy5kb25lUGlja2luZyA9IHRoaXMuZG9uZVBpY2tpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuY2FuY2VsUGlja2luZyA9IHRoaXMuY2FuY2VsUGlja2luZy5iaW5kKHRoaXMpXG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbiA9IHRoaXMuY2xlYXJTZWxlY3Rpb24uYmluZCh0aGlzKVxuXG4gICAgLy8gVmlzdWFsXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcblxuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRlIGZvciB0aGUgcGx1Z2luXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgYXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICBmaWxlczogW10sXG4gICAgICBmb2xkZXJzOiBbXSxcbiAgICAgIGRpcmVjdG9yaWVzOiBbXSxcbiAgICAgIGZpbHRlcklucHV0OiAnJyxcbiAgICAgIGlzU2VhcmNoVmlzaWJsZTogZmFsc2UsXG4gICAgfSlcbiAgfVxuXG4gIHRlYXJEb3duICgpIHtcbiAgICAvLyBOb3RoaW5nLlxuICB9XG5cbiAgX3VwZGF0ZUZpbGVzQW5kRm9sZGVycyAocmVzLCBmaWxlcywgZm9sZGVycykge1xuICAgIHRoaXMubmV4dFBhZ2VQYXRoID0gcmVzLm5leHRQYWdlUGF0aFxuICAgIHJlcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS5pc0ZvbGRlcikge1xuICAgICAgICBmb2xkZXJzLnB1c2goaXRlbSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGVzLnB1c2goaXRlbSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBmb2xkZXJzLCBmaWxlcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBwcm92aWRlciB2aWV3IGlzIHJlbmRlcmVkLlxuICAgKiBLaW5kIG9mIGxpa2UgYW4gaW5pdCBmdW5jdGlvbi5cbiAgICovXG4gIHByZUZpcnN0UmVuZGVyICgpIHtcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGRpZEZpcnN0UmVuZGVyOiB0cnVlIH0pXG4gICAgdGhpcy5wbHVnaW4ub25GaXJzdFJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogQmFzZWQgb24gZm9sZGVyIElELCBmZXRjaCBhIG5ldyBmb2xkZXIgYW5kIHVwZGF0ZSBpdCB0byBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIEZvbGRlciBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gICBGb2xkZXJzL2ZpbGVzIGluIGZvbGRlclxuICAgKi9cbiAgZ2V0Rm9sZGVyIChpZCwgbmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9zaGFyZWRIYW5kbGVyLmxvYWRlcldyYXBwZXIoXG4gICAgICB0aGlzLnByb3ZpZGVyLmxpc3QoaWQpLFxuICAgICAgKHJlcykgPT4ge1xuICAgICAgICBjb25zdCBmb2xkZXJzID0gW11cbiAgICAgICAgY29uc3QgZmlsZXMgPSBbXVxuICAgICAgICBsZXQgdXBkYXRlZERpcmVjdG9yaWVzXG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHN0YXRlLmRpcmVjdG9yaWVzLCAoZGlyKSA9PiBpZCA9PT0gZGlyLmlkKVxuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB1cGRhdGVkRGlyZWN0b3JpZXMgPSBzdGF0ZS5kaXJlY3Rvcmllcy5zbGljZSgwLCBpbmRleCArIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlZERpcmVjdG9yaWVzID0gc3RhdGUuZGlyZWN0b3JpZXMuY29uY2F0KFt7IGlkLCB0aXRsZTogbmFtZSB9XSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSByZXMudXNlcm5hbWUgfHwgdGhpcy51c2VybmFtZVxuICAgICAgICB0aGlzLl91cGRhdGVGaWxlc0FuZEZvbGRlcnMocmVzLCBmaWxlcywgZm9sZGVycylcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBkaXJlY3RvcmllczogdXBkYXRlZERpcmVjdG9yaWVzIH0pXG4gICAgICB9LFxuICAgICAgdGhpcy5oYW5kbGVFcnJvclxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIG5ldyBmb2xkZXJcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBmb2xkZXJcbiAgICovXG4gIGdldE5leHRGb2xkZXIgKGZvbGRlcikge1xuICAgIHRoaXMuZ2V0Rm9sZGVyKGZvbGRlci5yZXF1ZXN0UGF0aCwgZm9sZGVyLm5hbWUpXG4gICAgdGhpcy5sYXN0Q2hlY2tib3ggPSB1bmRlZmluZWRcbiAgfVxuXG4gIGFkZEZpbGUgKGZpbGUpIHtcbiAgICBjb25zdCB0YWdGaWxlID0ge1xuICAgICAgaWQ6IHRoaXMucHJvdmlkZXJGaWxlVG9JZChmaWxlKSxcbiAgICAgIHNvdXJjZTogdGhpcy5wbHVnaW4uaWQsXG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbmFtZTogZmlsZS5uYW1lIHx8IGZpbGUuaWQsXG4gICAgICB0eXBlOiBmaWxlLm1pbWVUeXBlLFxuICAgICAgaXNSZW1vdGU6IHRydWUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIGZpbGVJZDogZmlsZS5pZCxcbiAgICAgIH0sXG4gICAgICByZW1vdGU6IHtcbiAgICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLnBsdWdpbi5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgICAgdXJsOiBgJHt0aGlzLnByb3ZpZGVyLmZpbGVVcmwoZmlsZS5yZXF1ZXN0UGF0aCl9YCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIGZpbGVJZDogZmlsZS5pZCxcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiB0aGlzLnByb3ZpZGVyLm9wdHMsXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVUeXBlID0gZ2V0RmlsZVR5cGUodGFnRmlsZSlcbiAgICAvLyBUT0RPIFNob3VsZCB3ZSBqdXN0IGFsd2F5cyB1c2UgdGhlIHRodW1ibmFpbCBVUkwgaWYgaXQgZXhpc3RzP1xuICAgIGlmIChmaWxlVHlwZSAmJiBpc1ByZXZpZXdTdXBwb3J0ZWQoZmlsZVR5cGUpKSB7XG4gICAgICB0YWdGaWxlLnByZXZpZXcgPSBmaWxlLnRodW1ibmFpbFxuICAgIH1cbiAgICB0aGlzLnBsdWdpbi51cHB5LmxvZygnQWRkaW5nIHJlbW90ZSBmaWxlJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5wbHVnaW4udXBweS5hZGRGaWxlKHRhZ0ZpbGUpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICB0aGlzLnBsdWdpbi51cHB5LmxvZyhlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzZXNzaW9uIHRva2VuIG9uIGNsaWVudCBzaWRlLlxuICAgKi9cbiAgbG9nb3V0ICgpIHtcbiAgICB0aGlzLnByb3ZpZGVyLmxvZ291dCgpXG4gICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICBpZiAoIXJlcy5yZXZva2VkKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5wbHVnaW4udXBweS5pMThuKCdjb21wYW5pb25VbmF1dGhvcml6ZUhpbnQnLCB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgICAgICAgICAgdXJsOiByZXMubWFudWFsX3Jldm9rZV91cmwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5wbHVnaW4udXBweS5pbmZvKG1lc3NhZ2UsICdpbmZvJywgNzAwMClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZmlsZXM6IFtdLFxuICAgICAgICAgICAgZm9sZGVyczogW10sXG4gICAgICAgICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKG5ld1N0YXRlKVxuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKVxuICB9XG5cbiAgZmlsdGVyUXVlcnkgKGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IC4uLnN0YXRlLCBmaWx0ZXJJbnB1dDogZSA/IGUudGFyZ2V0LnZhbHVlIDogJycgfSlcbiAgfVxuXG4gIHNvcnRCeVRpdGxlICgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgLi4udGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKSB9XG4gICAgY29uc3QgeyBmaWxlcywgZm9sZGVycywgc29ydGluZyB9ID0gc3RhdGVcblxuICAgIGNvbnN0IHNvcnRlZEZpbGVzID0gZmlsZXMuc29ydCgoZmlsZUEsIGZpbGVCKSA9PiB7XG4gICAgICBpZiAoc29ydGluZyA9PT0gJ3RpdGxlRGVzY2VuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVCLm5hbWUubG9jYWxlQ29tcGFyZShmaWxlQS5uYW1lKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGVBLm5hbWUubG9jYWxlQ29tcGFyZShmaWxlQi5uYW1lKVxuICAgIH0pXG5cbiAgICBjb25zdCBzb3J0ZWRGb2xkZXJzID0gZm9sZGVycy5zb3J0KChmb2xkZXJBLCBmb2xkZXJCKSA9PiB7XG4gICAgICBpZiAoc29ydGluZyA9PT0gJ3RpdGxlRGVzY2VuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZvbGRlckIubmFtZS5sb2NhbGVDb21wYXJlKGZvbGRlckEubmFtZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb2xkZXJBLm5hbWUubG9jYWxlQ29tcGFyZShmb2xkZXJCLm5hbWUpXG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZmlsZXM6IHNvcnRlZEZpbGVzLFxuICAgICAgZm9sZGVyczogc29ydGVkRm9sZGVycyxcbiAgICAgIHNvcnRpbmc6IChzb3J0aW5nID09PSAndGl0bGVEZXNjZW5kaW5nJykgPyAndGl0bGVBc2NlbmRpbmcnIDogJ3RpdGxlRGVzY2VuZGluZycsXG4gICAgfSlcbiAgfVxuXG4gIHNvcnRCeURhdGUgKCkge1xuICAgIGNvbnN0IHN0YXRlID0geyAuLi50aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpIH1cbiAgICBjb25zdCB7IGZpbGVzLCBmb2xkZXJzLCBzb3J0aW5nIH0gPSBzdGF0ZVxuXG4gICAgY29uc3Qgc29ydGVkRmlsZXMgPSBmaWxlcy5zb3J0KChmaWxlQSwgZmlsZUIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBuZXcgRGF0ZShmaWxlQS5tb2RpZmllZERhdGUpXG4gICAgICBjb25zdCBiID0gbmV3IERhdGUoZmlsZUIubW9kaWZpZWREYXRlKVxuXG4gICAgICBpZiAoc29ydGluZyA9PT0gJ2RhdGVEZXNjZW5kaW5nJykge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPCBiID8gMSA6IDBcbiAgICAgIH1cbiAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMFxuICAgIH0pXG5cbiAgICBjb25zdCBzb3J0ZWRGb2xkZXJzID0gZm9sZGVycy5zb3J0KChmb2xkZXJBLCBmb2xkZXJCKSA9PiB7XG4gICAgICBjb25zdCBhID0gbmV3IERhdGUoZm9sZGVyQS5tb2RpZmllZERhdGUpXG4gICAgICBjb25zdCBiID0gbmV3IERhdGUoZm9sZGVyQi5tb2RpZmllZERhdGUpXG5cbiAgICAgIGlmIChzb3J0aW5nID09PSAnZGF0ZURlc2NlbmRpbmcnKSB7XG4gICAgICAgIHJldHVybiBhID4gYiA/IC0xIDogYSA8IGIgPyAxIDogMFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDBcbiAgICB9KVxuXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBmaWxlczogc29ydGVkRmlsZXMsXG4gICAgICBmb2xkZXJzOiBzb3J0ZWRGb2xkZXJzLFxuICAgICAgc29ydGluZzogKHNvcnRpbmcgPT09ICdkYXRlRGVzY2VuZGluZycpID8gJ2RhdGVBc2NlbmRpbmcnIDogJ2RhdGVEZXNjZW5kaW5nJyxcbiAgICB9KVxuICB9XG5cbiAgc29ydEJ5U2l6ZSAoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IC4uLnRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCkgfVxuICAgIGNvbnN0IHsgZmlsZXMsIHNvcnRpbmcgfSA9IHN0YXRlXG5cbiAgICAvLyBjaGVjayB0aGF0IHBsdWdpbiBzdXBwb3J0cyBmaWxlIHNpemVzXG4gICAgaWYgKCFmaWxlcy5sZW5ndGggfHwgIXRoaXMucGx1Z2luLmdldEl0ZW1EYXRhKGZpbGVzWzBdKS5zaXplKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzb3J0ZWRGaWxlcyA9IGZpbGVzLnNvcnQoKGZpbGVBLCBmaWxlQikgPT4ge1xuICAgICAgY29uc3QgYSA9IGZpbGVBLnNpemVcbiAgICAgIGNvbnN0IGIgPSBmaWxlQi5zaXplXG5cbiAgICAgIGlmIChzb3J0aW5nID09PSAnc2l6ZURlc2NlbmRpbmcnKSB7XG4gICAgICAgIHJldHVybiBhID4gYiA/IC0xIDogYSA8IGIgPyAxIDogMFxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwXG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZmlsZXM6IHNvcnRlZEZpbGVzLFxuICAgICAgc29ydGluZzogKHNvcnRpbmcgPT09ICdzaXplRGVzY2VuZGluZycpID8gJ3NpemVBc2NlbmRpbmcnIDogJ3NpemVEZXNjZW5kaW5nJyxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYWxsIGZpbGVzIGZvdW5kIGluc2lkZSBvZiBzcGVjaWZpZWQgZm9sZGVyLlxuICAgKlxuICAgKiBVc2VzIHNlcGFyYXRlZCBzdGF0ZSB3aGlsZSBmb2xkZXIgY29udGVudHMgYXJlIGJlaW5nIGZldGNoZWQgYW5kXG4gICAqIG1hbnRhaW5zIGxpc3Qgb2Ygc2VsZWN0ZWQgZm9sZGVycywgd2hpY2ggYXJlIHNlcGFyYXRlZCBmcm9tIGZpbGVzLlxuICAgKi9cbiAgYWRkRm9sZGVyIChmb2xkZXIpIHtcbiAgICBjb25zdCBmb2xkZXJJZCA9IHRoaXMucHJvdmlkZXJGaWxlVG9JZChmb2xkZXIpXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgZm9sZGVycyA9IHsgLi4uc3RhdGUuc2VsZWN0ZWRGb2xkZXJzIH1cbiAgICBpZiAoZm9sZGVySWQgaW4gZm9sZGVycyAmJiBmb2xkZXJzW2ZvbGRlcklkXS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9sZGVyc1tmb2xkZXJJZF0gPSB7IGxvYWRpbmc6IHRydWUsIGZpbGVzOiBbXSB9XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBzZWxlY3RlZEZvbGRlcnM6IHsgLi4uZm9sZGVycyB9IH0pXG4gICAgcmV0dXJuIHRoaXMubGlzdEFsbEZpbGVzKGZvbGRlci5yZXF1ZXN0UGF0aCkudGhlbigoZmlsZXMpID0+IHtcbiAgICAgIGxldCBjb3VudCA9IDBcbiAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMuYWRkRmlsZShmaWxlKVxuICAgICAgICBpZiAoc3VjY2VzcykgY291bnQrK1xuICAgICAgfSlcbiAgICAgIGNvbnN0IGlkcyA9IGZpbGVzLm1hcCh0aGlzLnByb3ZpZGVyRmlsZVRvSWQpXG4gICAgICBmb2xkZXJzW2ZvbGRlcklkXSA9IHtcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIGZpbGVzOiBpZHMsXG4gICAgICB9XG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IHNlbGVjdGVkRm9sZGVyczogZm9sZGVycyB9KVxuXG4gICAgICBsZXQgbWVzc2FnZVxuICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5wbHVnaW4udXBweS5pMThuKCdmb2xkZXJBZGRlZCcsIHtcbiAgICAgICAgICBzbWFydF9jb3VudDogY291bnQsIGZvbGRlcjogZm9sZGVyLm5hbWUsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5wbHVnaW4udXBweS5pMThuKCdlbXB0eUZvbGRlckFkZGVkJylcbiAgICAgIH1cbiAgICAgIHRoaXMucGx1Z2luLnVwcHkuaW5mbyhtZXNzYWdlKVxuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICAgIGNvbnN0IHNlbGVjdGVkRm9sZGVycyA9IHsgLi4uc3RhdGUuc2VsZWN0ZWRGb2xkZXJzIH1cbiAgICAgIGRlbGV0ZSBzZWxlY3RlZEZvbGRlcnNbZm9sZGVySWRdXG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IHNlbGVjdGVkRm9sZGVycyB9KVxuICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKVxuICAgIH0pXG4gIH1cblxuICBwcm92aWRlckZpbGVUb0lkIChmaWxlKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlRmlsZUlEKHtcbiAgICAgIGRhdGE6IGZpbGUsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUgfHwgZmlsZS5pZCxcbiAgICAgIHR5cGU6IGZpbGUubWltZVR5cGUsXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZUF1dGggKCkge1xuICAgIGNvbnN0IGF1dGhTdGF0ZSA9IGJ0b2EoSlNPTi5zdHJpbmdpZnkoeyBvcmlnaW46IGdldE9yaWdpbigpIH0pKVxuICAgIGNvbnN0IGNsaWVudFZlcnNpb24gPSBgQHVwcHkvcHJvdmlkZXItdmlld3M9JHtQcm92aWRlclZpZXcuVkVSU0lPTn1gXG4gICAgY29uc3QgbGluayA9IHRoaXMucHJvdmlkZXIuYXV0aFVybCh7IHN0YXRlOiBhdXRoU3RhdGUsIHVwcHlWZXJzaW9uczogY2xpZW50VmVyc2lvbiB9KVxuXG4gICAgY29uc3QgYXV0aFdpbmRvdyA9IHdpbmRvdy5vcGVuKGxpbmssICdfYmxhbmsnKVxuICAgIGNvbnN0IGhhbmRsZVRva2VuID0gKGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5faXNPcmlnaW5BbGxvd2VkKGUub3JpZ2luLCB0aGlzLnBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cykgfHwgZS5zb3VyY2UgIT09IGF1dGhXaW5kb3cpIHtcbiAgICAgICAgdGhpcy5wbHVnaW4udXBweS5sb2coYHJlamVjdGluZyBldmVudCBmcm9tICR7ZS5vcmlnaW59IHZzIGFsbG93ZWQgcGF0dGVybiAke3RoaXMucGx1Z2luLm9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGEgc3RyaW5nIGJlZm9yZSBkb2luZyB0aGUgSlNPTi5wYXJzZSB0byBtYWludGFpbiBzdXBwb3J0XG4gICAgICAvLyBmb3Igb2xkZXIgQ29tcGFuaW9uIHZlcnNpb25zIHRoYXQgdXNlZCBvYmplY3QgcmVmZXJlbmNlc1xuICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBlLmRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShlLmRhdGEpIDogZS5kYXRhXG5cbiAgICAgIGlmICghZGF0YS50b2tlbikge1xuICAgICAgICB0aGlzLnBsdWdpbi51cHB5LmxvZygnZGlkIG5vdCByZWNlaXZlIHRva2VuIGZyb20gYXV0aCB3aW5kb3cnKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgYXV0aFdpbmRvdy5jbG9zZSgpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVRva2VuKVxuICAgICAgdGhpcy5wcm92aWRlci5zZXRBdXRoVG9rZW4oZGF0YS50b2tlbilcbiAgICAgIHRoaXMucHJlRmlyc3RSZW5kZXIoKVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVRva2VuKVxuICB9XG5cbiAgX2lzT3JpZ2luQWxsb3dlZCAob3JpZ2luLCBhbGxvd2VkT3JpZ2luKSB7XG4gICAgY29uc3QgZ2V0UmVnZXggPSAodmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt2YWx1ZX0kYClcbiAgICAgIH0gaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhdHRlcm5zID0gQXJyYXkuaXNBcnJheShhbGxvd2VkT3JpZ2luKSA/IGFsbG93ZWRPcmlnaW4ubWFwKGdldFJlZ2V4KSA6IFtnZXRSZWdleChhbGxvd2VkT3JpZ2luKV1cbiAgICByZXR1cm4gcGF0dGVybnNcbiAgICAgIC5maWx0ZXIoKHBhdHRlcm4pID0+IHBhdHRlcm4gIT0gbnVsbCkgLy8gbG9vc2UgY29tcGFyaXNvbiB0byBjYXRjaCB1bmRlZmluZWRcbiAgICAgIC5zb21lKChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnRlc3Qob3JpZ2luKSB8fCBwYXR0ZXJuLnRlc3QoYCR7b3JpZ2lufS9gKSkgLy8gYWxsb3dpbmcgZm9yIHRyYWlsaW5nICcvJ1xuICB9XG5cbiAgaGFuZGxlRXJyb3IgKGVycm9yKSB7XG4gICAgY29uc3QgdXBweSA9IHRoaXMucGx1Z2luLnVwcHlcbiAgICB1cHB5LmxvZyhlcnJvci50b1N0cmluZygpKVxuICAgIGlmIChlcnJvci5pc0F1dGhFcnJvcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB1cHB5LmkxOG4oJ2NvbXBhbmlvbkVycm9yJylcbiAgICB1cHB5LmluZm8oeyBtZXNzYWdlLCBkZXRhaWxzOiBlcnJvci50b1N0cmluZygpIH0sICdlcnJvcicsIDUwMDApXG4gIH1cblxuICBoYW5kbGVTY3JvbGwgKGUpIHtcbiAgICBjb25zdCBzY3JvbGxQb3MgPSBlLnRhcmdldC5zY3JvbGxIZWlnaHQgLSAoZS50YXJnZXQuc2Nyb2xsVG9wICsgZS50YXJnZXQub2Zmc2V0SGVpZ2h0KVxuICAgIGNvbnN0IHBhdGggPSB0aGlzLm5leHRQYWdlUGF0aCB8fCBudWxsXG5cbiAgICBpZiAoc2Nyb2xsUG9zIDwgNTAgJiYgcGF0aCAmJiAhdGhpcy5faXNIYW5kbGluZ1Njcm9sbCkge1xuICAgICAgdGhpcy5wcm92aWRlci5saXN0KHBhdGgpXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGZpbGVzLCBmb2xkZXJzIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICAgICAgdGhpcy5fdXBkYXRlRmlsZXNBbmRGb2xkZXJzKHJlcywgZmlsZXMsIGZvbGRlcnMpXG4gICAgICAgIH0pLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IpXG4gICAgICAgIC50aGVuKCgpID0+IHsgdGhpcy5faXNIYW5kbGluZ1Njcm9sbCA9IGZhbHNlIH0pIC8vIGFsd2F5cyBjYWxsZWRcblxuICAgICAgdGhpcy5faXNIYW5kbGluZ1Njcm9sbCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBsaXN0QWxsRmlsZXMgKHBhdGgsIGZpbGVzID0gbnVsbCkge1xuICAgIGZpbGVzID0gZmlsZXMgfHwgW11cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wcm92aWRlci5saXN0KHBhdGgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICByZXMuaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGlmICghaXRlbS5pc0ZvbGRlcikge1xuICAgICAgICAgICAgZmlsZXMucHVzaChpdGVtKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZvbGRlcihpdGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgbW9yZUZpbGVzID0gcmVzLm5leHRQYWdlUGF0aCB8fCBudWxsXG4gICAgICAgIGlmIChtb3JlRmlsZXMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXN0QWxsRmlsZXMobW9yZUZpbGVzLCBmaWxlcylcbiAgICAgICAgICAgIC50aGVuKChmaWxlcykgPT4gcmVzb2x2ZShmaWxlcykpXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiByZWplY3QoZSkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZXMpXG4gICAgICB9KS5jYXRjaChlID0+IHJlamVjdChlKSlcbiAgICB9KVxuICB9XG5cbiAgZG9uZVBpY2tpbmcgKCkge1xuICAgIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IHByb21pc2VzID0gY3VycmVudFNlbGVjdGlvbi5tYXAoKGZpbGUpID0+IHtcbiAgICAgIGlmIChmaWxlLmlzRm9sZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEZvbGRlcihmaWxlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKVxuICAgIH0pXG5cbiAgICB0aGlzLl9zaGFyZWRIYW5kbGVyLmxvYWRlcldyYXBwZXIoUHJvbWlzZS5hbGwocHJvbWlzZXMpLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcbiAgICB9LCAoKSA9PiB7fSlcbiAgfVxuXG4gIGNhbmNlbFBpY2tpbmcgKCkge1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKVxuXG4gICAgY29uc3QgZGFzaGJvYXJkID0gdGhpcy5wbHVnaW4udXBweS5nZXRQbHVnaW4oJ0Rhc2hib2FyZCcpXG4gICAgaWYgKGRhc2hib2FyZCkgZGFzaGJvYXJkLmhpZGVBbGxQYW5lbHMoKVxuICB9XG5cbiAgY2xlYXJTZWxlY3Rpb24gKCkge1xuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgY3VycmVudFNlbGVjdGlvbjogW10gfSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUsIHZpZXdPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGF1dGhlbnRpY2F0ZWQsIGRpZEZpcnN0UmVuZGVyIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKCFkaWRGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5wcmVGaXJzdFJlbmRlcigpXG4gICAgfVxuXG4gICAgLy8gcmVsb2FkIHBsdWdpblN0YXRlIGZvciBcImxvYWRpbmdcIiBhdHRyaWJ1dGUgYmVjYXVzZSBpdCBtaWdodFxuICAgIC8vIGhhdmUgY2hhbmdlZCBhYm92ZS5cbiAgICBpZiAodGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgPExvYWRlclZpZXcgaTE4bj17dGhpcy5wbHVnaW4udXBweS5pMThufSAvPlxuICAgICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoIWF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDbG9zZVdyYXBwZXIgb25Vbm1vdW50PXt0aGlzLmNsZWFyU2VsZWN0aW9ufT5cbiAgICAgICAgICA8QXV0aFZpZXdcbiAgICAgICAgICAgIHBsdWdpbk5hbWU9e3RoaXMucGx1Z2luLnRpdGxlfVxuICAgICAgICAgICAgcGx1Z2luSWNvbj17dGhpcy5wbHVnaW4uaWNvbn1cbiAgICAgICAgICAgIGhhbmRsZUF1dGg9e3RoaXMuaGFuZGxlQXV0aH1cbiAgICAgICAgICAgIGkxOG49e3RoaXMucGx1Z2luLnVwcHkuaTE4bn1cbiAgICAgICAgICAgIGkxOG5BcnJheT17dGhpcy5wbHVnaW4udXBweS5pMThuQXJyYXl9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Vmlld09wdGlvbnMgPSB7IC4uLnRoaXMub3B0cywgLi4udmlld09wdGlvbnMgfVxuICAgIGNvbnN0IGhlYWRlclByb3BzID0ge1xuICAgICAgc2hvd0JyZWFkY3J1bWJzOiB0YXJnZXRWaWV3T3B0aW9ucy5zaG93QnJlYWRjcnVtYnMsXG4gICAgICBnZXRGb2xkZXI6IHRoaXMuZ2V0Rm9sZGVyLFxuICAgICAgZGlyZWN0b3JpZXM6IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCkuZGlyZWN0b3JpZXMsXG4gICAgICBwbHVnaW5JY29uOiB0aGlzLnBsdWdpbi5pY29uLFxuICAgICAgdGl0bGU6IHRoaXMucGx1Z2luLnRpdGxlLFxuICAgICAgbG9nb3V0OiB0aGlzLmxvZ291dCxcbiAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgaTE4bjogdGhpcy5wbHVnaW4udXBweS5pMThuLFxuICAgIH1cblxuICAgIGNvbnN0IGJyb3dzZXJQcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCksXG4gICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgIGdldE5leHRGb2xkZXI6IHRoaXMuZ2V0TmV4dEZvbGRlcixcbiAgICAgIGdldEZvbGRlcjogdGhpcy5nZXRGb2xkZXIsXG4gICAgICBmaWx0ZXJJdGVtczogdGhpcy5fc2hhcmVkSGFuZGxlci5maWx0ZXJJdGVtcyxcbiAgICAgIGZpbHRlclF1ZXJ5OiB0aGlzLmZpbHRlclF1ZXJ5LFxuICAgICAgc29ydEJ5VGl0bGU6IHRoaXMuc29ydEJ5VGl0bGUsXG4gICAgICBzb3J0QnlEYXRlOiB0aGlzLnNvcnRCeURhdGUsXG4gICAgICBsb2dvdXQ6IHRoaXMubG9nb3V0LFxuICAgICAgaXNDaGVja2VkOiB0aGlzLl9zaGFyZWRIYW5kbGVyLmlzQ2hlY2tlZCxcbiAgICAgIHRvZ2dsZUNoZWNrYm94OiB0aGlzLl9zaGFyZWRIYW5kbGVyLnRvZ2dsZUNoZWNrYm94LFxuICAgICAgaGFuZGxlU2Nyb2xsOiB0aGlzLmhhbmRsZVNjcm9sbCxcbiAgICAgIGxpc3RBbGxGaWxlczogdGhpcy5saXN0QWxsRmlsZXMsXG4gICAgICBkb25lOiB0aGlzLmRvbmVQaWNraW5nLFxuICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbFBpY2tpbmcsXG4gICAgICBoZWFkZXJDb21wb25lbnQ6IEhlYWRlcihoZWFkZXJQcm9wcyksXG4gICAgICB0aXRsZTogdGhpcy5wbHVnaW4udGl0bGUsXG4gICAgICB2aWV3VHlwZTogdGFyZ2V0Vmlld09wdGlvbnMudmlld1R5cGUsXG4gICAgICBzaG93VGl0bGVzOiB0YXJnZXRWaWV3T3B0aW9ucy5zaG93VGl0bGVzLFxuICAgICAgc2hvd0ZpbHRlcjogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd0ZpbHRlcixcbiAgICAgIHNob3dCcmVhZGNydW1iczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd0JyZWFkY3J1bWJzLFxuICAgICAgcGx1Z2luSWNvbjogdGhpcy5wbHVnaW4uaWNvbixcbiAgICAgIGkxOG46IHRoaXMucGx1Z2luLnVwcHkuaTE4bixcbiAgICAgIHVwcHlGaWxlczogdGhpcy5wbHVnaW4udXBweS5nZXRGaWxlcygpLFxuICAgICAgdmFsaWRhdGVSZXN0cmljdGlvbnM6IHRoaXMucGx1Z2luLnVwcHkudmFsaWRhdGVSZXN0cmljdGlvbnMsXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDbG9zZVdyYXBwZXIgb25Vbm1vdW50PXt0aGlzLmNsZWFyU2VsZWN0aW9ufT5cbiAgICAgICAgPEJyb3dzZXIgey4uLmJyb3dzZXJQcm9wc30gLz5cbiAgICAgIDwvQ2xvc2VXcmFwcGVyPlxuICAgIClcbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFtcbiAgICA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci11c2VyXCIga2V5PVwidXNlcm5hbWVcIj57cHJvcHMudXNlcm5hbWV9PC9zcGFuPixcbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXtwcm9wcy5sb2dvdXR9IGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlci11c2VyTG9nb3V0XCIga2V5PVwibG9nb3V0XCI+XG4gICAgICB7cHJvcHMuaTE4bignbG9nT3V0Jyl9XG4gICAgPC9idXR0b24+LFxuICBdKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1Byb3ZpZGVyVmlldycpXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17cHJvcHMudHJpZ2dlclNlYXJjaElucHV0fSBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXItdXNlckxvZ291dFwiPlxuICAgICAge3Byb3BzLmkxOG4oJ2JhY2tUb1NlYXJjaCcpfVxuICAgIDwvYnV0dG9uPlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIGxldCBpbnB1dFxuICBjb25zdCBoYW5kbGVLZXlQcmVzcyA9IChldikgPT4ge1xuICAgIGlmIChldi5rZXlDb2RlID09PSAxMykge1xuICAgICAgdmFsaWRhdGVBbmRTZWFyY2goKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlQW5kU2VhcmNoID0gKCkgPT4ge1xuICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgcHJvcHMuc2VhcmNoKGlucHV0LnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVNlYXJjaFByb3ZpZGVyXCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy10ZXh0SW5wdXQgdXBweS1TZWFyY2hQcm92aWRlci1pbnB1dFwiXG4gICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignZW50ZXJUZXh0VG9TZWFyY2gnKX1cbiAgICAgICAgcGxhY2Vob2xkZXI9e3Byb3BzLmkxOG4oJ2VudGVyVGV4dFRvU2VhcmNoJyl9XG4gICAgICAgIG9uS2V5VXA9e2hhbmRsZUtleVByZXNzfVxuICAgICAgICByZWY9eyhpbnB1dF8pID0+IHsgaW5wdXQgPSBpbnB1dF8gfX1cbiAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgLz5cbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1jLWJ0bi1wcmltYXJ5IHVwcHktU2VhcmNoUHJvdmlkZXItc2VhcmNoQnV0dG9uXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIG9uQ2xpY2s9e3ZhbGlkYXRlQW5kU2VhcmNofVxuICAgICAgPlxuICAgICAgICB7cHJvcHMuaTE4bignc2VhcmNoSW1hZ2VzJyl9XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgU2VhcmNoSW5wdXQgPSByZXF1aXJlKCcuL0lucHV0VmlldycpXG5jb25zdCBCcm93c2VyID0gcmVxdWlyZSgnLi4vQnJvd3NlcicpXG5jb25zdCBMb2FkZXJWaWV3ID0gcmVxdWlyZSgnLi4vTG9hZGVyJylcbmNvbnN0IGdlbmVyYXRlRmlsZUlEID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dlbmVyYXRlRmlsZUlEJylcbmNvbnN0IGdldEZpbGVUeXBlID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVUeXBlJylcbmNvbnN0IGlzUHJldmlld1N1cHBvcnRlZCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9pc1ByZXZpZXdTdXBwb3J0ZWQnKVxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9IZWFkZXInKVxuY29uc3QgU2hhcmVkSGFuZGxlciA9IHJlcXVpcmUoJy4uL1NoYXJlZEhhbmRsZXInKVxuY29uc3QgQ2xvc2VXcmFwcGVyID0gcmVxdWlyZSgnLi4vQ2xvc2VXcmFwcGVyJylcblxuLyoqXG4gKiBDbGFzcyB0byBlYXNpbHkgZ2VuZXJhdGUgZ2VuZXJpYyB2aWV3cyBmb3IgUHJvdmlkZXIgcGx1Z2luc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFByb3ZpZGVyVmlldyB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGx1Z2luIGluc3RhbmNlIG9mIHRoZSBwbHVnaW5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChwbHVnaW4sIG9wdHMpIHtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpblxuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyXG4gICAgdGhpcy5fc2hhcmVkSGFuZGxlciA9IG5ldyBTaGFyZWRIYW5kbGVyKHBsdWdpbilcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHZpZXdUeXBlOiAnZ3JpZCcsXG4gICAgICBzaG93VGl0bGVzOiBmYWxzZSxcbiAgICAgIHNob3dGaWx0ZXI6IGZhbHNlLFxuICAgICAgc2hvd0JyZWFkY3J1bWJzOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgLy8gTG9naWNcbiAgICB0aGlzLnNlYXJjaCA9IHRoaXMuc2VhcmNoLmJpbmQodGhpcylcbiAgICB0aGlzLnRyaWdnZXJTZWFyY2hJbnB1dCA9IHRoaXMudHJpZ2dlclNlYXJjaElucHV0LmJpbmQodGhpcylcbiAgICB0aGlzLmFkZEZpbGUgPSB0aGlzLmFkZEZpbGUuYmluZCh0aGlzKVxuICAgIHRoaXMucHJlRmlyc3RSZW5kZXIgPSB0aGlzLnByZUZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUVycm9yID0gdGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVTY3JvbGwgPSB0aGlzLmhhbmRsZVNjcm9sbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5kb25lUGlja2luZyA9IHRoaXMuZG9uZVBpY2tpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuY2FuY2VsUGlja2luZyA9IHRoaXMuY2FuY2VsUGlja2luZy5iaW5kKHRoaXMpXG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbiA9IHRoaXMuY2xlYXJTZWxlY3Rpb24uYmluZCh0aGlzKVxuXG4gICAgLy8gVmlzdWFsXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcblxuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRlIGZvciB0aGUgcGx1Z2luXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgaXNJbnB1dE1vZGU6IHRydWUsXG4gICAgICBmaWxlczogW10sXG4gICAgICBmb2xkZXJzOiBbXSxcbiAgICAgIGRpcmVjdG9yaWVzOiBbXSxcbiAgICAgIGZpbHRlcklucHV0OiAnJyxcbiAgICAgIGlzU2VhcmNoVmlzaWJsZTogZmFsc2UsXG4gICAgfSlcbiAgfVxuXG4gIHRlYXJEb3duICgpIHtcbiAgICAvLyBOb3RoaW5nLlxuICB9XG5cbiAgX3VwZGF0ZUZpbGVzQW5kSW5wdXRNb2RlIChyZXMsIGZpbGVzKSB7XG4gICAgdGhpcy5uZXh0UGFnZVF1ZXJ5ID0gcmVzLm5leHRQYWdlUXVlcnlcbiAgICB0aGlzLl9zZWFyY2hUZXJtID0gcmVzLnNlYXJjaGVkRm9yXG4gICAgcmVzLml0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHsgZmlsZXMucHVzaChpdGVtKSB9KVxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgaXNJbnB1dE1vZGU6IGZhbHNlLCBmaWxlcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBwcm92aWRlciB2aWV3IGlzIHJlbmRlcmVkLlxuICAgKiBLaW5kIG9mIGxpa2UgYW4gaW5pdCBmdW5jdGlvbi5cbiAgICovXG4gIHByZUZpcnN0UmVuZGVyICgpIHtcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGRpZEZpcnN0UmVuZGVyOiB0cnVlIH0pXG4gICAgdGhpcy5wbHVnaW4ub25GaXJzdFJlbmRlcigpXG4gIH1cblxuICBzZWFyY2ggKHF1ZXJ5KSB7XG4gICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5ID09PSB0aGlzLl9zZWFyY2hUZXJtKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIHNlYXJjaCBhZ2FpbiBhcyB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBzZWFyY2hcbiAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgaXNJbnB1dE1vZGU6IGZhbHNlIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkSGFuZGxlci5sb2FkZXJXcmFwcGVyKFxuICAgICAgdGhpcy5wcm92aWRlci5zZWFyY2gocXVlcnkpLFxuICAgICAgKHJlcykgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGVGaWxlc0FuZElucHV0TW9kZShyZXMsIFtdKVxuICAgICAgfSxcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3JcbiAgICApXG4gIH1cblxuICB0cmlnZ2VyU2VhcmNoSW5wdXQgKCkge1xuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgaXNJbnB1dE1vZGU6IHRydWUgfSlcbiAgfVxuXG4gIC8vIEB0b2RvIHRoaXMgZnVuY3Rpb24gc2hvdWxkIHJlYWxseSBiZSBhIGZ1bmN0aW9uIG9mIHRoZSBwbHVnaW4gYW5kIG5vdCB0aGUgdmlldy5cbiAgLy8gbWF5YmUgd2Ugc2hvdWxkIGNvbnNpZGVyIGNyZWF0aW5nIGEgYmFzZSBQcm92aWRlclBsdWdpbiBjbGFzcyB0aGF0IGhhcyB0aGlzIG1ldGhvZFxuICBhZGRGaWxlIChmaWxlKSB7XG4gICAgY29uc3QgdGFnRmlsZSA9IHtcbiAgICAgIGlkOiB0aGlzLnByb3ZpZGVyRmlsZVRvSWQoZmlsZSksXG4gICAgICBzb3VyY2U6IHRoaXMucGx1Z2luLmlkLFxuICAgICAgZGF0YTogZmlsZSxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSB8fCBmaWxlLmlkLFxuICAgICAgdHlwZTogZmlsZS5taW1lVHlwZSxcbiAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgYm9keToge1xuICAgICAgICBmaWxlSWQ6IGZpbGUuaWQsXG4gICAgICB9LFxuICAgICAgcmVtb3RlOiB7XG4gICAgICAgIGNvbXBhbmlvblVybDogdGhpcy5wbHVnaW4ub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICAgIHVybDogYCR7dGhpcy5wcm92aWRlci5maWxlVXJsKGZpbGUucmVxdWVzdFBhdGgpfWAsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBmaWxlSWQ6IGZpbGUuaWQsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogeyAuLi50aGlzLnByb3ZpZGVyLm9wdHMsIHByb3ZpZGVyOiBudWxsIH0sXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVUeXBlID0gZ2V0RmlsZVR5cGUodGFnRmlsZSlcbiAgICAvLyBUT0RPIFNob3VsZCB3ZSBqdXN0IGFsd2F5cyB1c2UgdGhlIHRodW1ibmFpbCBVUkwgaWYgaXQgZXhpc3RzP1xuICAgIGlmIChmaWxlVHlwZSAmJiBpc1ByZXZpZXdTdXBwb3J0ZWQoZmlsZVR5cGUpKSB7XG4gICAgICB0YWdGaWxlLnByZXZpZXcgPSBmaWxlLnRodW1ibmFpbFxuICAgIH1cbiAgICB0aGlzLnBsdWdpbi51cHB5LmxvZygnQWRkaW5nIHJlbW90ZSBmaWxlJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5wbHVnaW4udXBweS5hZGRGaWxlKHRhZ0ZpbGUpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgIHRoaXMucGx1Z2luLnVwcHkubG9nKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm92aWRlckZpbGVUb0lkIChmaWxlKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlRmlsZUlEKHtcbiAgICAgIGRhdGE6IGZpbGUsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUgfHwgZmlsZS5pZCxcbiAgICAgIHR5cGU6IGZpbGUubWltZVR5cGUsXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZUVycm9yIChlcnJvcikge1xuICAgIGNvbnN0IHVwcHkgPSB0aGlzLnBsdWdpbi51cHB5XG4gICAgdXBweS5sb2coZXJyb3IudG9TdHJpbmcoKSlcbiAgICBjb25zdCBtZXNzYWdlID0gdXBweS5pMThuKCdjb21wYW5pb25FcnJvcicpXG4gICAgdXBweS5pbmZvKHsgbWVzc2FnZSwgZGV0YWlsczogZXJyb3IudG9TdHJpbmcoKSB9LCAnZXJyb3InLCA1MDAwKVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsIChlKSB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zID0gZS50YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gKGUudGFyZ2V0LnNjcm9sbFRvcCArIGUudGFyZ2V0Lm9mZnNldEhlaWdodClcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMubmV4dFBhZ2VRdWVyeSB8fCBudWxsXG5cbiAgICBpZiAoc2Nyb2xsUG9zIDwgNTAgJiYgcXVlcnkgJiYgIXRoaXMuX2lzSGFuZGxpbmdTY3JvbGwpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIuc2VhcmNoKHRoaXMuX3NlYXJjaFRlcm0sIHF1ZXJ5KVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBmaWxlcyB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUZpbGVzQW5kSW5wdXRNb2RlKHJlcywgZmlsZXMpXG4gICAgICAgIH0pLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IpXG4gICAgICAgIC50aGVuKCgpID0+IHsgdGhpcy5faXNIYW5kbGluZ1Njcm9sbCA9IGZhbHNlIH0pIC8vIGFsd2F5cyBjYWxsZWRcblxuICAgICAgdGhpcy5faXNIYW5kbGluZ1Njcm9sbCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBkb25lUGlja2luZyAoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50U2VsZWN0aW9uIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgcHJvbWlzZXMgPSBjdXJyZW50U2VsZWN0aW9uLm1hcCgoZmlsZSkgPT4gdGhpcy5hZGRGaWxlKGZpbGUpKVxuXG4gICAgdGhpcy5fc2hhcmVkSGFuZGxlci5sb2FkZXJXcmFwcGVyKFByb21pc2UuYWxsKHByb21pc2VzKSwgKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG4gICAgfSwgKCkgPT4ge30pXG4gIH1cblxuICBjYW5jZWxQaWNraW5nICgpIHtcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcblxuICAgIGNvbnN0IGRhc2hib2FyZCA9IHRoaXMucGx1Z2luLnVwcHkuZ2V0UGx1Z2luKCdEYXNoYm9hcmQnKVxuICAgIGlmIChkYXNoYm9hcmQpIGRhc2hib2FyZC5oaWRlQWxsUGFuZWxzKClcbiAgfVxuXG4gIGNsZWFyU2VsZWN0aW9uICgpIHtcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGN1cnJlbnRTZWxlY3Rpb246IFtdIH0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlLCB2aWV3T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaWRGaXJzdFJlbmRlciwgaXNJbnB1dE1vZGUgfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBpZiAoIWRpZEZpcnN0UmVuZGVyKSB7XG4gICAgICB0aGlzLnByZUZpcnN0UmVuZGVyKClcbiAgICB9XG5cbiAgICAvLyByZWxvYWQgcGx1Z2luU3RhdGUgZm9yIFwibG9hZGluZ1wiIGF0dHJpYnV0ZSBiZWNhdXNlIGl0IG1pZ2h0XG4gICAgLy8gaGF2ZSBjaGFuZ2VkIGFib3ZlLlxuICAgIGlmICh0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLmxvYWRpbmcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDbG9zZVdyYXBwZXIgb25Vbm1vdW50PXt0aGlzLmNsZWFyU2VsZWN0aW9ufT5cbiAgICAgICAgICA8TG9hZGVyVmlldyBpMThuPXt0aGlzLnBsdWdpbi51cHB5LmkxOG59IC8+XG4gICAgICAgIDwvQ2xvc2VXcmFwcGVyPlxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChpc0lucHV0TW9kZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPENsb3NlV3JhcHBlciBvblVubW91bnQ9e3RoaXMuY2xlYXJTZWxlY3Rpb259PlxuICAgICAgICAgIDxTZWFyY2hJbnB1dFxuICAgICAgICAgICAgc2VhcmNoPXt0aGlzLnNlYXJjaH1cbiAgICAgICAgICAgIGkxOG49e3RoaXMucGx1Z2luLnVwcHkuaTE4bn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRWaWV3T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRzLCAuLi52aWV3T3B0aW9ucyB9XG4gICAgY29uc3QgYnJvd3NlclByb3BzID0ge1xuICAgICAgLi4udGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKSxcbiAgICAgIGlzQ2hlY2tlZDogdGhpcy5fc2hhcmVkSGFuZGxlci5pc0NoZWNrZWQsXG4gICAgICB0b2dnbGVDaGVja2JveDogdGhpcy5fc2hhcmVkSGFuZGxlci50b2dnbGVDaGVja2JveCxcbiAgICAgIGhhbmRsZVNjcm9sbDogdGhpcy5oYW5kbGVTY3JvbGwsXG4gICAgICBkb25lOiB0aGlzLmRvbmVQaWNraW5nLFxuICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbFBpY2tpbmcsXG4gICAgICBoZWFkZXJDb21wb25lbnQ6IEhlYWRlcih7XG4gICAgICAgIHRyaWdnZXJTZWFyY2hJbnB1dDogdGhpcy50cmlnZ2VyU2VhcmNoSW5wdXQsXG4gICAgICAgIGkxOG46IHRoaXMucGx1Z2luLnVwcHkuaTE4bixcbiAgICAgIH0pLFxuICAgICAgdGl0bGU6IHRoaXMucGx1Z2luLnRpdGxlLFxuICAgICAgdmlld1R5cGU6IHRhcmdldFZpZXdPcHRpb25zLnZpZXdUeXBlLFxuICAgICAgc2hvd1RpdGxlczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd1RpdGxlcyxcbiAgICAgIHNob3dGaWx0ZXI6IHRhcmdldFZpZXdPcHRpb25zLnNob3dGaWx0ZXIsXG4gICAgICBzaG93QnJlYWRjcnVtYnM6IHRhcmdldFZpZXdPcHRpb25zLnNob3dCcmVhZGNydW1icyxcbiAgICAgIHBsdWdpbkljb246IHRoaXMucGx1Z2luLmljb24sXG4gICAgICBpMThuOiB0aGlzLnBsdWdpbi51cHB5LmkxOG4sXG4gICAgICB1cHB5RmlsZXM6IHRoaXMucGx1Z2luLnVwcHkuZ2V0RmlsZXMoKSxcbiAgICAgIHZhbGlkYXRlUmVzdHJpY3Rpb25zOiB0aGlzLnBsdWdpbi51cHB5LnZhbGlkYXRlUmVzdHJpY3Rpb25zLFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgIDxCcm93c2VyIHsuLi5icm93c2VyUHJvcHN9IC8+XG4gICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICApXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9TZWFyY2hQcm92aWRlclZpZXcnKVxuIiwiY29uc3QgcmVtb3RlRmlsZU9ialRvTG9jYWwgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcmVtb3RlRmlsZU9ialRvTG9jYWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNoYXJlZEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAocGx1Z2luKSB7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB0aGlzLmZpbHRlckl0ZW1zID0gdGhpcy5maWx0ZXJJdGVtcy5iaW5kKHRoaXMpXG4gICAgdGhpcy50b2dnbGVDaGVja2JveCA9IHRoaXMudG9nZ2xlQ2hlY2tib3guYmluZCh0aGlzKVxuICAgIHRoaXMuaXNDaGVja2VkID0gdGhpcy5pc0NoZWNrZWQuYmluZCh0aGlzKVxuICAgIHRoaXMubG9hZGVyV3JhcHBlciA9IHRoaXMubG9hZGVyV3JhcHBlci5iaW5kKHRoaXMpXG4gIH1cblxuICBmaWx0ZXJJdGVtcyAoaXRlbXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBpZiAoIXN0YXRlLmZpbHRlcklucHV0IHx8IHN0YXRlLmZpbHRlcklucHV0ID09PSAnJykge1xuICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfVxuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGZvbGRlcikgPT4ge1xuICAgICAgcmV0dXJuIGZvbGRlci5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdGF0ZS5maWx0ZXJJbnB1dC50b0xvd2VyQ2FzZSgpKSAhPT0gLTFcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgZmlsZS9mb2xkZXIgY2hlY2tib3ggdG8gb24vb2ZmIHN0YXRlIHdoaWxlIHVwZGF0aW5nIGZpbGVzIGxpc3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzb21lIGV4dHJhIGNvbXBsZXhpdHkgY29tZXMgZnJvbSBzdXBwb3J0aW5nIHNoaWZ0K2NsaWNrIHRvXG4gICAqIHRvZ2dsZSBtdWx0aXBsZSBjaGVja2JveGVzIGF0IG9uY2UsIHdoaWNoIGlzIGRvbmUgYnkgZ2V0dGluZyBhbGwgZmlsZXNcbiAgICogaW4gYmV0d2VlbiBsYXN0IGNoZWNrZWQgZmlsZSBhbmQgY3VycmVudCBvbmUuXG4gICAqL1xuICB0b2dnbGVDaGVja2JveCAoZSwgZmlsZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLmN1cnJlbnRUYXJnZXQuZm9jdXMoKVxuICAgIGNvbnN0IHsgZm9sZGVycywgZmlsZXMgfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZmlsdGVySXRlbXMoZm9sZGVycy5jb25jYXQoZmlsZXMpKVxuXG4gICAgLy8gU2hpZnQtY2xpY2tpbmcgc2VsZWN0cyBhIHNpbmdsZSBjb25zZWN1dGl2ZSBsaXN0IG9mIGl0ZW1zXG4gICAgLy8gc3RhcnRpbmcgYXQgdGhlIHByZXZpb3VzIGNsaWNrIGFuZCBkZXNlbGVjdHMgZXZlcnl0aGluZyBlbHNlLlxuICAgIGlmICh0aGlzLmxhc3RDaGVja2JveCAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICBsZXQgY3VycmVudFNlbGVjdGlvblxuICAgICAgY29uc3QgcHJldkluZGV4ID0gaXRlbXMuaW5kZXhPZih0aGlzLmxhc3RDaGVja2JveClcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGl0ZW1zLmluZGV4T2YoZmlsZSlcbiAgICAgIGlmIChwcmV2SW5kZXggPCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgY3VycmVudFNlbGVjdGlvbiA9IGl0ZW1zLnNsaWNlKHByZXZJbmRleCwgY3VycmVudEluZGV4ICsgMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBpdGVtcy5zbGljZShjdXJyZW50SW5kZXgsIHByZXZJbmRleCArIDEpXG4gICAgICB9XG4gICAgICAvLyBDaGVjayByZXN0cmljdGlvbnMgb24gZWFjaCBmaWxlIGluIGN1cnJlbnRTZWxlY3Rpb24sXG4gICAgICAvLyByZWR1Y2UgaXQgdG8gb25seSBjb250YWluIGZpbGVzIHRoYXQgcGFzcyByZXN0cmljdGlvbnNcbiAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uLnJlZHVjZSgocmVkdWNlZEN1cnJlbnRTZWxlY3Rpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgdXBweSA9IHRoaXMucGx1Z2luLnVwcHlcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkUmVzdHJpY3Rpb25zID0gdXBweS52YWxpZGF0ZVJlc3RyaWN0aW9ucyhcbiAgICAgICAgICByZW1vdGVGaWxlT2JqVG9Mb2NhbChpdGVtKSxcbiAgICAgICAgICBbLi4udXBweS5nZXRGaWxlcygpLCAuLi5yZWR1Y2VkQ3VycmVudFNlbGVjdGlvbl1cbiAgICAgICAgKVxuICAgICAgICBpZiAoIXZhbGlkYXRlZFJlc3RyaWN0aW9ucy5yZXN1bHQpIHtcbiAgICAgICAgICB1cHB5LmluZm8oeyBtZXNzYWdlOiB2YWxpZGF0ZWRSZXN0cmljdGlvbnMucmVhc29uIH0sICdlcnJvcicsIHVwcHkub3B0cy5pbmZvVGltZW91dClcbiAgICAgICAgICByZXR1cm4gcmVkdWNlZEN1cnJlbnRTZWxlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLnJlZHVjZWRDdXJyZW50U2VsZWN0aW9uLCBpdGVtXVxuICAgICAgfSlcbiAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgY3VycmVudFNlbGVjdGlvbiB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q2hlY2tib3ggPSBmaWxlXG4gICAgY29uc3QgeyBjdXJyZW50U2VsZWN0aW9uIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKHRoaXMuaXNDaGVja2VkKGZpbGUpKSB7XG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb246IGN1cnJlbnRTZWxlY3Rpb24uZmlsdGVyKChpdGVtKSA9PiBpdGVtLmlkICE9PSBmaWxlLmlkKSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgY3VycmVudFNlbGVjdGlvbjogY3VycmVudFNlbGVjdGlvbi5jb25jYXQoW2ZpbGVdKSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaXNDaGVja2VkIChmaWxlKSB7XG4gICAgY29uc3QgeyBjdXJyZW50U2VsZWN0aW9uIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgLy8gY29tcGFyaW5nIGlkIGluc3RlYWQgb2YgdGhlIGZpbGUgb2JqZWN0LCBiZWNhdXNlIHRoZSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdFxuICAgIC8vIGNoYW5nZXMgd2hlbiB3ZSBzd2l0Y2ggZm9sZGVycywgYW5kIHRoZSBmaWxlIGxpc3QgaXMgdXBkYXRlZFxuICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uLnNvbWUoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGZpbGUuaWQpXG4gIH1cblxuICBsb2FkZXJXcmFwcGVyIChwcm9taXNlLCB0aGVuLCBjYXRjaF8pIHtcbiAgICBwcm9taXNlXG4gICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgbG9hZGluZzogZmFsc2UgfSlcbiAgICAgICAgdGhlbihyZXN1bHQpXG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgbG9hZGluZzogZmFsc2UgfSlcbiAgICAgICAgY2F0Y2hfKGVycilcbiAgICAgIH0pXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBsb2FkaW5nOiB0cnVlIH0pXG4gIH1cbn1cbiIsImNvbnN0IFByb3ZpZGVyVmlld3MgPSByZXF1aXJlKCcuL1Byb3ZpZGVyVmlldycpXG5jb25zdCBTZWFyY2hQcm92aWRlclZpZXdzID0gcmVxdWlyZSgnLi9TZWFyY2hQcm92aWRlclZpZXcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJvdmlkZXJWaWV3cyxcbiAgU2VhcmNoUHJvdmlkZXJWaWV3cyxcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvcm9ib2RvZ1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVHJhbnNsb2FkaXQgU0RLIGZvciBicm93c2VycyBiYXNlZCBvbiBVcHB5XCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMTAuMTFcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcImpzbmV4dDptYWluXCI6IFwic3JjL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidHJhbnNsb2FkaXRcIixcbiAgICBcImZpbGUgZW5jb2RpbmdcIixcbiAgICBcImVuY29kaW5nXCIsXG4gICAgXCJmaWxlIHByb2Nlc3NpbmdcIixcbiAgICBcInZpZGVvIGVuY29kaW5nXCIsXG4gICAgXCJjcm9wXCIsXG4gICAgXCJyZXNpemVcIixcbiAgICBcIndhdGVybWFya1wiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJmaWxlOi4uL2NvcmVcIixcbiAgICBcIkB1cHB5L2Rhc2hib2FyZFwiOiBcImZpbGU6Li4vZGFzaGJvYXJkXCIsXG4gICAgXCJAdXBweS9kcm9wYm94XCI6IFwiZmlsZTouLi9kcm9wYm94XCIsXG4gICAgXCJAdXBweS9mYWNlYm9va1wiOiBcImZpbGU6Li4vZmFjZWJvb2tcIixcbiAgICBcIkB1cHB5L2Zvcm1cIjogXCJmaWxlOi4uL2Zvcm1cIixcbiAgICBcIkB1cHB5L2dvb2dsZS1kcml2ZVwiOiBcImZpbGU6Li4vZ29vZ2xlLWRyaXZlXCIsXG4gICAgXCJAdXBweS9pbnN0YWdyYW1cIjogXCJmaWxlOi4uL2luc3RhZ3JhbVwiLFxuICAgIFwiQHVwcHkvb25lZHJpdmVcIjogXCJmaWxlOi4uL29uZWRyaXZlXCIsXG4gICAgXCJAdXBweS9zdGF0dXMtYmFyXCI6IFwiZmlsZTouLi9zdGF0dXMtYmFyXCIsXG4gICAgXCJAdXBweS90cmFuc2xvYWRpdFwiOiBcImZpbGU6Li4vdHJhbnNsb2FkaXRcIixcbiAgICBcIkB1cHB5L3VybFwiOiBcImZpbGU6Li4vdXJsXCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcIkB1cHB5L3dlYmNhbVwiOiBcImZpbGU6Li4vd2ViY2FtXCIsXG4gICAgXCJlczYtcHJvbWlzZVwiOiBcIjQuMi41XCIsXG4gICAgXCJ3aGF0d2ctZmV0Y2hcIjogXCIzLjYuMlwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvdG9BcnJheScpXG5jb25zdCBmaW5kRE9NRWxlbWVudCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kRE9NRWxlbWVudCcpXG5cbi8qKlxuICogQWRkIGZpbGVzIGZyb20gZXhpc3RpbmcgZmlsZSBpbnB1dHMgdG8gVXBweS5cbiAqL1xuY2xhc3MgQXR0YWNoRmlsZUlucHV0cyBleHRlbmRzIFBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcblxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0F0dGFjaEZpbGVJbnB1dHMnXG4gICAgdGhpcy50eXBlID0gJ2FjcXVpcmVyJ1xuXG4gICAgdGhpcy5oYW5kbGVDaGFuZ2UgPSB0aGlzLmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5pbnB1dHMgPSBudWxsXG4gIH1cblxuICBoYW5kbGVDaGFuZ2UgKGV2ZW50KSB7XG4gICAgdGhpcy5hZGRGaWxlcyhldmVudC50YXJnZXQpXG4gIH1cblxuICBhZGRGaWxlcyAoaW5wdXQpIHtcbiAgICBjb25zdCBmaWxlcyA9IHRvQXJyYXkoaW5wdXQuZmlsZXMpXG4gICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy51cHB5LmFkZEZpbGUoe1xuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgIGRhdGE6IGZpbGUsXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMuZWwgPSBmaW5kRE9NRWxlbWVudCh0aGlzLm9wdHMudGFyZ2V0KVxuICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQXR0YWNoRmlsZUlucHV0c10gVGFyZ2V0IGZvcm0gZG9lcyBub3QgZXhpc3QnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgcmVzdHJpY3Rpb25zIH0gPSB0aGlzLnVwcHkub3B0c1xuXG4gICAgdGhpcy5pbnB1dHMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICB0aGlzLmlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5oYW5kbGVDaGFuZ2UpXG5cbiAgICAgIGlmICghaW5wdXQuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgIGlmIChyZXN0cmljdGlvbnMubWF4TnVtYmVyT2ZGaWxlcyAhPT0gMSkge1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnbXVsdGlwbGUnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5wdXQuaGFzQXR0cmlidXRlKCdhY2NlcHQnKSAmJiByZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcykge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FjY2VwdCcsIHJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzLmpvaW4oJywnKSlcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpbnB1dCBhbHJlYWR5IGNvbnRhaW5zIGZpbGVzIChlZy4gdXNlciBzZWxlY3RlZCB0aGVtIGJlZm9yZSBVcHB5IGxvYWRlZCxcbiAgICAgIC8vIG9yIHRoZSBwYWdlIHdhcyByZWZyZXNoZWQgYW5kIHRoZSBicm93c2VyIGtlcHQgZmlsZXMgc2VsZWN0ZWQpXG4gICAgICB0aGlzLmFkZEZpbGVzKGlucHV0KVxuICAgIH0pXG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmhhbmRsZUNoYW5nZSlcbiAgICB9KVxuICAgIHRoaXMuaW5wdXRzID0gbnVsbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXR0YWNoRmlsZUlucHV0c1xuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgZmluZERPTUVsZW1lbnQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmluZERPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEFmdGVyIGFuIHVwbG9hZCBjb21wbGV0ZXMsIGluamVjdCByZXN1bHQgZGF0YSBmcm9tIFRyYW5zbG9hZGl0IGluIGEgaGlkZGVuIGlucHV0LlxuICpcbiAqIE11c3QgYmUgYWRkZWQgX2FmdGVyXyB0aGUgVHJhbnNsb2FkaXQgcGx1Z2luLlxuICovXG5jbGFzcyBUcmFuc2xvYWRpdEZvcm1SZXN1bHQgZXh0ZW5kcyBQbHVnaW4ge1xuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG5cbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdUcmFuc2xvYWRpdEZvcm1SZXN1bHQnXG4gICAgdGhpcy50eXBlID0gJ21vZGlmaWVyJ1xuXG4gICAgdGhpcy5oYW5kbGVVcGxvYWQgPSB0aGlzLmhhbmRsZVVwbG9hZC5iaW5kKHRoaXMpXG4gIH1cblxuICBnZXRBc3NlbWJseVN0YXR1c2VzIChmaWxlSURzKSB7XG4gICAgY29uc3QgYXNzZW1ibHlJZHMgPSBbXVxuICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgY29uc3QgYXNzZW1ibHkgPSBmaWxlLnRyYW5zbG9hZGl0ICYmIGZpbGUudHJhbnNsb2FkaXQuYXNzZW1ibHlcbiAgICAgIGlmIChhc3NlbWJseSAmJiBhc3NlbWJseUlkcy5pbmRleE9mKGFzc2VtYmx5KSA9PT0gLTEpIHtcbiAgICAgICAgYXNzZW1ibHlJZHMucHVzaChhc3NlbWJseSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgdGwgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMub3B0cy50cmFuc2xvYWRpdFBsdWdpbklkIHx8ICdUcmFuc2xvYWRpdCcpXG4gICAgcmV0dXJuIGFzc2VtYmx5SWRzLm1hcCgoaWQpID0+IHRsLmdldEFzc2VtYmx5KGlkKSlcbiAgfVxuXG4gIGhhbmRsZVVwbG9hZCAoZmlsZUlEcykge1xuICAgIGNvbnN0IGFzc2VtYmxpZXMgPSB0aGlzLmdldEFzc2VtYmx5U3RhdHVzZXMoZmlsZUlEcylcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICBpbnB1dC50eXBlID0gJ2hpZGRlbidcbiAgICBpbnB1dC5uYW1lID0gdGhpcy5vcHRzLm5hbWVcbiAgICBpbnB1dC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGFzc2VtYmxpZXMpXG5cbiAgICBjb25zdCB0YXJnZXQgPSBmaW5kRE9NRWxlbWVudCh0aGlzLm9wdHMudGFyZ2V0KVxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChpbnB1dClcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5hZGRQb3N0UHJvY2Vzc29yKHRoaXMuaGFuZGxlVXBsb2FkKVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkucmVtb3ZlUG9zdFByb2Nlc3Nvcih0aGlzLmhhbmRsZVVwbG9hZClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zbG9hZGl0Rm9ybVJlc3VsdFxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuXG4vKipcbiAqIEFkZCBhIGByZXN1bHRzYCBrZXkgdG8gdGhlIHVwbG9hZCByZXN1bHQgZGF0YSwgY29udGFpbmluZyBhbGwgVHJhbnNsb2FkaXQgQXNzZW1ibHkgcmVzdWx0cy5cbiAqL1xuY2xhc3MgVHJhbnNsb2FkaXRSZXN1bHRzUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuXG4gICAgdGhpcy50eXBlID0gJ21vZGlmaWVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1RyYW5zbG9hZGl0UmVzdWx0c1BsdWdpbidcbiAgICB0aGlzLl9hZnRlclVwbG9hZCA9IHRoaXMuX2FmdGVyVXBsb2FkLmJpbmQodGhpcylcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5hZGRQb3N0UHJvY2Vzc29yKHRoaXMuX2FmdGVyVXBsb2FkKVxuICB9XG5cbiAgX2FmdGVyVXBsb2FkIChmaWxlSURzLCB1cGxvYWRJRCkge1xuICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICAgIGNvbnN0IGFzc2VtYmxpZXMgPSByZXN1bHQgJiYgQXJyYXkuaXNBcnJheShyZXN1bHQudHJhbnNsb2FkaXQpID8gcmVzdWx0LnRyYW5zbG9hZGl0IDogW11cblxuICAgIC8vIE1lcmdlIHRoZSBhc3NlbWJseS5yZXN1bHRzWypdIGFycmF5cyBhbmQgYWRkIGBzdGVwTmFtZWAgYW5kXG4gICAgLy8gYGFzc2VtYmx5SWRgIHByb3BlcnRpZXMuXG4gICAgY29uc3QgYXNzZW1ibHlSZXN1bHRzID0gW11cbiAgICBhc3NlbWJsaWVzLmZvckVhY2goKGFzc2VtYmx5KSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhhc3NlbWJseS5yZXN1bHRzKS5mb3JFYWNoKChzdGVwTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXNzZW1ibHkucmVzdWx0c1tzdGVwTmFtZV1cbiAgICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgICBhc3NlbWJseVJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBhc3NlbWJseUlkOiBhc3NlbWJseS5hc3NlbWJseV9pZCxcbiAgICAgICAgICAgIHN0ZXBOYW1lLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLnVwcHkuYWRkUmVzdWx0RGF0YSh1cGxvYWRJRCwge1xuICAgICAgcmVzdWx0czogYXNzZW1ibHlSZXN1bHRzLFxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2xvYWRpdFJlc3VsdHNQbHVnaW5cbiIsImNvbnN0IERhc2hib2FyZCA9IHJlcXVpcmUoJ0B1cHB5L2Rhc2hib2FyZCcpXG5jb25zdCBoYXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaGFzUHJvcGVydHknKVxuXG5jb25zdCBkYXNoYm9hcmRPcHRpb25OYW1lcyA9IFtcbiAgJ21ldGFGaWVsZHMnLFxuICAnd2lkdGgnLFxuICAnaGVpZ2h0JyxcbiAgJ3RodW1ibmFpbFdpZHRoJyxcbiAgJ3Nob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0JyxcbiAgJ3Nob3dQcm9ncmVzc0RldGFpbHMnLFxuICAnaGlkZVJldHJ5QnV0dG9uJyxcbiAgJ2hpZGVDYW5jZWxCdXR0b24nLFxuICAnaGlkZVVwbG9hZEJ1dHRvbicsXG4gICdoaWRlUHJvZ3Jlc3NBZnRlckZpbmlzaCcsXG4gICdub3RlJyxcbiAgJ2Rpc2FibGVTdGF0dXNCYXInLFxuICAnZGlzYWJsZUluZm9ybWVyJyxcbiAgJ2Rpc2FibGVUaHVtYm5haWxHZW5lcmF0b3InLFxuICAnc2hvd1NlbGVjdGVkRmlsZXMnLFxuICAncHJvdWRseURpc3BsYXlQb3dlcmVkQnlVcHB5JyxcbiAgJ3RoZW1lJyxcbl1cblxuY29uc3QgbW9kYWxEYXNoYm9hcmRPcHRpb25OYW1lcyA9IFtcbiAgJ3RyaWdnZXInLFxuICAnY2xvc2VNb2RhbE9uQ2xpY2tPdXRzaWRlJyxcbiAgJ2Nsb3NlQWZ0ZXJGaW5pc2gnLFxuICAnZGlzYWJsZVBhZ2VTY3JvbGxXaGVuTW9kYWxPcGVuJyxcbiAgJ2FuaW1hdGVPcGVuQ2xvc2UnLFxuICAnb25SZXF1ZXN0Q2xvc2VNb2RhbCcsXG4gICdicm93c2VyQmFja0J1dHRvbkNsb3NlJyxcbl1cblxuZnVuY3Rpb24gYWRkRGFzaGJvYXJkUGx1Z2luICh1cHB5LCBvcHRzLCBvdmVycmlkZU9wdHMpIHtcbiAgY29uc3QgZGFzaGJvYXJkT3B0cyA9IHt9XG4gIGRhc2hib2FyZE9wdGlvbk5hbWVzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChoYXMob3B0cywga2V5KSkge1xuICAgICAgZGFzaGJvYXJkT3B0c1trZXldID0gb3B0c1trZXldXG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IGlubGluZSA9IG92ZXJyaWRlT3B0cy5pbmxpbmUgPT0gbnVsbCA/IGRhc2hib2FyZE9wdHMuaW5saW5lIDogb3ZlcnJpZGVPcHRzLmlubGluZVxuICBpZiAoIWlubGluZSkge1xuICAgIG1vZGFsRGFzaGJvYXJkT3B0aW9uTmFtZXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoaGFzKG9wdHMsIGtleSkpIHtcbiAgICAgICAgZGFzaGJvYXJkT3B0c1trZXldID0gb3B0c1trZXldXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHVwcHkudXNlKERhc2hib2FyZCwge1xuICAgIC4uLmRhc2hib2FyZE9wdHMsXG4gICAgLi4ub3ZlcnJpZGVPcHRzLFxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZERhc2hib2FyZFBsdWdpblxuIiwiY29uc3QgVHJhbnNsb2FkaXQgPSByZXF1aXJlKCdAdXBweS90cmFuc2xvYWRpdCcpXG5jb25zdCBoYXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaGFzUHJvcGVydHknKVxuXG5jb25zdCByZW1vdGVQcm92aWRlcnMgPSB7XG4gIGRyb3Bib3g6IHJlcXVpcmUoJ0B1cHB5L2Ryb3Bib3gnKSxcbiAgJ2dvb2dsZS1kcml2ZSc6IHJlcXVpcmUoJ0B1cHB5L2dvb2dsZS1kcml2ZScpLFxuICBpbnN0YWdyYW06IHJlcXVpcmUoJ0B1cHB5L2luc3RhZ3JhbScpLFxuICBmYWNlYm9vazogcmVxdWlyZSgnQHVwcHkvZmFjZWJvb2snKSxcbiAgb25lZHJpdmU6IHJlcXVpcmUoJ0B1cHB5L29uZWRyaXZlJyksXG4gIHVybDogcmVxdWlyZSgnQHVwcHkvdXJsJyksXG59XG5cbmNvbnN0IGxvY2FsUHJvdmlkZXJzID0ge1xuICB3ZWJjYW06IHJlcXVpcmUoJ0B1cHB5L3dlYmNhbScpLFxufVxuXG5jb25zdCByZW1vdGVQcm92aWRlck9wdGlvbk5hbWVzID0gW1xuICAnY29tcGFuaW9uVXJsJyxcbiAgJ2NvbXBhbmlvbkFsbG93ZWRIb3N0cycsXG4gICdjb21wYW5pb25IZWFkZXJzJyxcbiAgJ3NlcnZlckhlYWRlcnMnLFxuICAndGFyZ2V0Jyxcbl1cblxuLy8gTm8gc2hhcmVkIG9wdGlvbnMuXG5jb25zdCBsb2NhbFByb3ZpZGVyT3B0aW9uTmFtZXMgPSBbXG4gICd0YXJnZXQnLFxuXVxuXG5mdW5jdGlvbiBhZGRSZW1vdGVQcm92aWRlciAodXBweSwgbmFtZSwgb3B0cykge1xuICBjb25zdCBQcm92aWRlciA9IHJlbW90ZVByb3ZpZGVyc1tuYW1lXVxuICBjb25zdCBwcm92aWRlck9wdGlvbnMgPSB7XG4gICAgLy8gRGVmYXVsdCB0byB0aGUgOnRsOiBDb21wYW5pb24gc2VydmVycy5cbiAgICBjb21wYW5pb25Vcmw6IFRyYW5zbG9hZGl0LkNPTVBBTklPTixcbiAgICBjb21wYW5pb25BbGxvd2VkSG9zdHM6IFRyYW5zbG9hZGl0LkNPTVBBTklPTl9QQVRURVJOLFxuICB9XG5cbiAgcmVtb3RlUHJvdmlkZXJPcHRpb25OYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgaWYgKGhhcyhvcHRzLCBuYW1lKSkgcHJvdmlkZXJPcHRpb25zW25hbWVdID0gb3B0c1tuYW1lXVxuICB9KVxuICAvLyBBcHBseSBvdmVycmlkZXMgZm9yIGEgc3BlY2lmaWMgcHJvdmlkZXIgcGx1Z2luLlxuICBpZiAodHlwZW9mIG9wdHNbbmFtZV0gPT09ICdvYmplY3QnKSB7XG4gICAgT2JqZWN0LmFzc2lnbihwcm92aWRlck9wdGlvbnMsIG9wdHNbbmFtZV0pXG4gIH1cblxuICB1cHB5LnVzZShQcm92aWRlciwgcHJvdmlkZXJPcHRpb25zKVxufVxuXG5mdW5jdGlvbiBhZGRMb2NhbFByb3ZpZGVyICh1cHB5LCBuYW1lLCBvcHRzKSB7XG4gIGNvbnN0IFByb3ZpZGVyID0gbG9jYWxQcm92aWRlcnNbbmFtZV1cbiAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0ge31cblxuICBsb2NhbFByb3ZpZGVyT3B0aW9uTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGlmIChoYXMob3B0cywgbmFtZSkpIHByb3ZpZGVyT3B0aW9uc1tuYW1lXSA9IG9wdHNbbmFtZV1cbiAgfSlcbiAgLy8gQXBwbHkgb3ZlcnJpZGVzIGZvciBhIHNwZWNpZmljIHByb3ZpZGVyIHBsdWdpbi5cbiAgaWYgKHR5cGVvZiBvcHRzW25hbWVdID09PSAnb2JqZWN0Jykge1xuICAgIE9iamVjdC5hc3NpZ24ocHJvdmlkZXJPcHRpb25zLCBvcHRzW25hbWVdKVxuICB9XG5cbiAgdXBweS51c2UoUHJvdmlkZXIsIHByb3ZpZGVyT3B0aW9ucylcbn1cblxuZnVuY3Rpb24gYWRkUHJvdmlkZXJzICh1cHB5LCBuYW1lcywgb3B0cyA9IHt9KSB7XG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBpZiAoaGFzKHJlbW90ZVByb3ZpZGVycywgbmFtZSkpIHtcbiAgICAgIGFkZFJlbW90ZVByb3ZpZGVyKHVwcHksIG5hbWUsIG9wdHMpXG4gICAgfSBlbHNlIGlmIChoYXMobG9jYWxQcm92aWRlcnMsIG5hbWUpKSB7XG4gICAgICBhZGRMb2NhbFByb3ZpZGVyKHVwcHksIG5hbWUsIG9wdHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbGlkTmFtZXMgPSBbXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHJlbW90ZVByb3ZpZGVycyksXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKGxvY2FsUHJvdmlkZXJzKSxcbiAgICAgIF1cbiAgICAgIGNvbnN0IGV4cGVjdGVkTmFtZVN0cmluZyA9IHZhbGlkTmFtZXNcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAubWFwKCh2YWxpZE5hbWUpID0+IGAnJHt2YWxpZE5hbWV9J2ApXG4gICAgICAgIC5qb2luKCcsICcpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcHJvdmlkZXIgJyR7bmFtZX0nLCBleHBlY3RlZCBvbmUgb2YgWyR7ZXhwZWN0ZWROYW1lU3RyaW5nfV1gKVxuICAgIH1cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRQcm92aWRlcnNcbiIsImNvbnN0IFRyYW5zbG9hZGl0ID0gcmVxdWlyZSgnQHVwcHkvdHJhbnNsb2FkaXQnKVxuY29uc3QgaGFzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2hhc1Byb3BlcnR5JylcbmNvbnN0IFRyYW5zbG9hZGl0UmVzdWx0cyA9IHJlcXVpcmUoJy4vVHJhbnNsb2FkaXRSZXN1bHRzUGx1Z2luJylcblxuY29uc3QgdHJhbnNsb2FkaXRPcHRpb25OYW1lcyA9IFtcbiAgJ3NlcnZpY2UnLFxuICAnd2FpdEZvckVuY29kaW5nJyxcbiAgJ3dhaXRGb3JNZXRhZGF0YScsXG4gICdhbHdheXNSdW5Bc3NlbWJseScsXG4gICdpbXBvcnRGcm9tVXBsb2FkVVJMcycsXG4gICdzaWduYXR1cmUnLFxuICAncGFyYW1zJyxcbiAgJ2ZpZWxkcycsXG4gICdsaW1pdCcsXG4gICdsb2NhbGUnLFxuICAnZ2V0QXNzZW1ibHlPcHRpb25zJyxcbl1cblxuZnVuY3Rpb24gYWRkVHJhbnNsb2FkaXRQbHVnaW4gKHVwcHksIG9wdHMpIHtcbiAgY29uc3QgdHJhbnNsb2FkaXRPcHRpb25zID0ge31cbiAgdHJhbnNsb2FkaXRPcHRpb25OYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgaWYgKGhhcyhvcHRzLCBuYW1lKSkgdHJhbnNsb2FkaXRPcHRpb25zW25hbWVdID0gb3B0c1tuYW1lXVxuICB9KVxuICB1cHB5LnVzZShUcmFuc2xvYWRpdCwgdHJhbnNsb2FkaXRPcHRpb25zKVxuXG4gIC8vIEFkZHMgYSBgcmVzdWx0c2Aga2V5IHRvIHRoZSB1cGxvYWQgcmVzdWx0IGRhdGEgY29udGFpbmluZyBhIGZsYXQgYXJyYXkgb2YgYWxsIHJlc3VsdHMgZnJvbSBhbGwgQXNzZW1ibGllcy5cbiAgaWYgKHRyYW5zbG9hZGl0T3B0aW9ucy53YWl0Rm9yRW5jb2RpbmcpIHtcbiAgICB1cHB5LnVzZShUcmFuc2xvYWRpdFJlc3VsdHMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRUcmFuc2xvYWRpdFBsdWdpblxuIiwiY29uc3QgVXBweSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgaGFzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2hhc1Byb3BlcnR5JylcblxuY29uc3QgZXZlbnROYW1lcyA9IHtcbiAgLy8gRmlsZSBtYW5hZ2VtZW50IGV2ZW50c1xuICBvbkZpbGVBZGRlZDogJ2ZpbGUtYWRkZWQnLFxuICBvbkZpbGVSZW1vdmVkOiAnZmlsZS1yZW1vdmVkJyxcblxuICAvLyBUcmFuc2xvYWRpdCBldmVudHNcbiAgb25JbXBvcnRFcnJvcjogJ3RyYW5zbG9hZGl0OmltcG9ydC1lcnJvcicsXG4gIG9uQXNzZW1ibHlDcmVhdGVkOiAndHJhbnNsb2FkaXQ6YXNzZW1ibHktY3JlYXRlZCcsXG4gIG9uQXNzZW1ibHlFeGVjdXRpbmc6ICd0cmFuc2xvYWRpdDphc3NlbWJseS1leGVjdXRpbmcnLFxuICBvbkFzc2VtYmx5RXJyb3I6ICd0cmFuc2xvYWRpdDphc3NlbWJseS1lcnJvcicsXG4gIG9uQXNzZW1ibHlDb21wbGV0ZTogJ3RyYW5zbG9hZGl0OmNvbXBsZXRlJyxcbiAgb25SZXN1bHQ6ICd0cmFuc2xvYWRpdDpyZXN1bHQnLFxuXG4gIC8vIFVwbG9hZCBldmVudHNcbiAgb25TdGFydDogJ3VwbG9hZCcsXG4gIG9uUGF1c2U6ICdwYXVzZS1hbGwnLFxuICBvbkZpbGVQYXVzZTogJ3VwbG9hZC1wYXVzZScsXG4gIG9uQ2FuY2VsOiAnY2FuY2VsLWFsbCcsXG4gIG9uRXJyb3I6ICdlcnJvcicsIC8vIG1vc3RseSBha2luIHRvIHByb21pc2UgcmVqZWN0aW9uXG4gIG9uRmlsZUNhbmNlbDogJ3VwbG9hZC1jYW5jZWwnLFxuICBvbkZpbGVQcm9ncmVzczogJ3VwbG9hZC1wcm9ncmVzcycsXG4gIG9uRmlsZUVycm9yOiAndXBsb2FkLWVycm9yJyxcbiAgb25VcGxvYWRlZDogJ3RyYW5zbG9hZGl0OnVwbG9hZCcsXG4gIG9uQ29tcGxldGU6ICdjb21wbGV0ZScsIC8vIG1vc3RseSBha2luIHRvIHByb21pc2UgcmVzb2x1dGlvblxufVxuXG5jb25zdCB1cHB5T3B0aW9uTmFtZXMgPSBbXG4gICdhdXRvUHJvY2VlZCcsXG4gICdyZXN0cmljdGlvbnMnLFxuICAnbWV0YScsXG4gICdvbkJlZm9yZUZpbGVBZGRlZCcsXG4gICdvbkJlZm9yZVVwbG9hZCcsXG4gICdkZWJ1ZycsXG5dXG5mdW5jdGlvbiBjcmVhdGVVcHB5IChvcHRzLCBvdmVycmlkZXMgPSB7fSkge1xuICBjb25zdCB1cHB5T3B0aW9ucyA9IHt9XG4gIHVwcHlPcHRpb25OYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgaWYgKGhhcyhvcHRzLCBuYW1lKSkgdXBweU9wdGlvbnNbbmFtZV0gPSBvcHRzW25hbWVdXG4gIH0pXG4gIE9iamVjdC5hc3NpZ24odXBweU9wdGlvbnMsIG92ZXJyaWRlcylcblxuICBjb25zdCB1cHB5ID0gbmV3IFVwcHkodXBweU9wdGlvbnMpXG5cbiAgLy8gQnVpbHRpbiBldmVudCBhbGlhc2VzXG4gIE9iamVjdC5rZXlzKGV2ZW50TmFtZXMpLmZvckVhY2goKG9wdGlvbk5hbWUpID0+IHtcbiAgICBjb25zdCBldmVudE5hbWUgPSBldmVudE5hbWVzW29wdGlvbk5hbWVdXG4gICAgaWYgKHR5cGVvZiBvcHRzW29wdGlvbk5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1cHB5Lm9uKGV2ZW50TmFtZSwgb3B0c1tvcHRpb25OYW1lXSlcbiAgICB9XG4gIH0pXG5cbiAgLy8gQ3VzdG9tIGV2ZW50cyAodGhlc2Ugc2hvdWxkIHByb2JhYmx5IGJlIGFkZGVkIHRvIGNvcmUpXG4gIGlmICh0eXBlb2Ygb3B0cy5vblByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXBweS5vbigndXBsb2FkLXByb2dyZXNzJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyB0b3RhbFByb2dyZXNzIH0gPSB1cHB5LmdldFN0YXRlKClcbiAgICAgIG9wdHMub25Qcm9ncmVzcy5jYWxsKHVwcHksIHRvdGFsUHJvZ3Jlc3MpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB1cHB5XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVXBweVxuIiwiY29uc3QgY3JlYXRlVXBweSA9IHJlcXVpcmUoJy4vY3JlYXRlVXBweScpXG5jb25zdCBhZGREYXNoYm9hcmRQbHVnaW4gPSByZXF1aXJlKCcuL2FkZERhc2hib2FyZFBsdWdpbicpXG5jb25zdCBhZGRUcmFuc2xvYWRpdFBsdWdpbiA9IHJlcXVpcmUoJy4vYWRkVHJhbnNsb2FkaXRQbHVnaW4nKVxuY29uc3QgYWRkUHJvdmlkZXJzID0gcmVxdWlyZSgnLi9hZGRQcm92aWRlcnMnKVxuXG5mdW5jdGlvbiBkYXNoYm9hcmQgKHRhcmdldCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGlubGluZSA9IG9wdHMuaW5saW5lID09IG51bGwgPyB0cnVlIDogb3B0cy5pbmxpbmVcblxuICBjb25zdCBwbHVnaW5JZCA9ICdEYXNoYm9hcmQnXG4gIGNvbnN0IHVwcHkgPSBjcmVhdGVVcHB5KG9wdHMpXG4gIGFkZFRyYW5zbG9hZGl0UGx1Z2luKHVwcHksIG9wdHMpXG4gIGFkZERhc2hib2FyZFBsdWdpbih1cHB5LCBvcHRzLCB7XG4gICAgaWQ6IHBsdWdpbklkLFxuICAgIGlubGluZSxcbiAgICB0YXJnZXQsXG4gICAgY2xvc2VBZnRlckZpbmlzaDogZmFsc2UsXG4gIH0pXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5wcm92aWRlcnMpKSB7XG4gICAgYWRkUHJvdmlkZXJzKHVwcHksIG9wdHMucHJvdmlkZXJzLCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgLy8gSW5zdGFsbCBwcm92aWRlcnMgaW50byB0aGUgRGFzaGJvYXJkLlxuICAgICAgdGFyZ2V0OiB1cHB5LmdldFBsdWdpbihwbHVnaW5JZCksXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB1cHB5XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGFzaGJvYXJkXG4iLCJjb25zdCBVcHB5ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBGb3JtID0gcmVxdWlyZSgnQHVwcHkvZm9ybScpXG5jb25zdCBTdGF0dXNCYXIgPSByZXF1aXJlKCdAdXBweS9zdGF0dXMtYmFyJylcbmNvbnN0IGZpbmRET01FbGVtZW50ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZpbmRET01FbGVtZW50JylcbmNvbnN0IGhhcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9oYXNQcm9wZXJ0eScpXG5jb25zdCBBdHRhY2hGaWxlSW5wdXRzID0gcmVxdWlyZSgnLi9BdHRhY2hGaWxlSW5wdXRzJylcbmNvbnN0IFRyYW5zbG9hZGl0Rm9ybVJlc3VsdCA9IHJlcXVpcmUoJy4vVHJhbnNsb2FkaXRGb3JtUmVzdWx0JylcbmNvbnN0IGFkZERhc2hib2FyZFBsdWdpbiA9IHJlcXVpcmUoJy4vYWRkRGFzaGJvYXJkUGx1Z2luJylcbmNvbnN0IGFkZFRyYW5zbG9hZGl0UGx1Z2luID0gcmVxdWlyZSgnLi9hZGRUcmFuc2xvYWRpdFBsdWdpbicpXG5jb25zdCBhZGRQcm92aWRlcnMgPSByZXF1aXJlKCcuL2FkZFByb3ZpZGVycycpXG5cbmNvbnN0IGRlZmF1bHRMb2NhbGVTdHJpbmdzID0ge1xuICBjaG9vc2VGaWxlczogJ0Nob29zZSBmaWxlcycsXG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdExvY2FsZSAoZGVmYXVsdHMsIHVzZXJQcm92aWRlZCA9IHt9KSB7XG4gIGNvbnN0IHN0cmluZ3MgPSB1c2VyUHJvdmlkZWQuc3RyaW5ncyB8fCB7fVxuICByZXR1cm4ge1xuICAgIC4uLnVzZXJQcm92aWRlZCxcbiAgICBzdHJpbmdzOiB7IC4uLmRlZmF1bHRzLCAuLi5zdHJpbmdzIH0sXG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybSAodGFyZ2V0LCBvcHRzKSB7XG4gIGlmICghb3B0cykgdGhyb3cgbmV3IFR5cGVFcnJvcigncm9ib2RvZy5mb3JtOiBtdXN0IHByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QnKVxuXG4gIG9wdHMgPSB7XG4gICAgLi4ub3B0cyxcbiAgICBsb2NhbGU6IG1lcmdlRGVmYXVsdExvY2FsZShkZWZhdWx0TG9jYWxlU3RyaW5ncywgb3B0cy5sb2NhbGUpLFxuICB9XG5cbiAgY29uc3QgdXBweSA9IG5ldyBVcHB5KG9wdHMpXG4gIGFkZFRyYW5zbG9hZGl0UGx1Z2luKHVwcHksIG9wdHMpXG5cbiAgdXBweS51c2UoVHJhbnNsb2FkaXRGb3JtUmVzdWx0LCB7XG4gICAgdGFyZ2V0LFxuICAgIHRyYW5zbG9hZGl0UGx1Z2luSWQ6ICdUcmFuc2xvYWRpdCcsXG4gICAgbmFtZTogJ3RyYW5zbG9hZGl0JyxcbiAgfSlcblxuICBsZXQgc3VibWl0T25TdWNjZXNzID0gdHJ1ZVxuICBpZiAoaGFzKG9wdHMsICdzdWJtaXRPblN1Y2Nlc3MnKSkge1xuICAgIHN1Ym1pdE9uU3VjY2VzcyA9ICEhb3B0cy5zdWJtaXRPblN1Y2Nlc3NcbiAgfVxuXG4gIGNvbnN0IGZvcm1PcHRpb25zID0ge1xuICAgIHRhcmdldCxcbiAgICB0cmlnZ2VyVXBsb2FkT25TdWJtaXQ6IHRydWUsXG4gICAgc3VibWl0T25TdWNjZXNzLFxuICAgIGFkZFJlc3VsdFRvRm9ybTogZmFsc2UsIC8vIHVzaW5nIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkXG4gIH1cbiAgaWYgKGhhcyhvcHRzLCAndHJpZ2dlclVwbG9hZE9uU3VibWl0JykpIHtcbiAgICBmb3JtT3B0aW9ucy50cmlnZ2VyVXBsb2FkT25TdWJtaXQgPSBvcHRzLnRyaWdnZXJVcGxvYWRPblN1Ym1pdFxuICB9XG5cbiAgdXBweS51c2UoRm9ybSwgZm9ybU9wdGlvbnMpXG5cbiAgY29uc3QgdXNlRGFzaGJvYXJkID0gb3B0cy5kYXNoYm9hcmQgfHwgb3B0cy5tb2RhbFxuXG4gIGlmICh1c2VEYXNoYm9hcmQpIHtcbiAgICBjb25zdCBkYXNoYm9hcmRUYXJnZXQgPSBmaW5kRE9NRWxlbWVudChvcHRzLmRhc2hib2FyZCkgfHwgZG9jdW1lbnQuYm9keVxuICAgIGNvbnN0IGRhc2hib2FyZElkID0gJ2Zvcm06RGFzaGJvYXJkJ1xuICAgIGNvbnN0IGRhc2hib2FyZE9wdHMgPSB7XG4gICAgICBpZDogZGFzaGJvYXJkSWQsXG4gICAgICB0YXJnZXQ6IGRhc2hib2FyZFRhcmdldCxcbiAgICB9XG4gICAgaWYgKG9wdHMubW9kYWwpIHtcbiAgICAgIGNvbnN0IHRyaWdnZXIgPSAnaW5wdXRbdHlwZT1cImZpbGVcIl0nXG4gICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdXBweS5pMThuKCdjaG9vc2VGaWxlcycpXG4gICAgICBidXR0b24udHlwZSA9ICdidXR0b24nXG4gICAgICBjb25zdCBvbGQgPSBmaW5kRE9NRWxlbWVudCh0cmlnZ2VyLCBmaW5kRE9NRWxlbWVudCh0YXJnZXQpKVxuICAgICAgb2xkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJ1dHRvbiwgb2xkKVxuICAgICAgZGFzaGJvYXJkT3B0cy5pbmxpbmUgPSBmYWxzZVxuICAgICAgZGFzaGJvYXJkT3B0cy50cmlnZ2VyID0gYnV0dG9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGRhc2hib2FyZE9wdHMuaW5saW5lID0gdHJ1ZVxuICAgICAgZGFzaGJvYXJkT3B0cy5oaWRlVXBsb2FkQnV0dG9uID0gdHJ1ZVxuICAgIH1cbiAgICBhZGREYXNoYm9hcmRQbHVnaW4odXBweSwgb3B0cywgZGFzaGJvYXJkT3B0cylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMucHJvdmlkZXJzKSkge1xuICAgICAgYWRkUHJvdmlkZXJzKHVwcHksIG9wdHMucHJvdmlkZXJzLCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIHRhcmdldDogdXBweS5nZXRQbHVnaW4oZGFzaGJvYXJkSWQpLFxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXBweS51c2UoQXR0YWNoRmlsZUlucHV0cywgeyB0YXJnZXQgfSlcbiAgfVxuXG4gIGlmIChvcHRzLnN0YXR1c0Jhcikge1xuICAgIHVwcHkudXNlKFN0YXR1c0Jhciwge1xuICAgICAgdGFyZ2V0OiBvcHRzLnN0YXR1c0JhcixcbiAgICAgIC8vIGhpZGUgbW9zdCBvZiB0aGUgdGhpbmdzIHRvIGtlZXAgb3VyIGFwaSBzaW1wbGUsXG4gICAgICAvLyB3ZSBjYW4gY2hhbmdlIHRoaXMgaW4gdGhlIGZ1dHVyZSBpZiBzb21lb25lIG5lZWRzIGl0XG4gICAgICBoaWRlVXBsb2FkQnV0dG9uOiB0cnVlLFxuICAgICAgaGlkZUFmdGVyRmluaXNoOiB0cnVlLFxuICAgICAgaGlkZVJldHJ5QnV0dG9uOiB0cnVlLFxuICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uczogdHJ1ZSxcbiAgICAgIGhpZGVDYW5jZWxCdXR0b25zOiB0cnVlLFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdXBweVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1cbiIsImNvbnN0IGZvcm0gPSByZXF1aXJlKCcuL2Zvcm0nKVxuY29uc3QgZGFzaGJvYXJkID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQnKVxuY29uc3QgcGljayA9IHJlcXVpcmUoJy4vcGljaycpXG5jb25zdCB1cGxvYWQgPSByZXF1aXJlKCcuL3VwbG9hZCcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkYXNoYm9hcmQsXG4gIGZvcm0sXG4gIHBpY2ssXG4gIHVwbG9hZCxcbiAgVkVSU0lPTjogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbn1cbiIsImNvbnN0IGNyZWF0ZVVwcHkgPSByZXF1aXJlKCcuL2NyZWF0ZVVwcHknKVxuY29uc3QgYWRkRGFzaGJvYXJkUGx1Z2luID0gcmVxdWlyZSgnLi9hZGREYXNoYm9hcmRQbHVnaW4nKVxuY29uc3QgYWRkVHJhbnNsb2FkaXRQbHVnaW4gPSByZXF1aXJlKCcuL2FkZFRyYW5zbG9hZGl0UGx1Z2luJylcbmNvbnN0IGFkZFByb3ZpZGVycyA9IHJlcXVpcmUoJy4vYWRkUHJvdmlkZXJzJylcblxuY29uc3QgQ0FOQ0VMID0ge31cblxuZnVuY3Rpb24gcGljayAob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHRhcmdldCA9IG9wdHMudGFyZ2V0IHx8IGRvY3VtZW50LmJvZHlcblxuICBjb25zdCBwbHVnaW5JZCA9ICdwaWNrJ1xuICBjb25zdCB1cHB5ID0gY3JlYXRlVXBweShvcHRzLCB7XG4gICAgYWxsb3dNdWx0aXBsZVVwbG9hZHM6IGZhbHNlLFxuICB9KVxuICBhZGRUcmFuc2xvYWRpdFBsdWdpbih1cHB5LCBvcHRzKVxuICBhZGREYXNoYm9hcmRQbHVnaW4odXBweSwgb3B0cywge1xuICAgIGlkOiBwbHVnaW5JZCxcbiAgICB0YXJnZXQsXG4gICAgY2xvc2VBZnRlckZpbmlzaDogdHJ1ZSxcbiAgfSlcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRzLnByb3ZpZGVycykpIHtcbiAgICBhZGRQcm92aWRlcnModXBweSwgb3B0cy5wcm92aWRlcnMsIHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICAvLyBJbnN0YWxsIHByb3ZpZGVycyBpbnRvIHRoZSBEYXNoYm9hcmQuXG4gICAgICB0YXJnZXQ6IHVwcHkuZ2V0UGx1Z2luKHBsdWdpbklkKSxcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB1cHB5Lm9uKCdjb21wbGV0ZScsIChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQuZmFpbGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKHJlc3VsdClcbiAgICAgIH1cbiAgICB9KVxuICAgIHVwcHkub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgIHVwcHkub24oJ2NhbmNlbC1hbGwnLCAoKSA9PiByZWplY3QoQ0FOQ0VMKSlcbiAgICB1cHB5LmdldFBsdWdpbihwbHVnaW5JZClcbiAgICAgIC5vcGVuTW9kYWwoKVxuICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sIChlcnIpID0+IHtcbiAgICBpZiAoZXJyID09PSBDQU5DRUwpIHtcbiAgICAgIHVwcHkuZ2V0UGx1Z2luKHBsdWdpbklkKVxuICAgICAgICAucmVxdWVzdENsb3NlTW9kYWwoKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlja1xuIiwiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcbmNvbnN0IGNyZWF0ZVVwcHkgPSByZXF1aXJlKCcuL2NyZWF0ZVVwcHknKVxuY29uc3QgYWRkVHJhbnNsb2FkaXRQbHVnaW4gPSByZXF1aXJlKCcuL2FkZFRyYW5zbG9hZGl0UGx1Z2luJylcblxuZnVuY3Rpb24gdXBsb2FkIChmaWxlcywgb3B0cyA9IHt9KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmaWxlcykgJiYgdHlwZW9mIGZpbGVzLmxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICBmaWxlcyA9IHRvQXJyYXkoZmlsZXMpXG4gIH1cblxuICBjb25zdCB1cHB5ID0gY3JlYXRlVXBweShvcHRzLCB7XG4gICAgYWxsb3dNdWx0aXBsZVVwbG9hZHM6IGZhbHNlLFxuICB9KVxuXG4gIGFkZFRyYW5zbG9hZGl0UGx1Z2luKHVwcHksIG9wdHMpXG5cbiAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgIHVwcHkuYWRkRmlsZSh7XG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgbWV0YTogZmlsZS5tZXRhIHx8IHt9LFxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHVwcHkudXBsb2FkKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGxvYWRcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvc3RhdHVzLWJhclwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBwcm9ncmVzcyBiYXIgZm9yIFVwcHksIHdpdGggbWFueSBiZWxscyBhbmQgd2hpc3RsZXMuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuOS41XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJwcm9ncmVzcyBiYXJcIixcbiAgICBcInN0YXR1cyBiYXJcIixcbiAgICBcInByb2dyZXNzXCIsXG4gICAgXCJ1cGxvYWRcIixcbiAgICBcImV0YVwiLFxuICAgIFwic3BlZWRcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB0cmFuc2xvYWRpdC9wcmV0dGllci1ieXRlc1wiOiBcIjAuMC43XCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcImNsYXNzbmFtZXNcIjogXCJeMi4yLjZcIixcbiAgICBcImxvZGFzaC50aHJvdHRsZVwiOiBcIl40LjEuMVwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoLnRocm90dGxlJylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IHN0YXR1c0JhclN0YXRlcyA9IHJlcXVpcmUoJy4vU3RhdHVzQmFyU3RhdGVzJylcbmNvbnN0IHByZXR0aWVyQnl0ZXMgPSByZXF1aXJlKCdAdHJhbnNsb2FkaXQvcHJldHRpZXItYnl0ZXMnKVxuY29uc3QgcHJldHR5RVRBID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3ByZXR0eUVUQScpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVByb2Nlc3NpbmdQcm9ncmVzcyAoZmlsZXMpIHtcbiAgLy8gQ29sbGVjdCBwcmUgb3IgcG9zdHByb2Nlc3NpbmcgcHJvZ3Jlc3Mgc3RhdGVzLlxuICBjb25zdCBwcm9ncmVzc2VzID0gW11cbiAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgIGNvbnN0IHsgcHJvZ3Jlc3MgfSA9IGZpbGVzW2ZpbGVJRF1cbiAgICBpZiAocHJvZ3Jlc3MucHJlcHJvY2Vzcykge1xuICAgICAgcHJvZ3Jlc3Nlcy5wdXNoKHByb2dyZXNzLnByZXByb2Nlc3MpXG4gICAgfVxuICAgIGlmIChwcm9ncmVzcy5wb3N0cHJvY2Vzcykge1xuICAgICAgcHJvZ3Jlc3Nlcy5wdXNoKHByb2dyZXNzLnBvc3Rwcm9jZXNzKVxuICAgIH1cbiAgfSlcblxuICAvLyBJbiB0aGUgZnV0dXJlIHdlIHNob3VsZCBwcm9iYWJseSBkbyB0aGlzIGRpZmZlcmVudGx5LiBGb3Igbm93IHdlJ2xsIHRha2UgdGhlXG4gIC8vIG1vZGUgYW5kIG1lc3NhZ2UgZnJvbSB0aGUgZmlyc3QgZmlsZeKAplxuICBjb25zdCB7IG1vZGUsIG1lc3NhZ2UgfSA9IHByb2dyZXNzZXNbMF1cbiAgY29uc3QgdmFsdWUgPSBwcm9ncmVzc2VzLmZpbHRlcihpc0RldGVybWluYXRlKS5yZWR1Y2UoKHRvdGFsLCBwcm9ncmVzcywgaW5kZXgsIGFsbCkgPT4ge1xuICAgIHJldHVybiB0b3RhbCArIHByb2dyZXNzLnZhbHVlIC8gYWxsLmxlbmd0aFxuICB9LCAwKVxuICBmdW5jdGlvbiBpc0RldGVybWluYXRlIChwcm9ncmVzcykge1xuICAgIHJldHVybiBwcm9ncmVzcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1vZGUsXG4gICAgbWVzc2FnZSxcbiAgICB2YWx1ZSxcbiAgfVxufVxuXG5mdW5jdGlvbiB0b2dnbGVQYXVzZVJlc3VtZSAocHJvcHMpIHtcbiAgaWYgKHByb3BzLmlzQWxsQ29tcGxldGUpIHJldHVyblxuXG4gIGlmICghcHJvcHMucmVzdW1hYmxlVXBsb2Fkcykge1xuICAgIHJldHVybiBwcm9wcy5jYW5jZWxBbGwoKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzQWxsUGF1c2VkKSB7XG4gICAgcmV0dXJuIHByb3BzLnJlc3VtZUFsbCgpXG4gIH1cblxuICByZXR1cm4gcHJvcHMucGF1c2VBbGwoKVxufVxuXG5mdW5jdGlvbiBSZW5kZXJSZVNlbGVjdEdob3N0cyAoeyBpMThuIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXNlcnZpY2VNc2dcIj5cbiAgICAgIHtpMThuKCdyZVNlbGVjdEdob3N0cycpfVxuICAgICAgPHN2ZyBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvbiB1cHB5LVN0YXR1c0Jhci1zZXJ2aWNlTXNnLWdob3N0c0ljb25cIiBhcmlhLWhpZGRlbj1cInRydWVcIiB3aWR0aD1cIjE1XCIgaGVpZ2h0PVwiMTlcIiB2aWV3Qm94PVwiMCAwIDM1IDM5XCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMS43MDggMzguNjZjMS43MDkgMCAzLjQxNy0zLjQxNyA2LjgzNC0zLjQxNyAzLjQxNiAwIDUuMTI1IDMuNDE3IDguNjEgMy40MTcgMy4zNDggMCA1LjA1Ni0zLjQxNyA4LjQ3My0zLjQxNyA0LjMwNSAwIDUuMTI1IDMuNDE3IDYuODMzIDMuNDE3Ljg4OSAwIDEuNzA5LS44ODkgMS43MDktMS43MDl2LTE5LjY4QzM0LjE2Ny01Ljc1NyAwLTUuNzU3IDAgMTcuMjcxdjE5LjY4YzAgLjgyLjg4OCAxLjcwOSAxLjcwOCAxLjcwOXptOC41NDItMTcuMDg0YTMuMzgzIDMuMzgzIDAgMDEtMy40MTctMy40MTYgMy4zODMgMy4zODMgMCAwMTMuNDE3LTMuNDE3IDMuMzgzIDMuMzgzIDAgMDEzLjQxNyAzLjQxNyAzLjM4MyAzLjM4MyAwIDAxLTMuNDE3IDMuNDE2em0xMy42NjcgMEEzLjM4MyAzLjM4MyAwIDAxMjAuNSAxOC4xNmEzLjM4MyAzLjM4MyAwIDAxMy40MTctMy40MTcgMy4zODMgMy4zODMgMCAwMTMuNDE2IDMuNDE3IDMuMzgzIDMuMzgzIDAgMDEtMy40MTYgMy40MTZ6XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHByb3BzID0gcHJvcHMgfHwge31cblxuICBjb25zdCB7XG4gICAgbmV3RmlsZXMsXG4gICAgYWxsb3dOZXdVcGxvYWQsXG4gICAgaXNVcGxvYWRJblByb2dyZXNzLFxuICAgIGlzQWxsUGF1c2VkLFxuICAgIHJlc3VtYWJsZVVwbG9hZHMsXG4gICAgZXJyb3IsXG4gICAgaGlkZVVwbG9hZEJ1dHRvbixcbiAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b24sXG4gICAgaGlkZUNhbmNlbEJ1dHRvbixcbiAgICBoaWRlUmV0cnlCdXR0b24sXG4gICAgcmVjb3ZlcmVkU3RhdGUsXG4gIH0gPSBwcm9wc1xuXG4gIGNvbnN0IHVwbG9hZFN0YXRlID0gcHJvcHMudXBsb2FkU3RhdGVcblxuICBsZXQgcHJvZ3Jlc3NWYWx1ZSA9IHByb3BzLnRvdGFsUHJvZ3Jlc3NcbiAgbGV0IHByb2dyZXNzTW9kZVxuICBsZXQgcHJvZ3Jlc3NCYXJDb250ZW50XG5cbiAgaWYgKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfUFJFUFJPQ0VTU0lORyB8fCB1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BPU1RQUk9DRVNTSU5HKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBjYWxjdWxhdGVQcm9jZXNzaW5nUHJvZ3Jlc3MocHJvcHMuZmlsZXMpXG4gICAgcHJvZ3Jlc3NNb2RlID0gcHJvZ3Jlc3MubW9kZVxuICAgIGlmIChwcm9ncmVzc01vZGUgPT09ICdkZXRlcm1pbmF0ZScpIHtcbiAgICAgIHByb2dyZXNzVmFsdWUgPSBwcm9ncmVzcy52YWx1ZSAqIDEwMFxuICAgIH1cblxuICAgIHByb2dyZXNzQmFyQ29udGVudCA9IFByb2dyZXNzQmFyUHJvY2Vzc2luZyhwcm9ncmVzcylcbiAgfSBlbHNlIGlmICh1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0NPTVBMRVRFKSB7XG4gICAgcHJvZ3Jlc3NCYXJDb250ZW50ID0gUHJvZ3Jlc3NCYXJDb21wbGV0ZShwcm9wcylcbiAgfSBlbHNlIGlmICh1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1VQTE9BRElORykge1xuICAgIGlmICghcHJvcHMuc3VwcG9ydHNVcGxvYWRQcm9ncmVzcykge1xuICAgICAgcHJvZ3Jlc3NNb2RlID0gJ2luZGV0ZXJtaW5hdGUnXG4gICAgICBwcm9ncmVzc1ZhbHVlID0gbnVsbFxuICAgIH1cblxuICAgIHByb2dyZXNzQmFyQ29udGVudCA9IFByb2dyZXNzQmFyVXBsb2FkaW5nKHByb3BzKVxuICB9IGVsc2UgaWYgKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfRVJST1IpIHtcbiAgICBwcm9ncmVzc1ZhbHVlID0gdW5kZWZpbmVkXG4gICAgcHJvZ3Jlc3NCYXJDb250ZW50ID0gUHJvZ3Jlc3NCYXJFcnJvcihwcm9wcylcbiAgfVxuXG4gIGNvbnN0IHdpZHRoID0gdHlwZW9mIHByb2dyZXNzVmFsdWUgPT09ICdudW1iZXInID8gcHJvZ3Jlc3NWYWx1ZSA6IDEwMFxuICBsZXQgaXNIaWRkZW4gPSAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HICYmIHByb3BzLmhpZGVVcGxvYWRCdXR0b24pXG4gICAgfHwgKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfV0FJVElORyAmJiAhcHJvcHMubmV3RmlsZXMgPiAwKVxuICAgIHx8ICh1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0NPTVBMRVRFICYmIHByb3BzLmhpZGVBZnRlckZpbmlzaClcblxuICBsZXQgc2hvd1VwbG9hZEJ0biA9ICFlcnJvciAmJiBuZXdGaWxlc1xuICAgICYmICFpc1VwbG9hZEluUHJvZ3Jlc3MgJiYgIWlzQWxsUGF1c2VkXG4gICAgJiYgYWxsb3dOZXdVcGxvYWQgJiYgIWhpZGVVcGxvYWRCdXR0b25cblxuICBpZiAocmVjb3ZlcmVkU3RhdGUpIHtcbiAgICBpc0hpZGRlbiA9IGZhbHNlXG4gICAgc2hvd1VwbG9hZEJ0biA9IHRydWVcbiAgfVxuXG4gIGNvbnN0IHNob3dDYW5jZWxCdG4gPSAhaGlkZUNhbmNlbEJ1dHRvblxuICAgICYmIHVwbG9hZFN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfV0FJVElOR1xuICAgICYmIHVwbG9hZFN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfQ09NUExFVEVcbiAgY29uc3Qgc2hvd1BhdXNlUmVzdW1lQnRuID0gcmVzdW1hYmxlVXBsb2FkcyAmJiAhaGlkZVBhdXNlUmVzdW1lQnV0dG9uXG4gICAgJiYgdXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9VUExPQURJTkdcblxuICBjb25zdCBzaG93UmV0cnlCdG4gPSBlcnJvciAmJiAhaGlkZVJldHJ5QnV0dG9uXG5cbiAgY29uc3Qgc2hvd0RvbmVCdG4gPSBwcm9wcy5kb25lQnV0dG9uSGFuZGxlciAmJiB1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0NPTVBMRVRFXG5cbiAgY29uc3QgcHJvZ3Jlc3NDbGFzc05hbWVzID0gYHVwcHktU3RhdHVzQmFyLXByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAke3Byb2dyZXNzTW9kZSA/IGBpcy0ke3Byb2dyZXNzTW9kZX1gIDogJyd9YFxuXG4gIGNvbnN0IHN0YXR1c0JhckNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKFxuICAgIHsgJ3VwcHktUm9vdCc6IHByb3BzLmlzVGFyZ2V0RE9NRWwgfSxcbiAgICAndXBweS1TdGF0dXNCYXInLFxuICAgIGBpcy0ke3VwbG9hZFN0YXRlfWAsXG4gICAgeyAnaGFzLWdob3N0cyc6IHByb3BzLmlzU29tZUdob3N0IH1cbiAgKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0YXR1c0JhckNsYXNzTmFtZXN9IGFyaWEtaGlkZGVuPXtpc0hpZGRlbn0+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17cHJvZ3Jlc3NDbGFzc05hbWVzfVxuICAgICAgICBzdHlsZT17eyB3aWR0aDogYCR7d2lkdGh9JWAgfX1cbiAgICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCJcbiAgICAgICAgYXJpYS12YWx1ZW1pbj1cIjBcIlxuICAgICAgICBhcmlhLXZhbHVlbWF4PVwiMTAwXCJcbiAgICAgICAgYXJpYS12YWx1ZW5vdz17cHJvZ3Jlc3NWYWx1ZX1cbiAgICAgIC8+XG4gICAgICB7cHJvZ3Jlc3NCYXJDb250ZW50fVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1hY3Rpb25zXCI+XG4gICAgICAgIHtzaG93VXBsb2FkQnRuID8gPFVwbG9hZEJ0biB7Li4ucHJvcHN9IHVwbG9hZFN0YXRlPXt1cGxvYWRTdGF0ZX0gLz4gOiBudWxsfVxuICAgICAgICB7c2hvd1JldHJ5QnRuID8gPFJldHJ5QnRuIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgICB7c2hvd1BhdXNlUmVzdW1lQnRuID8gPFBhdXNlUmVzdW1lQnV0dG9uIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgICB7c2hvd0NhbmNlbEJ0biA/IDxDYW5jZWxCdG4gey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICAgIHtzaG93RG9uZUJ0biA/IDxEb25lQnRuIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgVXBsb2FkQnRuID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHVwbG9hZEJ0bkNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKFxuICAgICd1cHB5LXUtcmVzZXQnLFxuICAgICd1cHB5LWMtYnRuJyxcbiAgICAndXBweS1TdGF0dXNCYXItYWN0aW9uQnRuJyxcbiAgICAndXBweS1TdGF0dXNCYXItYWN0aW9uQnRuLS11cGxvYWQnLFxuICAgIHsgJ3VwcHktYy1idG4tcHJpbWFyeSc6IHByb3BzLnVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfV0FJVElORyB9LFxuICAgIHsgJ3VwcHktU3RhdHVzQmFyLWFjdGlvbkJ0bi0tZGlzYWJsZWQnOiBwcm9wcy5pc1NvbWVHaG9zdCB9XG4gIClcblxuICBjb25zdCB1cGxvYWRCdG5UZXh0ID0gcHJvcHMubmV3RmlsZXMgJiYgcHJvcHMuaXNVcGxvYWRTdGFydGVkICYmICFwcm9wcy5yZWNvdmVyZWRTdGF0ZVxuICAgID8gcHJvcHMuaTE4bigndXBsb2FkWE5ld0ZpbGVzJywgeyBzbWFydF9jb3VudDogcHJvcHMubmV3RmlsZXMgfSlcbiAgICA6IHByb3BzLmkxOG4oJ3VwbG9hZFhGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzIH0pXG5cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGNsYXNzTmFtZT17dXBsb2FkQnRuQ2xhc3NOYW1lc31cbiAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ3VwbG9hZFhGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzIH0pfVxuICAgICAgb25DbGljaz17cHJvcHMuc3RhcnRVcGxvYWR9XG4gICAgICBkaXNhYmxlZD17cHJvcHMuaXNTb21lR2hvc3R9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAge3VwbG9hZEJ0blRleHR9XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuY29uc3QgUmV0cnlCdG4gPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktU3RhdHVzQmFyLWFjdGlvbkJ0biB1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLXJldHJ5XCJcbiAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ3JldHJ5VXBsb2FkJyl9XG4gICAgICBvbkNsaWNrPXtwcm9wcy5yZXRyeUFsbH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCIxMFwiIHZpZXdCb3g9XCIwIDAgOCAxMFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTQgMi40MDhhMi43NSAyLjc1IDAgMSAwIDIuNzUgMi43NS42MjYuNjI2IDAgMCAxIDEuMjUuMDE4di4wMjNhNCA0IDAgMSAxLTQtNC4wNDFWLjI1YS4yNS4yNSAwIDAgMSAuMzg5LS4yMDhsMi4yOTkgMS41MzNhLjI1LjI1IDAgMCAxIDAgLjQxNmwtMi4zIDEuNTMzQS4yNS4yNSAwIDAgMSA0IDMuMzE2di0uOTA4elwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICAgIHtwcm9wcy5pMThuKCdyZXRyeScpfVxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbmNvbnN0IENhbmNlbEJ0biA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktU3RhdHVzQmFyLWFjdGlvbkNpcmNsZUJ0blwiXG4gICAgICB0aXRsZT17cHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgIG9uQ2xpY2s9e3Byb3BzLmNhbmNlbEFsbH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPGNpcmNsZSBmaWxsPVwiIzg4OFwiIGN4PVwiOFwiIGN5PVwiOFwiIHI9XCI4XCIgLz5cbiAgICAgICAgICA8cGF0aCBmaWxsPVwiI0ZGRlwiIGQ9XCJNOS4yODMgOGwyLjU2NyAyLjU2Ny0xLjI4MyAxLjI4M0w4IDkuMjgzIDUuNDMzIDExLjg1IDQuMTUgMTAuNTY3IDYuNzE3IDggNC4xNSA1LjQzMyA1LjQzMyA0LjE1IDggNi43MTdsMi41NjctMi41NjcgMS4yODMgMS4yODN6XCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuY29uc3QgUGF1c2VSZXN1bWVCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBpc0FsbFBhdXNlZCwgaTE4biB9ID0gcHJvcHNcbiAgY29uc3QgdGl0bGUgPSBpc0FsbFBhdXNlZCA/IGkxOG4oJ3Jlc3VtZScpIDogaTE4bigncGF1c2UnKVxuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdGl0bGU9e3RpdGxlfVxuICAgICAgYXJpYS1sYWJlbD17dGl0bGV9XG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1TdGF0dXNCYXItYWN0aW9uQ2lyY2xlQnRuXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgb25DbGljaz17KCkgPT4gdG9nZ2xlUGF1c2VSZXN1bWUocHJvcHMpfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIHtpc0FsbFBhdXNlZCA/IChcbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiPlxuICAgICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjODg4XCIgY3g9XCI4XCIgY3k9XCI4XCIgcj1cIjhcIiAvPlxuICAgICAgICAgICAgPHBhdGggZmlsbD1cIiNGRkZcIiBkPVwiTTYgNC4yNUwxMS41IDggNiAxMS43NXpcIiAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApIDogKFxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG4gICAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgIDxjaXJjbGUgZmlsbD1cIiM4ODhcIiBjeD1cIjhcIiBjeT1cIjhcIiByPVwiOFwiIC8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTUgNC41aDJ2N0g1di03em00IDBoMnY3SDl2LTd6XCIgZmlsbD1cIiNGRkZcIiAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApfVxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbmNvbnN0IERvbmVCdG4gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBpMThuIH0gPSBwcm9wc1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1TdGF0dXNCYXItYWN0aW9uQnRuIHVwcHktU3RhdHVzQmFyLWFjdGlvbkJ0bi0tZG9uZVwiXG4gICAgICBvbkNsaWNrPXtwcm9wcy5kb25lQnV0dG9uSGFuZGxlcn1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICB7aTE4bignZG9uZScpfVxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbmNvbnN0IExvYWRpbmdTcGlubmVyID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzdmcgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3Bpbm5lclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCI+XG4gICAgICA8cGF0aCBkPVwiTTEzLjk4MyA2LjU0N2MtLjEyLTIuNTA5LTEuNjQtNC44OTMtMy45MzktNS45MzYtMi40OC0xLjEyNy01LjQ4OC0uNjU2LTcuNTU2IDEuMDk0Qy41MjQgMy4zNjctLjM5OCA2LjA0OC4xNjIgOC41NjJjLjU1NiAyLjQ5NSAyLjQ2IDQuNTIgNC45NCA1LjE4MyAyLjkzMi43ODQgNS42MS0uNjAyIDcuMjU2LTMuMDE1LTEuNDkzIDEuOTkzLTMuNzQ1IDMuMzA5LTYuMjk4IDIuODY4LTIuNTE0LS40MzQtNC41NzgtMi4zNDktNS4xNTMtNC44NGE2LjIyNiA2LjIyNiAwIDAgMSAyLjk4LTYuNzc4QzYuMzQuNTg2IDkuNzQgMS4xIDExLjM3MyAzLjQ5M2MuNDA3LjU5Ni42OTMgMS4yODIuODQyIDEuOTg4LjEyNy41OTguMDczIDEuMTk3LjE2MSAxLjc5NC4wNzguNTI1LjU0MyAxLjI1NyAxLjE1Ljg2NC41MjUtLjM0MS40OS0xLjA1LjQ1Ni0xLjU5Mi0uMDA3LS4xNS4wMi4zIDAgMFwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuY29uc3QgUHJvZ3Jlc3NCYXJQcm9jZXNzaW5nID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gTWF0aC5yb3VuZChwcm9wcy52YWx1ZSAqIDEwMClcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItY29udGVudFwiPlxuICAgICAgPExvYWRpbmdTcGlubmVyIC8+XG4gICAgICB7cHJvcHMubW9kZSA9PT0gJ2RldGVybWluYXRlJyA/IGAke3ZhbHVlfSUgXFx1MDBCNyBgIDogJyd9XG4gICAgICB7cHJvcHMubWVzc2FnZX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCByZW5kZXJEb3QgPSAoKSA9PlxuICAnIFxcdTAwQjcgJ1xuXG5jb25zdCBQcm9ncmVzc0RldGFpbHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgaWZTaG93RmlsZXNVcGxvYWRlZE9mVG90YWwgPSBwcm9wcy5udW1VcGxvYWRzID4gMVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNTZWNvbmRhcnlcIj5cbiAgICAgIHtcbiAgICAgICAgaWZTaG93RmlsZXNVcGxvYWRlZE9mVG90YWxcbiAgICAgICAgJiYgcHJvcHMuaTE4bignZmlsZXNVcGxvYWRlZE9mVG90YWwnLCB7XG4gICAgICAgICAgY29tcGxldGU6IHByb3BzLmNvbXBsZXRlLFxuICAgICAgICAgIHNtYXJ0X2NvdW50OiBwcm9wcy5udW1VcGxvYWRzLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItYWRkaXRpb25hbEluZm9cIj5cbiAgICAgICAgey8qIFdoZW4gc2hvdWxkIHdlIHJlbmRlciB0aGlzIGRvdD9cbiAgICAgICAgICAxLiAuLWFkZGl0aW9uYWxJbmZvIGlzIHNob3duIChoYXBwZW5zIG9ubHkgb24gZGVza3RvcHMpXG4gICAgICAgICAgMi4gQU5EICdmaWxlc1VwbG9hZGVkT2ZUb3RhbCcgd2FzIHNob3duXG4gICAgICAgICovfVxuICAgICAgICB7aWZTaG93RmlsZXNVcGxvYWRlZE9mVG90YWwgJiYgcmVuZGVyRG90KCl9XG5cbiAgICAgICAge1xuICAgICAgICAgIHByb3BzLmkxOG4oJ2RhdGFVcGxvYWRlZE9mVG90YWwnLCB7XG4gICAgICAgICAgICBjb21wbGV0ZTogcHJldHRpZXJCeXRlcyhwcm9wcy50b3RhbFVwbG9hZGVkU2l6ZSksXG4gICAgICAgICAgICB0b3RhbDogcHJldHRpZXJCeXRlcyhwcm9wcy50b3RhbFNpemUpLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB7cmVuZGVyRG90KCl9XG5cbiAgICAgICAge1xuICAgICAgICAgIHByb3BzLmkxOG4oJ3hUaW1lTGVmdCcsIHtcbiAgICAgICAgICAgIHRpbWU6IHByZXR0eUVUQShwcm9wcy50b3RhbEVUQSksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IFVua25vd25Qcm9ncmVzc0RldGFpbHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1NlY29uZGFyeVwiPlxuICAgICAge3Byb3BzLmkxOG4oJ2ZpbGVzVXBsb2FkZWRPZlRvdGFsJywgeyBjb21wbGV0ZTogcHJvcHMuY29tcGxldGUsIHNtYXJ0X2NvdW50OiBwcm9wcy5udW1VcGxvYWRzIH0pfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IFVwbG9hZE5ld2x5QWRkZWRGaWxlcyA9IChwcm9wcykgPT4ge1xuICBjb25zdCB1cGxvYWRCdG5DbGFzc05hbWVzID0gY2xhc3NOYW1lcyhcbiAgICAndXBweS11LXJlc2V0JyxcbiAgICAndXBweS1jLWJ0bicsXG4gICAgJ3VwcHktU3RhdHVzQmFyLWFjdGlvbkJ0bicsXG4gICAgJ3VwcHktU3RhdHVzQmFyLWFjdGlvbkJ0bi0tdXBsb2FkTmV3bHlBZGRlZCdcbiAgKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNTZWNvbmRhcnlcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzU2Vjb25kYXJ5SGludFwiPlxuICAgICAgICB7cHJvcHMuaTE4bigneE1vcmVGaWxlc0FkZGVkJywgeyBzbWFydF9jb3VudDogcHJvcHMubmV3RmlsZXMgfSl9XG4gICAgICA8L2Rpdj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT17dXBsb2FkQnRuQ2xhc3NOYW1lc31cbiAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bigndXBsb2FkWEZpbGVzJywgeyBzbWFydF9jb3VudDogcHJvcHMubmV3RmlsZXMgfSl9XG4gICAgICAgIG9uQ2xpY2s9e3Byb3BzLnN0YXJ0VXBsb2FkfVxuICAgICAgPlxuICAgICAgICB7cHJvcHMuaTE4bigndXBsb2FkJyl9XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBUaHJvdHRsZWRQcm9ncmVzc0RldGFpbHMgPSB0aHJvdHRsZShQcm9ncmVzc0RldGFpbHMsIDUwMCwgeyBsZWFkaW5nOiB0cnVlLCB0cmFpbGluZzogdHJ1ZSB9KVxuXG5jb25zdCBQcm9ncmVzc0JhclVwbG9hZGluZyA9IChwcm9wcykgPT4ge1xuICBpZiAoIXByb3BzLmlzVXBsb2FkU3RhcnRlZCB8fCBwcm9wcy5pc0FsbENvbXBsZXRlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHRpdGxlID0gcHJvcHMuaXNBbGxQYXVzZWQgPyBwcm9wcy5pMThuKCdwYXVzZWQnKSA6IHByb3BzLmkxOG4oJ3VwbG9hZGluZycpXG4gIGNvbnN0IHNob3dVcGxvYWROZXdseUFkZGVkRmlsZXMgPSBwcm9wcy5uZXdGaWxlcyAmJiBwcm9wcy5pc1VwbG9hZFN0YXJ0ZWRcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItY29udGVudFwiIGFyaWEtbGFiZWw9e3RpdGxlfSB0aXRsZT17dGl0bGV9PlxuICAgICAgeyFwcm9wcy5pc0FsbFBhdXNlZCA/IDxMb2FkaW5nU3Bpbm5lciAvPiA6IG51bGx9XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1ByaW1hcnlcIj5cbiAgICAgICAgICB7cHJvcHMuc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA/IGAke3RpdGxlfTogJHtwcm9wcy50b3RhbFByb2dyZXNzfSVgIDogdGl0bGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IXByb3BzLmlzQWxsUGF1c2VkICYmICFzaG93VXBsb2FkTmV3bHlBZGRlZEZpbGVzICYmIHByb3BzLnNob3dQcm9ncmVzc0RldGFpbHNcbiAgICAgICAgICA/IChwcm9wcy5zdXBwb3J0c1VwbG9hZFByb2dyZXNzID8gPFRocm90dGxlZFByb2dyZXNzRGV0YWlscyB7Li4ucHJvcHN9IC8+IDogPFVua25vd25Qcm9ncmVzc0RldGFpbHMgey4uLnByb3BzfSAvPilcbiAgICAgICAgICA6IG51bGx9XG4gICAgICAgIHtzaG93VXBsb2FkTmV3bHlBZGRlZEZpbGVzID8gPFVwbG9hZE5ld2x5QWRkZWRGaWxlcyB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IFByb2dyZXNzQmFyQ29tcGxldGUgPSAoeyB0b3RhbFByb2dyZXNzLCBpMThuIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWNvbnRlbnRcIiByb2xlPVwic3RhdHVzXCIgdGl0bGU9e2kxOG4oJ2NvbXBsZXRlJyl9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNQcmltYXJ5XCI+XG4gICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c0luZGljYXRvciB1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTVcIiBoZWlnaHQ9XCIxMVwiIHZpZXdCb3g9XCIwIDAgMTUgMTFcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNLjQxNCA1Ljg0M0wxLjYyNyA0LjYzbDMuNDcyIDMuNDcyTDEzLjIwMiAwbDEuMjEyIDEuMjEzTDUuMSAxMC41Mjh6XCIgLz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICB7aTE4bignY29tcGxldGUnKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBQcm9ncmVzc0JhckVycm9yID0gKHsgZXJyb3IsIHJldHJ5QWxsLCBoaWRlUmV0cnlCdXR0b24sIGkxOG4gfSkgPT4ge1xuICBmdW5jdGlvbiBkaXNwbGF5RXJyb3JBbGVydCAoKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYCR7aTE4bigndXBsb2FkRmFpbGVkJyl9IFxcblxcbiAke2Vycm9yfWBcbiAgICBhbGVydChlcnJvck1lc3NhZ2UpXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItY29udGVudFwiIHJvbGU9XCJhbGVydFwiIHRpdGxlPXtpMThuKCd1cGxvYWRGYWlsZWQnKX0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1ByaW1hcnlcIj5cbiAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzSW5kaWNhdG9yIHVwcHktYy1pY29uXCIgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjExXCIgdmlld0JveD1cIjAgMCAxMSAxMVwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk00LjI3OCA1LjVMMCAxLjIyMiAxLjIyMiAwIDUuNSA0LjI3OCA5Ljc3OCAwIDExIDEuMjIyIDYuNzIyIDUuNSAxMSA5Ljc3OCA5Ljc3OCAxMSA1LjUgNi43MjIgMS4yMjIgMTEgMCA5Ljc3OHpcIiAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIHtpMThuKCd1cGxvYWRGYWlsZWQnKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxzcGFuXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWRldGFpbHNcIlxuICAgICAgICBhcmlhLWxhYmVsPXtlcnJvcn1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcC1yaWdodFwiXG4gICAgICAgIGRhdGEtbWljcm90aXAtc2l6ZT1cIm1lZGl1bVwiXG4gICAgICAgIHJvbGU9XCJ0b29sdGlwXCJcbiAgICAgICAgb25DbGljaz17ZGlzcGxheUVycm9yQWxlcnR9XG4gICAgICA+XG4gICAgICAgID9cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNUQVRFX0VSUk9SOiAnZXJyb3InLFxuICBTVEFURV9XQUlUSU5HOiAnd2FpdGluZycsXG4gIFNUQVRFX1BSRVBST0NFU1NJTkc6ICdwcmVwcm9jZXNzaW5nJyxcbiAgU1RBVEVfVVBMT0FESU5HOiAndXBsb2FkaW5nJyxcbiAgU1RBVEVfUE9TVFBST0NFU1NJTkc6ICdwb3N0cHJvY2Vzc2luZycsXG4gIFNUQVRFX0NPTVBMRVRFOiAnY29tcGxldGUnLFxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IFN0YXR1c0JhclVJID0gcmVxdWlyZSgnLi9TdGF0dXNCYXInKVxuY29uc3Qgc3RhdHVzQmFyU3RhdGVzID0gcmVxdWlyZSgnLi9TdGF0dXNCYXJTdGF0ZXMnKVxuY29uc3QgZ2V0U3BlZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0U3BlZWQnKVxuY29uc3QgZ2V0Qnl0ZXNSZW1haW5pbmcgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0Qnl0ZXNSZW1haW5pbmcnKVxuY29uc3QgZ2V0VGV4dERpcmVjdGlvbiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRUZXh0RGlyZWN0aW9uJylcblxuLyoqXG4gKiBTdGF0dXNCYXI6IHJlbmRlcnMgYSBzdGF0dXMgYmFyIHdpdGggdXBsb2FkL3BhdXNlL3Jlc3VtZS9jYW5jZWwvcmV0cnkgYnV0dG9ucyxcbiAqIHByb2dyZXNzIHBlcmNlbnRhZ2UgYW5kIHRpbWUgcmVtYWluaW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFN0YXR1c0JhciBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdTdGF0dXNCYXInXG4gICAgdGhpcy50aXRsZSA9ICdTdGF0dXNCYXInXG4gICAgdGhpcy50eXBlID0gJ3Byb2dyZXNzaW5kaWNhdG9yJ1xuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICB1cGxvYWRpbmc6ICdVcGxvYWRpbmcnLFxuICAgICAgICB1cGxvYWQ6ICdVcGxvYWQnLFxuICAgICAgICBjb21wbGV0ZTogJ0NvbXBsZXRlJyxcbiAgICAgICAgdXBsb2FkRmFpbGVkOiAnVXBsb2FkIGZhaWxlZCcsXG4gICAgICAgIHBhdXNlZDogJ1BhdXNlZCcsXG4gICAgICAgIHJldHJ5OiAnUmV0cnknLFxuICAgICAgICByZXRyeVVwbG9hZDogJ1JldHJ5IHVwbG9hZCcsXG4gICAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICAgIHBhdXNlOiAnUGF1c2UnLFxuICAgICAgICByZXN1bWU6ICdSZXN1bWUnLFxuICAgICAgICBkb25lOiAnRG9uZScsXG4gICAgICAgIGZpbGVzVXBsb2FkZWRPZlRvdGFsOiB7XG4gICAgICAgICAgMDogJyV7Y29tcGxldGV9IG9mICV7c21hcnRfY291bnR9IGZpbGUgdXBsb2FkZWQnLFxuICAgICAgICAgIDE6ICcle2NvbXBsZXRlfSBvZiAle3NtYXJ0X2NvdW50fSBmaWxlcyB1cGxvYWRlZCcsXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFVcGxvYWRlZE9mVG90YWw6ICcle2NvbXBsZXRlfSBvZiAle3RvdGFsfScsXG4gICAgICAgIHhUaW1lTGVmdDogJyV7dGltZX0gbGVmdCcsXG4gICAgICAgIHVwbG9hZFhGaWxlczoge1xuICAgICAgICAgIDA6ICdVcGxvYWQgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1VwbG9hZCAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgICAgIH0sXG4gICAgICAgIHVwbG9hZFhOZXdGaWxlczoge1xuICAgICAgICAgIDA6ICdVcGxvYWQgKyV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgICAgIDE6ICdVcGxvYWQgKyV7c21hcnRfY291bnR9IGZpbGVzJyxcbiAgICAgICAgfSxcbiAgICAgICAgeE1vcmVGaWxlc0FkZGVkOiB7XG4gICAgICAgICAgMDogJyV7c21hcnRfY291bnR9IG1vcmUgZmlsZSBhZGRlZCcsXG4gICAgICAgICAgMTogJyV7c21hcnRfY291bnR9IG1vcmUgZmlsZXMgYWRkZWQnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB0YXJnZXQ6ICdib2R5JyxcbiAgICAgIGhpZGVVcGxvYWRCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVJldHJ5QnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlQ2FuY2VsQnV0dG9uOiBmYWxzZSxcbiAgICAgIHNob3dQcm9ncmVzc0RldGFpbHM6IGZhbHNlLFxuICAgICAgaGlkZUFmdGVyRmluaXNoOiB0cnVlLFxuICAgICAgZG9uZUJ1dHRvbkhhbmRsZXI6IG51bGwsXG4gICAgfVxuXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuaW5zdGFsbCA9IHRoaXMuaW5zdGFsbC5iaW5kKHRoaXMpXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgZ2V0VG90YWxTcGVlZCAoZmlsZXMpIHtcbiAgICBsZXQgdG90YWxTcGVlZCA9IDBcbiAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICB0b3RhbFNwZWVkICs9IGdldFNwZWVkKGZpbGUucHJvZ3Jlc3MpXG4gICAgfSlcbiAgICByZXR1cm4gdG90YWxTcGVlZFxuICB9XG5cbiAgZ2V0VG90YWxFVEEgKGZpbGVzKSB7XG4gICAgY29uc3QgdG90YWxTcGVlZCA9IHRoaXMuZ2V0VG90YWxTcGVlZChmaWxlcylcbiAgICBpZiAodG90YWxTcGVlZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBjb25zdCB0b3RhbEJ5dGVzUmVtYWluaW5nID0gZmlsZXMucmVkdWNlKCh0b3RhbCwgZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIHRvdGFsICsgZ2V0Qnl0ZXNSZW1haW5pbmcoZmlsZS5wcm9ncmVzcylcbiAgICB9LCAwKVxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQodG90YWxCeXRlc1JlbWFpbmluZyAvIHRvdGFsU3BlZWQgKiAxMCkgLyAxMFxuICB9XG5cbiAgc3RhcnRVcGxvYWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyByZWNvdmVyZWRTdGF0ZSB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICBpZiAocmVjb3ZlcmVkU3RhdGUpIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCdyZXN0b3JlLWNvbmZpcm1lZCcpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudXBweS51cGxvYWQoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAvLyBFcnJvciBsb2dnZWQgaW4gQ29yZVxuICAgIH0pXG4gIH1cblxuICBnZXRVcGxvYWRpbmdTdGF0ZSAoaXNBbGxFcnJvcmVkLCBpc0FsbENvbXBsZXRlLCByZWNvdmVyZWRTdGF0ZSwgZmlsZXMpIHtcbiAgICBpZiAoaXNBbGxFcnJvcmVkKSB7XG4gICAgICByZXR1cm4gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0VSUk9SXG4gICAgfVxuXG4gICAgaWYgKGlzQWxsQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfQ09NUExFVEVcbiAgICB9XG5cbiAgICBpZiAocmVjb3ZlcmVkU3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfV0FJVElOR1xuICAgIH1cblxuICAgIGxldCBzdGF0ZSA9IHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HXG4gICAgY29uc3QgZmlsZUlEcyA9IE9iamVjdC5rZXlzKGZpbGVzKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZUlEcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBmaWxlc1tmaWxlSURzW2ldXS5wcm9ncmVzc1xuICAgICAgLy8gSWYgQU5ZIGZpbGVzIGFyZSBiZWluZyB1cGxvYWRlZCByaWdodCBub3csIHNob3cgdGhlIHVwbG9hZGluZyBzdGF0ZS5cbiAgICAgIGlmIChwcm9ncmVzcy51cGxvYWRTdGFydGVkICYmICFwcm9ncmVzcy51cGxvYWRDb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1VQTE9BRElOR1xuICAgICAgfVxuICAgICAgLy8gSWYgZmlsZXMgYXJlIGJlaW5nIHByZXByb2Nlc3NlZCBBTkQgcG9zdHByb2Nlc3NlZCBhdCB0aGlzIHRpbWUsIHdlIHNob3cgdGhlXG4gICAgICAvLyBwcmVwcm9jZXNzIHN0YXRlLiBJZiBhbnkgZmlsZXMgYXJlIGJlaW5nIHVwbG9hZGVkIHdlIHNob3cgdXBsb2FkaW5nLlxuICAgICAgaWYgKHByb2dyZXNzLnByZXByb2Nlc3MgJiYgc3RhdGUgIT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9VUExPQURJTkcpIHtcbiAgICAgICAgc3RhdGUgPSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfUFJFUFJPQ0VTU0lOR1xuICAgICAgfVxuICAgICAgLy8gSWYgTk8gZmlsZXMgYXJlIGJlaW5nIHByZXByb2Nlc3NlZCBvciB1cGxvYWRlZCByaWdodCBub3csIGJ1dCBzb21lIGZpbGVzIGFyZVxuICAgICAgLy8gYmVpbmcgcG9zdHByb2Nlc3NlZCwgc2hvdyB0aGUgcG9zdHByb2Nlc3Mgc3RhdGUuXG4gICAgICBpZiAocHJvZ3Jlc3MucG9zdHByb2Nlc3MgJiYgc3RhdGUgIT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9VUExPQURJTkcgJiYgc3RhdGUgIT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HKSB7XG4gICAgICAgIHN0YXRlID0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BPU1RQUk9DRVNTSU5HXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhcGFiaWxpdGllcyxcbiAgICAgIGZpbGVzLFxuICAgICAgYWxsb3dOZXdVcGxvYWQsXG4gICAgICB0b3RhbFByb2dyZXNzLFxuICAgICAgZXJyb3IsXG4gICAgICByZWNvdmVyZWRTdGF0ZSxcbiAgICB9ID0gc3RhdGVcblxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyB0byBDb3JlLCB0byBzaGFyZSBiZXR3ZWVuIFN0YXR1cyBCYXIgYW5kIERhc2hib2FyZFxuICAgIC8vIChhbmQgYW55IG90aGVyIHBsdWdpbiB0aGF0IG1pZ2h0IG5lZWQgaXQsIHRvbylcblxuICAgIGNvbnN0IGZpbGVzQXJyYXkgPSBPYmplY3Qua2V5cyhmaWxlcykubWFwKGZpbGUgPT4gZmlsZXNbZmlsZV0pXG5cbiAgICBsZXQgbmV3RmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICAgICAgJiYgIWZpbGUucHJvZ3Jlc3MucHJlcHJvY2Vzc1xuICAgICAgICAmJiAhZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICAvLyBJZiBzb21lIHN0YXRlIHdhcyByZWNvdmVyZWQsIHdlIHdhbnQgdG8gc2hvdyBVcGxvYWQgYnV0dG9uL2NvdW50ZXJcbiAgICAvLyBmb3IgYWxsIHRoZSBmaWxlcywgYmVjYXVzZSBpbiB0aGlzIGNhc2UgaXTigJlzIG5vdCBhbiBVcGxvYWQgYnV0dG9uLFxuICAgIC8vIGJ1dCDigJxDb25maXJtIFJlc3RvcmUgQnV0dG9u4oCdXG4gICAgaWYgKHJlY292ZXJlZFN0YXRlKSB7XG4gICAgICBuZXdGaWxlcyA9IGZpbGVzQXJyYXlcbiAgICB9XG5cbiAgICBjb25zdCB1cGxvYWRTdGFydGVkRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcihmaWxlID0+IGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZClcbiAgICBjb25zdCBwYXVzZWRGaWxlcyA9IHVwbG9hZFN0YXJ0ZWRGaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLmlzUGF1c2VkKVxuICAgIGNvbnN0IGNvbXBsZXRlRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcihmaWxlID0+IGZpbGUucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUpXG4gICAgY29uc3QgZXJyb3JlZEZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoZmlsZSA9PiBmaWxlLmVycm9yKVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc0ZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhZmlsZS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgICAgICAgICAgICYmIGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgIH0pXG5cbiAgICBjb25zdCBpblByb2dyZXNzTm90UGF1c2VkRmlsZXMgPSBpblByb2dyZXNzRmlsZXMuZmlsdGVyKGZpbGUgPT4gIWZpbGUuaXNQYXVzZWQpXG5cbiAgICBjb25zdCBzdGFydGVkRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgICAgICB8fCBmaWxlLnByb2dyZXNzLnByZXByb2Nlc3NcbiAgICAgICAgfHwgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICBjb25zdCBwcm9jZXNzaW5nRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcihmaWxlID0+IGZpbGUucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzKVxuXG4gICAgY29uc3QgdG90YWxFVEEgPSB0aGlzLmdldFRvdGFsRVRBKGluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcylcblxuICAgIGxldCB0b3RhbFNpemUgPSAwXG4gICAgbGV0IHRvdGFsVXBsb2FkZWRTaXplID0gMFxuICAgIHN0YXJ0ZWRGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICB0b3RhbFNpemUgKz0gKGZpbGUucHJvZ3Jlc3MuYnl0ZXNUb3RhbCB8fCAwKVxuICAgICAgdG90YWxVcGxvYWRlZFNpemUgKz0gKGZpbGUucHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZCB8fCAwKVxuICAgIH0pXG5cbiAgICBjb25zdCBpc1VwbG9hZFN0YXJ0ZWQgPSBzdGFydGVkRmlsZXMubGVuZ3RoID4gMFxuXG4gICAgY29uc3QgaXNBbGxDb21wbGV0ZSA9IHRvdGFsUHJvZ3Jlc3MgPT09IDEwMFxuICAgICAgJiYgY29tcGxldGVGaWxlcy5sZW5ndGggPT09IE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGhcbiAgICAgICYmIHByb2Nlc3NpbmdGaWxlcy5sZW5ndGggPT09IDBcblxuICAgIGNvbnN0IGlzQWxsRXJyb3JlZCA9IGVycm9yICYmIGVycm9yZWRGaWxlcy5sZW5ndGggPT09IGZpbGVzQXJyYXkubGVuZ3RoXG5cbiAgICBjb25zdCBpc0FsbFBhdXNlZCA9IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGggIT09IDBcbiAgICAgICYmIHBhdXNlZEZpbGVzLmxlbmd0aCA9PT0gaW5Qcm9ncmVzc0ZpbGVzLmxlbmd0aFxuXG4gICAgY29uc3QgaXNVcGxvYWRJblByb2dyZXNzID0gaW5Qcm9ncmVzc0ZpbGVzLmxlbmd0aCA+IDBcbiAgICBjb25zdCByZXN1bWFibGVVcGxvYWRzID0gY2FwYWJpbGl0aWVzLnJlc3VtYWJsZVVwbG9hZHMgfHwgZmFsc2VcbiAgICBjb25zdCBzdXBwb3J0c1VwbG9hZFByb2dyZXNzID0gY2FwYWJpbGl0aWVzLnVwbG9hZFByb2dyZXNzICE9PSBmYWxzZVxuICAgIGNvbnN0IGlzU29tZUdob3N0ID0gZmlsZXNBcnJheS5zb21lKChmaWxlKSA9PiBmaWxlLmlzR2hvc3QpXG5cbiAgICByZXR1cm4gU3RhdHVzQmFyVUkoe1xuICAgICAgZXJyb3IsXG4gICAgICB1cGxvYWRTdGF0ZTogdGhpcy5nZXRVcGxvYWRpbmdTdGF0ZShpc0FsbEVycm9yZWQsIGlzQWxsQ29tcGxldGUsIHJlY292ZXJlZFN0YXRlLCBzdGF0ZS5maWxlcyB8fCB7fSksXG4gICAgICBhbGxvd05ld1VwbG9hZCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MsXG4gICAgICB0b3RhbFNpemUsXG4gICAgICB0b3RhbFVwbG9hZGVkU2l6ZSxcbiAgICAgIGlzQWxsQ29tcGxldGUsXG4gICAgICBpc0FsbFBhdXNlZCxcbiAgICAgIGlzQWxsRXJyb3JlZCxcbiAgICAgIGlzVXBsb2FkU3RhcnRlZCxcbiAgICAgIGlzVXBsb2FkSW5Qcm9ncmVzcyxcbiAgICAgIGlzU29tZUdob3N0LFxuICAgICAgcmVjb3ZlcmVkU3RhdGUsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVGaWxlcy5sZW5ndGgsXG4gICAgICBuZXdGaWxlczogbmV3RmlsZXMubGVuZ3RoLFxuICAgICAgbnVtVXBsb2Fkczogc3RhcnRlZEZpbGVzLmxlbmd0aCxcbiAgICAgIHRvdGFsRVRBLFxuICAgICAgZmlsZXMsXG4gICAgICBpMThuOiB0aGlzLmkxOG4sXG4gICAgICBwYXVzZUFsbDogdGhpcy51cHB5LnBhdXNlQWxsLFxuICAgICAgcmVzdW1lQWxsOiB0aGlzLnVwcHkucmVzdW1lQWxsLFxuICAgICAgcmV0cnlBbGw6IHRoaXMudXBweS5yZXRyeUFsbCxcbiAgICAgIGNhbmNlbEFsbDogdGhpcy51cHB5LmNhbmNlbEFsbCxcbiAgICAgIHN0YXJ0VXBsb2FkOiB0aGlzLnN0YXJ0VXBsb2FkLFxuICAgICAgZG9uZUJ1dHRvbkhhbmRsZXI6IHRoaXMub3B0cy5kb25lQnV0dG9uSGFuZGxlcixcbiAgICAgIHJlc3VtYWJsZVVwbG9hZHMsXG4gICAgICBzdXBwb3J0c1VwbG9hZFByb2dyZXNzLFxuICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogdGhpcy5vcHRzLnNob3dQcm9ncmVzc0RldGFpbHMsXG4gICAgICBoaWRlVXBsb2FkQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVVwbG9hZEJ1dHRvbixcbiAgICAgIGhpZGVSZXRyeUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbixcbiAgICAgIGhpZGVDYW5jZWxCdXR0b246IHRoaXMub3B0cy5oaWRlQ2FuY2VsQnV0dG9uLFxuICAgICAgaGlkZUFmdGVyRmluaXNoOiB0aGlzLm9wdHMuaGlkZUFmdGVyRmluaXNoLFxuICAgICAgaXNUYXJnZXRET01FbDogdGhpcy5pc1RhcmdldERPTUVsLFxuICAgIH0pXG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICAvLyBTZXQgdGhlIHRleHQgZGlyZWN0aW9uIGlmIHRoZSBwYWdlIGhhcyBub3QgZGVmaW5lZCBvbmUuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBnZXRUZXh0RGlyZWN0aW9uKGVsZW1lbnQpXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIGVsZW1lbnQuZGlyID0gJ2x0cidcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3N0b3JlLWRlZmF1bHRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBkZWZhdWx0IHNpbXBsZSBvYmplY3QtYmFzZWQgc3RvcmUgZm9yIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMi43XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXN0b3JlXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9XG59XG4iLCIvKipcbiAqIERlZmF1bHQgc3RvcmUgdGhhdCBrZWVwcyBzdGF0ZSBpbiBhIHNpbXBsZSBvYmplY3QuXG4gKi9cbmNsYXNzIERlZmF1bHRTdG9yZSB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnN0YXRlID0ge31cbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdXG4gIH1cblxuICBnZXRTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVcbiAgfVxuXG4gIHNldFN0YXRlIChwYXRjaCkge1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHsgLi4udGhpcy5zdGF0ZSB9XG4gICAgY29uc3QgbmV4dFN0YXRlID0geyAuLi50aGlzLnN0YXRlLCAuLi5wYXRjaCB9XG5cbiAgICB0aGlzLnN0YXRlID0gbmV4dFN0YXRlXG4gICAgdGhpcy5fcHVibGlzaChwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcGF0Y2gpXG4gIH1cblxuICBzdWJzY3JpYmUgKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5jYWxsYmFja3MucHVzaChsaXN0ZW5lcilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICAgIHRoaXMuY2FsbGJhY2tzLnNwbGljZShcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5kZXhPZihsaXN0ZW5lciksXG4gICAgICAgIDFcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBfcHVibGlzaCAoLi4uYXJncykge1xuICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBsaXN0ZW5lciguLi5hcmdzKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZhdWx0U3RvcmUgKCkge1xuICByZXR1cm4gbmV3IERlZmF1bHRTdG9yZSgpXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3RodW1ibmFpbC1nZW5lcmF0b3JcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlVwcHkgcGx1Z2luIHRoYXQgZ2VuZXJhdGVzIHNtYWxsIHByZXZpZXdzIG9mIGltYWdlcyB0byBzaG93IG9uIHlvdXIgdXBsb2FkIFVJLlwiLFxuICBcInZlcnNpb25cIjogXCIxLjcuMTBcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJ0aHVtYm5haWxcIixcbiAgICBcInByZXZpZXdcIixcbiAgICBcInJlc2l6ZVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJleGlmclwiOiBcIl42LjAuMFwiLFxuICAgIFwibWF0aC1sb2cyXCI6IFwiXjEuMC4xXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibmFtZXNwYWNlLWVtaXR0ZXJcIjogXCIyLjAuMVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IGRhdGFVUkl0b0Jsb2IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZGF0YVVSSXRvQmxvYicpXG5jb25zdCBpc09iamVjdFVSTCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9pc09iamVjdFVSTCcpXG5jb25zdCBpc1ByZXZpZXdTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNQcmV2aWV3U3VwcG9ydGVkJylcbmNvbnN0IE1hdGhMb2cyID0gcmVxdWlyZSgnbWF0aC1sb2cyJykgLy8gUG9seWZpbGwgZm9yIElFLlxuY29uc3QgZXhpZnIgPSByZXF1aXJlKCdleGlmci9kaXN0L21pbmkubGVnYWN5LnVtZC5qcycpXG5cbi8qKlxuICogVGhlIFRodW1ibmFpbCBHZW5lcmF0b3IgcGx1Z2luXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUaHVtYm5haWxHZW5lcmF0b3IgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ21vZGlmaWVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1RodW1ibmFpbEdlbmVyYXRvcidcbiAgICB0aGlzLnRpdGxlID0gJ1RodW1ibmFpbCBHZW5lcmF0b3InXG4gICAgdGhpcy5xdWV1ZSA9IFtdXG4gICAgdGhpcy5xdWV1ZVByb2Nlc3NpbmcgPSBmYWxzZVxuICAgIHRoaXMuZGVmYXVsdFRodW1ibmFpbERpbWVuc2lvbiA9IDIwMFxuICAgIHRoaXMudGh1bWJuYWlsVHlwZSA9IHRoaXMub3B0cy50aHVtYm5haWxUeXBlIHx8ICdpbWFnZS9qcGVnJ1xuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBnZW5lcmF0aW5nVGh1bWJuYWlsczogJ0dlbmVyYXRpbmcgdGh1bWJuYWlscy4uLicsXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdGh1bWJuYWlsV2lkdGg6IG51bGwsXG4gICAgICB0aHVtYm5haWxIZWlnaHQ6IG51bGwsXG4gICAgICB3YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZDogZmFsc2UsXG4gICAgICBsYXp5OiBmYWxzZSxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIGlmICh0aGlzLm9wdHMubGF6eSAmJiB0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGh1bWJuYWlsR2VuZXJhdG9yOiBUaGUgYGxhenlgIGFuZCBgd2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWRgIG9wdGlvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4gUGxlYXNlIGVuc3VyZSBhdCBtb3N0IG9uZSBvZiB0aGVtIGlzIHNldCB0byBgdHJ1ZWAuJylcbiAgICB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICBzdXBlci5zZXRPcHRpb25zKG5ld09wdHMpXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGh1bWJuYWlsIGZvciB0aGUgZ2l2ZW4gVXBweSBmaWxlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHt7ZGF0YTogQmxvYn19IGZpbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRIZWlnaHRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjcmVhdGVUaHVtYm5haWwgKGZpbGUsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpIHtcbiAgICAvLyBidWcgaW4gdGhlIGNvbXBhdGliaWxpdHkgZGF0YVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgY29uc3Qgb3JpZ2luYWxVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUuZGF0YSlcblxuICAgIGNvbnN0IG9ubG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKClcbiAgICAgIGltYWdlLnNyYyA9IG9yaWdpbmFsVXJsXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAvLyBidWcgaW4gdGhlIGNvbXBhdGliaWxpdHkgZGF0YVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9yaWdpbmFsVXJsKVxuICAgICAgICByZXNvbHZlKGltYWdlKVxuICAgICAgfSlcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIGJ1ZyBpbiB0aGUgY29tcGF0aWJpbGl0eSBkYXRhXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob3JpZ2luYWxVcmwpXG4gICAgICAgIHJlamVjdChldmVudC5lcnJvciB8fCBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgdGh1bWJuYWlsJykpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCBvcmllbnRhdGlvblByb21pc2UgPSBleGlmci5yb3RhdGlvbihmaWxlLmRhdGEpLmNhdGNoKF9lcnIgPT4gMSlcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChbb25sb2FkLCBvcmllbnRhdGlvblByb21pc2VdKVxuICAgICAgLnRoZW4oKFtpbWFnZSwgb3JpZW50YXRpb25dKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmdldFByb3BvcnRpb25hbERpbWVuc2lvbnMoaW1hZ2UsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIG9yaWVudGF0aW9uLmRlZylcbiAgICAgICAgY29uc3Qgcm90YXRlZEltYWdlID0gdGhpcy5yb3RhdGVJbWFnZShpbWFnZSwgb3JpZW50YXRpb24pXG4gICAgICAgIGNvbnN0IHJlc2l6ZWRJbWFnZSA9IHRoaXMucmVzaXplSW1hZ2Uocm90YXRlZEltYWdlLCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodClcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzVG9CbG9iKHJlc2l6ZWRJbWFnZSwgdGhpcy50aHVtYm5haWxUeXBlLCA4MClcbiAgICAgIH0pXG4gICAgICAudGhlbihibG9iID0+IHtcbiAgICAgICAgLy8gYnVnIGluIHRoZSBjb21wYXRpYmlsaXR5IGRhdGFcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuZXcgY2FsY3VsYXRlZCBkaW1lbnNpb25zIGZvciB0aGUgZ2l2ZW4gaW1hZ2UgYW5kIGEgdGFyZ2V0IHdpZHRoXG4gICAqIG9yIGhlaWdodC4gSWYgYm90aCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBnaXZlbiwgb25seSB3aWR0aCBpcyB0YWtlbiBpbnRvXG4gICAqIGFjY291bnQuIElmIG5laXRoZXIgd2lkdGggbm9yIGhlaWdodCBhcmUgZ2l2ZW4sIHRoZSBkZWZhdWx0IGRpbWVuc2lvblxuICAgKiBpcyB1c2VkLlxuICAgKi9cbiAgZ2V0UHJvcG9ydGlvbmFsRGltZW5zaW9ucyAoaW1nLCB3aWR0aCwgaGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHZhciBhc3BlY3QgPSBpbWcud2lkdGggLyBpbWcuaGVpZ2h0XG4gICAgaWYgKHJvdGF0aW9uID09PSA5MCB8fCByb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICBhc3BlY3QgPSBpbWcuaGVpZ2h0IC8gaW1nLndpZHRoXG4gICAgfVxuXG4gICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQod2lkdGggLyBhc3BlY3QpLFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQoaGVpZ2h0ICogYXNwZWN0KSxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5kZWZhdWx0VGh1bWJuYWlsRGltZW5zaW9uLFxuICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuZGVmYXVsdFRodW1ibmFpbERpbWVuc2lvbiAvIGFzcGVjdCksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSB0aGUgaW1hZ2UgZG9lc27igJl0IGV4Y2VlZCBicm93c2VyL2RldmljZSBjYW52YXMgbGltaXRzLlxuICAgKiBGb3IgaW9zIHdpdGggMjU2IFJBTSBhbmQgaWVcbiAgICovXG4gIHByb3RlY3QgKGltYWdlKSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjA4MTQ4My9tYXhpbXVtLXNpemUtb2YtYS1jYW52YXMtZWxlbWVudFxuXG4gICAgdmFyIHJhdGlvID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHRcblxuICAgIHZhciBtYXhTcXVhcmUgPSA1MDAwMDAwIC8vIGlvcyBtYXggY2FudmFzIHNxdWFyZVxuICAgIHZhciBtYXhTaXplID0gNDA5NiAvLyBpZSBtYXggY2FudmFzIGRpbWVuc2lvbnNcblxuICAgIHZhciBtYXhXID0gTWF0aC5mbG9vcihNYXRoLnNxcnQobWF4U3F1YXJlICogcmF0aW8pKVxuICAgIHZhciBtYXhIID0gTWF0aC5mbG9vcihtYXhTcXVhcmUgLyBNYXRoLnNxcnQobWF4U3F1YXJlICogcmF0aW8pKVxuICAgIGlmIChtYXhXID4gbWF4U2l6ZSkge1xuICAgICAgbWF4VyA9IG1heFNpemVcbiAgICAgIG1heEggPSBNYXRoLnJvdW5kKG1heFcgLyByYXRpbylcbiAgICB9XG4gICAgaWYgKG1heEggPiBtYXhTaXplKSB7XG4gICAgICBtYXhIID0gbWF4U2l6ZVxuICAgICAgbWF4VyA9IE1hdGgucm91bmQocmF0aW8gKiBtYXhIKVxuICAgIH1cbiAgICBpZiAoaW1hZ2Uud2lkdGggPiBtYXhXKSB7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgIGNhbnZhcy53aWR0aCA9IG1heFdcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBtYXhIXG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIG1heFcsIG1heEgpXG4gICAgICBpbWFnZSA9IGNhbnZhc1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBhbiBpbWFnZSB0byB0aGUgdGFyZ2V0IGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgQ2FudmFzIHdpdGggdGhlIHJlc2l6ZWQgaW1hZ2Ugb24gaXQuXG4gICAqL1xuICByZXNpemVJbWFnZSAoaW1hZ2UsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpIHtcbiAgICAvLyBSZXNpemluZyBpbiBzdGVwcyByZWZhY3RvcmVkIHRvIHVzZSBhIHNvbHV0aW9uIGZyb21cbiAgICAvLyBodHRwczovL2Jsb2cudXBsb2FkY2FyZS5jb20vaW1hZ2UtcmVzaXplLWluLWJyb3dzZXJzLWlzLWJyb2tlbi1lMzhlZWQwOGRmMDFcblxuICAgIGltYWdlID0gdGhpcy5wcm90ZWN0KGltYWdlKVxuXG4gICAgdmFyIHN0ZXBzID0gTWF0aC5jZWlsKE1hdGhMb2cyKGltYWdlLndpZHRoIC8gdGFyZ2V0V2lkdGgpKVxuICAgIGlmIChzdGVwcyA8IDEpIHtcbiAgICAgIHN0ZXBzID0gMVxuICAgIH1cbiAgICB2YXIgc1cgPSB0YXJnZXRXaWR0aCAqIE1hdGgucG93KDIsIHN0ZXBzIC0gMSlcbiAgICB2YXIgc0ggPSB0YXJnZXRIZWlnaHQgKiBNYXRoLnBvdygyLCBzdGVwcyAtIDEpXG4gICAgdmFyIHggPSAyXG5cbiAgICB3aGlsZSAoc3RlcHMtLSkge1xuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICBjYW52YXMud2lkdGggPSBzV1xuICAgICAgY2FudmFzLmhlaWdodCA9IHNIXG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHNXLCBzSClcbiAgICAgIGltYWdlID0gY2FudmFzXG5cbiAgICAgIHNXID0gTWF0aC5yb3VuZChzVyAvIHgpXG4gICAgICBzSCA9IE1hdGgucm91bmQoc0ggLyB4KVxuICAgIH1cblxuICAgIHJldHVybiBpbWFnZVxuICB9XG5cbiAgcm90YXRlSW1hZ2UgKGltYWdlLCB0cmFuc2xhdGUpIHtcbiAgICB2YXIgdyA9IGltYWdlLndpZHRoXG4gICAgdmFyIGggPSBpbWFnZS5oZWlnaHRcblxuICAgIGlmICh0cmFuc2xhdGUuZGVnID09PSA5MCB8fCB0cmFuc2xhdGUuZGVnID09PSAyNzApIHtcbiAgICAgIHcgPSBpbWFnZS5oZWlnaHRcbiAgICAgIGggPSBpbWFnZS53aWR0aFxuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IHdcbiAgICBjYW52YXMuaGVpZ2h0ID0gaFxuXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGNvbnRleHQudHJhbnNsYXRlKHcgLyAyLCBoIC8gMilcbiAgICBpZiAodHJhbnNsYXRlLmNhbnZhcykge1xuICAgICAgY29udGV4dC5yb3RhdGUodHJhbnNsYXRlLnJhZClcbiAgICAgIGNvbnRleHQuc2NhbGUodHJhbnNsYXRlLnNjYWxlWCwgdHJhbnNsYXRlLnNjYWxlWSlcbiAgICB9XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIC1pbWFnZS53aWR0aCAvIDIsIC1pbWFnZS5oZWlnaHQgLyAyLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KVxuXG4gICAgcmV0dXJuIGNhbnZhc1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgYSA8Y2FudmFzPiBlbGVtZW50J3MgY29udGVudCB0byBhIEJsb2Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjYW52YXNUb0Jsb2IgKGNhbnZhcywgdHlwZSwgcXVhbGl0eSkge1xuICAgIHRyeSB7XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gMTgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IHJlYWQgaW1hZ2UsIHByb2JhYmx5IGFuIHN2ZyB3aXRoIGV4dGVybmFsIHJlc291cmNlcycpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYW52YXMudG9CbG9iKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNhbnZhcy50b0Jsb2IocmVzb2x2ZSwgdHlwZSwgcXVhbGl0eSlcbiAgICAgIH0pLnRoZW4oKGJsb2IpID0+IHtcbiAgICAgICAgaWYgKGJsb2IgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWFkIGltYWdlLCBwcm9iYWJseSBhbiBzdmcgd2l0aCBleHRlcm5hbCByZXNvdXJjZXMnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9iXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gZGF0YVVSSXRvQmxvYihjYW52YXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpLCB7fSlcbiAgICB9KS50aGVuKChibG9iKSA9PiB7XG4gICAgICBpZiAoYmxvYiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBleHRyYWN0IGJsb2IsIHByb2JhYmx5IGFuIG9sZCBicm93c2VyJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBibG9iXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByZXZpZXcgVVJMIGZvciBhIGZpbGUuXG4gICAqL1xuICBzZXRQcmV2aWV3VVJMIChmaWxlSUQsIHByZXZpZXcpIHtcbiAgICB0aGlzLnVwcHkuc2V0RmlsZVN0YXRlKGZpbGVJRCwgeyBwcmV2aWV3IH0pXG4gIH1cblxuICBhZGRUb1F1ZXVlIChpdGVtKSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGl0ZW0pXG4gICAgaWYgKHRoaXMucXVldWVQcm9jZXNzaW5nID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5wcm9jZXNzUXVldWUoKVxuICAgIH1cbiAgfVxuXG4gIHByb2Nlc3NRdWV1ZSAoKSB7XG4gICAgdGhpcy5xdWV1ZVByb2Nlc3NpbmcgPSB0cnVlXG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXBweS5nZXRGaWxlKHRoaXMucXVldWUuc2hpZnQoKSlcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICB0aGlzLnVwcHkubG9nKCdbVGh1bWJuYWlsR2VuZXJhdG9yXSBmaWxlIHdhcyByZW1vdmVkIGJlZm9yZSBhIHRodW1ibmFpbCBjb3VsZCBiZSBnZW5lcmF0ZWQsIGJ1dCBub3QgcmVtb3ZlZCBmcm9tIHRoZSBxdWV1ZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZycsICdlcnJvcicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFRodW1ibmFpbChjdXJyZW50KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHt9KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGhhbmRsZS1jYWxsYmFjay1lcnJcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5wcm9jZXNzUXVldWUoKSlcbiAgICB9XG4gICAgdGhpcy5xdWV1ZVByb2Nlc3NpbmcgPSBmYWxzZVxuICAgIHRoaXMudXBweS5sb2coJ1tUaHVtYm5haWxHZW5lcmF0b3JdIEVtcHRpZWQgdGh1bWJuYWlsIHF1ZXVlJylcbiAgICB0aGlzLnVwcHkuZW1pdCgndGh1bWJuYWlsOmFsbC1nZW5lcmF0ZWQnKVxuICB9XG5cbiAgcmVxdWVzdFRodW1ibmFpbCAoZmlsZSkge1xuICAgIGlmIChpc1ByZXZpZXdTdXBwb3J0ZWQoZmlsZS50eXBlKSAmJiAhZmlsZS5pc1JlbW90ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGh1bWJuYWlsKGZpbGUsIHRoaXMub3B0cy50aHVtYm5haWxXaWR0aCwgdGhpcy5vcHRzLnRodW1ibmFpbEhlaWdodClcbiAgICAgICAgLnRoZW4ocHJldmlldyA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRQcmV2aWV3VVJMKGZpbGUuaWQsIHByZXZpZXcpXG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhgW1RodW1ibmFpbEdlbmVyYXRvcl0gR2VuZXJhdGVkIHRodW1ibmFpbCBmb3IgJHtmaWxlLmlkfWApXG4gICAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3RodW1ibmFpbDpnZW5lcmF0ZWQnLCB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlLmlkKSwgcHJldmlldylcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhgW1RodW1ibmFpbEdlbmVyYXRvcl0gRmFpbGVkIHRodW1ibmFpbCBmb3IgJHtmaWxlLmlkfTpgLCAnd2FybmluZycpXG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIsICd3YXJuaW5nJylcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndGh1bWJuYWlsOmVycm9yJywgdGhpcy51cHB5LmdldEZpbGUoZmlsZS5pZCksIGVycilcbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICBvbkZpbGVBZGRlZCA9IChmaWxlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgIWZpbGUucHJldmlld1xuICAgICAgJiYgZmlsZS5kYXRhXG4gICAgICAmJiBpc1ByZXZpZXdTdXBwb3J0ZWQoZmlsZS50eXBlKVxuICAgICAgJiYgIWZpbGUuaXNSZW1vdGVcbiAgICApIHtcbiAgICAgIHRoaXMuYWRkVG9RdWV1ZShmaWxlLmlkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYSBsYXp5IHJlcXVlc3QgZm9yIGEgdGh1bWJuYWlsIGlmIHRoZSB0aHVtYm5haWwgaGFzIG5vdCB5ZXQgYmVlbiBnZW5lcmF0ZWQuXG4gICAqL1xuICBvbkNhbmNlbFJlcXVlc3QgPSAoZmlsZSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5xdWV1ZS5pbmRleE9mKGZpbGUuaWQpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5xdWV1ZS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aHVtYm5haWwgZm9yIGEgZmlsZS4gQ2FuY2VsIGxhenkgcmVxdWVzdHMgYW5kIGZyZWUgdGhlIHRodW1ibmFpbCBVUkwuXG4gICAqL1xuICBvbkZpbGVSZW1vdmVkID0gKGZpbGUpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuaW5kZXhPZihmaWxlLmlkKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMucXVldWUuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIG9iamVjdCBVUkxzLlxuICAgIGlmIChmaWxlLnByZXZpZXcgJiYgaXNPYmplY3RVUkwoZmlsZS5wcmV2aWV3KSkge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChmaWxlLnByZXZpZXcpXG4gICAgfVxuICB9XG5cbiAgb25SZXN0b3JlZCA9ICgpID0+IHtcbiAgICBjb25zdCByZXN0b3JlZEZpbGVzID0gdGhpcy51cHB5LmdldEZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gZmlsZS5pc1Jlc3RvcmVkKVxuICAgIHJlc3RvcmVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgLy8gT25seSBhZGQgYmxvYiBVUkxzOyB0aGV5IGFyZSBsaWtlbHkgaW52YWxpZCBhZnRlciBiZWluZyByZXN0b3JlZC5cbiAgICAgIGlmICghZmlsZS5wcmV2aWV3IHx8IGlzT2JqZWN0VVJMKGZpbGUucHJldmlldykpIHtcbiAgICAgICAgdGhpcy5hZGRUb1F1ZXVlKGZpbGUuaWQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHdhaXRVbnRpbEFsbFByb2Nlc3NlZCA9IChmaWxlSURzKSA9PiB7XG4gICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgICB0aGlzLnVwcHkuZW1pdCgncHJlcHJvY2Vzcy1wcm9ncmVzcycsIGZpbGUsIHtcbiAgICAgICAgbW9kZTogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLmkxOG4oJ2dlbmVyYXRpbmdUaHVtYm5haWxzJyksXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCBlbWl0UHJlcHJvY2Vzc0NvbXBsZXRlRm9yQWxsID0gKCkgPT4ge1xuICAgICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3ByZXByb2Nlc3MtY29tcGxldGUnLCBmaWxlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMucXVldWVQcm9jZXNzaW5nKSB7XG4gICAgICAgIHRoaXMudXBweS5vbmNlKCd0aHVtYm5haWw6YWxsLWdlbmVyYXRlZCcsICgpID0+IHtcbiAgICAgICAgICBlbWl0UHJlcHJvY2Vzc0NvbXBsZXRlRm9yQWxsKClcbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXRQcmVwcm9jZXNzQ29tcGxldGVGb3JBbGwoKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51cHB5Lm9uKCdmaWxlLXJlbW92ZWQnLCB0aGlzLm9uRmlsZVJlbW92ZWQpXG4gICAgaWYgKHRoaXMub3B0cy5sYXp5KSB7XG4gICAgICB0aGlzLnVwcHkub24oJ3RodW1ibmFpbDpyZXF1ZXN0JywgdGhpcy5vbkZpbGVBZGRlZClcbiAgICAgIHRoaXMudXBweS5vbigndGh1bWJuYWlsOmNhbmNlbCcsIHRoaXMub25DYW5jZWxSZXF1ZXN0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwcHkub24oJ2ZpbGUtYWRkZWQnLCB0aGlzLm9uRmlsZUFkZGVkKVxuICAgICAgdGhpcy51cHB5Lm9uKCdyZXN0b3JlZCcsIHRoaXMub25SZXN0b3JlZClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLndhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkKSB7XG4gICAgICB0aGlzLnVwcHkuYWRkUHJlUHJvY2Vzc29yKHRoaXMud2FpdFVudGlsQWxsUHJvY2Vzc2VkKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51cHB5Lm9mZignZmlsZS1yZW1vdmVkJywgdGhpcy5vbkZpbGVSZW1vdmVkKVxuICAgIGlmICh0aGlzLm9wdHMubGF6eSkge1xuICAgICAgdGhpcy51cHB5Lm9mZigndGh1bWJuYWlsOnJlcXVlc3QnLCB0aGlzLm9uRmlsZUFkZGVkKVxuICAgICAgdGhpcy51cHB5Lm9mZigndGh1bWJuYWlsOmNhbmNlbCcsIHRoaXMub25DYW5jZWxSZXF1ZXN0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLWFkZGVkJywgdGhpcy5vbkZpbGVBZGRlZClcbiAgICAgIHRoaXMudXBweS5vZmYoJ3Jlc3RvcmVkJywgdGhpcy5vblJlc3RvcmVkKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRoaXMudXBweS5yZW1vdmVQcmVQcm9jZXNzb3IodGhpcy53YWl0VW50aWxBbGxQcm9jZXNzZWQpXG4gICAgfVxuICB9XG59XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlXG4gICAgOiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9jYXRpb24ucG9ydFxuICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gISFvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBkZXRlY3QgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnRcbiAgdGhpcy5pc1JlYWN0TmF0aXZlID0gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJyk7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBvciBSZWFjdE5hdGl2ZSBjbGllbnRcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmlzUmVhY3ROYXRpdmUpIHtcbiAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubG9jYWxBZGRyZXNzKSB7XG4gICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBvbiBoYW5kc2hha2VcbiAgdGhpcy5pZCA9IG51bGw7XG4gIHRoaXMudXBncmFkZXMgPSBudWxsO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuXG4gIC8vIHNldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gcGVyLXRyYW5zcG9ydCBvcHRpb25zXG4gIHZhciBvcHRpb25zID0gdGhpcy50cmFuc3BvcnRPcHRpb25zW25hbWVdIHx8IHt9O1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgYWdlbnQ6IG9wdGlvbnMuYWdlbnQgfHwgdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogb3B0aW9ucy5ob3N0bmFtZSB8fCB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiBvcHRpb25zLnNlY3VyZSB8fCB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoLFxuICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IG9wdGlvbnMuanNvbnAgfHwgdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogb3B0aW9ucy5mb3JjZUJhc2U2NCB8fCB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IG9wdGlvbnMudGltZXN0YW1wUmVxdWVzdHMgfHwgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogb3B0aW9ucy50aW1lc3RhbXBQYXJhbSB8fCB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuICAgIHBvbGljeVBvcnQ6IG9wdGlvbnMucG9saWN5UG9ydCB8fCB0aGlzLnBvbGljeVBvcnQsXG4gICAgcGZ4OiBvcHRpb25zLnBmeCB8fCB0aGlzLnBmeCxcbiAgICBrZXk6IG9wdGlvbnMua2V5IHx8IHRoaXMua2V5LFxuICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSB8fCB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogb3B0aW9ucy5jZXJ0IHx8IHRoaXMuY2VydCxcbiAgICBjYTogb3B0aW9ucy5jYSB8fCB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyB8fCB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCB8fCB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgIGV4dHJhSGVhZGVyczogb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgdGhpcy5leHRyYUhlYWRlcnMsXG4gICAgZm9yY2VOb2RlOiBvcHRpb25zLmZvcmNlTm9kZSB8fCB0aGlzLmZvcmNlTm9kZSxcbiAgICBsb2NhbEFkZHJlc3M6IG9wdGlvbnMubG9jYWxBZGRyZXNzIHx8IHRoaXMubG9jYWxBZGRyZXNzLFxuICAgIHJlcXVlc3RUaW1lb3V0OiBvcHRpb25zLnJlcXVlc3RUaW1lb3V0IHx8IHRoaXMucmVxdWVzdFRpbWVvdXQsXG4gICAgcHJvdG9jb2xzOiBvcHRpb25zLnByb3RvY29scyB8fCB2b2lkICgwKSxcbiAgICBpc1JlYWN0TmF0aXZlOiB0aGlzLmlzUmVhY3ROYXRpdmVcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9PSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICB0cnkge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pO1xuICB2YXIgZmFpbGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuICgpIHtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT09IG1zZy50eXBlICYmICdwcm9iZScgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCAoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlICgpIHtcbiAgICBvbmVycm9yKCd0cmFuc3BvcnQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSAoKSB7XG4gICAgb25lcnJvcignc29ja2V0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlICh0bykge1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UoSlNPTi5wYXJzZShwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gIHRoaXMub25PcGVuKCk7XG4gIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgncGluZycpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICgnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YSxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIGlmIChmbikgdGhpcy5vbmNlKCdmbHVzaCcsIGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlICgpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIGNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSAoKSB7XG4gICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIHJlc3VsdHMgb2YgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uXG4gIHRoaXMuaXNSZWFjdE5hdGl2ZSA9IG9wdHMuaXNSZWFjdE5hdGl2ZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nIChvcHRzKSB7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgb3B0cy54c2NoZW1lID0geHM7XG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG4gICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cbiIsIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG4vKipcbiAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG5cbnZhciByTmV3bGluZSA9IC9cXG4vZztcbnZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7IH1cblxuLyoqXG4gKiBVbnRpbCBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWwgaXMgc2hpcHBlZC5cbiAqL1xuZnVuY3Rpb24gZ2xvYiAoKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmXG4gICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93XG4gICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge307XG59XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgdmFyIGdsb2JhbCA9IGdsb2IoKTtcbiAgICBjYWxsYmFja3MgPSBnbG9iYWwuX19fZWlvID0gKGdsb2JhbC5fX19laW8gfHwgW10pO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuICB0aGlzLmluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgIHNlbGYub25EYXRhKG1zZyk7XG4gIH0pO1xuXG4gIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcbiAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG4gIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJywgZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfSBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiIsIi8qIGdsb2JhbCBhdHRhY2hFdmVudCAqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUiAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSkgfHxcbiAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIG9wdHMucmVxdWVzdFRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgJiYgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayh0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAoJ1BPU1QnID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc3VwcG9ydHNCaW5hcnkgJiYgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgIT09IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlYnVnKCd4aHIgZGF0YSAlcycsIHRoaXMuZGF0YSk7XG4gICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChmcm9tRXJyb3IpIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlIHx8IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cblJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5SZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmICh0eXBlb2YgYXR0YWNoRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB0ZXJtaW5hdGlvbkV2ZW50ID0gJ29ucGFnZWhpZGUnIGluIHNlbGYgPyAncGFnZWhpZGUnIDogJ3VubG9hZCc7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0ZXJtaW5hdGlvbkV2ZW50LCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlciAoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChvblBhdXNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UgKCkge1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgICgnaHR0cCcgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXG52YXIgQnJvd3NlcldlYlNvY2tldCwgTm9kZVdlYlNvY2tldDtcblxuaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gIEJyb3dzZXJXZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICBCcm93c2VyV2ViU29ja2V0ID0gc2VsZi5XZWJTb2NrZXQgfHwgc2VsZi5Nb3pXZWJTb2NrZXQ7XG59IGVsc2Uge1xuICB0cnkge1xuICAgIE5vZGVXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xuICB9IGNhdGNoIChlKSB7IH1cbn1cblxuLyoqXG4gKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG4gKiBpbiB0aGUgYnJvd3NlciBvciB0cnkgdG8gcmVzb2x2ZSBXZWJTb2NrZXQtY29tcGF0aWJsZVxuICogaW50ZXJmYWNlIGV4cG9zZWQgYnkgYHdzYCBmb3IgTm9kZS1saWtlIGVudmlyb25tZW50LlxuICovXG5cbnZhciBXZWJTb2NrZXRJbXBsID0gQnJvd3NlcldlYlNvY2tldCB8fCBOb2RlV2ViU29ja2V0O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQgJiYgIW9wdHMuZm9yY2VOb2RlO1xuICB0aGlzLnByb3RvY29scyA9IG9wdHMucHJvdG9jb2xzO1xuICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgV2ViU29ja2V0SW1wbCA9IE5vZGVXZWJTb2NrZXQ7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdGhpcy5wcm90b2NvbHM7XG4gIHZhciBvcHRzID0ge1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlXG4gIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICBvcHRzLmhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcbiAgfVxuICBpZiAodGhpcy5sb2NhbEFkZHJlc3MpIHtcbiAgICBvcHRzLmxvY2FsQWRkcmVzcyA9IHRoaXMubG9jYWxBZGRyZXNzO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLndzID1cbiAgICAgIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ICYmICF0aGlzLmlzUmVhY3ROYXRpdmVcbiAgICAgICAgPyBwcm90b2NvbHNcbiAgICAgICAgICA/IG5ldyBXZWJTb2NrZXRJbXBsKHVyaSwgcHJvdG9jb2xzKVxuICAgICAgICAgIDogbmV3IFdlYlNvY2tldEltcGwodXJpKVxuICAgICAgICA6IG5ldyBXZWJTb2NrZXRJbXBsKHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMud3Muc3VwcG9ydHMgJiYgdGhpcy53cy5zdXBwb3J0cy5iaW5hcnkpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnbm9kZWJ1ZmZlcic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcbiAgICAoZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PT0gdHlwZW9mIGRhdGEgPyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldEltcGwgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXRJbXBsICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgc2VsZltbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIi8qKlxyXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXHJcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gIHZhciBzdHIgPSAnJztcclxuXHJcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcclxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XHJcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdHI7XHJcbn07XHJcblxyXG4vKipcclxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcclxuICB2YXIgcXJ5ID0ge307XHJcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xyXG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XHJcbiAgfVxyXG4gIHJldHVybiBxcnk7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBQYXJzZXMgYW4gVVJJXHJcbiAqXHJcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XHJcblxyXG52YXIgcGFydHMgPSBbXHJcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcclxuXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XHJcbiAgICB2YXIgc3JjID0gc3RyLFxyXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxyXG4gICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxyXG4gICAgICAgIHVyaSA9IHt9LFxyXG4gICAgICAgIGkgPSAxNDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG4gICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XHJcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XHJcbiAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1cmk7XHJcbn07XHJcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwICh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdLm5zcHM7XG4gIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cbiAgdmFyIGlvO1xuXG4gIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG4gIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkLnF1ZXJ5O1xuICB9XG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgsIG9wdHMpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlciAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdmFyIF9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IF9wYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIGdlbmVyYXRlIGBzb2NrZXQuaWRgIGZvciB0aGUgZ2l2ZW4gYG5zcGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbnNwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKG5zcCkge1xuICByZXR1cm4gKG5zcCA9PT0gJy8nID8gJycgOiAobnNwICsgJyMnKSkgKyB0aGlzLmVuZ2luZS5pZDtcbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmZsYWdzID0ge307XG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgfVxuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiAodGhpcy5mbGFncy5iaW5hcnkgIT09IHVuZGVmaW5lZCA/IHRoaXMuZmxhZ3MuYmluYXJ5IDogaGFzQmluKGFyZ3MpKSA/IHBhcnNlci5CSU5BUllfRVZFTlQgOiBwYXJzZXIuRVZFTlQsXG4gICAgZGF0YTogYXJnc1xuICB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgdGhpcy5mbGFncyA9IHt9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT09IHRoaXMubnNwKSB7XG4gICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgIHZhciBxdWVyeSA9IHR5cGVvZiB0aGlzLnF1ZXJ5ID09PSAnb2JqZWN0JyA/IHBhcnNlcXMuZW5jb2RlKHRoaXMucXVlcnkpIDogdGhpcy5xdWVyeTtcbiAgICAgIGRlYnVnKCdzZW5kaW5nIGNvbm5lY3QgcGFja2V0IHdpdGggcXVlcnkgJXMnLCBxdWVyeSk7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiBxdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBwYWNrZXQubnNwID09PSB0aGlzLm5zcDtcbiAgdmFyIHJvb3ROYW1lc3BhY2VFcnJvciA9IHBhY2tldC50eXBlID09PSBwYXJzZXIuRVJST1IgJiYgcGFja2V0Lm5zcCA9PT0gJy8nO1xuXG4gIGlmICghc2FtZU5hbWVzcGFjZSAmJiAhcm9vdE5hbWVzcGFjZUVycm9yKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYmluYXJ5IGZsYWdcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIGVtaXR0ZWQgZGF0YSBjb250YWlucyBiaW5hcnlcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uIChiaW5hcnkpIHtcbiAgdGhpcy5mbGFncy5iaW5hcnkgPSBiaW5hcnk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwgKHVyaSwgbG9jKSB7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgbG9jID0gbG9jIHx8ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uKTtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXScpO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0FDSycsXG4gICdFUlJPUicsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQklOQVJZX0FDSydcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbi8qKlxuICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cbi8qKlxuICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cbnZhciBFUlJPUl9QQUNLRVQgPSBleHBvcnRzLkVSUk9SICsgJ1wiZW5jb2RlIGVycm9yXCInO1xuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHZhciBzdHIgPSAnJyArIG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzICsgJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9PSBvYmoubnNwKSB7XG4gICAgc3RyICs9IG9iai5uc3AgKyAnLCc7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIHZhciBwYXlsb2FkID0gdHJ5U3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgICBpZiAocGF5bG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHN0ciArPSBwYXlsb2FkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRVJST1JfUEFDS0VUO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiB0cnlTdHJpbmdpZnkoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICB9XG5cbiAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG59XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZW5jb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgaSA9IDA7XG4gIC8vIGxvb2sgdXAgdHlwZVxuICB2YXIgcCA9IHtcbiAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSlcbiAgfTtcblxuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHtcbiAgICByZXR1cm4gZXJyb3IoJ3Vua25vd24gcGFja2V0IHR5cGUgJyArIHAudHlwZSk7XG4gIH1cblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gcC50eXBlKSB7XG4gICAgdmFyIHN0YXJ0ID0gaSArIDE7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nICYmIGkgIT0gc3RyLmxlbmd0aCkge31cbiAgICB2YXIgYnVmID0gc3RyLnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9PSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgIHZhciBzdGFydCA9IGkgKyAxO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT09IGMpIGJyZWFrO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLm5zcCA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICB2YXIgc3RhcnQgPSBpICsgMTtcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIoc3RyLnN1YnN0cmluZyhzdGFydCwgaSArIDEpKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIHZhciBpc1BheWxvYWRWYWxpZCA9IHBheWxvYWQgIT09IGZhbHNlICYmIChwLnR5cGUgPT09IGV4cG9ydHMuRVJST1IgfHwgaXNBcnJheShwYXlsb2FkKSk7XG4gICAgaWYgKGlzUGF5bG9hZFZhbGlkKSB7XG4gICAgICBwLmRhdGEgPSBwYXlsb2FkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXJyb3IoJ2ludmFsaWQgcGF5bG9hZCcpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yOiAnICsgbXNnXG4gIH07XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbnZhciB3aXRoTmF0aXZlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nO1xudmFyIHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSA6IChvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKHdpdGhOYXRpdmVCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KG9iaikpKTtcbn1cbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xyXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cclxuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS90cmFuc2xvYWRpdFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFRyYW5zbG9hZGl0IHBsdWdpbiBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gVHJhbnNsb2FkaXQgZm9yIGFsbCBraW5kcyBvZiBwcm9jZXNzaW5nLCBzdWNoIGFzIHRyYW5zY29kaW5nIHZpZGVvLCByZXNpemluZyBpbWFnZXMsIHppcHBpbmcvdW56aXBwaW5nLCBhbmQgbW9yZVwiLFxuICBcInZlcnNpb25cIjogXCIxLjYuMjVcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInRyYW5zbG9hZGl0XCIsXG4gICAgXCJmaWxlIGVuY29kaW5nXCIsXG4gICAgXCJlbmNvZGluZ1wiLFxuICAgIFwiZmlsZSBwcm9jZXNzaW5nXCIsXG4gICAgXCJ2aWRlbyBlbmNvZGluZ1wiLFxuICAgIFwiY3JvcFwiLFxuICAgIFwicmVzaXplXCIsXG4gICAgXCJ3YXRlcm1hcmtcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3R1c1wiOiBcImZpbGU6Li4vdHVzXCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcImNvbXBvbmVudC1lbWl0dGVyXCI6IFwiXjEuMi4xXCIsXG4gICAgXCJzb2NrZXQuaW8tY2xpZW50XCI6IFwifjIuMi4wXCIsXG4gICAgXCJ1cmwtcGFyc2VcIjogXCJeMS40LjdcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IGlvID0gcmVxdWlyZVNvY2tldElvXG5jb25zdCBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKVxuY29uc3QgaGFzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2hhc1Byb3BlcnR5JylcbmNvbnN0IHBhcnNlVXJsID0gcmVxdWlyZSgnLi9wYXJzZVVybCcpXG5jb25zdCBOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvTmV0d29ya0Vycm9yJylcbmNvbnN0IGZldGNoV2l0aE5ldHdvcmtFcnJvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9mZXRjaFdpdGhOZXR3b3JrRXJyb3InKVxuXG4vLyBMYXp5IGxvYWQgc29ja2V0LmlvIHRvIGF2b2lkIGEgY29uc29sZSBlcnJvclxuLy8gaW4gSUUgMTAgd2hlbiB0aGUgVHJhbnNsb2FkaXQgcGx1Z2luIGlzIG5vdCB1c2VkLlxuLy8gKFRoZSBjb25zb2xlLmVycm9yIGNhbGwgY29tZXMgZnJvbSBgYnVmZmVyYC4gSVxuLy8gdGhpbmsgd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHRoYXQgcGFydCBvZiBzb2NrZXQuaW9cbi8vIGF0IGFsbOKApilcbmxldCBzb2NrZXRJb1xuZnVuY3Rpb24gcmVxdWlyZVNvY2tldElvICgpIHtcbiAgaWYgKCFzb2NrZXRJbykge1xuICAgIHNvY2tldElvID0gcmVxdWlyZSgnc29ja2V0LmlvLWNsaWVudCcpXG4gIH1cbiAgcmV0dXJuIHNvY2tldElvXG59XG5cbmNvbnN0IEFTU0VNQkxZX1VQTE9BRElORyA9ICdBU1NFTUJMWV9VUExPQURJTkcnXG5jb25zdCBBU1NFTUJMWV9FWEVDVVRJTkcgPSAnQVNTRU1CTFlfRVhFQ1VUSU5HJ1xuY29uc3QgQVNTRU1CTFlfQ09NUExFVEVEID0gJ0FTU0VNQkxZX0NPTVBMRVRFRCdcblxuY29uc3Qgc3RhdHVzT3JkZXIgPSBbXG4gIEFTU0VNQkxZX1VQTE9BRElORyxcbiAgQVNTRU1CTFlfRVhFQ1VUSU5HLFxuICBBU1NFTUJMWV9DT01QTEVURUQsXG5dXG5cbi8qKlxuICogQ2hlY2sgdGhhdCBhbiBhc3NlbWJseSBzdGF0dXMgaXMgZXF1YWwgdG8gb3IgbGFyZ2VyIHRoYW4gc29tZSBkZXNpcmVkIHN0YXR1cy5cbiAqIEl0IGNoZWNrcyBmb3IgdGhpbmdzIHRoYXQgYXJlIGxhcmdlciBzbyB0aGF0IGEgY29tcGFyaXNvbiBsaWtlIHRoaXMgd29ya3MsXG4gKiB3aGVuIHRoZSBvbGQgYXNzZW1ibHkgc3RhdHVzIGlzIFVQTE9BRElORyBidXQgdGhlIG5ldyBpcyBGSU5JU0hFRDpcbiAqXG4gKiAhaXNTdGF0dXMob2xkU3RhdHVzLCBBU1NFTUJMWV9FWEVDVVRJTkcpICYmIGlzU3RhdHVzKG5ld1N0YXRlLCBBU1NFTUJMWV9FWEVDVVRJTkcpXG4gKlxuICog4oCmc28gdGhhdCB3ZSBjYW4gZW1pdCB0aGUgJ2V4ZWN1dGluZycgZXZlbnQgZXZlbiBpZiB0aGUgZXhlY3V0aW9uIHN0ZXAgd2FzIHNvXG4gKiBmYXN0IHRoYXQgd2UgbWlzc2VkIGl0LlxuICovXG5mdW5jdGlvbiBpc1N0YXR1cyAoc3RhdHVzLCB0ZXN0KSB7XG4gIHJldHVybiBzdGF0dXNPcmRlci5pbmRleE9mKHN0YXR1cykgPj0gc3RhdHVzT3JkZXIuaW5kZXhPZih0ZXN0KVxufVxuXG5jbGFzcyBUcmFuc2xvYWRpdEFzc2VtYmx5IGV4dGVuZHMgRW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChhc3NlbWJseSkge1xuICAgIHN1cGVyKClcblxuICAgIC8vIFRoZSBjdXJyZW50IGFzc2VtYmx5IHN0YXR1cy5cbiAgICB0aGlzLnN0YXR1cyA9IGFzc2VtYmx5XG4gICAgLy8gVGhlIHNvY2tldC5pbyBjb25uZWN0aW9uLlxuICAgIHRoaXMuc29ja2V0ID0gbnVsbFxuICAgIC8vIFRoZSBpbnRlcnZhbCB0aW1lciBmb3IgZnVsbCBzdGF0dXMgdXBkYXRlcy5cbiAgICB0aGlzLnBvbGxJbnRlcnZhbCA9IG51bGxcbiAgICAvLyBXaGV0aGVyIHRoaXMgYXNzZW1ibHkgaGFzIGJlZW4gY2xvc2VkIChmaW5pc2hlZCBvciBlcnJvcmVkKVxuICAgIHRoaXMuY2xvc2VkID0gZmFsc2VcbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RTb2NrZXQoKVxuICAgIHRoaXMuX2JlZ2luUG9sbGluZygpXG4gIH1cblxuICBfb25GaW5pc2hlZCAoKSB7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2hlZCcpXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBfY29ubmVjdFNvY2tldCAoKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VVcmwodGhpcy5zdGF0dXMud2Vic29ja2V0X3VybClcbiAgICBjb25zdCBzb2NrZXQgPSBpbygpLmNvbm5lY3QocGFyc2VkLm9yaWdpbiwge1xuICAgICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnXSxcbiAgICAgIHBhdGg6IHBhcnNlZC5wYXRobmFtZSxcbiAgICB9KVxuXG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgc29ja2V0LmVtaXQoJ2Fzc2VtYmx5X2Nvbm5lY3QnLCB7XG4gICAgICAgIGlkOiB0aGlzLnN0YXR1cy5hc3NlbWJseV9pZCxcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpXG4gICAgfSlcblxuICAgIHNvY2tldC5vbignY29ubmVjdF9mYWlsZWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkVycm9yKG5ldyBOZXR3b3JrRXJyb3IoJ1RyYW5zbG9hZGl0IFNvY2tldC5pbyBjb25uZWN0aW9uIGVycm9yJykpXG4gICAgICB0aGlzLnNvY2tldCA9IG51bGxcbiAgICB9KVxuXG4gICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgIHNvY2tldC5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbFxuICAgIH0pXG5cbiAgICBzb2NrZXQub24oJ2Fzc2VtYmx5X2ZpbmlzaGVkJywgKCkgPT4ge1xuICAgICAgdGhpcy5fb25GaW5pc2hlZCgpXG4gICAgfSlcblxuICAgIHNvY2tldC5vbignYXNzZW1ibHlfdXBsb2FkX2ZpbmlzaGVkJywgKGZpbGUpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgndXBsb2FkJywgZmlsZSlcbiAgICAgIHRoaXMuc3RhdHVzLnVwbG9hZHMucHVzaChmaWxlKVxuICAgIH0pXG5cbiAgICBzb2NrZXQub24oJ2Fzc2VtYmx5X3VwbG9hZGluZ19maW5pc2hlZCcsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZXhlY3V0aW5nJylcbiAgICB9KVxuXG4gICAgc29ja2V0Lm9uKCdhc3NlbWJseV91cGxvYWRfbWV0YV9kYXRhX2V4dHJhY3RlZCcsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnbWV0YWRhdGEnKVxuICAgICAgdGhpcy5fZmV0Y2hTdGF0dXMoeyBkaWZmOiBmYWxzZSB9KVxuICAgIH0pXG5cbiAgICBzb2NrZXQub24oJ2Fzc2VtYmx5X3Jlc3VsdF9maW5pc2hlZCcsIChzdGVwTmFtZSwgcmVzdWx0KSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ3Jlc3VsdCcsIHN0ZXBOYW1lLCByZXN1bHQpXG4gICAgICBpZiAoIXRoaXMuc3RhdHVzLnJlc3VsdHNbc3RlcE5hbWVdKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzLnJlc3VsdHNbc3RlcE5hbWVdID0gW11cbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdHVzLnJlc3VsdHNbc3RlcE5hbWVdLnB1c2gocmVzdWx0KVxuICAgIH0pXG5cbiAgICBzb2NrZXQub24oJ2Fzc2VtYmx5X2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgdGhpcy5fb25FcnJvcihlcnIpXG4gICAgICAvLyBSZWZldGNoIGZvciB1cGRhdGVkIHN0YXR1cyBjb2RlXG4gICAgICB0aGlzLl9mZXRjaFN0YXR1cyh7IGRpZmY6IGZhbHNlIH0pXG4gICAgfSlcblxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gIH1cblxuICBfb25FcnJvciAoZXJyKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGVyci5tZXNzYWdlKSwgZXJyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWdpbiBwb2xsaW5nIGZvciBhc3NlbWJseSBzdGF0dXMgY2hhbmdlcy4gVGhpcyBzZW5kcyBhIHJlcXVlc3QgdG8gdGhlXG4gICAqIGFzc2VtYmx5IHN0YXR1cyBlbmRwb2ludCBldmVyeSBzbyBvZnRlbiwgaWYgdGhlIHNvY2tldCBpcyBub3QgY29ubmVjdGVkLlxuICAgKiBJZiB0aGUgc29ja2V0IGNvbm5lY3Rpb24gZmFpbHMgb3IgdGFrZXMgYSBsb25nIHRpbWUsIHdlIHdvbid0IG1pc3MgYW55XG4gICAqIGV2ZW50cy5cbiAgICovXG4gIF9iZWdpblBvbGxpbmcgKCkge1xuICAgIHRoaXMucG9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnNvY2tldCB8fCAhdGhpcy5zb2NrZXQuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2ZldGNoU3RhdHVzKClcbiAgICAgIH1cbiAgICB9LCAyMDAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbG9hZCBhc3NlbWJseSBzdGF0dXMuIFVzZWZ1bCBpZiB0aGUgc29ja2V0IGRvZXNuJ3Qgd29yay5cbiAgICpcbiAgICogUGFzcyBgZGlmZjogZmFsc2VgIHRvIGF2b2lkIGVtaXR0aW5nIGRpZmYgZXZlbnRzLCBpbnN0ZWFkIG9ubHkgZW1pdHRpbmdcbiAgICogJ3N0YXR1cycuXG4gICAqL1xuICBfZmV0Y2hTdGF0dXMgKHsgZGlmZiA9IHRydWUgfSA9IHt9KSB7XG4gICAgcmV0dXJuIGZldGNoV2l0aE5ldHdvcmtFcnJvcih0aGlzLnN0YXR1cy5hc3NlbWJseV9zc2xfdXJsKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbigoc3RhdHVzKSA9PiB7XG4gICAgICAgIC8vIEF2b2lkIHVwZGF0aW5nIGlmIHdlIGNsb3NlZCBkdXJpbmcgdGhpcyByZXF1ZXN0J3MgbGlmZXRpbWUuXG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuXG4gICAgICAgIHRoaXMuZW1pdCgnc3RhdHVzJywgc3RhdHVzKVxuXG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoc3RhdHVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5fb25FcnJvcihlcnIpKVxuICB9XG5cbiAgdXBkYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hTdGF0dXMoeyBkaWZmOiB0cnVlIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoaXMgYXNzZW1ibHkncyBzdGF0dXMgd2l0aCBhIGZ1bGwgbmV3IG9iamVjdC4gRXZlbnRzIHdpbGwgYmVcbiAgICogZW1pdHRlZCBmb3Igc3RhdHVzIGNoYW5nZXMsIG5ldyBmaWxlcywgYW5kIG5ldyByZXN1bHRzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dCBUaGUgbmV3IGFzc2VtYmx5IHN0YXR1cyBvYmplY3QuXG4gICAqL1xuICB1cGRhdGVTdGF0dXMgKG5leHQpIHtcbiAgICB0aGlzLl9kaWZmU3RhdHVzKHRoaXMuc3RhdHVzLCBuZXh0KVxuICAgIHRoaXMuc3RhdHVzID0gbmV4dFxuICB9XG5cbiAgLyoqXG4gICAqIERpZmYgdHdvIGFzc2VtYmx5IHN0YXR1c2VzLCBhbmQgZW1pdCB0aGUgZXZlbnRzIG5lY2Vzc2FyeSB0byBnbyBmcm9tIGBwcmV2YFxuICAgKiB0byBgbmV4dGAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2IFRoZSBwcmV2aW91cyBhc3NlbWJseSBzdGF0dXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0IFRoZSBuZXcgYXNzZW1ibHkgc3RhdHVzLlxuICAgKi9cbiAgX2RpZmZTdGF0dXMgKHByZXYsIG5leHQpIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gcHJldi5va1xuICAgIGNvbnN0IG5leHRTdGF0dXMgPSBuZXh0Lm9rXG5cbiAgICBpZiAobmV4dC5lcnJvciAmJiAhcHJldi5lcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuX29uRXJyb3IobmV4dClcbiAgICB9XG5cbiAgICAvLyBEZXNpcmVkIGVtaXQgb3JkZXI6XG4gICAgLy8gIC0gZXhlY3V0aW5nXG4gICAgLy8gIC0gKG4gw5cgdXBsb2FkKVxuICAgIC8vICAtIG1ldGFkYXRhXG4gICAgLy8gIC0gKG0gw5cgcmVzdWx0KVxuICAgIC8vICAtIGZpbmlzaGVkXG4gICAgLy8gVGhlIGJlbG93IGNoZWNrcyBydW4gaW4gdGhpcyBvcmRlciwgdGhhdCB3YXkgZXZlbiBpZiB3ZSBqdW1wIGZyb21cbiAgICAvLyBVUExPQURJTkcgc3RyYWlnaHQgdG8gRklOSVNIRUQgYWxsIHRoZSBldmVudHMgYXJlIGVtaXR0ZWQgYXMgZXhwZWN0ZWQuXG5cbiAgICBjb25zdCBub3dFeGVjdXRpbmdcbiAgICAgID0gaXNTdGF0dXMobmV4dFN0YXR1cywgQVNTRU1CTFlfRVhFQ1VUSU5HKVxuICAgICAgJiYgIWlzU3RhdHVzKHByZXZTdGF0dXMsIEFTU0VNQkxZX0VYRUNVVElORylcbiAgICBpZiAobm93RXhlY3V0aW5nKSB7XG4gICAgICAvLyBXaXRob3V0IFdlYlNvY2tldHMsIHRoaXMgaXMgb3VyIG9ubHkgd2F5IHRvIHRlbGwgaWYgdXBsb2FkaW5nIGZpbmlzaGVkLlxuICAgICAgLy8gSGVuY2UsIHdlIGVtaXQgdGhpcyBqdXN0IGJlZm9yZSB0aGUgJ3VwbG9hZCdzIGFuZCBiZWZvcmUgdGhlICdtZXRhZGF0YSdcbiAgICAgIC8vIGV2ZW50IGZvciB0aGUgbW9zdCBpbnR1aXRpdmUgb3JkZXJpbmcsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIF91c3VhbF9cbiAgICAgIC8vIG9yZGVyaW5nIChpZiBub3QgZ3VhcmFudGVlZCkgdGhhdCB5b3UnZCBnZXQgb24gdGhlIFdlYlNvY2tldC5cbiAgICAgIHRoaXMuZW1pdCgnZXhlY3V0aW5nJylcbiAgICB9XG5cbiAgICAvLyBGaW5kIG5ldyB1cGxvYWRlZCBmaWxlcy5cbiAgICBPYmplY3Qua2V5cyhuZXh0LnVwbG9hZHMpXG4gICAgICAuZmlsdGVyKCh1cGxvYWQpID0+ICFoYXMocHJldi51cGxvYWRzLCB1cGxvYWQpKVxuICAgICAgLm1hcCgodXBsb2FkKSA9PiBuZXh0LnVwbG9hZHNbdXBsb2FkXSlcbiAgICAgIC5mb3JFYWNoKCh1cGxvYWQpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGxvYWQnLCB1cGxvYWQpXG4gICAgICB9KVxuXG4gICAgaWYgKG5vd0V4ZWN1dGluZykge1xuICAgICAgdGhpcy5lbWl0KCdtZXRhZGF0YScpXG4gICAgfVxuXG4gICAgLy8gRmluZCBuZXcgcmVzdWx0cy5cbiAgICBPYmplY3Qua2V5cyhuZXh0LnJlc3VsdHMpLmZvckVhY2goKHN0ZXBOYW1lKSA9PiB7XG4gICAgICBjb25zdCBuZXh0UmVzdWx0cyA9IG5leHQucmVzdWx0c1tzdGVwTmFtZV1cbiAgICAgIGNvbnN0IHByZXZSZXN1bHRzID0gcHJldi5yZXN1bHRzW3N0ZXBOYW1lXVxuXG4gICAgICBuZXh0UmVzdWx0c1xuICAgICAgICAuZmlsdGVyKChuKSA9PiAhcHJldlJlc3VsdHMgfHwgIXByZXZSZXN1bHRzLnNvbWUoKHApID0+IHAuaWQgPT09IG4uaWQpKVxuICAgICAgICAuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdyZXN1bHQnLCBzdGVwTmFtZSwgcmVzdWx0KVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICBpZiAoaXNTdGF0dXMobmV4dFN0YXR1cywgQVNTRU1CTFlfQ09NUExFVEVEKVxuICAgICAgICAmJiAhaXNTdGF0dXMocHJldlN0YXR1cywgQVNTRU1CTFlfQ09NUExFVEVEKSkge1xuICAgICAgdGhpcy5lbWl0KCdmaW5pc2hlZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdXBkYXRpbmcgdGhpcyBhc3NlbWJseS5cbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHRydWVcbiAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5zb2NrZXQgPSBudWxsXG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wb2xsSW50ZXJ2YWwpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2xvYWRpdEFzc2VtYmx5XG4iLCIvKipcbiAqIENoZWNrIHRoYXQgQXNzZW1ibHkgcGFyYW1ldGVycyBhcmUgcHJlc2VudCBhbmQgaW5jbHVkZSBhbGwgcmVxdWlyZWQgZmllbGRzLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVBhcmFtcyAocGFyYW1zKSB7XG4gIGlmICghcGFyYW1zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2xvYWRpdDogVGhlIGBwYXJhbXNgIG9wdGlvbiBpcyByZXF1aXJlZC4nKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcmFtcyA9IEpTT04ucGFyc2UocGFyYW1zKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gVGVsbCB0aGUgdXNlciB0aGF0IHRoaXMgaXMgbm90IGFuIFVwcHkgYnVnIVxuICAgICAgZXJyLm1lc3NhZ2UgPSBgVHJhbnNsb2FkaXQ6IFRoZSBcXGBwYXJhbXNcXGAgb3B0aW9uIGlzIGEgbWFsZm9ybWVkIEpTT04gc3RyaW5nOiAke1xuICAgICAgICBlcnIubWVzc2FnZX1gXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhcmFtcy5hdXRoIHx8ICFwYXJhbXMuYXV0aC5rZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zbG9hZGl0OiBUaGUgYHBhcmFtcy5hdXRoLmtleWAgb3B0aW9uIGlzIHJlcXVpcmVkLiAnXG4gICAgICArICdZb3UgY2FuIGZpbmQgeW91ciBUcmFuc2xvYWRpdCBBUEkga2V5IGF0IGh0dHBzOi8vdHJhbnNsb2FkaXQuY29tL2FjY291bnQvYXBpLXNldHRpbmdzLicpXG4gIH1cbn1cblxuLyoqXG4gKiBUdXJuIFRyYW5zbG9hZGl0IHBsdWdpbiBvcHRpb25zIGFuZCBhIGxpc3Qgb2YgZmlsZXMgaW50byBhIGxpc3Qgb2YgQXNzZW1ibHlcbiAqIG9wdGlvbnMuXG4gKi9cbmNsYXNzIEFzc2VtYmx5T3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yIChmaWxlcywgb3B0cykge1xuICAgIHRoaXMuZmlsZXMgPSBmaWxlc1xuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgVXBweS1zcGVjaWZpYyBBc3NlbWJseSBvcHRpb24gZmVhdHVyZXMgdG8gYSBUcmFuc2xvYWRpdC1cbiAgICogY29tcGF0aWJsZSBvYmplY3QuXG4gICAqL1xuICBfbm9ybWFsaXplQXNzZW1ibHlPcHRpb25zIChmaWxlLCBhc3NlbWJseU9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhc3NlbWJseU9wdGlvbnMuZmllbGRzKSkge1xuICAgICAgY29uc3QgZmllbGROYW1lcyA9IGFzc2VtYmx5T3B0aW9ucy5maWVsZHNcbiAgICAgIGFzc2VtYmx5T3B0aW9ucy5maWVsZHMgPSB7fVxuICAgICAgZmllbGROYW1lcy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgYXNzZW1ibHlPcHRpb25zLmZpZWxkc1tmaWVsZE5hbWVdID0gZmlsZS5tZXRhW2ZpZWxkTmFtZV1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCFhc3NlbWJseU9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBhc3NlbWJseU9wdGlvbnMuZmllbGRzID0ge31cbiAgICB9XG5cbiAgICByZXR1cm4gYXNzZW1ibHlPcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogR2V0IEFzc2VtYmx5IG9wdGlvbnMgZm9yIGEgZmlsZS5cbiAgICovXG4gIF9nZXRBc3NlbWJseU9wdGlvbnMgKGZpbGUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRzXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ2V0QXNzZW1ibHlPcHRpb25zKGZpbGUsIG9wdGlvbnMpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKGFzc2VtYmx5T3B0aW9ucykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplQXNzZW1ibHlPcHRpb25zKGZpbGUsIGFzc2VtYmx5T3B0aW9ucylcbiAgICAgIH0pXG4gICAgICAudGhlbigoYXNzZW1ibHlPcHRpb25zKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKGFzc2VtYmx5T3B0aW9ucy5wYXJhbXMpXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaWxlSURzOiBbZmlsZS5pZF0sXG4gICAgICAgICAgb3B0aW9uczogYXNzZW1ibHlPcHRpb25zLFxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgQXNzZW1ibGllcyB3aXRoIHRoZSBzYW1lIG9wdGlvbnMgaW50byBhIHNpbmdsZSBBc3NlbWJseSBmb3IgYWxsIHRoZVxuICAgKiByZWxldmFudCBmaWxlcy5cbiAgICovXG4gIF9kZWR1cGUgKGxpc3QpIHtcbiAgICBjb25zdCBkZWR1cGVNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgbGlzdC5mb3JFYWNoKCh7IGZpbGVJRHMsIG9wdGlvbnMgfSkgPT4ge1xuICAgICAgY29uc3QgaWQgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKVxuICAgICAgaWYgKGRlZHVwZU1hcFtpZF0pIHtcbiAgICAgICAgZGVkdXBlTWFwW2lkXS5maWxlSURzLnB1c2goLi4uZmlsZUlEcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZHVwZU1hcFtpZF0gPSB7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBmaWxlSURzOiBbLi4uZmlsZUlEc10sXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRlZHVwZU1hcCkubWFwKChpZCkgPT4gZGVkdXBlTWFwW2lkXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHNldCBvZiBBc3NlbWJsaWVzIHRoYXQgd2lsbCBoYW5kbGUgdGhlIHVwbG9hZC5cbiAgICogUmV0dXJucyBhIFByb21pc2UgZm9yIGFuIG9iamVjdCB3aXRoIGtleXM6XG4gICAqICAtIGZpbGVJRHMgLSBhbiBhcnJheSBvZiBmaWxlIElEcyB0byBhZGQgdG8gdGhpcyBBc3NlbWJseVxuICAgKiAgLSBvcHRpb25zIC0gQXNzZW1ibHkgb3B0aW9uc1xuICAgKi9cbiAgYnVpbGQgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdHNcblxuICAgIGlmICh0aGlzLmZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgdGhpcy5maWxlcy5tYXAoKGZpbGUpID0+IHRoaXMuX2dldEFzc2VtYmx5T3B0aW9ucyhmaWxlKSlcbiAgICAgICkudGhlbigobGlzdCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVkdXBlKGxpc3QpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsd2F5c1J1bkFzc2VtYmx5KSB7XG4gICAgICAvLyBObyBmaWxlcywganVzdCBnZW5lcmF0ZSBvbmUgQXNzZW1ibHlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIG9wdGlvbnMuZ2V0QXNzZW1ibHlPcHRpb25zKG51bGwsIG9wdGlvbnMpXG4gICAgICApLnRoZW4oKGFzc2VtYmx5T3B0aW9ucykgPT4ge1xuICAgICAgICB2YWxpZGF0ZVBhcmFtcyhhc3NlbWJseU9wdGlvbnMucGFyYW1zKVxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICBmaWxlSURzOiB0aGlzLmZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5pZCksXG4gICAgICAgICAgb3B0aW9uczogYXNzZW1ibHlPcHRpb25zLFxuICAgICAgICB9XVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZmlsZXMgYW5kIHdlIGRvIG5vdCBgYWx3YXlzUnVuQXNzZW1ibHlgLFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nLlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlbWJseU9wdGlvbnNcbm1vZHVsZS5leHBvcnRzLnZhbGlkYXRlUGFyYW1zID0gdmFsaWRhdGVQYXJhbXNcbiIsImNvbnN0IEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpXG5cbi8qKlxuICogVHJhY2sgY29tcGxldGlvbiBvZiBtdWx0aXBsZSBhc3NlbWJsaWVzLlxuICpcbiAqIEVtaXRzICdhc3NlbWJseS1jb21wbGV0ZScgd2hlbiBhbiBhc3NlbWJseSBjb21wbGV0ZXMuXG4gKiBFbWl0cyAnYXNzZW1ibHktZXJyb3InIHdoZW4gYW4gYXNzZW1ibHkgZmFpbHMuXG4gKiBFeHBvc2VzIGEgYC5wcm9taXNlYCBwcm9wZXJ0eSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGFzc2VtYmxpZXMgaGF2ZVxuICogY29tcGxldGVkIChvciBmYWlsZWQpLlxuICovXG5jbGFzcyBUcmFuc2xvYWRpdEFzc2VtYmx5V2F0Y2hlciBleHRlbmRzIEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAodXBweSwgYXNzZW1ibHlJRHMpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl91cHB5ID0gdXBweVxuICAgIHRoaXMuX2Fzc2VtYmx5SURzID0gYXNzZW1ibHlJRHNcbiAgICB0aGlzLl9yZW1haW5pbmcgPSBhc3NlbWJseUlEcy5sZW5ndGhcblxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlXG4gICAgICB0aGlzLl9yZWplY3QgPSByZWplY3RcbiAgICB9KVxuXG4gICAgdGhpcy5fb25Bc3NlbWJseUNvbXBsZXRlID0gdGhpcy5fb25Bc3NlbWJseUNvbXBsZXRlLmJpbmQodGhpcylcbiAgICB0aGlzLl9vbkFzc2VtYmx5Q2FuY2VsID0gdGhpcy5fb25Bc3NlbWJseUNhbmNlbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25Bc3NlbWJseUVycm9yID0gdGhpcy5fb25Bc3NlbWJseUVycm9yLmJpbmQodGhpcylcbiAgICB0aGlzLl9vbkltcG9ydEVycm9yID0gdGhpcy5fb25JbXBvcnRFcnJvci5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9hZGRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFyZSB3ZSB3YXRjaGluZyB0aGlzIGFzc2VtYmx5IElEP1xuICAgKi9cbiAgX3dhdGNoaW5nIChpZCkge1xuICAgIHJldHVybiB0aGlzLl9hc3NlbWJseUlEcy5pbmRleE9mKGlkKSAhPT0gLTFcbiAgfVxuXG4gIF9vbkFzc2VtYmx5Q29tcGxldGUgKGFzc2VtYmx5KSB7XG4gICAgaWYgKCF0aGlzLl93YXRjaGluZyhhc3NlbWJseS5hc3NlbWJseV9pZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3VwcHkubG9nKGBbVHJhbnNsb2FkaXRdIEFzc2VtYmx5V2F0Y2hlcjogR290IEFzc2VtYmx5IGZpbmlzaCAke2Fzc2VtYmx5LmFzc2VtYmx5X2lkfWApXG5cbiAgICB0aGlzLmVtaXQoJ2Fzc2VtYmx5LWNvbXBsZXRlJywgYXNzZW1ibHkuYXNzZW1ibHlfaWQpXG5cbiAgICB0aGlzLl9jaGVja0FsbENvbXBsZXRlKClcbiAgfVxuXG4gIF9vbkFzc2VtYmx5Q2FuY2VsIChhc3NlbWJseSkge1xuICAgIGlmICghdGhpcy5fd2F0Y2hpbmcoYXNzZW1ibHkuYXNzZW1ibHlfaWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jaGVja0FsbENvbXBsZXRlKClcbiAgfVxuXG4gIF9vbkFzc2VtYmx5RXJyb3IgKGFzc2VtYmx5LCBlcnJvcikge1xuICAgIGlmICghdGhpcy5fd2F0Y2hpbmcoYXNzZW1ibHkuYXNzZW1ibHlfaWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl91cHB5LmxvZyhgW1RyYW5zbG9hZGl0XSBBc3NlbWJseVdhdGNoZXI6IEdvdCBBc3NlbWJseSBlcnJvciAke2Fzc2VtYmx5LmFzc2VtYmx5X2lkfWApXG4gICAgdGhpcy5fdXBweS5sb2coZXJyb3IpXG5cbiAgICB0aGlzLmVtaXQoJ2Fzc2VtYmx5LWVycm9yJywgYXNzZW1ibHkuYXNzZW1ibHlfaWQsIGVycm9yKVxuXG4gICAgdGhpcy5fY2hlY2tBbGxDb21wbGV0ZSgpXG4gIH1cblxuICBfb25JbXBvcnRFcnJvciAoYXNzZW1ibHksIGZpbGVJRCwgZXJyb3IpIHtcbiAgICBpZiAoIXRoaXMuX3dhdGNoaW5nKGFzc2VtYmx5LmFzc2VtYmx5X2lkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gTm90IHN1cmUgaWYgd2Ugc2hvdWxkIGJlIGRvaW5nIHNvbWV0aGluZyB3aGVuIGl0J3MganVzdCBvbmUgZmlsZSBmYWlsaW5nLlxuICAgIC8vIEFUTSwgdGhlIG9ubHkgb3B0aW9ucyBhcmUgMSkgaWdub3Jpbmcgb3IgMikgZmFpbGluZyB0aGUgZW50aXJlIHVwbG9hZC5cbiAgICAvLyBJIHRoaW5rIGZhaWxpbmcgdGhlIHVwbG9hZCBpcyBiZXR0ZXIgdGhhbiBzaWxlbnRseSBpZ25vcmluZy5cbiAgICAvLyBJbiB0aGUgZnV0dXJlIHdlIHNob3VsZCBtYXliZSBoYXZlIGEgd2F5IHRvIHJlc29sdmUgdXBsb2FkcyB3aXRoIHNvbWUgZmFpbHVyZXMsXG4gICAgLy8gbGlrZSByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYHsgc3VjY2Vzc2Z1bCwgZmFpbGVkIH1gIHVwbG9hZHMuXG4gICAgdGhpcy5fb25Bc3NlbWJseUVycm9yKGFzc2VtYmx5LCBlcnJvcilcbiAgfVxuXG4gIF9jaGVja0FsbENvbXBsZXRlICgpIHtcbiAgICB0aGlzLl9yZW1haW5pbmcgLT0gMVxuICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgIC8vIFdlJ3JlIGRvbmUsIHRoZXNlIGxpc3RlbmVycyBjYW4gYmUgcmVtb3ZlZFxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKClcbiAgICAgIHRoaXMuX3Jlc29sdmUoKVxuICAgIH1cbiAgfVxuXG4gIF9yZW1vdmVMaXN0ZW5lcnMgKCkge1xuICAgIHRoaXMuX3VwcHkub2ZmKCd0cmFuc2xvYWRpdDpjb21wbGV0ZScsIHRoaXMuX29uQXNzZW1ibHlDb21wbGV0ZSlcbiAgICB0aGlzLl91cHB5Lm9mZigndHJhbnNsb2FkaXQ6YXNzZW1ibHktY2FuY2VsJywgdGhpcy5fb25Bc3NlbWJseUNhbmNlbClcbiAgICB0aGlzLl91cHB5Lm9mZigndHJhbnNsb2FkaXQ6YXNzZW1ibHktZXJyb3InLCB0aGlzLl9vbkFzc2VtYmx5RXJyb3IpXG4gICAgdGhpcy5fdXBweS5vZmYoJ3RyYW5zbG9hZGl0OmltcG9ydC1lcnJvcicsIHRoaXMuX29uSW1wb3J0RXJyb3IpXG4gIH1cblxuICBfYWRkTGlzdGVuZXJzICgpIHtcbiAgICB0aGlzLl91cHB5Lm9uKCd0cmFuc2xvYWRpdDpjb21wbGV0ZScsIHRoaXMuX29uQXNzZW1ibHlDb21wbGV0ZSlcbiAgICB0aGlzLl91cHB5Lm9uKCd0cmFuc2xvYWRpdDphc3NlbWJseS1jYW5jZWwnLCB0aGlzLl9vbkFzc2VtYmx5Q2FuY2VsKVxuICAgIHRoaXMuX3VwcHkub24oJ3RyYW5zbG9hZGl0OmFzc2VtYmx5LWVycm9yJywgdGhpcy5fb25Bc3NlbWJseUVycm9yKVxuICAgIHRoaXMuX3VwcHkub24oJ3RyYW5zbG9hZGl0OmltcG9ydC1lcnJvcicsIHRoaXMuX29uSW1wb3J0RXJyb3IpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2xvYWRpdEFzc2VtYmx5V2F0Y2hlclxuIiwiY29uc3QgZmV0Y2hXaXRoTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZldGNoV2l0aE5ldHdvcmtFcnJvcicpXG5jb25zdCBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuXG4vKipcbiAqIEEgQmFyZWJvbmVzIEhUVFAgQVBJIGNsaWVudCBmb3IgVHJhbnNsb2FkaXQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ2xpZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xuICAgIHRoaXMub3B0cyA9IG9wdHNcblxuICAgIHRoaXMuX3JlcG9ydEVycm9yID0gdGhpcy5fcmVwb3J0RXJyb3IuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faGVhZGVycyA9IHtcbiAgICAgICdUcmFuc2xvYWRpdC1DbGllbnQnOiB0aGlzLm9wdHMuY2xpZW50LFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYXNzZW1ibHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gb3B0aW9ucy5wYXJhbXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuZmllbGRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnNpZ25hdHVyZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5leHBlY3RlZEZpbGVzXG4gICAqL1xuICBjcmVhdGVBc3NlbWJseSAoe1xuICAgIHBhcmFtcyxcbiAgICBmaWVsZHMsXG4gICAgc2lnbmF0dXJlLFxuICAgIGV4cGVjdGVkRmlsZXMsXG4gIH0pIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICBkYXRhLmFwcGVuZCgncGFyYW1zJywgdHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZydcbiAgICAgID8gcGFyYW1zXG4gICAgICA6IEpTT04uc3RyaW5naWZ5KHBhcmFtcykpXG4gICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgZGF0YS5hcHBlbmQoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSlcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhmaWVsZHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgZGF0YS5hcHBlbmQoa2V5LCBmaWVsZHNba2V5XSlcbiAgICB9KVxuICAgIGRhdGEuYXBwZW5kKCdudW1fZXhwZWN0ZWRfdXBsb2FkX2ZpbGVzJywgZXhwZWN0ZWRGaWxlcylcblxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoJy9hc3NlbWJsaWVzJywgYCR7dGhpcy5vcHRzLnNlcnZpY2V9YCkuaHJlZlxuICAgIHJldHVybiBmZXRjaFdpdGhOZXR3b3JrRXJyb3IodXJsLCB7XG4gICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMsXG4gICAgICBib2R5OiBkYXRhLFxuICAgIH0pXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSkudGhlbigoYXNzZW1ibHkpID0+IHtcbiAgICAgICAgaWYgKGFzc2VtYmx5LmVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYXNzZW1ibHkuZXJyb3IpXG4gICAgICAgICAgZXJyb3IuZGV0YWlscyA9IGFzc2VtYmx5Lm1lc3NhZ2VcbiAgICAgICAgICBlcnJvci5hc3NlbWJseSA9IGFzc2VtYmx5XG4gICAgICAgICAgaWYgKGFzc2VtYmx5LmFzc2VtYmx5X2lkKSB7XG4gICAgICAgICAgICBlcnJvci5kZXRhaWxzICs9ICcgJyArIGBBc3NlbWJseSBJRDogJHthc3NlbWJseS5hc3NlbWJseV9pZH1gXG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNzZW1ibHlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5fcmVwb3J0RXJyb3IoZXJyLCB7IHVybCwgdHlwZTogJ0FQSV9FUlJPUicgfSkpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXJ2ZSByZXNvdXJjZXMgZm9yIGEgZmlsZSBpbiBhbiBBc3NlbWJseS4gVGhlbiBhZGRGaWxlIGNhbiBiZSB1c2VkIGxhdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYXNzZW1ibHlcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZVxuICAgKi9cbiAgcmVzZXJ2ZUZpbGUgKGFzc2VtYmx5LCBmaWxlKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGVuY29kZVVSSUNvbXBvbmVudChmaWxlLnNpemUpXG4gICAgY29uc3QgdXJsID0gYCR7YXNzZW1ibHkuYXNzZW1ibHlfc3NsX3VybH0vcmVzZXJ2ZV9maWxlP3NpemU9JHtzaXplfWBcbiAgICByZXR1cm4gZmV0Y2hXaXRoTmV0d29ya0Vycm9yKHVybCwgeyBtZXRob2Q6ICdwb3N0JywgaGVhZGVyczogdGhpcy5faGVhZGVycyB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5fcmVwb3J0RXJyb3IoZXJyLCB7IGFzc2VtYmx5LCBmaWxlLCB1cmwsIHR5cGU6ICdBUElfRVJST1InIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIEltcG9ydCBhIHJlbW90ZSBmaWxlIHRvIGFuIEFzc2VtYmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYXNzZW1ibHlcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZVxuICAgKi9cbiAgYWRkRmlsZSAoYXNzZW1ibHksIGZpbGUpIHtcbiAgICBpZiAoIWZpbGUudXBsb2FkVVJMKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdGaWxlIGRvZXMgbm90IGhhdmUgYW4gYHVwbG9hZFVSTGAuJykpXG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBlbmNvZGVVUklDb21wb25lbnQoZmlsZS5zaXplKVxuICAgIGNvbnN0IHVwbG9hZFVybCA9IGVuY29kZVVSSUNvbXBvbmVudChmaWxlLnVwbG9hZFVSTClcbiAgICBjb25zdCBmaWxlbmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChmaWxlLm5hbWUpXG4gICAgY29uc3QgZmllbGRuYW1lID0gJ2ZpbGUnXG5cbiAgICBjb25zdCBxcyA9IGBzaXplPSR7c2l6ZX0mZmlsZW5hbWU9JHtmaWxlbmFtZX0mZmllbGRuYW1lPSR7ZmllbGRuYW1lfSZzM1VybD0ke3VwbG9hZFVybH1gXG4gICAgY29uc3QgdXJsID0gYCR7YXNzZW1ibHkuYXNzZW1ibHlfc3NsX3VybH0vYWRkX2ZpbGU/JHtxc31gXG4gICAgcmV0dXJuIGZldGNoV2l0aE5ldHdvcmtFcnJvcih1cmwsIHsgbWV0aG9kOiAncG9zdCcsIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLmNhdGNoKChlcnIpID0+IHRoaXMuX3JlcG9ydEVycm9yKGVyciwgeyBhc3NlbWJseSwgZmlsZSwgdXJsLCB0eXBlOiAnQVBJX0VSUk9SJyB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYSBydW5uaW5nIEFzc2VtYmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYXNzZW1ibHlcbiAgICovXG4gIGNhbmNlbEFzc2VtYmx5IChhc3NlbWJseSkge1xuICAgIGNvbnN0IHVybCA9IGFzc2VtYmx5LmFzc2VtYmx5X3NzbF91cmxcbiAgICByZXR1cm4gZmV0Y2hXaXRoTmV0d29ya0Vycm9yKHVybCwgeyBtZXRob2Q6ICdkZWxldGUnLCBoZWFkZXJzOiB0aGlzLl9oZWFkZXJzIH0pXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB0aGlzLl9yZXBvcnRFcnJvcihlcnIsIHsgdXJsLCB0eXBlOiAnQVBJX0VSUk9SJyB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdHVzIGZvciBhbiBhc3NlbWJseS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgc3RhdHVzIGVuZHBvaW50IG9mIHRoZSBhc3NlbWJseS5cbiAgICovXG4gIGdldEFzc2VtYmx5U3RhdHVzICh1cmwpIHtcbiAgICByZXR1cm4gZmV0Y2hXaXRoTmV0d29ya0Vycm9yKHVybCwgeyBoZWFkZXJzOiB0aGlzLl9oZWFkZXJzIH0pXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB0aGlzLl9yZXBvcnRFcnJvcihlcnIsIHsgdXJsLCB0eXBlOiAnU1RBVFVTX0VSUk9SJyB9KSlcbiAgfVxuXG4gIHN1Ym1pdEVycm9yIChlcnIsIHsgZW5kcG9pbnQsIGluc3RhbmNlLCBhc3NlbWJseSB9KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVyci5kZXRhaWxzXG4gICAgICA/IGAke2Vyci5tZXNzYWdlfSAoJHtlcnIuZGV0YWlsc30pYFxuICAgICAgOiBlcnIubWVzc2FnZVxuXG4gICAgcmV0dXJuIGZldGNoV2l0aE5ldHdvcmtFcnJvcignaHR0cHM6Ly90cmFuc2xvYWRpdHN0YXR1cy5jb20vY2xpZW50X2Vycm9yJywge1xuICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGVuZHBvaW50LFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgYXNzZW1ibHlfaWQ6IGFzc2VtYmx5LFxuICAgICAgICBhZ2VudDogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJycsXG4gICAgICAgIGNsaWVudDogdGhpcy5vcHRzLmNsaWVudCxcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2UsXG4gICAgICB9KSxcbiAgICB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gIH1cblxuICBfcmVwb3J0RXJyb3IgKGVyciwgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMub3B0cy5lcnJvclJlcG9ydGluZyA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICB0eXBlOiBwYXJhbXMudHlwZSxcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5hc3NlbWJseSkge1xuICAgICAgb3B0cy5hc3NlbWJseSA9IHBhcmFtcy5hc3NlbWJseS5hc3NlbWJseV9pZFxuICAgICAgb3B0cy5pbnN0YW5jZSA9IHBhcmFtcy5hc3NlbWJseS5pbnN0YW5jZVxuICAgIH1cbiAgICBpZiAocGFyYW1zLnVybCkge1xuICAgICAgb3B0cy5lbmRwb2ludCA9IHBhcmFtcy51cmxcbiAgICB9XG5cbiAgICB0aGlzLnN1Ym1pdEVycm9yKGVyciwgb3B0cykuY2F0Y2goKF8pID0+IHtcbiAgICAgIC8vIG5vdCBtdWNoIHdlIGNhbiBkbyB0aGVuIGlzIHRoZXJlXG4gICAgfSlcblxuICAgIHRocm93IGVyclxuICB9XG59XG4iLCJjb25zdCBUcmFuc2xhdG9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL1RyYW5zbGF0b3InKVxuY29uc3QgaGFzUHJvcGVydHkgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaGFzUHJvcGVydHknKVxuY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgVHVzID0gcmVxdWlyZSgnQHVwcHkvdHVzJylcbmNvbnN0IEFzc2VtYmx5ID0gcmVxdWlyZSgnLi9Bc3NlbWJseScpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL0NsaWVudCcpXG5jb25zdCBBc3NlbWJseU9wdGlvbnMgPSByZXF1aXJlKCcuL0Fzc2VtYmx5T3B0aW9ucycpXG5jb25zdCBBc3NlbWJseVdhdGNoZXIgPSByZXF1aXJlKCcuL0Fzc2VtYmx5V2F0Y2hlcicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRBc3NlbWJseU9wdGlvbnMgKGZpbGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxuICAgIHNpZ25hdHVyZTogb3B0aW9ucy5zaWduYXR1cmUsXG4gICAgZmllbGRzOiBvcHRpb25zLmZpZWxkcyxcbiAgfVxufVxuXG5jb25zdCBDT01QQU5JT04gPSAnaHR0cHM6Ly9hcGkyLnRyYW5zbG9hZGl0LmNvbS9jb21wYW5pb24nXG4vLyBSZWdleCBtYXRjaGluZyBhY2NlcHRhYmxlIHBvc3RNZXNzYWdlKCkgb3JpZ2lucyBmb3IgYXV0aGVudGljYXRpb24gZmVlZGJhY2sgZnJvbSBjb21wYW5pb24uXG5jb25zdCBBTExPV0VEX0NPTVBBTklPTl9QQVRURVJOID0gL1xcLnRyYW5zbG9hZGl0XFwuY29tJC9cbi8vIFJlZ2V4IHVzZWQgdG8gY2hlY2sgaWYgYSBDb21wYW5pb24gYWRkcmVzcyBpcyBydW4gYnkgVHJhbnNsb2FkaXQuXG5jb25zdCBUTF9DT01QQU5JT04gPSAvaHR0cHM/OlxcL1xcL2FwaTIoPzotXFx3Kyk/XFwudHJhbnNsb2FkaXRcXC5jb21cXC9jb21wYW5pb24vXG5jb25zdCBUTF9VUFBZX1NFUlZFUiA9IC9odHRwcz86XFwvXFwvYXBpMig/Oi1cXHcrKT9cXC50cmFuc2xvYWRpdFxcLmNvbVxcL3VwcHktc2VydmVyL1xuXG4vKipcbiAqIFVwbG9hZCBmaWxlcyB0byBUcmFuc2xvYWRpdCB1c2luZyBUdXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVHJhbnNsb2FkaXQgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ3VwbG9hZGVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1RyYW5zbG9hZGl0J1xuICAgIHRoaXMudGl0bGUgPSAnVHJhbnNsb2FkaXQnXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7XG4gICAgICAgIGNyZWF0aW5nQXNzZW1ibHk6ICdQcmVwYXJpbmcgdXBsb2FkLi4uJyxcbiAgICAgICAgY3JlYXRpbmdBc3NlbWJseUZhaWxlZDogJ1RyYW5zbG9hZGl0OiBDb3VsZCBub3QgY3JlYXRlIEFzc2VtYmx5JyxcbiAgICAgICAgZW5jb2Rpbmc6ICdFbmNvZGluZy4uLicsXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgc2VydmljZTogJ2h0dHBzOi8vYXBpMi50cmFuc2xvYWRpdC5jb20nLFxuICAgICAgZXJyb3JSZXBvcnRpbmc6IHRydWUsXG4gICAgICB3YWl0Rm9yRW5jb2Rpbmc6IGZhbHNlLFxuICAgICAgd2FpdEZvck1ldGFkYXRhOiBmYWxzZSxcbiAgICAgIGFsd2F5c1J1bkFzc2VtYmx5OiBmYWxzZSxcbiAgICAgIGltcG9ydEZyb21VcGxvYWRVUkxzOiBmYWxzZSxcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHBhcmFtczogbnVsbCxcbiAgICAgIGZpZWxkczoge30sXG4gICAgICBnZXRBc3NlbWJseU9wdGlvbnM6IGRlZmF1bHRHZXRBc3NlbWJseU9wdGlvbnMsXG4gICAgICBsaW1pdDogMCxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgdGhpcy5fcHJlcGFyZVVwbG9hZCA9IHRoaXMuX3ByZXBhcmVVcGxvYWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2FmdGVyVXBsb2FkID0gdGhpcy5fYWZ0ZXJVcGxvYWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX29uRXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcylcbiAgICB0aGlzLl9vblR1c0Vycm9yID0gdGhpcy5fb25UdXNFcnJvci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25DYW5jZWxBbGwgPSB0aGlzLl9vbkNhbmNlbEFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25GaWxlVXBsb2FkVVJMQXZhaWxhYmxlID0gdGhpcy5fb25GaWxlVXBsb2FkVVJMQXZhaWxhYmxlLmJpbmQodGhpcylcbiAgICB0aGlzLl9vblJlc3RvcmVkID0gdGhpcy5fb25SZXN0b3JlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZ2V0UGVyc2lzdGVudERhdGEgPSB0aGlzLl9nZXRQZXJzaXN0ZW50RGF0YS5iaW5kKHRoaXMpXG5cbiAgICBjb25zdCBoYXNDdXN0b21Bc3NlbWJseU9wdGlvbnMgPSB0aGlzLm9wdHMuZ2V0QXNzZW1ibHlPcHRpb25zICE9PSBkZWZhdWx0T3B0aW9ucy5nZXRBc3NlbWJseU9wdGlvbnNcbiAgICBpZiAodGhpcy5vcHRzLnBhcmFtcykge1xuICAgICAgQXNzZW1ibHlPcHRpb25zLnZhbGlkYXRlUGFyYW1zKHRoaXMub3B0cy5wYXJhbXMpXG4gICAgfSBlbHNlIGlmICghaGFzQ3VzdG9tQXNzZW1ibHlPcHRpb25zKSB7XG4gICAgICAvLyBUaHJvdyB0aGUgc2FtZSBlcnJvciB0aGF0IHdlJ2QgdGhyb3cgaWYgdGhlIGBwYXJhbXNgIHJldHVybmVkIGZyb20gYVxuICAgICAgLy8gYGdldEFzc2VtYmx5T3B0aW9ucygpYCBmdW5jdGlvbiBpcyBudWxsLlxuICAgICAgQXNzZW1ibHlPcHRpb25zLnZhbGlkYXRlUGFyYW1zKG51bGwpXG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnQgPSBuZXcgQ2xpZW50KHtcbiAgICAgIHNlcnZpY2U6IHRoaXMub3B0cy5zZXJ2aWNlLFxuICAgICAgY2xpZW50OiB0aGlzLl9nZXRDbGllbnRWZXJzaW9uKCksXG4gICAgICBlcnJvclJlcG9ydGluZzogdGhpcy5vcHRzLmVycm9yUmVwb3J0aW5nLFxuICAgIH0pXG4gICAgLy8gQ29udGFpbnMgQXNzZW1ibHkgaW5zdGFuY2VzIGZvciBpbi1wcm9ncmVzcyBBc3NlbWJsaWVzLlxuICAgIHRoaXMuYWN0aXZlQXNzZW1ibGllcyA9IHt9XG4gICAgLy8gQ29udGFpbnMgYSBtYXBwaW5nIG9mIHVwbG9hZElEIHRvIEFzc2VtYmx5V2F0Y2hlclxuICAgIHRoaXMuYXNzZW1ibHlXYXRjaGVycyA9IHt9XG4gICAgLy8gQ29udGFpbnMgYSBmaWxlIElEcyB0aGF0IGhhdmUgY29tcGxldGVkIHBvc3Rwcm9jZXNzaW5nIGJlZm9yZSB0aGUgdXBsb2FkIHRoZXkgYmVsb25nIHRvIGhhcyBlbnRlcmVkIHRoZSBwb3N0cHJvY2VzcyBzdGFnZS5cbiAgICB0aGlzLmNvbXBsZXRlZEZpbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB9XG5cbiAgc2V0T3B0aW9ucyAobmV3T3B0cykge1xuICAgIHN1cGVyLnNldE9wdGlvbnMobmV3T3B0cylcbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgfVxuXG4gIGkxOG5Jbml0ICgpIHtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihbdGhpcy5kZWZhdWx0TG9jYWxlLCB0aGlzLnVwcHkubG9jYWxlLCB0aGlzLm9wdHMubG9jYWxlXSlcbiAgICB0aGlzLmkxOG4gPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlLmJpbmQodGhpcy50cmFuc2xhdG9yKVxuICAgIHRoaXMuaTE4bkFycmF5ID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZUFycmF5LmJpbmQodGhpcy50cmFuc2xhdG9yKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoKSAvLyBzbyB0aGF0IFVJIHJlLXJlbmRlcnMgYW5kIHdlIHNlZSB0aGUgdXBkYXRlZCBsb2NhbGVcbiAgfVxuXG4gIF9nZXRDbGllbnRWZXJzaW9uICgpIHtcbiAgICBjb25zdCBsaXN0ID0gW1xuICAgICAgYHVwcHktY29yZToke3RoaXMudXBweS5jb25zdHJ1Y3Rvci5WRVJTSU9OfWAsXG4gICAgICBgdXBweS10cmFuc2xvYWRpdDoke3RoaXMuY29uc3RydWN0b3IuVkVSU0lPTn1gLFxuICAgICAgYHVwcHktdHVzOiR7VHVzLlZFUlNJT059YCxcbiAgICBdXG5cbiAgICBjb25zdCBhZGRQbHVnaW5WZXJzaW9uID0gKHBsdWdpbk5hbWUsIHZlcnNpb25OYW1lKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHBsdWdpbk5hbWUpXG4gICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgIGxpc3QucHVzaChgJHt2ZXJzaW9uTmFtZX06JHtwbHVnaW4uY29uc3RydWN0b3IuVkVSU0lPTn1gKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMuaW1wb3J0RnJvbVVwbG9hZFVSTHMpIHtcbiAgICAgIGFkZFBsdWdpblZlcnNpb24oJ1hIUlVwbG9hZCcsICd1cHB5LXhoci11cGxvYWQnKVxuICAgICAgYWRkUGx1Z2luVmVyc2lvbignQXdzUzMnLCAndXBweS1hd3MtczMnKVxuICAgICAgYWRkUGx1Z2luVmVyc2lvbignQXdzUzNNdWx0aXBhcnQnLCAndXBweS1hd3MtczMtbXVsdGlwYXJ0JylcbiAgICB9XG5cbiAgICBhZGRQbHVnaW5WZXJzaW9uKCdEcm9wYm94JywgJ3VwcHktZHJvcGJveCcpXG4gICAgYWRkUGx1Z2luVmVyc2lvbignQm94JywgJ3VwcHktYm94JylcbiAgICBhZGRQbHVnaW5WZXJzaW9uKCdGYWNlYm9vaycsICd1cHB5LWZhY2Vib29rJylcbiAgICBhZGRQbHVnaW5WZXJzaW9uKCdHb29nbGVEcml2ZScsICd1cHB5LWdvb2dsZS1kcml2ZScpXG4gICAgYWRkUGx1Z2luVmVyc2lvbignSW5zdGFncmFtJywgJ3VwcHktaW5zdGFncmFtJylcbiAgICBhZGRQbHVnaW5WZXJzaW9uKCdPbmVEcml2ZScsICd1cHB5LW9uZWRyaXZlJylcbiAgICBhZGRQbHVnaW5WZXJzaW9uKCdab29tJywgJ3VwcHktem9vbScpXG4gICAgYWRkUGx1Z2luVmVyc2lvbignVXJsJywgJ3VwcHktdXJsJylcblxuICAgIHJldHVybiBsaXN0LmpvaW4oJywnKVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBtZXRhZGF0YSB0byBmaWxlcyB0byBjb25maWd1cmUgdGhlIFR1cyBwbHVnaW4gdG8gdXBsb2FkIHRvIFRyYW5zbG9hZGl0LlxuICAgKiBBbHNvIHVzZSBUcmFuc2xvYWRpdCdzIENvbXBhbmlvblxuICAgKlxuICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90dXMvdHVzZC93aWtpL1VwbG9hZGluZy10by1UcmFuc2xvYWRpdC11c2luZy10dXMjdXBsb2FkaW5nLXVzaW5nLXR1c1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZmlsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdHVzXG4gICAqL1xuICBfYXR0YWNoQXNzZW1ibHlNZXRhZGF0YSAoZmlsZSwgc3RhdHVzKSB7XG4gICAgLy8gQWRkIHRoZSBtZXRhZGF0YSBwYXJhbWV0ZXJzIFRyYW5zbG9hZGl0IG5lZWRzLlxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAuLi5maWxlLm1ldGEsXG4gICAgICBhc3NlbWJseV91cmw6IHN0YXR1cy5hc3NlbWJseV91cmwsXG4gICAgICBmaWxlbmFtZTogZmlsZS5uYW1lLFxuICAgICAgZmllbGRuYW1lOiAnZmlsZScsXG4gICAgfVxuICAgIC8vIEFkZCBBc3NlbWJseS1zcGVjaWZpYyBUdXMgZW5kcG9pbnQuXG4gICAgY29uc3QgdHVzID0ge1xuICAgICAgLi4uZmlsZS50dXMsXG4gICAgICBlbmRwb2ludDogc3RhdHVzLnR1c191cmwsXG4gICAgICAvLyBJbmNsdWRlIFgtUmVxdWVzdC1JRCBoZWFkZXJzIGZvciBiZXR0ZXIgZGVidWdnaW5nLlxuICAgICAgYWRkUmVxdWVzdElkOiB0cnVlLFxuICAgIH1cblxuICAgIC8vIFNldCBDb21wYW5pb24gbG9jYXRpb24uIFdlIG9ubHkgYWRkIHRoaXMsIGlmICdmaWxlJyBoYXMgdGhlIGF0dHJpYnV0ZVxuICAgIC8vIHJlbW90ZSwgYmVjYXVzZSB0aGlzIGlzIHRoZSBjcml0ZXJpYSB0byBpZGVudGlmeSByZW1vdGUgZmlsZXMuXG4gICAgLy8gV2Ugb25seSByZXBsYWNlIHRoZSBob3N0bmFtZSBmb3IgVHJhbnNsb2FkaXQncyBjb21wYW5pb25zLCBzbyB0aGF0XG4gICAgLy8gcGVvcGxlIGNhbiBhbHNvIHNlbGYtaG9zdCB0aGVtIHdoaWxlIHN0aWxsIHVzaW5nIFRyYW5zbG9hZGl0IGZvciBlbmNvZGluZy5cbiAgICBsZXQgcmVtb3RlID0gZmlsZS5yZW1vdGVcbiAgICBpZiAoZmlsZS5yZW1vdGUgJiYgVExfVVBQWV9TRVJWRVIudGVzdChmaWxlLnJlbW90ZS5jb21wYW5pb25VcmwpKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgaHR0cHM6Ly9hcGkyLnRyYW5zbG9hZGl0LmNvbS91cHB5LXNlcnZlciBlbmRwb2ludCB3YXMgcmVuYW1lZCB0byAnXG4gICAgICAgICsgJ2h0dHBzOi8vYXBpMi50cmFuc2xvYWRpdC5jb20vY29tcGFuaW9uLCBwbGVhc2UgdXBkYXRlIHlvdXIgYGNvbXBhbmlvblVybGAgJ1xuICAgICAgICArICdvcHRpb25zIGFjY29yZGluZ2x5LidcbiAgICAgIClcbiAgICAgIC8vIEV4cGxpY2l0bHkgbG9nIHRoaXMgZXJyb3IgaGVyZSBiZWNhdXNlIGl0IGlzIGNhdWdodCBieSB0aGUgYGNyZWF0ZUFzc2VtYmx5YFxuICAgICAgLy8gUHJvbWlzZSBmdXJ0aGVyIGFsb25nLlxuICAgICAgLy8gVGhhdCdzIGZpbmUsIGJ1dCBjcmVhdGVBc3NlbWJseSBvbmx5IHNob3dzIHRoZSBpbmZvcm1lciwgd2UgbmVlZCBzb21ldGhpbmcgYVxuICAgICAgLy8gbGl0dGxlIG1vcmUgbm9pc3kuXG4gICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmIChmaWxlLnJlbW90ZSAmJiBUTF9DT01QQU5JT04udGVzdChmaWxlLnJlbW90ZS5jb21wYW5pb25VcmwpKSB7XG4gICAgICBjb25zdCBuZXdIb3N0ID0gc3RhdHVzLmNvbXBhbmlvbl91cmxcbiAgICAgICAgLnJlcGxhY2UoL1xcLyQvLCAnJylcbiAgICAgIGNvbnN0IHBhdGggPSBmaWxlLnJlbW90ZS51cmxcbiAgICAgICAgLnJlcGxhY2UoZmlsZS5yZW1vdGUuY29tcGFuaW9uVXJsLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL15cXC8vLCAnJylcblxuICAgICAgcmVtb3RlID0ge1xuICAgICAgICAuLi5maWxlLnJlbW90ZSxcbiAgICAgICAgY29tcGFuaW9uVXJsOiBuZXdIb3N0LFxuICAgICAgICB1cmw6IGAke25ld0hvc3R9LyR7cGF0aH1gLFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSBBc3NlbWJseSBJRCB0aGlzIGZpbGUgaXMgaW4gb24gdGhlIGZpbGUgdW5kZXIgdGhlIGB0cmFuc2xvYWRpdGAga2V5LlxuICAgIGNvbnN0IG5ld0ZpbGUgPSB7XG4gICAgICAuLi5maWxlLFxuICAgICAgdHJhbnNsb2FkaXQ6IHtcbiAgICAgICAgYXNzZW1ibHk6IHN0YXR1cy5hc3NlbWJseV9pZCxcbiAgICAgIH0sXG4gICAgfVxuICAgIC8vIE9ubHkgY29uZmlndXJlIHRoZSBUdXMgcGx1Z2luIGlmIHdlIGFyZSB1cGxvYWRpbmcgc3RyYWlnaHQgdG8gVHJhbnNsb2FkaXQgKHRoZSBkZWZhdWx0KS5cbiAgICBpZiAoIXRoaXMub3B0cy5pbXBvcnRGcm9tVXBsb2FkVVJMcykge1xuICAgICAgT2JqZWN0LmFzc2lnbihuZXdGaWxlLCB7IG1ldGEsIHR1cywgcmVtb3RlIH0pXG4gICAgfVxuICAgIHJldHVybiBuZXdGaWxlXG4gIH1cblxuICBfY3JlYXRlQXNzZW1ibHkgKGZpbGVJRHMsIHVwbG9hZElELCBvcHRpb25zKSB7XG4gICAgdGhpcy51cHB5LmxvZygnW1RyYW5zbG9hZGl0XSBDcmVhdGUgQXNzZW1ibHknKVxuXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmNyZWF0ZUFzc2VtYmx5KHtcbiAgICAgIHBhcmFtczogb3B0aW9ucy5wYXJhbXMsXG4gICAgICBmaWVsZHM6IG9wdGlvbnMuZmllbGRzLFxuICAgICAgZXhwZWN0ZWRGaWxlczogZmlsZUlEcy5sZW5ndGgsXG4gICAgICBzaWduYXR1cmU6IG9wdGlvbnMuc2lnbmF0dXJlLFxuICAgIH0pLnRoZW4oKG5ld0Fzc2VtYmx5KSA9PiB7XG4gICAgICBjb25zdCBhc3NlbWJseSA9IG5ldyBBc3NlbWJseShuZXdBc3NlbWJseSlcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGFzc2VtYmx5LnN0YXR1c1xuICAgICAgY29uc3QgYXNzZW1ibHlJRCA9IHN0YXR1cy5hc3NlbWJseV9pZFxuXG4gICAgICBjb25zdCB7IGFzc2VtYmxpZXMsIHVwbG9hZHNBc3NlbWJsaWVzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAvLyBTdG9yZSB0aGUgQXNzZW1ibHkgc3RhdHVzLlxuICAgICAgICBhc3NlbWJsaWVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGllcyxcbiAgICAgICAgICBbYXNzZW1ibHlJRF06IHN0YXR1cyxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3RvcmUgdGhlIGxpc3Qgb2YgQXNzZW1ibGllcyByZWxhdGVkIHRvIHRoaXMgdXBsb2FkLlxuICAgICAgICB1cGxvYWRzQXNzZW1ibGllczoge1xuICAgICAgICAgIC4uLnVwbG9hZHNBc3NlbWJsaWVzLFxuICAgICAgICAgIFt1cGxvYWRJRF06IFtcbiAgICAgICAgICAgIC4uLnVwbG9hZHNBc3NlbWJsaWVzW3VwbG9hZElEXSxcbiAgICAgICAgICAgIGFzc2VtYmx5SUQsXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHsgZmlsZXMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7fVxuICAgICAgZmlsZUlEcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICB1cGRhdGVkRmlsZXNbaWRdID0gdGhpcy5fYXR0YWNoQXNzZW1ibHlNZXRhZGF0YSh0aGlzLnVwcHkuZ2V0RmlsZShpZCksIHN0YXR1cylcbiAgICAgIH0pXG4gICAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgICBmaWxlczoge1xuICAgICAgICAgIC4uLmZpbGVzLFxuICAgICAgICAgIC4uLnVwZGF0ZWRGaWxlcyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMudXBweS5lbWl0KCd0cmFuc2xvYWRpdDphc3NlbWJseS1jcmVhdGVkJywgc3RhdHVzLCBmaWxlSURzKVxuXG4gICAgICB0aGlzLnVwcHkubG9nKGBbVHJhbnNsb2FkaXRdIENyZWF0ZWQgQXNzZW1ibHkgJHthc3NlbWJseUlEfWApXG4gICAgICByZXR1cm4gYXNzZW1ibHlcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBlcnIubWVzc2FnZSA9IGAke3RoaXMuaTE4bignY3JlYXRpbmdBc3NlbWJseUZhaWxlZCcpfTogJHtlcnIubWVzc2FnZX1gXG4gICAgICAvLyBSZWplY3QgdGhlIHByb21pc2UuXG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG5cbiAgX2NyZWF0ZUFzc2VtYmx5V2F0Y2hlciAoYXNzZW1ibHlJRCwgZmlsZUlEcywgdXBsb2FkSUQpIHtcbiAgLy8gQXNzZW1ibHlXYXRjaGVyIHRyYWNrcyBjb21wbGV0aW9uIHN0YXRlcyBvZiBhbGwgQXNzZW1ibGllcyBpbiB0aGlzIHVwbG9hZC5cbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IEFzc2VtYmx5V2F0Y2hlcih0aGlzLnVwcHksIGFzc2VtYmx5SUQpXG5cbiAgICB3YXRjaGVyLm9uKCdhc3NlbWJseS1jb21wbGV0ZScsIChpZCkgPT4ge1xuICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLmdldEFzc2VtYmx5RmlsZXMoaWQpXG4gICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIHRoaXMuY29tcGxldGVkRmlsZXNbZmlsZS5pZF0gPSB0cnVlXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCdwb3N0cHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB3YXRjaGVyLm9uKCdhc3NlbWJseS1lcnJvcicsIChpZCwgZXJyb3IpID0+IHtcbiAgICAvLyBDbGVhciBwb3N0cHJvY2Vzc2luZyBzdGF0ZSBmb3IgYWxsIG91ciBmaWxlcy5cbiAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRBc3NlbWJseUZpbGVzKGlkKVxuICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgLy8gVE9ETyBNYXliZSBtYWtlIGEgcG9zdHByb2Nlc3MtZXJyb3IgZXZlbnQgaGVyZT9cbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycm9yKVxuXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCdwb3N0cHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLmFzc2VtYmx5V2F0Y2hlcnNbdXBsb2FkSURdID0gd2F0Y2hlclxuICB9XG5cbiAgX3Nob3VsZFdhaXRBZnRlclVwbG9hZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cy53YWl0Rm9yRW5jb2RpbmcgfHwgdGhpcy5vcHRzLndhaXRGb3JNZXRhZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgd2hlbiBgaW1wb3J0RnJvbVVwbG9hZFVSTHNgIGlzIGVuYWJsZWQ6IHJlc2VydmVzIGFsbCBmaWxlcyBpblxuICAgKiB0aGUgQXNzZW1ibHkuXG4gICAqL1xuICBfcmVzZXJ2ZUZpbGVzIChhc3NlbWJseSwgZmlsZUlEcykge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlSURzLm1hcCgoZmlsZUlEKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc2VydmVGaWxlKGFzc2VtYmx5LnN0YXR1cywgZmlsZSlcbiAgICB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHdoZW4gYGltcG9ydEZyb21VcGxvYWRVUkxzYCBpcyBlbmFibGVkOiBhZGRzIGZpbGVzIHRvIHRoZSBBc3NlbWJseVxuICAgKiBvbmNlIHRoZXkgaGF2ZSBiZWVuIGZ1bGx5IHVwbG9hZGVkLlxuICAgKi9cbiAgX29uRmlsZVVwbG9hZFVSTEF2YWlsYWJsZSAocmF3RmlsZSkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShyYXdGaWxlLmlkKVxuICAgIGlmICghZmlsZSB8fCAhZmlsZS50cmFuc2xvYWRpdCB8fCAhZmlsZS50cmFuc2xvYWRpdC5hc3NlbWJseSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBhc3NlbWJsaWVzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBhc3NlbWJseSA9IGFzc2VtYmxpZXNbZmlsZS50cmFuc2xvYWRpdC5hc3NlbWJseV1cblxuICAgIHRoaXMuY2xpZW50LmFkZEZpbGUoYXNzZW1ibHksIGZpbGUpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgdGhpcy51cHB5LmVtaXQoJ3RyYW5zbG9hZGl0OmltcG9ydC1lcnJvcicsIGFzc2VtYmx5LCBmaWxlLmlkLCBlcnIpXG4gICAgfSlcbiAgfVxuXG4gIF9maW5kRmlsZSAodXBsb2FkZWRGaWxlKSB7XG4gICAgY29uc3QgZmlsZXMgPSB0aGlzLnVwcHkuZ2V0RmlsZXMoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpbGUgPSBmaWxlc1tpXVxuICAgICAgLy8gQ29tcGxldGVkIGZpbGUgdXBsb2FkLlxuICAgICAgaWYgKGZpbGUudXBsb2FkVVJMID09PSB1cGxvYWRlZEZpbGUudHVzX3VwbG9hZF91cmwpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVcbiAgICAgIH1cbiAgICAgIC8vIEluLXByb2dyZXNzIGZpbGUgdXBsb2FkLlxuICAgICAgaWYgKGZpbGUudHVzICYmIGZpbGUudHVzLnVwbG9hZFVybCA9PT0gdXBsb2FkZWRGaWxlLnR1c191cGxvYWRfdXJsKSB7XG4gICAgICAgIHJldHVybiBmaWxlXG4gICAgICB9XG4gICAgICBpZiAoIXVwbG9hZGVkRmlsZS5pc190dXNfZmlsZSkge1xuICAgICAgICAvLyBGaW5nZXJzLWNyb3NzZWQgY2hlY2sgZm9yIG5vbi10dXMgdXBsb2FkcywgZWcgaW1wb3J0ZWQgZnJvbSBTMy5cbiAgICAgICAgaWYgKGZpbGUubmFtZSA9PT0gdXBsb2FkZWRGaWxlLm5hbWUgJiYgZmlsZS5zaXplID09PSB1cGxvYWRlZEZpbGUuc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBmaWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfb25GaWxlVXBsb2FkQ29tcGxldGUgKGFzc2VtYmx5SWQsIHVwbG9hZGVkRmlsZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgZmlsZSA9IHRoaXMuX2ZpbmRGaWxlKHVwbG9hZGVkRmlsZSlcbiAgICBpZiAoIWZpbGUpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tUcmFuc2xvYWRpdF0gQ291bGRu4oCZdCBmaWxlIHRoZSBmaWxlLCBpdCB3YXMgbGlrZWx5IHJlbW92ZWQgaW4gdGhlIHByb2Nlc3MnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgZmlsZXM6IHtcbiAgICAgICAgLi4uc3RhdGUuZmlsZXMsXG4gICAgICAgIFt1cGxvYWRlZEZpbGUuaWRdOiB7XG4gICAgICAgICAgYXNzZW1ibHk6IGFzc2VtYmx5SWQsXG4gICAgICAgICAgaWQ6IGZpbGUuaWQsXG4gICAgICAgICAgdXBsb2FkZWRGaWxlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KVxuICAgIHRoaXMudXBweS5lbWl0KCd0cmFuc2xvYWRpdDp1cGxvYWQnLCB1cGxvYWRlZEZpbGUsIHRoaXMuZ2V0QXNzZW1ibHkoYXNzZW1ibHlJZCkpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgd2hlbiBhIG5ldyBBc3NlbWJseSByZXN1bHQgY29tZXMgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NlbWJseUlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGVwTmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVzdWx0XG4gICAqL1xuICBfb25SZXN1bHQgKGFzc2VtYmx5SWQsIHN0ZXBOYW1lLCByZXN1bHQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGZpbGUgPSBzdGF0ZS5maWxlc1tyZXN1bHQub3JpZ2luYWxfaWRdXG4gICAgLy8gVGhlIGBmaWxlYCBtYXkgbm90IGV4aXN0IGlmIGFuIGltcG9ydCByb2JvdCB3YXMgdXNlZCBpbnN0ZWFkIG9mIGEgZmlsZSB1cGxvYWQuXG4gICAgcmVzdWx0LmxvY2FsSWQgPSBmaWxlID8gZmlsZS5pZCA6IG51bGxcblxuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3RlcE5hbWUsXG4gICAgICBpZDogcmVzdWx0LmlkLFxuICAgICAgYXNzZW1ibHk6IGFzc2VtYmx5SWQsXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICByZXN1bHRzOiBbLi4uc3RhdGUucmVzdWx0cywgZW50cnldLFxuICAgIH0pXG4gICAgdGhpcy51cHB5LmVtaXQoJ3RyYW5zbG9hZGl0OnJlc3VsdCcsIHN0ZXBOYW1lLCByZXN1bHQsIHRoaXMuZ2V0QXNzZW1ibHkoYXNzZW1ibHlJZCkpXG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhbiBBc3NlbWJseSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZywgZ2V0IHRoZSBmaW5hbCBzdGF0ZVxuICAgKiBhbmQgZW1pdCBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXR1c1xuICAgKi9cbiAgX29uQXNzZW1ibHlGaW5pc2hlZCAoc3RhdHVzKSB7XG4gICAgY29uc3QgdXJsID0gc3RhdHVzLmFzc2VtYmx5X3NzbF91cmxcbiAgICB0aGlzLmNsaWVudC5nZXRBc3NlbWJseVN0YXR1cyh1cmwpLnRoZW4oKGZpbmFsU3RhdHVzKSA9PiB7XG4gICAgICBjb25zdCBhc3NlbWJseUlkID0gZmluYWxTdGF0dXMuYXNzZW1ibHlfaWRcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgYXNzZW1ibGllczoge1xuICAgICAgICAgIC4uLnN0YXRlLmFzc2VtYmxpZXMsXG4gICAgICAgICAgW2Fzc2VtYmx5SWRdOiBmaW5hbFN0YXR1cyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICB0aGlzLnVwcHkuZW1pdCgndHJhbnNsb2FkaXQ6Y29tcGxldGUnLCBmaW5hbFN0YXR1cylcbiAgICB9KVxuICB9XG5cbiAgX2NhbmNlbEFzc2VtYmx5IChhc3NlbWJseSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5jYW5jZWxBc3NlbWJseShhc3NlbWJseSkudGhlbigoKSA9PiB7XG4gICAgICAvLyBUT0RPIGJ1YmJsZSB0aGlzIHRocm91Z2ggQXNzZW1ibHlXYXRjaGVyIHNvIGl0cyBldmVudCBoYW5kbGVycyBjYW4gY2xlYW4gdXAgY29ycmVjdGx5XG4gICAgICB0aGlzLnVwcHkuZW1pdCgndHJhbnNsb2FkaXQ6YXNzZW1ibHktY2FuY2VsbGVkJywgYXNzZW1ibHkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGFsbCBmaWxlcyBhcmUgcmVtb3ZlZCwgY2FuY2VsIGluLXByb2dyZXNzIEFzc2VtYmxpZXMuXG4gICAqL1xuICBfb25DYW5jZWxBbGwgKCkge1xuICAgIGNvbnN0IHsgdXBsb2Fkc0Fzc2VtYmxpZXMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgY29uc3QgYXNzZW1ibHlJRHMgPSBPYmplY3Qua2V5cyh1cGxvYWRzQXNzZW1ibGllcykucmVkdWNlKChhY2MsIHVwbG9hZElEKSA9PiB7XG4gICAgICBhY2MucHVzaCguLi51cGxvYWRzQXNzZW1ibGllc1t1cGxvYWRJRF0pXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjYW5jZWxQcm9taXNlcyA9IGFzc2VtYmx5SURzLm1hcCgoYXNzZW1ibHlJRCkgPT4ge1xuICAgICAgY29uc3QgYXNzZW1ibHkgPSB0aGlzLmdldEFzc2VtYmx5KGFzc2VtYmx5SUQpXG4gICAgICByZXR1cm4gdGhpcy5fY2FuY2VsQXNzZW1ibHkoYXNzZW1ibHkpXG4gICAgfSlcblxuICAgIFByb21pc2UuYWxsKGNhbmNlbFByb21pc2VzKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbSBzdGF0ZSBzZXJpYWxpemF0aW9uIGZvciB0aGUgR29sZGVuIFJldHJpZXZlciBwbHVnaW4uXG4gICAqIEl0IHdpbGwgcGFzcyB0aGlzIGJhY2sgdG8gdGhlIGBfb25SZXN0b3JlZGAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldERhdGFcbiAgICovXG4gIF9nZXRQZXJzaXN0ZW50RGF0YSAoc2V0RGF0YSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgYXNzZW1ibGllcyA9IHN0YXRlLmFzc2VtYmxpZXNcbiAgICBjb25zdCB1cGxvYWRzQXNzZW1ibGllcyA9IHN0YXRlLnVwbG9hZHNBc3NlbWJsaWVzXG5cbiAgICBzZXREYXRhKHtcbiAgICAgIFt0aGlzLmlkXToge1xuICAgICAgICBhc3NlbWJsaWVzLFxuICAgICAgICB1cGxvYWRzQXNzZW1ibGllcyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIF9vblJlc3RvcmVkIChwbHVnaW5EYXRhKSB7XG4gICAgY29uc3Qgc2F2ZWRTdGF0ZSA9IHBsdWdpbkRhdGEgJiYgcGx1Z2luRGF0YVt0aGlzLmlkXSA/IHBsdWdpbkRhdGFbdGhpcy5pZF0gOiB7fVxuICAgIGNvbnN0IHByZXZpb3VzQXNzZW1ibGllcyA9IHNhdmVkU3RhdGUuYXNzZW1ibGllcyB8fCB7fVxuICAgIGNvbnN0IHVwbG9hZHNBc3NlbWJsaWVzID0gc2F2ZWRTdGF0ZS51cGxvYWRzQXNzZW1ibGllcyB8fCB7fVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHVwbG9hZHNBc3NlbWJsaWVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gcmVzdG9yZS5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgbG9hZGVkIEFzc2VtYmx5IHN0YXR1c2VzIHRvIGEgVHJhbnNsb2FkaXQgcGx1Z2luIHN0YXRlIG9iamVjdC5cbiAgICBjb25zdCByZXN0b3JlU3RhdGUgPSAoYXNzZW1ibGllcykgPT4ge1xuICAgICAgY29uc3QgZmlsZXMgPSB7fVxuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdXG4gICAgICBPYmplY3Qua2V5cyhhc3NlbWJsaWVzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBhc3NlbWJsaWVzW2lkXVxuXG4gICAgICAgIHN0YXR1cy51cGxvYWRzLmZvckVhY2goKHVwbG9hZGVkRmlsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLl9maW5kRmlsZSh1cGxvYWRlZEZpbGUpXG4gICAgICAgICAgZmlsZXNbdXBsb2FkZWRGaWxlLmlkXSA9IHtcbiAgICAgICAgICAgIGlkOiBmaWxlLmlkLFxuICAgICAgICAgICAgYXNzZW1ibHk6IGlkLFxuICAgICAgICAgICAgdXBsb2FkZWRGaWxlLFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgICBPYmplY3Qua2V5cyhzdGF0dXMucmVzdWx0cykuZm9yRWFjaCgoc3RlcE5hbWUpID0+IHtcbiAgICAgICAgICBzdGF0dXMucmVzdWx0c1tzdGVwTmFtZV0uZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gc3RhdGUuZmlsZXNbcmVzdWx0Lm9yaWdpbmFsX2lkXVxuICAgICAgICAgICAgcmVzdWx0LmxvY2FsSWQgPSBmaWxlID8gZmlsZS5pZCA6IG51bGxcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiByZXN1bHQuaWQsXG4gICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgc3RlcE5hbWUsXG4gICAgICAgICAgICAgIGFzc2VtYmx5OiBpZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBhc3NlbWJsaWVzLFxuICAgICAgICBmaWxlcyxcbiAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgdXBsb2Fkc0Fzc2VtYmxpZXMsXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFNldCB1cCB0aGUgQXNzZW1ibHkgaW5zdGFuY2VzIGFuZCBBc3NlbWJseVdhdGNoZXJzIGZvciBleGlzdGluZyBBc3NlbWJsaWVzLlxuICAgIGNvbnN0IHJlc3RvcmVBc3NlbWJsaWVzID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBhc3NlbWJsaWVzLCB1cGxvYWRzQXNzZW1ibGllcyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICAgIC8vIFNldCB1cCB0aGUgYXNzZW1ibHkgd2F0Y2hlcnMgYWdhaW4gZm9yIGFsbCB0aGUgb25nb2luZyB1cGxvYWRzLlxuICAgICAgT2JqZWN0LmtleXModXBsb2Fkc0Fzc2VtYmxpZXMpLmZvckVhY2goKHVwbG9hZElEKSA9PiB7XG4gICAgICAgIGNvbnN0IGFzc2VtYmx5SURzID0gdXBsb2Fkc0Fzc2VtYmxpZXNbdXBsb2FkSURdXG4gICAgICAgIGNvbnN0IGZpbGVJRHNJblVwbG9hZCA9IGFzc2VtYmx5SURzLnJlZHVjZSgoYWNjLCBhc3NlbWJseUlEKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZUlEc0luQXNzZW1ibHkgPSB0aGlzLmdldEFzc2VtYmx5RmlsZXMoYXNzZW1ibHlJRCkubWFwKChmaWxlKSA9PiBmaWxlLmlkKVxuICAgICAgICAgIGFjYy5wdXNoKC4uLmZpbGVJRHNJbkFzc2VtYmx5KVxuICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgfSwgW10pXG4gICAgICAgIHRoaXMuX2NyZWF0ZUFzc2VtYmx5V2F0Y2hlcihhc3NlbWJseUlEcywgZmlsZUlEc0luVXBsb2FkLCB1cGxvYWRJRClcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGFsbEFzc2VtYmx5SURzID0gT2JqZWN0LmtleXMoYXNzZW1ibGllcylcbiAgICAgIGFsbEFzc2VtYmx5SURzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IGFzc2VtYmx5ID0gbmV3IEFzc2VtYmx5KGFzc2VtYmxpZXNbaWRdKVxuICAgICAgICB0aGlzLl9jb25uZWN0QXNzZW1ibHkoYXNzZW1ibHkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIEZvcmNlLXVwZGF0ZSBhbGwgQXNzZW1ibGllcyB0byBjaGVjayBmb3IgbWlzc2VkIGV2ZW50cy5cbiAgICBjb25zdCB1cGRhdGVBc3NlbWJsaWVzID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBhc3NlbWJsaWVzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgT2JqZWN0LmtleXMoYXNzZW1ibGllcykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUFzc2VtYmxpZXNbaWRdLnVwZGF0ZSgpXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBhbGwgQXNzZW1ibHkgc3RhdGUuXG4gICAgdGhpcy5yZXN0b3JlZCA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgcmVzdG9yZVN0YXRlKHByZXZpb3VzQXNzZW1ibGllcylcbiAgICAgIHJlc3RvcmVBc3NlbWJsaWVzKClcbiAgICAgIHJldHVybiB1cGRhdGVBc3NlbWJsaWVzKClcbiAgICB9KVxuXG4gICAgdGhpcy5yZXN0b3JlZC50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVzdG9yZWQgPSBudWxsXG4gICAgfSlcbiAgfVxuXG4gIF9jb25uZWN0QXNzZW1ibHkgKGFzc2VtYmx5KSB7XG4gICAgY29uc3QgeyBzdGF0dXMgfSA9IGFzc2VtYmx5XG4gICAgY29uc3QgaWQgPSBzdGF0dXMuYXNzZW1ibHlfaWRcbiAgICB0aGlzLmFjdGl2ZUFzc2VtYmxpZXNbaWRdID0gYXNzZW1ibHlcblxuICAgIC8vIFN5bmMgbG9jYWwgYGFzc2VtYmxpZXNgIHN0YXRlXG4gICAgYXNzZW1ibHkub24oJ3N0YXR1cycsIChuZXdTdGF0dXMpID0+IHtcbiAgICAgIGNvbnN0IHsgYXNzZW1ibGllcyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgYXNzZW1ibGllczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxpZXMsXG4gICAgICAgICAgW2lkXTogbmV3U3RhdHVzLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgYXNzZW1ibHkub24oJ3VwbG9hZCcsIChmaWxlKSA9PiB7XG4gICAgICB0aGlzLl9vbkZpbGVVcGxvYWRDb21wbGV0ZShpZCwgZmlsZSlcbiAgICB9KVxuICAgIGFzc2VtYmx5Lm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgZXJyb3IuYXNzZW1ibHkgPSBhc3NlbWJseS5zdGF0dXNcbiAgICAgIHRoaXMudXBweS5lbWl0KCd0cmFuc2xvYWRpdDphc3NlbWJseS1lcnJvcicsIGFzc2VtYmx5LnN0YXR1cywgZXJyb3IpXG4gICAgfSlcblxuICAgIGFzc2VtYmx5Lm9uKCdleGVjdXRpbmcnLCAoKSA9PiB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgndHJhbnNsb2FkaXQ6YXNzZW1ibHktZXhlY3V0aW5nJywgYXNzZW1ibHkuc3RhdHVzKVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5vcHRzLndhaXRGb3JFbmNvZGluZykge1xuICAgICAgYXNzZW1ibHkub24oJ3Jlc3VsdCcsIChzdGVwTmFtZSwgcmVzdWx0KSA9PiB7XG4gICAgICAgIHRoaXMuX29uUmVzdWx0KGlkLCBzdGVwTmFtZSwgcmVzdWx0KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLndhaXRGb3JFbmNvZGluZykge1xuICAgICAgYXNzZW1ibHkub24oJ2ZpbmlzaGVkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9vbkFzc2VtYmx5RmluaXNoZWQoYXNzZW1ibHkuc3RhdHVzKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy53YWl0Rm9yTWV0YWRhdGEpIHtcbiAgICAgIGFzc2VtYmx5Lm9uKCdtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgdGhpcy5fb25Bc3NlbWJseUZpbmlzaGVkKGFzc2VtYmx5LnN0YXR1cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gTm8gbmVlZCB0byBjb25uZWN0IHRvIHRoZSBzb2NrZXQgaWYgdGhlIEFzc2VtYmx5IGhhcyBjb21wbGV0ZWQgYnkgbm93LlxuICAgIGlmIChhc3NlbWJseS5vayA9PT0gJ0FTU0VNQkxZX0NPTVBMRVRFJykge1xuICAgICAgcmV0dXJuIGFzc2VtYmx5XG4gICAgfVxuXG4gICAgLy8gVE9ETyBEbyB3ZSBzdGlsbCBuZWVkIHRoaXMgZm9yIGFueXRoaW5n4oCmP1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGNvbnN0IGNvbm5lY3RlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGFzc2VtYmx5Lm9uY2UoJ2Nvbm5lY3QnLCByZXNvbHZlKVxuICAgICAgYXNzZW1ibHkub25jZSgnc3RhdHVzJywgcmVzb2x2ZSlcbiAgICAgIGFzc2VtYmx5Lm9uY2UoJ2Vycm9yJywgcmVqZWN0KVxuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZygnW1RyYW5zbG9hZGl0XSBTb2NrZXQgaXMgcmVhZHknKVxuICAgIH0pXG5cbiAgICBhc3NlbWJseS5jb25uZWN0KClcbiAgICByZXR1cm4gYXNzZW1ibHlcbiAgfVxuXG4gIF9wcmVwYXJlVXBsb2FkIChmaWxlSURzLCB1cGxvYWRJRCkge1xuICAgIC8vIE9ubHkgdXNlIGZpbGVzIHdpdGhvdXQgZXJyb3JzXG4gICAgZmlsZUlEcyA9IGZpbGVJRHMuZmlsdGVyKChmaWxlKSA9PiAhZmlsZS5lcnJvcilcblxuICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgdGhpcy51cHB5LmVtaXQoJ3ByZXByb2Nlc3MtcHJvZ3Jlc3MnLCBmaWxlLCB7XG4gICAgICAgIG1vZGU6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5pMThuKCdjcmVhdGluZ0Fzc2VtYmx5JyksXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCBjcmVhdGVBc3NlbWJseSA9ICh7IGZpbGVJRHMsIG9wdGlvbnMgfSkgPT4ge1xuICAgICAgbGV0IGNyZWF0ZWRBc3NlbWJseVxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUFzc2VtYmx5KGZpbGVJRHMsIHVwbG9hZElELCBvcHRpb25zKS50aGVuKChhc3NlbWJseSkgPT4ge1xuICAgICAgICBjcmVhdGVkQXNzZW1ibHkgPSBhc3NlbWJseVxuICAgICAgICBpZiAodGhpcy5vcHRzLmltcG9ydEZyb21VcGxvYWRVUkxzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2VydmVGaWxlcyhhc3NlbWJseSwgZmlsZUlEcylcbiAgICAgICAgfVxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgncHJlcHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBjcmVhdGVkQXNzZW1ibHlcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgICAgIC8vIENsZWFyIHByZXByb2Nlc3Npbmcgc3RhdGUgd2hlbiB0aGUgQXNzZW1ibHkgY291bGQgbm90IGJlIGNyZWF0ZWQsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBVSSBnZXRzIGNvbmZ1c2VkIGFib3V0IHRoZSBsaW5nZXJpbmcgcHJvZ3Jlc3Mga2V5c1xuICAgICAgICAgIHRoaXMudXBweS5lbWl0KCdwcmVwcm9jZXNzLWNvbXBsZXRlJywgZmlsZSlcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyKVxuICAgICAgICB9KVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgeyB1cGxvYWRzQXNzZW1ibGllcyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICB1cGxvYWRzQXNzZW1ibGllczoge1xuICAgICAgICAuLi51cGxvYWRzQXNzZW1ibGllcyxcbiAgICAgICAgW3VwbG9hZElEXTogW10sXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBjb25zdCBmaWxlcyA9IGZpbGVJRHMubWFwKChpZCkgPT4gdGhpcy51cHB5LmdldEZpbGUoaWQpKVxuICAgIGNvbnN0IGFzc2VtYmx5T3B0aW9ucyA9IG5ldyBBc3NlbWJseU9wdGlvbnMoZmlsZXMsIHRoaXMub3B0cylcblxuICAgIHJldHVybiBhc3NlbWJseU9wdGlvbnMuYnVpbGQoKS50aGVuKFxuICAgICAgKGFzc2VtYmxpZXMpID0+IFByb21pc2UuYWxsKFxuICAgICAgICBhc3NlbWJsaWVzLm1hcChjcmVhdGVBc3NlbWJseSlcbiAgICAgICkudGhlbigoY3JlYXRlZEFzc2VtYmxpZXMpID0+IHtcbiAgICAgICAgY29uc3QgYXNzZW1ibHlJRHMgPSBjcmVhdGVkQXNzZW1ibGllcy5tYXAoYXNzZW1ibHkgPT4gYXNzZW1ibHkuc3RhdHVzLmFzc2VtYmx5X2lkKVxuICAgICAgICB0aGlzLl9jcmVhdGVBc3NlbWJseVdhdGNoZXIoYXNzZW1ibHlJRHMsIGZpbGVJRHMsIHVwbG9hZElEKVxuICAgICAgICBjcmVhdGVkQXNzZW1ibGllcy5tYXAoYXNzZW1ibHkgPT4gdGhpcy5fY29ubmVjdEFzc2VtYmx5KGFzc2VtYmx5KSlcbiAgICAgIH0pLFxuICAgICAgLy8gSWYgc29tZXRoaW5nIHdlbnQgd3JvbmcgYmVmb3JlIGFueSBBc3NlbWJsaWVzIGNvdWxkIGJlIGNyZWF0ZWQsXG4gICAgICAvLyBjbGVhciBhbGwgcHJvY2Vzc2luZyBzdGF0ZS5cbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgICAgIHRoaXMudXBweS5lbWl0KCdwcmVwcm9jZXNzLWNvbXBsZXRlJywgZmlsZSlcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyKVxuICAgICAgICB9KVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBfYWZ0ZXJVcGxvYWQgKGZpbGVJRHMsIHVwbG9hZElEKSB7XG4gICAgY29uc3QgZmlsZXMgPSBmaWxlSURzLm1hcChmaWxlSUQgPT4gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKSlcbiAgICAvLyBPbmx5IHVzZSBmaWxlcyB3aXRob3V0IGVycm9yc1xuICAgIGZpbGVJRHMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+ICFmaWxlLmVycm9yKS5tYXAoZmlsZSA9PiBmaWxlLmlkKVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcblxuICAgIC8vIElmIHdlJ3JlIHN0aWxsIHJlc3RvcmluZyBzdGF0ZSwgd2FpdCBmb3IgdGhhdCB0byBiZSBkb25lLlxuICAgIGlmICh0aGlzLnJlc3RvcmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXN0b3JlZC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FmdGVyVXBsb2FkKGZpbGVJRHMsIHVwbG9hZElEKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBhc3NlbWJseUlEcyA9IHN0YXRlLnVwbG9hZHNBc3NlbWJsaWVzW3VwbG9hZElEXVxuXG4gICAgY29uc3QgY2xvc2VTb2NrZXRDb25uZWN0aW9ucyA9ICgpID0+IHtcbiAgICAgIGFzc2VtYmx5SURzLmZvckVhY2goKGFzc2VtYmx5SUQpID0+IHtcbiAgICAgICAgY29uc3QgYXNzZW1ibHkgPSB0aGlzLmFjdGl2ZUFzc2VtYmxpZXNbYXNzZW1ibHlJRF1cbiAgICAgICAgYXNzZW1ibHkuY2xvc2UoKVxuICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmVBc3NlbWJsaWVzW2Fzc2VtYmx5SURdXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgdG8gd2FpdCBmb3IgZW5jb2RpbmcgbWV0YWRhdGEgb3IgcmVzdWx0cywgd2UgY2FuIGNsb3NlXG4gICAgLy8gdGhlIHNvY2tldCBpbW1lZGlhdGVseSBhbmQgZmluaXNoIHRoZSB1cGxvYWQuXG4gICAgaWYgKCF0aGlzLl9zaG91bGRXYWl0QWZ0ZXJVcGxvYWQoKSkge1xuICAgICAgY2xvc2VTb2NrZXRDb25uZWN0aW9ucygpXG4gICAgICBjb25zdCBhc3NlbWJsaWVzID0gYXNzZW1ibHlJRHMubWFwKChpZCkgPT4gdGhpcy5nZXRBc3NlbWJseShpZCkpXG4gICAgICB0aGlzLnVwcHkuYWRkUmVzdWx0RGF0YSh1cGxvYWRJRCwgeyB0cmFuc2xvYWRpdDogYXNzZW1ibGllcyB9KVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgLy8gSWYgbm8gQXNzZW1ibGllcyB3ZXJlIGNyZWF0ZWQgZm9yIHRoaXMgdXBsb2FkLCB3ZSBhbHNvIGRvIG5vdCBoYXZlIHRvIHdhaXQuXG4gICAgLy8gVGhlcmUncyBhbHNvIG5vIHNvY2tldHMgb3IgYW55dGhpbmcgdG8gY2xvc2UsIHNvIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5LlxuICAgIGlmIChhc3NlbWJseUlEcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudXBweS5hZGRSZXN1bHREYXRhKHVwbG9hZElELCB7IHRyYW5zbG9hZGl0OiBbXSB9KVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgY29uc3QgaW5jb21wbGV0ZUZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gIWhhc1Byb3BlcnR5KHRoaXMuY29tcGxldGVkRmlsZXMsIGZpbGUuaWQpKVxuICAgIGluY29tcGxldGVGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgncG9zdHByb2Nlc3MtcHJvZ3Jlc3MnLCBmaWxlLCB7XG4gICAgICAgIG1vZGU6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5pMThuKCdlbmNvZGluZycpLFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3Qgd2F0Y2hlciA9IHRoaXMuYXNzZW1ibHlXYXRjaGVyc1t1cGxvYWRJRF1cbiAgICByZXR1cm4gd2F0Y2hlci5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgY2xvc2VTb2NrZXRDb25uZWN0aW9ucygpXG5cbiAgICAgIGNvbnN0IGFzc2VtYmxpZXMgPSBhc3NlbWJseUlEcy5tYXAoKGlkKSA9PiB0aGlzLmdldEFzc2VtYmx5KGlkKSlcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBBc3NlbWJseSBJRCBsaXN0IGZvciB0aGlzIHVwbG9hZCxcbiAgICAgIC8vIGl0J3Mgbm8gbG9uZ2VyIGdvaW5nIHRvIGJlIHVzZWQgYW55d2hlcmUuXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgY29uc3QgdXBsb2Fkc0Fzc2VtYmxpZXMgPSB7IC4uLnN0YXRlLnVwbG9hZHNBc3NlbWJsaWVzIH1cbiAgICAgIGRlbGV0ZSB1cGxvYWRzQXNzZW1ibGllc1t1cGxvYWRJRF1cbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyB1cGxvYWRzQXNzZW1ibGllcyB9KVxuXG4gICAgICB0aGlzLnVwcHkuYWRkUmVzdWx0RGF0YSh1cGxvYWRJRCwge1xuICAgICAgICB0cmFuc2xvYWRpdDogYXNzZW1ibGllcyxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9vbkVycm9yIChlcnIgPSBudWxsLCB1cGxvYWRJRCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgYXNzZW1ibHlJRHMgPSBzdGF0ZS51cGxvYWRzQXNzZW1ibGllc1t1cGxvYWRJRF1cblxuICAgIGFzc2VtYmx5SURzLmZvckVhY2goKGFzc2VtYmx5SUQpID0+IHtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZUFzc2VtYmxpZXNbYXNzZW1ibHlJRF0pIHtcbiAgICAgICAgdGhpcy5hY3RpdmVBc3NlbWJsaWVzW2Fzc2VtYmx5SURdLmNsb3NlKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgX29uVHVzRXJyb3IgKGVycikge1xuICAgIGlmIChlcnIgJiYgL150dXM6IC8udGVzdChlcnIubWVzc2FnZSkpIHtcbiAgICAgIGNvbnN0IHhociA9IGVyci5vcmlnaW5hbFJlcXVlc3QgPyBlcnIub3JpZ2luYWxSZXF1ZXN0LmdldFVuZGVybHlpbmdPYmplY3QoKSA6IG51bGxcbiAgICAgIGNvbnN0IHVybCA9IHhociAmJiB4aHIucmVzcG9uc2VVUkwgPyB4aHIucmVzcG9uc2VVUkwgOiBudWxsXG4gICAgICB0aGlzLmNsaWVudC5zdWJtaXRFcnJvcihlcnIsIHsgdXJsLCB0eXBlOiAnVFVTX0VSUk9SJyB9KS50aGVuKChfKSA9PiB7XG4gICAgICAgIC8vIGlmIHdlIGNhbid0IHJlcG9ydCB0aGUgZXJyb3IgdGhhdCBzdWNrc1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkuYWRkUHJlUHJvY2Vzc29yKHRoaXMuX3ByZXBhcmVVcGxvYWQpXG4gICAgdGhpcy51cHB5LmFkZFBvc3RQcm9jZXNzb3IodGhpcy5fYWZ0ZXJVcGxvYWQpXG5cbiAgICAvLyBXZSBtYXkgbmVlZCB0byBjbG9zZSBzb2NrZXQuaW8gY29ubmVjdGlvbnMgb24gZXJyb3IuXG4gICAgdGhpcy51cHB5Lm9uKCdlcnJvcicsIHRoaXMuX29uRXJyb3IpXG5cbiAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uLlxuICAgIHRoaXMudXBweS5vbignY2FuY2VsLWFsbCcsIHRoaXMuX29uQ2FuY2VsQWxsKVxuXG4gICAgLy8gRm9yIGVycm9yIHJlcG9ydGluZy5cbiAgICB0aGlzLnVwcHkub24oJ3VwbG9hZC1lcnJvcicsIHRoaXMuX29uVHVzRXJyb3IpXG5cbiAgICBpZiAodGhpcy5vcHRzLmltcG9ydEZyb21VcGxvYWRVUkxzKSB7XG4gICAgICAvLyBObyB1cGxvYWRlciBuZWVkZWQgd2hlbiBpbXBvcnRpbmc7IGluc3RlYWQgd2UgdGFrZSB0aGUgdXBsb2FkIFVSTCBmcm9tIGFuIGV4aXN0aW5nIHVwbG9hZGVyLlxuICAgICAgdGhpcy51cHB5Lm9uKCd1cGxvYWQtc3VjY2VzcycsIHRoaXMuX29uRmlsZVVwbG9hZFVSTEF2YWlsYWJsZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cHB5LnVzZShUdXMsIHtcbiAgICAgICAgLy8gRGlzYWJsZSB0dXMtanMtY2xpZW50IGZpbmdlcnByaW50aW5nLCBvdGhlcndpc2UgdXBsb2FkaW5nIHRoZSBzYW1lIGZpbGUgYXQgZGlmZmVyZW50IHRpbWVzXG4gICAgICAgIC8vIHdpbGwgdXBsb2FkIHRvIGFuIG91dGRhdGVkIEFzc2VtYmx5LCBhbmQgd2Ugd29uJ3QgZ2V0IHNvY2tldCBldmVudHMgZm9yIGl0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBUbyByZXN1bWUgYSBUcmFuc2xvYWRpdCB1cGxvYWQsIHdlIG5lZWQgdG8gcmVjb25uZWN0IHRvIHRoZSB3ZWJzb2NrZXQsIGFuZCB0aGUgc3RhdGUgdGhhdCdzXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIGRvIHRoYXQgaXMgbm90IHNhdmVkIGJ5IHR1cy1qcy1jbGllbnQncyBmaW5nZXJwcmludGluZy4gV2UgbmVlZCB0aGUgdHVzIFVSTCxcbiAgICAgICAgLy8gdGhlIEFzc2VtYmx5IFVSTCwgYW5kIHRoZSBXZWJTb2NrZXQgVVJMLCBhdCBsZWFzdC4gV2UgYWxzbyBuZWVkIHRvIGtub3cgX2FsbF8gdGhlIGZpbGVzIHRoYXRcbiAgICAgICAgLy8gd2VyZSBhZGRlZCB0byB0aGUgQXNzZW1ibHksIHNvIHdlIGNhbiBwcm9wZXJseSBjb21wbGV0ZSBpdC4gQWxsIHRoYXQgc3RhdGUgaXMgaGFuZGxlZCBieVxuICAgICAgICAvLyBHb2xkZW4gUmV0cmlldmVyLiBTbywgR29sZGVuIFJldHJpZXZlciBpcyByZXF1aXJlZCB0byBkbyByZXN1bWFiaWxpdHkgd2l0aCB0aGUgVHJhbnNsb2FkaXQgcGx1Z2luLFxuICAgICAgICAvLyBhbmQgd2UgZGlzYWJsZSBUdXMncyBkZWZhdWx0IHJlc3VtZSBpbXBsZW1lbnRhdGlvbiB0byBwcmV2ZW50IGJhZCBiZWhhdmlvdXJzLlxuICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IGZhbHNlLFxuICAgICAgICByZXN1bWU6IGZhbHNlLFxuICAgICAgICAvLyBEaXNhYmxlIENvbXBhbmlvbidzIHJldHJ5IG9wdGltaXNhdGlvbjsgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIGVuZHBvaW50IG9uIHJldHJ5XG4gICAgICAgIC8vIHNvIGl0IGNhbid0IGp1c3QgcmV1c2UgdGhlIHNhbWUgdHVzLlVwbG9hZCBpbnN0YW5jZSBzZXJ2ZXItc2lkZS5cbiAgICAgICAgdXNlRmFzdFJlbW90ZVJldHJ5OiBmYWxzZSxcbiAgICAgICAgLy8gT25seSBzZW5kIEFzc2VtYmx5IG1ldGFkYXRhIHRvIHRoZSB0dXMgZW5kcG9pbnQuXG4gICAgICAgIG1ldGFGaWVsZHM6IFsnYXNzZW1ibHlfdXJsJywgJ2ZpbGVuYW1lJywgJ2ZpZWxkbmFtZSddLFxuICAgICAgICAvLyBQYXNzIHRoZSBsaW1pdCBvcHRpb24gdG8gQHVwcHkvdHVzXG4gICAgICAgIGxpbWl0OiB0aGlzLm9wdHMubGltaXQsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMudXBweS5vbigncmVzdG9yZTpnZXQtZGF0YScsIHRoaXMuX2dldFBlcnNpc3RlbnREYXRhKVxuICAgIHRoaXMudXBweS5vbigncmVzdG9yZWQnLCB0aGlzLl9vblJlc3RvcmVkKVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAvLyBDb250YWlucyBBc3NlbWJseSBzdGF0dXMgb2JqZWN0cywgaW5kZXhlZCBieSB0aGVpciBJRC5cbiAgICAgIGFzc2VtYmxpZXM6IHt9LFxuICAgICAgLy8gQ29udGFpbnMgYXJyYXlzIG9mIEFzc2VtYmx5IElEcywgaW5kZXhlZCBieSB0aGUgdXBsb2FkIElEIHRoYXQgdGhleSBiZWxvbmcgdG8uXG4gICAgICB1cGxvYWRzQXNzZW1ibGllczoge30sXG4gICAgICAvLyBDb250YWlucyBmaWxlIGRhdGEgZnJvbSBUcmFuc2xvYWRpdCwgaW5kZXhlZCBieSB0aGVpciBUcmFuc2xvYWRpdC1hc3NpZ25lZCBJRC5cbiAgICAgIGZpbGVzOiB7fSxcbiAgICAgIC8vIENvbnRhaW5zIHJlc3VsdCBkYXRhIGZyb20gVHJhbnNsb2FkaXQuXG4gICAgICByZXN1bHRzOiBbXSxcbiAgICB9KVxuXG4gICAgLy8gV2UgY2Fubm90IGNhbmNlbCBpbmRpdmlkdWFsIGZpbGVzIGJlY2F1c2UgQXNzZW1ibGllcyB0ZW5kIHRvIGNvbnRhaW4gbWFueSBmaWxlcy5cbiAgICBjb25zdCB7IGNhcGFiaWxpdGllcyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgIC4uLmNhcGFiaWxpdGllcyxcbiAgICAgICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbjogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5yZW1vdmVQcmVQcm9jZXNzb3IodGhpcy5fcHJlcGFyZVVwbG9hZClcbiAgICB0aGlzLnVwcHkucmVtb3ZlUG9zdFByb2Nlc3Nvcih0aGlzLl9hZnRlclVwbG9hZClcbiAgICB0aGlzLnVwcHkub2ZmKCdlcnJvcicsIHRoaXMuX29uRXJyb3IpXG5cbiAgICBpZiAodGhpcy5vcHRzLmltcG9ydEZyb21VcGxvYWRVUkxzKSB7XG4gICAgICB0aGlzLnVwcHkub2ZmKCd1cGxvYWQtc3VjY2VzcycsIHRoaXMuX29uRmlsZVVwbG9hZFVSTEF2YWlsYWJsZSlcbiAgICB9XG5cbiAgICBjb25zdCB7IGNhcGFiaWxpdGllcyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgIC4uLmNhcGFiaWxpdGllcyxcbiAgICAgICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGdldEFzc2VtYmx5IChpZCkge1xuICAgIGNvbnN0IHsgYXNzZW1ibGllcyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgcmV0dXJuIGFzc2VtYmxpZXNbaWRdXG4gIH1cblxuICBnZXRBc3NlbWJseUZpbGVzIChhc3NlbWJseUlEKSB7XG4gICAgcmV0dXJuIHRoaXMudXBweS5nZXRGaWxlcygpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGUgJiYgZmlsZS50cmFuc2xvYWRpdCAmJiBmaWxlLnRyYW5zbG9hZGl0LmFzc2VtYmx5ID09PSBhc3NlbWJseUlEXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5DT01QQU5JT04gPSBDT01QQU5JT05cbm1vZHVsZS5leHBvcnRzLlVQUFlfU0VSVkVSID0gQ09NUEFOSU9OXG5tb2R1bGUuZXhwb3J0cy5DT01QQU5JT05fUEFUVEVSTiA9IEFMTE9XRURfQ09NUEFOSU9OX1BBVFRFUk5cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VVcmwgKHVybCkge1xuICBjb25zdCBzY2hlbWUgPSAvXlxcdys6XFwvXFwvLy5leGVjKHVybClcbiAgbGV0IGkgPSAwXG4gIGlmIChzY2hlbWUpIHtcbiAgICBpID0gc2NoZW1lWzBdLmxlbmd0aCArIDFcbiAgfVxuICBjb25zdCBzbGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJy8nLCBpKVxuICBpZiAoc2xhc2hJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3JpZ2luOiB1cmwsXG4gICAgICBwYXRobmFtZTogJy8nLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3JpZ2luOiB1cmwuc2xpY2UoMCwgc2xhc2hJbmRleCksXG4gICAgcGF0aG5hbWU6IHVybC5zbGljZShzbGFzaEluZGV4KSxcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS90dXNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlJlc3VtYWJsZSB1cGxvYWRzIGZvciBVcHB5IHVzaW5nIFR1cy5pb1wiLFxuICBcInZlcnNpb25cIjogXCIxLjkuMVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcInVwbG9hZFwiLFxuICAgIFwicmVzdW1hYmxlXCIsXG4gICAgXCJ0dXNcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwidHVzLWpzLWNsaWVudFwiOiBcIl4yLjEuMVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgdHVzID0gcmVxdWlyZSgndHVzLWpzLWNsaWVudCcpXG5cbmZ1bmN0aW9uIGlzQ29yZG92YSAoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgdHlwZW9mIHdpbmRvdy5QaG9uZUdhcCAhPT0gJ3VuZGVmaW5lZCdcbiAgICB8fCB0eXBlb2Ygd2luZG93LkNvcmRvdmEgIT09ICd1bmRlZmluZWQnXG4gICAgfHwgdHlwZW9mIHdpbmRvdy5jb3Jkb3ZhICE9PSAndW5kZWZpbmVkJ1xuICApXG59XG5cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUgKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdzdHJpbmcnXG4gICAgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJ1xufVxuXG4vLyBXZSBvdmVycmlkZSB0dXMgZmluZ2VycHJpbnQgdG8gdXBweeKAmXMgYGZpbGUuaWRgLCBzaW5jZSB0aGUgYGZpbGUuaWRgXG4vLyBub3cgYWxzbyBpbmNsdWRlcyBgcmVsYXRpdmVQYXRoYCBmb3IgZmlsZXMgYWRkZWQgZnJvbSBmb2xkZXJzLlxuLy8gVGhpcyBtZWFucyB5b3UgY2FuIGFkZCAyIGlkZW50aWNhbCBmaWxlcywgaWYgb25lIGlzIGluIGZvbGRlciBhLFxuLy8gdGhlIG90aGVyIGluIGZvbGRlciBiIOKAlCBgYS9maWxlLmpwZ2AgYW5kIGBiL2ZpbGUuanBnYCwgd2hlbiBhZGRlZFxuLy8gdG9nZXRoZXIgd2l0aCBhIGZvbGRlciwgd2lsbCBiZSB0cmVhdGVkIGFzIDIgc2VwYXJhdGUgZmlsZXMuXG4vL1xuLy8gRm9yIFJlYWN0IE5hdGl2ZSBhbmQgQ29yZG92YSwgd2UgbGV0IHR1cy1qcy1jbGllbnTigJlzIGRlZmF1bHRcbi8vIGZpbmdlcnByaW50IGhhbmRsaW5nIHRha2UgY2hhcmdlLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaW5nZXJwcmludCAodXBweUZpbGVPYmopIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzQ29yZG92YSgpIHx8IGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgcmV0dXJuIHR1cy5kZWZhdWx0T3B0aW9ucy5maW5nZXJwcmludChmaWxlLCBvcHRpb25zKVxuICAgIH1cblxuICAgIGNvbnN0IHVwcHlGaW5nZXJwcmludCA9IFtcbiAgICAgICd0dXMnLFxuICAgICAgdXBweUZpbGVPYmouaWQsXG4gICAgICBvcHRpb25zLmVuZHBvaW50LFxuICAgIF0uam9pbignLScpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVwcHlGaW5nZXJwcmludClcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgdHVzID0gcmVxdWlyZSgndHVzLWpzLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyLCBSZXF1ZXN0Q2xpZW50LCBTb2NrZXQgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgZW1pdFNvY2tldFByb2dyZXNzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2VtaXRTb2NrZXRQcm9ncmVzcycpXG5jb25zdCBnZXRTb2NrZXRIb3N0ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldFNvY2tldEhvc3QnKVxuY29uc3Qgc2V0dGxlID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3NldHRsZScpXG5jb25zdCBFdmVudFRyYWNrZXIgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvRXZlbnRUcmFja2VyJylcbmNvbnN0IE5ldHdvcmtFcnJvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9OZXR3b3JrRXJyb3InKVxuY29uc3QgaXNOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNOZXR3b3JrRXJyb3InKVxuY29uc3QgUmF0ZUxpbWl0ZWRRdWV1ZSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9SYXRlTGltaXRlZFF1ZXVlJylcbmNvbnN0IGhhc1Byb3BlcnR5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2hhc1Byb3BlcnR5JylcbmNvbnN0IGdldEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9nZXRGaW5nZXJwcmludCcpXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlR1c09wdGlvbnN9IFR1c09wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCd0dXMtanMtY2xpZW50JykuVXBsb2FkT3B0aW9uc30gUmF3VHVzT3B0aW9ucyAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ0B1cHB5L2NvcmUnKS5VcHB5fSBVcHB5ICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnQHVwcHkvY29yZScpLlVwcHlGaWxlfSBVcHB5RmlsZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ0B1cHB5L2NvcmUnKS5GYWlsZWRVcHB5RmlsZTx7fT59IEZhaWxlZFVwcHlGaWxlICovXG5cbi8qKlxuICogRXh0cmFjdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3R1cy90dXMtanMtY2xpZW50L2Jsb2IvbWFzdGVyL2xpYi91cGxvYWQuanMjTDEzXG4gKiBleGNlcHRlZCB3ZSByZW1vdmVkICdmaW5nZXJwcmludCcga2V5IHRvIGF2b2lkIGFkZGluZyBtb3JlIGRlcGVuZGVuY2llc1xuICpcbiAqIEB0eXBlIHtSYXdUdXNPcHRpb25zfVxuICovXG5jb25zdCB0dXNEZWZhdWx0T3B0aW9ucyA9IHtcbiAgZW5kcG9pbnQ6ICcnLFxuXG4gIHVwbG9hZFVybDogbnVsbCxcbiAgbWV0YWRhdGE6IHt9LFxuICB1cGxvYWRTaXplOiBudWxsLFxuXG4gIG9uUHJvZ3Jlc3M6IG51bGwsXG4gIG9uQ2h1bmtDb21wbGV0ZTogbnVsbCxcbiAgb25TdWNjZXNzOiBudWxsLFxuICBvbkVycm9yOiBudWxsLFxuXG4gIG92ZXJyaWRlUGF0Y2hNZXRob2Q6IGZhbHNlLFxuICBoZWFkZXJzOiB7fSxcbiAgYWRkUmVxdWVzdElkOiBmYWxzZSxcblxuICBjaHVua1NpemU6IEluZmluaXR5LFxuICByZXRyeURlbGF5czogWzAsIDEwMDAsIDMwMDAsIDUwMDBdLFxuICBwYXJhbGxlbFVwbG9hZHM6IDEsXG4gIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogdHJ1ZSxcbiAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3M6IGZhbHNlLFxuICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogZmFsc2UsXG4gIHVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbjogZmFsc2UsXG59XG5cbi8qKlxuICogVHVzIHJlc3VtYWJsZSBmaWxlIHVwbG9hZGVyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVHVzIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBweX0gdXBweVxuICAgKiBAcGFyYW0ge1R1c09wdGlvbnN9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnR5cGUgPSAndXBsb2FkZXInXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnVHVzJ1xuICAgIHRoaXMudGl0bGUgPSAnVHVzJ1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXV0b1JldHJ5OiB0cnVlLFxuICAgICAgcmVzdW1lOiB0cnVlLFxuICAgICAgdXNlRmFzdFJlbW90ZVJldHJ5OiB0cnVlLFxuICAgICAgbGltaXQ6IDAsXG4gICAgICByZXRyeURlbGF5czogWzAsIDEwMDAsIDMwMDAsIDUwMDBdLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi5cIikuVHVzT3B0aW9uc30gKi9cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXVsdGFuZW91cyB1cGxvYWQgbGltaXRpbmcgaXMgc2hhcmVkIGFjcm9zcyBhbGwgdXBsb2FkcyB3aXRoIHRoaXMgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHR5cGUge1JhdGVMaW1pdGVkUXVldWV9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0cyA9IG5ldyBSYXRlTGltaXRlZFF1ZXVlKHRoaXMub3B0cy5saW1pdClcblxuICAgIHRoaXMudXBsb2FkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHRoaXMudXBsb2FkZXJFdmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgdGhpcy51cGxvYWRlclNvY2tldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICB0aGlzLmhhbmRsZVJlc2V0UHJvZ3Jlc3MgPSB0aGlzLmhhbmRsZVJlc2V0UHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlVXBsb2FkID0gdGhpcy5oYW5kbGVVcGxvYWQuYmluZCh0aGlzKVxuICB9XG5cbiAgaGFuZGxlUmVzZXRQcm9ncmVzcyAoKSB7XG4gICAgY29uc3QgZmlsZXMgPSB7IC4uLnRoaXMudXBweS5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAvLyBPbmx5IGNsb25lIHRoZSBmaWxlIG9iamVjdCBpZiBpdCBoYXMgYSBUdXMgYHVwbG9hZFVybGAgYXR0YWNoZWQuXG4gICAgICBpZiAoZmlsZXNbZmlsZUlEXS50dXMgJiYgZmlsZXNbZmlsZUlEXS50dXMudXBsb2FkVXJsKSB7XG4gICAgICAgIGNvbnN0IHR1c1N0YXRlID0geyAuLi5maWxlc1tmaWxlSURdLnR1cyB9XG4gICAgICAgIGRlbGV0ZSB0dXNTdGF0ZS51cGxvYWRVcmxcbiAgICAgICAgZmlsZXNbZmlsZUlEXSA9IHsgLi4uZmlsZXNbZmlsZUlEXSwgdHVzOiB0dXNTdGF0ZSB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7IGZpbGVzIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgYWxsIHJlZmVyZW5jZXMgZm9yIGEgZmlsZSdzIHVwbG9hZDogdGhlIHR1cy5VcGxvYWQgaW5zdGFuY2UsXG4gICAqIGFueSBldmVudHMgcmVsYXRlZCB0byB0aGUgZmlsZSwgYW5kIHRoZSBDb21wYW5pb24gV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICovXG4gIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzIChmaWxlSUQsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0aGlzLnVwbG9hZGVyc1tmaWxlSURdKSB7XG4gICAgICBjb25zdCB1cGxvYWRlciA9IHRoaXMudXBsb2FkZXJzW2ZpbGVJRF1cbiAgICAgIHVwbG9hZGVyLmFib3J0KClcbiAgICAgIGlmIChvcHRzLmFib3J0KSB7XG4gICAgICAgIC8vIHRvIGF2b2lkIDQyMyBlcnJvciBmcm9tIHR1cyBzZXJ2ZXIsIHdlIHdhaXRcbiAgICAgICAgLy8gdG8gYmUgc3VyZSB0aGUgcHJldmlvdXMgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGJlZm9yZSB0ZXJtaW5hdGluZyB0aGUgdXBsb2FkXG4gICAgICAgIC8vIEB0b2RvIHJlbW92ZSB0aGUgdGltZW91dCB3aGVuIHRoaXMgXCJ3YWl0XCIgaXMgaGFuZGxlZCBpbiB0dXMtanMtY2xpZW50IGludGVybmFsbHlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB1cGxvYWRlci5hYm9ydCh0cnVlKSwgMTAwMClcbiAgICAgIH1cbiAgICAgIHRoaXMudXBsb2FkZXJzW2ZpbGVJRF0gPSBudWxsXG4gICAgfVxuICAgIGlmICh0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0pIHtcbiAgICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5yZW1vdmUoKVxuICAgICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy51cGxvYWRlclNvY2tldHNbZmlsZUlEXSkge1xuICAgICAgdGhpcy51cGxvYWRlclNvY2tldHNbZmlsZUlEXS5jbG9zZSgpXG4gICAgICB0aGlzLnVwbG9hZGVyU29ja2V0c1tmaWxlSURdID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgVHVzIHVwbG9hZC5cbiAgICpcbiAgICogQSBsb3QgY2FuIGhhcHBlbiBkdXJpbmcgYW4gdXBsb2FkLCBzbyB0aGlzIGlzIHF1aXRlIGhhcmQgdG8gZm9sbG93IVxuICAgKiAtIEZpcnN0LCB0aGUgdXBsb2FkIGlzIHN0YXJ0ZWQuIElmIHRoZSBmaWxlIHdhcyBhbHJlYWR5IHBhdXNlZCBieSB0aGUgdGltZSB0aGUgdXBsb2FkIHN0YXJ0cywgbm90aGluZyBzaG91bGQgaGFwcGVuLlxuICAgKiAgIElmIHRoZSBgbGltaXRgIG9wdGlvbiBpcyB1c2VkLCB0aGUgdXBsb2FkIG11c3QgYmUgcXVldWVkIG9udG8gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS5cbiAgICogICBXaGVuIGFuIHVwbG9hZCBzdGFydHMsIHdlIHN0b3JlIHRoZSB0dXMuVXBsb2FkIGluc3RhbmNlLCBhbmQgYW4gRXZlbnRUcmFja2VyIGluc3RhbmNlIHRoYXQgbWFuYWdlcyB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAqICAgZm9yIHBhdXNpbmcsIGNhbmNlbGxhdGlvbiwgcmVtb3ZhbCwgZXRjLlxuICAgKiAtIFdoaWxlIHRoZSB1cGxvYWQgaXMgaW4gcHJvZ3Jlc3MsIGl0IG1heSBiZSBwYXVzZWQgb3IgY2FuY2VsbGVkLlxuICAgKiAgIFBhdXNpbmcgYWJvcnRzIHRoZSB1bmRlcmx5aW5nIHR1cy5VcGxvYWQsIGFuZCByZW1vdmVzIHRoZSB1cGxvYWQgZnJvbSB0aGUgYHRoaXMucmVxdWVzdHNgIHF1ZXVlLiBBbGwgb3RoZXIgc3RhdGUgaXNcbiAgICogICBtYWludGFpbmVkLlxuICAgKiAgIENhbmNlbGxpbmcgcmVtb3ZlcyB0aGUgdXBsb2FkIGZyb20gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZSwgYW5kIGNvbXBsZXRlbHkgYWJvcnRzIHRoZSB1cGxvYWQtLXRoZSB0dXMuVXBsb2FkIGluc3RhbmNlXG4gICAqICAgaXMgYWJvcnRlZCBhbmQgZGlzY2FyZGVkLCB0aGUgRXZlbnRUcmFja2VyIGluc3RhbmNlIGlzIGRlc3Ryb3llZCAocmVtb3ZpbmcgYWxsIGxpc3RlbmVycykuXG4gICAqICAgUmVzdW1pbmcgdGhlIHVwbG9hZCB1c2VzIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUgYXMgd2VsbCwgdG8gcHJldmVudCBzZWxlY3RpdmVseSBwYXVzaW5nIGFuZCByZXN1bWluZyB1cGxvYWRzIGZyb21cbiAgICogICBieXBhc3NpbmcgdGhlIGxpbWl0LlxuICAgKiAtIEFmdGVyIGNvbXBsZXRpbmcgYW4gdXBsb2FkLCB0aGUgdHVzLlVwbG9hZCBhbmQgRXZlbnRUcmFja2VyIGluc3RhbmNlcyBhcmUgY2xlYW5lZCB1cCwgYW5kIHRoZSB1cGxvYWQgaXMgbWFya2VkIGFzIGRvbmVcbiAgICogICBpbiB0aGUgYHRoaXMucmVxdWVzdHNgIHF1ZXVlLlxuICAgKiAtIFdoZW4gYW4gdXBsb2FkIGNvbXBsZXRlZCB3aXRoIGFuIGVycm9yLCB0aGUgc2FtZSBoYXBwZW5zIGFzIG9uIHN1Y2Nlc3NmdWwgY29tcGxldGlvbiwgYnV0IHRoZSBgdXBsb2FkKClgIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqXG4gICAqIFdoZW4gd29ya2luZyBvbiB0aGlzIGZ1bmN0aW9uLCBrZWVwIGluIG1pbmQ6XG4gICAqICAtIFdoZW4gYW4gdXBsb2FkIGlzIGNvbXBsZXRlZCBvciBjYW5jZWxsZWQgZm9yIGFueSByZWFzb24sIHRoZSB0dXMuVXBsb2FkIGFuZCBFdmVudFRyYWNrZXIgaW5zdGFuY2VzIG5lZWQgdG8gYmUgY2xlYW5lZCB1cCB1c2luZyB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkuXG4gICAqICAtIFdoZW4gYW4gdXBsb2FkIGlzIGNhbmNlbGxlZCBvciBwYXVzZWQsIGZvciBhbnkgcmVhc29uLCBpdCBuZWVkcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZSB1c2luZyBgcXVldWVkUmVxdWVzdC5hYm9ydCgpYC5cbiAgICogIC0gV2hlbiBhbiB1cGxvYWQgaXMgY29tcGxldGVkIGZvciBhbnkgcmVhc29uLCBpbmNsdWRpbmcgZXJyb3JzLCBpdCBuZWVkcyB0byBiZSBtYXJrZWQgYXMgc3VjaCB1c2luZyBgcXVldWVkUmVxdWVzdC5kb25lKClgLlxuICAgKiAgLSBXaGVuIGFuIHVwbG9hZCBpcyBzdGFydGVkIG9yIHJlc3VtZWQsIGl0IG5lZWRzIHRvIGdvIHRocm91Z2ggdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS4gVGhlIGBxdWV1ZWRSZXF1ZXN0YCB2YXJpYWJsZSBtdXN0IGJlIHVwZGF0ZWQgc28gdGhlIG90aGVyIHVzZXMgb2YgaXQgYXJlIHZhbGlkLlxuICAgKiAgLSBCZWZvcmUgcmVwbGFjaW5nIHRoZSBgcXVldWVkUmVxdWVzdGAgdmFyaWFibGUsIHRoZSBwcmV2aW91cyBgcXVldWVkUmVxdWVzdGAgbXVzdCBiZSBhYm9ydGVkLCBlbHNlIGl0IHdpbGwga2VlcCB0YWtpbmcgdXAgYSBzcG90IGluIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZSBmb3IgdXNlIHdpdGggdXBsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50IGZpbGUgaW4gYSBxdWV1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWwgbnVtYmVyIG9mIGZpbGVzIGluIGEgcXVldWVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICB1cGxvYWQgKGZpbGUsIGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHR1cyB1cGxvYWRcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdGFydGVkJywgZmlsZSlcblxuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAuLi4oZmlsZS50dXMgfHwge30pLFxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge1Jhd1R1c09wdGlvbnN9ICovXG4gICAgICBjb25zdCB1cGxvYWRPcHRpb25zID0ge1xuICAgICAgICAuLi50dXNEZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgLy8gVE9ETyBvbmx5IHB1dCB0dXMtc3BlY2lmaWMgb3B0aW9ucyBpbj9cbiAgICAgICAgLi4ub3B0cyxcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHVwbG9hZE9wdGlvbnMucmVzdW1lXG5cbiAgICAgIC8vIE1ha2UgYHJlc3VtZTogdHJ1ZWAgd29yayBsaWtlIGl0IGRpZCBpbiB0dXMtanMtY2xpZW50IHYxLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIGluIEB1cHB5L3R1cyB2MlxuICAgICAgaWYgKG9wdHMucmVzdW1lKSB7XG4gICAgICAgIHVwbG9hZE9wdGlvbnMuc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICAvLyBXZSBvdmVycmlkZSB0dXMgZmluZ2VycHJpbnQgdG8gdXBweeKAmXMgYGZpbGUuaWRgLCBzaW5jZSB0aGUgYGZpbGUuaWRgXG4gICAgICAvLyBub3cgYWxzbyBpbmNsdWRlcyBgcmVsYXRpdmVQYXRoYCBmb3IgZmlsZXMgYWRkZWQgZnJvbSBmb2xkZXJzLlxuICAgICAgLy8gVGhpcyBtZWFucyB5b3UgY2FuIGFkZCAyIGlkZW50aWNhbCBmaWxlcywgaWYgb25lIGlzIGluIGZvbGRlciBhLFxuICAgICAgLy8gdGhlIG90aGVyIGluIGZvbGRlciBiLlxuICAgICAgdXBsb2FkT3B0aW9ucy5maW5nZXJwcmludCA9IGdldEZpbmdlcnByaW50KGZpbGUpXG5cbiAgICAgIHVwbG9hZE9wdGlvbnMub25CZWZvcmVSZXF1ZXN0ID0gKHJlcSkgPT4ge1xuICAgICAgICBjb25zdCB4aHIgPSByZXEuZ2V0VW5kZXJseWluZ09iamVjdCgpXG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uQmVmb3JlUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9wdHMub25CZWZvcmVSZXF1ZXN0KHJlcSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuXG4gICAgICAgIGNvbnN0IHhociA9IGVyci5vcmlnaW5hbFJlcXVlc3QgPyBlcnIub3JpZ2luYWxSZXF1ZXN0LmdldFVuZGVybHlpbmdPYmplY3QoKSA6IG51bGxcbiAgICAgICAgaWYgKGlzTmV0d29ya0Vycm9yKHhocikpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgTmV0d29ya0Vycm9yKGVyciwgeGhyKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtZXJyb3InLCBmaWxlLCBlcnIpXG5cbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgIH1cblxuICAgICAgdXBsb2FkT3B0aW9ucy5vblByb2dyZXNzID0gKGJ5dGVzVXBsb2FkZWQsIGJ5dGVzVG90YWwpID0+IHtcbiAgICAgICAgdGhpcy5vblJlY2VpdmVVcGxvYWRVcmwoZmlsZSwgdXBsb2FkLnVybClcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1wcm9ncmVzcycsIGZpbGUsIHtcbiAgICAgICAgICB1cGxvYWRlcjogdGhpcyxcbiAgICAgICAgICBieXRlc1VwbG9hZGVkLFxuICAgICAgICAgIGJ5dGVzVG90YWwsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHVwbG9hZE9wdGlvbnMub25TdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1cGxvYWRSZXNwID0ge1xuICAgICAgICAgIHVwbG9hZFVSTDogdXBsb2FkLnVybCxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcXVldWVkUmVxdWVzdC5kb25lKClcblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN1Y2Nlc3MnLCBmaWxlLCB1cGxvYWRSZXNwKVxuXG4gICAgICAgIGlmICh1cGxvYWQudXJsKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhgRG93bmxvYWQgJHt1cGxvYWQuZmlsZS5uYW1lfSBmcm9tICR7dXBsb2FkLnVybH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSh1cGxvYWQpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvcHlQcm9wID0gKG9iaiwgc3JjUHJvcCwgZGVzdFByb3ApID0+IHtcbiAgICAgICAgaWYgKGhhc1Byb3BlcnR5KG9iaiwgc3JjUHJvcCkgJiYgIWhhc1Byb3BlcnR5KG9iaiwgZGVzdFByb3ApKSB7XG4gICAgICAgICAgb2JqW2Rlc3RQcm9wXSA9IG9ialtzcmNQcm9wXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICAgIGNvbnN0IG1ldGEgPSB7fVxuICAgICAgY29uc3QgbWV0YUZpZWxkcyA9IEFycmF5LmlzQXJyYXkob3B0cy5tZXRhRmllbGRzKVxuICAgICAgICA/IG9wdHMubWV0YUZpZWxkc1xuICAgICAgICAvLyBTZW5kIGFsb25nIGFsbCBmaWVsZHMgYnkgZGVmYXVsdC5cbiAgICAgICAgOiBPYmplY3Qua2V5cyhmaWxlLm1ldGEpXG4gICAgICBtZXRhRmllbGRzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgbWV0YVtpdGVtXSA9IGZpbGUubWV0YVtpdGVtXVxuICAgICAgfSlcblxuICAgICAgLy8gdHVzZCB1c2VzIG1ldGFkYXRhIGZpZWxkcyAnZmlsZXR5cGUnIGFuZCAnZmlsZW5hbWUnXG4gICAgICBjb3B5UHJvcChtZXRhLCAndHlwZScsICdmaWxldHlwZScpXG4gICAgICBjb3B5UHJvcChtZXRhLCAnbmFtZScsICdmaWxlbmFtZScpXG5cbiAgICAgIHVwbG9hZE9wdGlvbnMubWV0YWRhdGEgPSBtZXRhXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUuZGF0YSwgdXBsb2FkT3B0aW9ucylcbiAgICAgIHRoaXMudXBsb2FkZXJzW2ZpbGUuaWRdID0gdXBsb2FkXG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGUuaWRdID0gbmV3IEV2ZW50VHJhY2tlcih0aGlzLnVwcHkpXG5cbiAgICAgIC8vIE1ha2UgYHJlc3VtZTogdHJ1ZWAgd29yayBsaWtlIGl0IGRpZCBpbiB0dXMtanMtY2xpZW50IHYxLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIGluIEB1cHB5L3R1cyB2Mi5cbiAgICAgIGlmIChvcHRzLnJlc3VtZSkge1xuICAgICAgICB1cGxvYWQuZmluZFByZXZpb3VzVXBsb2FkcygpLnRoZW4oKHByZXZpb3VzVXBsb2FkcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzVXBsb2FkID0gcHJldmlvdXNVcGxvYWRzWzBdXG4gICAgICAgICAgaWYgKHByZXZpb3VzVXBsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLnVwcHkubG9nKGBbVHVzXSBSZXN1bWluZyB1cGxvYWQgb2YgJHtmaWxlLmlkfSBzdGFydGVkIGF0ICR7cHJldmlvdXNVcGxvYWQuY3JlYXRpb25UaW1lfWApXG4gICAgICAgICAgICB1cGxvYWQucmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkKHByZXZpb3VzVXBsb2FkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgbGV0IHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLnJ1bigoKSA9PiB7XG4gICAgICAgIGlmICghZmlsZS5pc1BhdXNlZCkge1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGdldHMgc2NoZWR1bGVkIHRvIHJ1biBfYWZ0ZXJfIGBmaW5kUHJldmlvdXNVcGxvYWRzKClgIHJldHVybnMuXG4gICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGluIEB1cHB5L3R1cyB2Mi5cbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHVwbG9hZC5zdGFydCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBoZXJlLCB0aGUgY2FsbGVyIHdpbGwgdGFrZSBjYXJlIG9mIGNhbmNlbGxpbmcgdGhlIHVwbG9hZCBpdHNlbGZcbiAgICAgICAgLy8gdXNpbmcgcmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoKS4gVGhpcyBpcyBiZWNhdXNlIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkgaGFzIHRvIGJlXG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoaXMgcmVxdWVzdCBpcyBzdGlsbCBpbiB0aGUgcXVldWUsIGFuZCBoYXMgbm90IGJlZW4gc3RhcnRlZCB5ZXQsIHRvby4gQXRcbiAgICAgICAgLy8gdGhhdCBwb2ludCB0aGlzIGNhbmNlbGxhdGlvbiBmdW5jdGlvbiBpcyBub3QgZ29pbmcgdG8gYmUgY2FsbGVkLlxuICAgICAgICAvLyBBbHNvLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgcmVxdWVzdCBmcm9tIHRoZSBxdWV1ZSBfd2l0aG91dF8gZGVzdHJveWluZyBldmVyeXRoaW5nXG4gICAgICAgIC8vIHJlbGF0ZWQgdG8gdGhpcyB1cGxvYWQgdG8gaGFuZGxlIHBhdXNlcy5cbiAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uRmlsZVJlbW92ZShmaWxlLmlkLCAodGFyZ2V0RmlsZUlEKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQsIHsgYWJvcnQ6ICEhdXBsb2FkLnVybCB9KVxuICAgICAgICByZXNvbHZlKGB1cGxvYWQgJHt0YXJnZXRGaWxlSUR9IHdhcyByZW1vdmVkYClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25QYXVzZShmaWxlLmlkLCAoaXNQYXVzZWQpID0+IHtcbiAgICAgICAgaWYgKGlzUGF1c2VkKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgZmlsZSBmcm9tIHRoZSBxdWV1ZSBzbyBhbm90aGVyIGZpbGUgY2FuIHN0YXJ0IGluIGl0cyBwbGFjZS5cbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlc3VtaW5nIGFuIHVwbG9hZCBzaG91bGQgYmUgcXVldWVkLCBlbHNlIHlvdSBjb3VsZCBwYXVzZSBhbmQgdGhlbiByZXN1bWUgYSBxdWV1ZWQgdXBsb2FkIHRvIG1ha2UgaXQgc2tpcCB0aGUgcXVldWUuXG4gICAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgcXVldWVkUmVxdWVzdCA9IHRoaXMucmVxdWVzdHMucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHVwbG9hZC5zdGFydCgpXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2VBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgdXBsb2FkLmFib3J0KClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25DYW5jZWxBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkLCB7IGFib3J0OiAhIXVwbG9hZC51cmwgfSlcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7ZmlsZS5pZH0gd2FzIGNhbmNlbGVkYClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXN1bWVBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgaWYgKGZpbGUuZXJyb3IpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoKVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdXBsb2FkLnN0YXJ0KClcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZSBmb3IgdXNlIHdpdGggdXBsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50IGZpbGUgaW4gYSBxdWV1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWwgbnVtYmVyIG9mIGZpbGVzIGluIGEgcXVldWVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICB1cGxvYWRSZW1vdGUgKGZpbGUsIGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4udGhpcy5vcHRzIH1cbiAgICBpZiAoZmlsZS50dXMpIHtcbiAgICAgIC8vIEluc3RhbGwgZmlsZS1zcGVjaWZpYyB1cGxvYWQgb3ZlcnJpZGVzLlxuICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCBmaWxlLnR1cylcbiAgICB9XG5cbiAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN0YXJ0ZWQnLCBmaWxlKVxuICAgIHRoaXMudXBweS5sb2coZmlsZS5yZW1vdGUudXJsKVxuXG4gICAgaWYgKGZpbGUuc2VydmVyVG9rZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RUb1NlcnZlclNvY2tldChmaWxlKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBDbGllbnQgPSBmaWxlLnJlbW90ZS5wcm92aWRlck9wdGlvbnMucHJvdmlkZXIgPyBQcm92aWRlciA6IFJlcXVlc3RDbGllbnRcbiAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQodGhpcy51cHB5LCBmaWxlLnJlbW90ZS5wcm92aWRlck9wdGlvbnMpXG5cbiAgICAgIC8vICEhIGNhbmNlbGxhdGlvbiBpcyBOT1Qgc3VwcG9ydGVkIGF0IHRoaXMgc3RhZ2UgeWV0XG4gICAgICBjbGllbnQucG9zdChmaWxlLnJlbW90ZS51cmwsIHtcbiAgICAgICAgLi4uZmlsZS5yZW1vdGUuYm9keSxcbiAgICAgICAgZW5kcG9pbnQ6IG9wdHMuZW5kcG9pbnQsXG4gICAgICAgIHVwbG9hZFVybDogb3B0cy51cGxvYWRVcmwsXG4gICAgICAgIHByb3RvY29sOiAndHVzJyxcbiAgICAgICAgc2l6ZTogZmlsZS5kYXRhLnNpemUsXG4gICAgICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVycyxcbiAgICAgICAgbWV0YWRhdGE6IGZpbGUubWV0YSxcbiAgICAgIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICB0aGlzLnVwcHkuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHsgc2VydmVyVG9rZW46IHJlcy50b2tlbiB9KVxuICAgICAgICBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZS5pZClcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFRvU2VydmVyU29ja2V0KGZpbGUpXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtZXJyb3InLCBmaWxlLCBlcnIpXG4gICAgICAgIHJlamVjdChlcnIpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VlIHRoZSBjb21tZW50IG9uIHRoZSB1cGxvYWQoKSBtZXRob2QuXG4gICAqXG4gICAqIEFkZGl0aW9uYWxseSwgd2hlbiBhbiB1cGxvYWQgaXMgcmVtb3ZlZCwgY29tcGxldGVkLCBvciBjYW5jZWxsZWQsIHdlIG5lZWQgdG8gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkgZnVuY3Rpb24sIHNvIHRoZSBzYW1lIGd1aWRlbGluZXMgYXBwbHkgYXMgaW4gdXBsb2FkKCkuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBweUZpbGV9IGZpbGVcbiAgICovXG4gIGNvbm5lY3RUb1NlcnZlclNvY2tldCAoZmlsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0b2tlbiA9IGZpbGUuc2VydmVyVG9rZW5cbiAgICAgIGNvbnN0IGhvc3QgPSBnZXRTb2NrZXRIb3N0KGZpbGUucmVtb3RlLmNvbXBhbmlvblVybClcbiAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBTb2NrZXQoeyB0YXJnZXQ6IGAke2hvc3R9L2FwaS8ke3Rva2VufWAsIGF1dG9PcGVuOiBmYWxzZSB9KVxuICAgICAgdGhpcy51cGxvYWRlclNvY2tldHNbZmlsZS5pZF0gPSBzb2NrZXRcbiAgICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZS5pZF0gPSBuZXcgRXZlbnRUcmFja2VyKHRoaXMudXBweSlcblxuICAgICAgdGhpcy5vbkZpbGVSZW1vdmUoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgLy8gc3RpbGwgc2VuZCBwYXVzZSBldmVudCBpbiBjYXNlIHdlIGFyZSBkZWFsaW5nIHdpdGggb2xkZXIgdmVyc2lvbiBvZiBjb21wYW5pb25cbiAgICAgICAgLy8gQHRvZG8gZG9uJ3Qgc2VuZCBwYXVzZSBldmVudCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgc29ja2V0LnNlbmQoJ2NhbmNlbCcsIHt9KVxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG4gICAgICAgIHJlc29sdmUoYHVwbG9hZCAke2ZpbGUuaWR9IHdhcyByZW1vdmVkYClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25QYXVzZShmaWxlLmlkLCAoaXNQYXVzZWQpID0+IHtcbiAgICAgICAgaWYgKGlzUGF1c2VkKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgZmlsZSBmcm9tIHRoZSBxdWV1ZSBzbyBhbm90aGVyIGZpbGUgY2FuIHN0YXJ0IGluIGl0cyBwbGFjZS5cbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXN1bWluZyBhbiB1cGxvYWQgc2hvdWxkIGJlIHF1ZXVlZCwgZWxzZSB5b3UgY291bGQgcGF1c2UgYW5kIHRoZW4gcmVzdW1lIGEgcXVldWVkIHVwbG9hZCB0byBtYWtlIGl0IHNraXAgdGhlIHF1ZXVlLlxuICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2VBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uQ2FuY2VsQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIC8vIHN0aWxsIHNlbmQgcGF1c2UgZXZlbnQgaW4gY2FzZSB3ZSBhcmUgZGVhbGluZyB3aXRoIG9sZGVyIHZlcnNpb24gb2YgY29tcGFuaW9uXG4gICAgICAgIC8vIEB0b2RvIGRvbid0IHNlbmQgcGF1c2UgZXZlbnQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIHNvY2tldC5zZW5kKCdjYW5jZWwnLCB7fSlcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuICAgICAgICByZXNvbHZlKGB1cGxvYWQgJHtmaWxlLmlkfSB3YXMgY2FuY2VsZWRgKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblJlc3VtZUFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICBpZiAoZmlsZS5lcnJvcikge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgc29ja2V0LnNlbmQoJ3Jlc3VtZScsIHt9KVxuICAgICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblJldHJ5KGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgLy8gT25seSBkbyB0aGUgcmV0cnkgaWYgdGhlIHVwbG9hZCBpcyBhY3R1YWxseSBpbiBwcm9ncmVzcztcbiAgICAgICAgLy8gZWxzZSB3ZSBjb3VsZCB0cnkgdG8gc2VuZCB0aGVzZSBtZXNzYWdlcyB3aGVuIHRoZSB1cGxvYWQgaXMgc3RpbGwgcXVldWVkLlxuICAgICAgICAvLyBXZSBtYXkgbmVlZCBhIGJldHRlciBjaGVjayBmb3IgdGhpcyBzaW5jZSB0aGUgc29ja2V0IG1heSBhbHNvIGJlIGNsb3NlZFxuICAgICAgICAvLyBmb3Igb3RoZXIgcmVhc29ucywgbGlrZSBuZXR3b3JrIGZhaWx1cmVzLlxuICAgICAgICBpZiAoc29ja2V0LmlzT3Blbikge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICAgIHNvY2tldC5zZW5kKCdyZXN1bWUnLCB7fSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblJldHJ5QWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBvblJldHJ5KCkgY2FsbFxuICAgICAgICBpZiAoc29ja2V0LmlzT3Blbikge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICAgIHNvY2tldC5zZW5kKCdyZXN1bWUnLCB7fSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdwcm9ncmVzcycsIChwcm9ncmVzc0RhdGEpID0+IGVtaXRTb2NrZXRQcm9ncmVzcyh0aGlzLCBwcm9ncmVzc0RhdGEsIGZpbGUpKVxuXG4gICAgICBzb2NrZXQub24oJ2Vycm9yJywgKGVyckRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBlcnJEYXRhLmVycm9yXG4gICAgICAgIGNvbnN0IGVycm9yID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IobWVzc2FnZSksIHsgY2F1c2U6IGVyckRhdGEuZXJyb3IgfSlcblxuICAgICAgICAvLyBJZiB0aGUgcmVtb3RlIHJldHJ5IG9wdGltaXNhdGlvbiBzaG91bGQgbm90IGJlIHVzZWQsXG4gICAgICAgIC8vIGNsb3NlIHRoZSBzb2NrZXTigJR0aGlzIHdpbGwgdGVsbCBjb21wYW5pb24gdG8gY2xlYXIgc3RhdGUgYW5kIGRlbGV0ZSB0aGUgZmlsZS5cbiAgICAgICAgaWYgKCF0aGlzLm9wdHMudXNlRmFzdFJlbW90ZVJldHJ5KSB7XG4gICAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VydmVyVG9rZW4gc28gdGhhdCBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgcmV0cnkuXG4gICAgICAgICAgdGhpcy51cHB5LnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7XG4gICAgICAgICAgICBzZXJ2ZXJUb2tlbjogbnVsbCxcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvY2tldC5jbG9zZSgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyb3IpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignc3VjY2VzcycsIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwbG9hZFJlc3AgPSB7XG4gICAgICAgICAgdXBsb2FkVVJMOiBkYXRhLnVybCxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtc3VjY2VzcycsIGZpbGUsIHVwbG9hZFJlc3ApXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcXVldWVkUmVxdWVzdC5kb25lKClcblxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG5cbiAgICAgIGxldCBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICBzb2NrZXQub3BlbigpXG4gICAgICAgIGlmIChmaWxlLmlzUGF1c2VkKSB7XG4gICAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBoZXJlLCB0aGUgY2FsbGVyIHdpbGwgdGFrZSBjYXJlIG9mIGNhbmNlbGxpbmcgdGhlIHVwbG9hZCBpdHNlbGZcbiAgICAgICAgLy8gdXNpbmcgcmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoKS4gVGhpcyBpcyBiZWNhdXNlIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkgaGFzIHRvIGJlXG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoaXMgcmVxdWVzdCBpcyBzdGlsbCBpbiB0aGUgcXVldWUsIGFuZCBoYXMgbm90IGJlZW4gc3RhcnRlZCB5ZXQsIHRvby4gQXRcbiAgICAgICAgLy8gdGhhdCBwb2ludCB0aGlzIGNhbmNlbGxhdGlvbiBmdW5jdGlvbiBpcyBub3QgZ29pbmcgdG8gYmUgY2FsbGVkLlxuICAgICAgICAvLyBBbHNvLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgcmVxdWVzdCBmcm9tIHRoZSBxdWV1ZSBfd2l0aG91dF8gZGVzdHJveWluZyBldmVyeXRoaW5nXG4gICAgICAgIC8vIHJlbGF0ZWQgdG8gdGhpcyB1cGxvYWQgdG8gaGFuZGxlIHBhdXNlcy5cbiAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgdGhlIHVwbG9hZFVybCBvbiB0aGUgZmlsZSBvcHRpb25zLCBzbyB0aGF0IHdoZW4gR29sZGVuIFJldHJpZXZlclxuICAgKiByZXN0b3JlcyBzdGF0ZSwgd2Ugd2lsbCBjb250aW51ZSB1cGxvYWRpbmcgdG8gdGhlIGNvcnJlY3QgVVJMLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwcHlGaWxlfSBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cGxvYWRVUkxcbiAgICovXG4gIG9uUmVjZWl2ZVVwbG9hZFVybCAoZmlsZSwgdXBsb2FkVVJMKSB7XG4gICAgY29uc3QgY3VycmVudEZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlLmlkKVxuICAgIGlmICghY3VycmVudEZpbGUpIHJldHVyblxuICAgIC8vIE9ubHkgZG8gdGhlIHVwZGF0ZSBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiB1cGxvYWQgVVJMIHlldC5cbiAgICBpZiAoIWN1cnJlbnRGaWxlLnR1cyB8fCBjdXJyZW50RmlsZS50dXMudXBsb2FkVXJsICE9PSB1cGxvYWRVUkwpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tUdXNdIFN0b3JpbmcgdXBsb2FkIHVybCcpXG4gICAgICB0aGlzLnVwcHkuc2V0RmlsZVN0YXRlKGN1cnJlbnRGaWxlLmlkLCB7XG4gICAgICAgIHR1czogeyAuLi5jdXJyZW50RmlsZS50dXMsIHVwbG9hZFVybDogdXBsb2FkVVJMIH0sXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKTogdm9pZH0gY2JcbiAgICovXG4gIG9uRmlsZVJlbW92ZSAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbignZmlsZS1yZW1vdmVkJywgKGZpbGUpID0+IHtcbiAgICAgIGlmIChmaWxlSUQgPT09IGZpbGUuaWQpIGNiKGZpbGUuaWQpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oYm9vbGVhbik6IHZvaWR9IGNiXG4gICAqL1xuICBvblBhdXNlIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCd1cGxvYWQtcGF1c2UnLCAodGFyZ2V0RmlsZUlELCBpc1BhdXNlZCkgPT4ge1xuICAgICAgaWYgKGZpbGVJRCA9PT0gdGFyZ2V0RmlsZUlEKSB7XG4gICAgICAgIC8vIGNvbnN0IGlzUGF1c2VkID0gdGhpcy51cHB5LnBhdXNlUmVzdW1lKGZpbGVJRClcbiAgICAgICAgY2IoaXNQYXVzZWQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gY2JcbiAgICovXG4gIG9uUmV0cnkgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ3VwbG9hZC1yZXRyeScsICh0YXJnZXRGaWxlSUQpID0+IHtcbiAgICAgIGlmIChmaWxlSUQgPT09IHRhcmdldEZpbGVJRCkge1xuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gY2JcbiAgICovXG4gIG9uUmV0cnlBbGwgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ3JldHJ5LWFsbCcsIChmaWxlc1RvUmV0cnkpID0+IHtcbiAgICAgIGlmICghdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKSkgcmV0dXJuXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gY2JcbiAgICovXG4gIG9uUGF1c2VBbGwgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ3BhdXNlLWFsbCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKSkgcmV0dXJuXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gY2JcbiAgICovXG4gIG9uQ2FuY2VsQWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdjYW5jZWwtYWxsJywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpKSByZXR1cm5cbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBjYlxuICAgKi9cbiAgb25SZXN1bWVBbGwgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ3Jlc3VtZS1hbGwnLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpIHJldHVyblxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsoVXBweUZpbGUgfCBGYWlsZWRVcHB5RmlsZSlbXX0gZmlsZXNcbiAgICovXG4gIHVwbG9hZEZpbGVzIChmaWxlcykge1xuICAgIGNvbnN0IHByb21pc2VzID0gZmlsZXMubWFwKChmaWxlLCBpKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gaSArIDFcbiAgICAgIGNvbnN0IHRvdGFsID0gZmlsZXMubGVuZ3RoXG5cbiAgICAgIGlmICgnZXJyb3InIGluIGZpbGUgJiYgZmlsZS5lcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGZpbGUuZXJyb3IpKVxuICAgICAgfSBpZiAoZmlsZS5pc1JlbW90ZSkge1xuICAgICAgICAvLyBXZSBlbWl0IHVwbG9hZC1zdGFydGVkIGhlcmUsIHNvIHRoYXQgaXQncyBhbHNvIGVtaXR0ZWQgZm9yIGZpbGVzXG4gICAgICAgIC8vIHRoYXQgaGF2ZSB0byB3YWl0IGR1ZSB0byB0aGUgYGxpbWl0YCBvcHRpb24uXG4gICAgICAgIC8vIERvbid0IGRvdWJsZS1lbWl0IHVwbG9hZC1zdGFydGVkIGZvciBHb2xkZW4gUmV0cmlldmVyLXJlc3RvcmVkIGZpbGVzIHRoYXQgd2VyZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgaWYgKCFmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQgfHwgIWZpbGUuaXNSZXN0b3JlZCkge1xuICAgICAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtc3RhcnRlZCcsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkUmVtb3RlKGZpbGUsIGN1cnJlbnQsIHRvdGFsKVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgZG91YmxlLWVtaXQgdXBsb2FkLXN0YXJ0ZWQgZm9yIEdvbGRlbiBSZXRyaWV2ZXItcmVzdG9yZWQgZmlsZXMgdGhhdCB3ZXJlIGFscmVhZHkgc3RhcnRlZFxuICAgICAgaWYgKCFmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQgfHwgIWZpbGUuaXNSZXN0b3JlZCkge1xuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN0YXJ0ZWQnLCBmaWxlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudXBsb2FkKGZpbGUsIGN1cnJlbnQsIHRvdGFsKVxuICAgIH0pXG5cbiAgICByZXR1cm4gc2V0dGxlKHByb21pc2VzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZpbGVJRHNcbiAgICovXG4gIGhhbmRsZVVwbG9hZCAoZmlsZUlEcykge1xuICAgIGlmIChmaWxlSURzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy51cHB5LmxvZygnW1R1c10gTm8gZmlsZXMgdG8gdXBsb2FkJylcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMubGltaXQgPT09IDApIHtcbiAgICAgIHRoaXMudXBweS5sb2coXG4gICAgICAgICdbVHVzXSBXaGVuIHVwbG9hZGluZyBtdWx0aXBsZSBmaWxlcyBhdCBvbmNlLCBjb25zaWRlciBzZXR0aW5nIHRoZSBgbGltaXRgIG9wdGlvbiAodG8gYDEwYCBmb3IgZXhhbXBsZSksIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgY29uY3VycmVudCB1cGxvYWRzLCB3aGljaCBoZWxwcyBwcmV2ZW50IG1lbW9yeSBhbmQgbmV0d29yayBpc3N1ZXM6IGh0dHBzOi8vdXBweS5pby9kb2NzL3R1cy8jbGltaXQtMCcsXG4gICAgICAgICd3YXJuaW5nJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMudXBweS5sb2coJ1tUdXNdIFVwbG9hZGluZy4uLicpXG4gICAgY29uc3QgZmlsZXNUb1VwbG9hZCA9IGZpbGVJRHMubWFwKChmaWxlSUQpID0+IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpXG5cbiAgICByZXR1cm4gdGhpcy51cGxvYWRGaWxlcyhmaWxlc1RvVXBsb2FkKVxuICAgICAgLnRoZW4oKCkgPT4gbnVsbClcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7XG4gICAgICBjYXBhYmlsaXRpZXM6IHsgLi4udGhpcy51cHB5LmdldFN0YXRlKCkuY2FwYWJpbGl0aWVzLCByZXN1bWFibGVVcGxvYWRzOiB0cnVlIH0sXG4gICAgfSlcbiAgICB0aGlzLnVwcHkuYWRkVXBsb2FkZXIodGhpcy5oYW5kbGVVcGxvYWQpXG5cbiAgICB0aGlzLnVwcHkub24oJ3Jlc2V0LXByb2dyZXNzJywgdGhpcy5oYW5kbGVSZXNldFByb2dyZXNzKVxuXG4gICAgaWYgKHRoaXMub3B0cy5hdXRvUmV0cnkpIHtcbiAgICAgIHRoaXMudXBweS5vbignYmFjay1vbmxpbmUnLCB0aGlzLnVwcHkucmV0cnlBbGwpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgY2FwYWJpbGl0aWVzOiB7IC4uLnRoaXMudXBweS5nZXRTdGF0ZSgpLmNhcGFiaWxpdGllcywgcmVzdW1hYmxlVXBsb2FkczogZmFsc2UgfSxcbiAgICB9KVxuICAgIHRoaXMudXBweS5yZW1vdmVVcGxvYWRlcih0aGlzLmhhbmRsZVVwbG9hZClcblxuICAgIGlmICh0aGlzLm9wdHMuYXV0b1JldHJ5KSB7XG4gICAgICB0aGlzLnVwcHkub2ZmKCdiYWNrLW9ubGluZScsIHRoaXMudXBweS5yZXRyeUFsbClcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvdXJsXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgVXJsIHBsdWdpbiBsZXRzIHVzZXJzIGltcG9ydCBmaWxlcyBmcm9tIHRoZSBJbnRlcm5ldC4gUGFzdGUgYW55IFVSTCBhbmQgaXTigJlsbCBiZSBhZGRlZCFcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS41LjIyXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVybFwiLFxuICAgIFwiaW1wb3J0IGZyb20gdXJsXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29tcGFuaW9uLWNsaWVudFwiOiBcImZpbGU6Li4vY29tcGFuaW9uLWNsaWVudFwiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNsYXNzIFVybFVJIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5oYW5kbGVLZXlQcmVzcyA9IHRoaXMuaGFuZGxlS2V5UHJlc3MuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLmlucHV0LnZhbHVlID0gJydcbiAgfVxuXG4gIGhhbmRsZUtleVByZXNzIChldikge1xuICAgIGlmIChldi5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5wcm9wcy5hZGRGaWxlKHRoaXMuaW5wdXQudmFsdWUpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2xpY2sgKCkge1xuICAgIHRoaXMucHJvcHMuYWRkRmlsZSh0aGlzLmlucHV0LnZhbHVlKVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVVybFwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLXRleHRJbnB1dCB1cHB5LVVybC1pbnB1dFwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bignZW50ZXJVcmxUb0ltcG9ydCcpfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXt0aGlzLnByb3BzLmkxOG4oJ2VudGVyVXJsVG9JbXBvcnQnKX1cbiAgICAgICAgICBvbktleVVwPXt0aGlzLmhhbmRsZUtleVByZXNzfVxuICAgICAgICAgIHJlZj17KGlucHV0KSA9PiB7IHRoaXMuaW5wdXQgPSBpbnB1dCB9fVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeSB1cHB5LVVybC1pbXBvcnRCdXR0b25cIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG4gICAgICAgID5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuKCdpbXBvcnQnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVcmxVSVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IHsgUmVxdWVzdENsaWVudCB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCBVcmxVSSA9IHJlcXVpcmUoJy4vVXJsVUkuanMnKVxuY29uc3QgZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybCA9IHJlcXVpcmUoJy4vdXRpbHMvZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybCcpXG5cbmZ1bmN0aW9uIFVybEljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiNGRjc1M0VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yMi43ODggMTUuMzg5bC0yLjE5OSAyLjE5YTMuMTg0IDMuMTg0IDAgMCAxLS41MTMuNDM3Yy0uODA2LjU4NC0xLjY4Ni44NzYtMi42MzguODc2YTQuMzc4IDQuMzc4IDAgMCAxLTMuNTE5LTEuNzUyYy0uMjItLjI5Mi0uMTQ2LS44MDIuMTQ3LTEuMDIxLjI5My0uMjIuODA2LS4xNDYgMS4wMjYuMTQ2Ljk1MyAxLjMxMyAyLjc4NSAxLjUzMiA0LjEwNS41ODNhLjU3MS41NzEgMCAwIDAgLjI5My0uMjkybDIuMTk5LTIuMTg5YzEuMS0xLjE2NyAxLjEtMi45OTItLjA3My00LjA4NmEyLjk3NiAyLjk3NiAwIDAgMC00LjEwNSAwbC0xLjI0NiAxLjI0YS43MS43MSAwIDAgMS0xLjAyNiAwIC43MDMuNzAzIDAgMCAxIDAtMS4wMjJsMS4yNDYtMS4yNGE0LjMwNSA0LjMwNSAwIDAgMSA2LjA4MyAwYzEuODMzIDEuNjA1IDEuOTA2IDQuNDUxLjIyIDYuMTN6bS03LjE4MyA1LjAzNWwtMS4yNDYgMS4yNGEyLjk3NiAyLjk3NiAwIDAgMS00LjEwNSAwYy0xLjE3Mi0xLjA5NC0xLjE3Mi0yLjk5MS0uMDczLTQuMDg2bDIuMi0yLjE5LjI5Mi0uMjkxYy42Ni0uNDM4IDEuMzkzLS42NTcgMi4yLS41ODQuODA1LjE0NiAxLjQ2NS41MSAxLjkwNSAxLjE2OC4yMi4yOTIuNzMzLjM2NSAxLjAyNi4xNDYuMjkzLS4yMi4zNjctLjczLjE0Ny0xLjAyMi0uNzMzLS45NDktMS43Ni0xLjUzMi0yLjg1OS0xLjY3OC0xLjEtLjIyLTIuMjcyLjA3My0zLjIyNS44MDJsLS40NC40MzgtMi4xOTkgMi4xOWMtMS42ODYgMS43NS0xLjYxMiA0LjUyNC4wNzQgNi4yMDIuODguODAzIDEuOTc5IDEuMjQxIDMuMDc4IDEuMjQxIDEuMSAwIDIuMTk5LS40MzggMy4wNzktMS4yNGwxLjI0Ni0xLjI0MWEuNzAzLjcwMyAwIDAgMCAwLTEuMDIyYy0uMjk0LS4yOTItLjgwNy0uMzY1LTEuMS0uMDczelwiIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG4vKipcbiAqIFVybFxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVcmwgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnVXJsJ1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0xpbmsnXG4gICAgdGhpcy50eXBlID0gJ2FjcXVpcmVyJ1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IDxVcmxJY29uIC8+XG5cbiAgICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zIGFuZCBsb2NhbGVcbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7XG4gICAgICAgIGltcG9ydDogJ0ltcG9ydCcsXG4gICAgICAgIGVudGVyVXJsVG9JbXBvcnQ6ICdFbnRlciBVUkwgdG8gaW1wb3J0IGEgZmlsZScsXG4gICAgICAgIGZhaWxlZFRvRmV0Y2g6ICdDb21wYW5pb24gZmFpbGVkIHRvIGZldGNoIHRoaXMgVVJMLCBwbGVhc2UgbWFrZSBzdXJlIGl04oCZcyBjb3JyZWN0JyxcbiAgICAgICAgZW50ZXJDb3JyZWN0VXJsOiAnSW5jb3JyZWN0IFVSTDogUGxlYXNlIG1ha2Ugc3VyZSB5b3UgYXJlIGVudGVyaW5nIGEgZGlyZWN0IGxpbmsgdG8gYSBmaWxlJyxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fVxuXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG5cbiAgICBpZiAoIXRoaXMuaG9zdG5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcGFuaW9uIGhvc3RuYW1lIGlzIHJlcXVpcmVkLCBwbGVhc2UgY29uc3VsdCBodHRwczovL3VwcHkuaW8vZG9jcy9jb21wYW5pb24nKVxuICAgIH1cblxuICAgIC8vIEJpbmQgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciByZWZlcmVuY2FiaWxpdHlcbiAgICB0aGlzLmdldE1ldGEgPSB0aGlzLmdldE1ldGEuYmluZCh0aGlzKVxuICAgIHRoaXMuYWRkRmlsZSA9IHRoaXMuYWRkRmlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVSb290RHJvcCA9IHRoaXMuaGFuZGxlUm9vdERyb3AuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlUm9vdFBhc3RlID0gdGhpcy5oYW5kbGVSb290UGFzdGUuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5jbGllbnQgPSBuZXcgUmVxdWVzdENsaWVudCh1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgfSlcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICBzdXBlci5zZXRPcHRpb25zKG5ld09wdHMpXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLmkxOG5BcnJheSA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICBnZXRGaWxlTmFtZUZyb21VcmwgKHVybCkge1xuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZignLycpICsgMSlcbiAgfVxuXG4gIGNoZWNrSWZDb3JyZWN0VVJMICh1cmwpIHtcbiAgICBpZiAoIXVybCkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCBwcm90b2NvbCA9IHVybC5tYXRjaCgvXihbYS16MC05XSspOlxcL1xcLy8pWzFdXG4gICAgaWYgKHByb3RvY29sICE9PSAnaHR0cCcgJiYgcHJvdG9jb2wgIT09ICdodHRwcycpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBhZGRQcm90b2NvbFRvVVJMICh1cmwpIHtcbiAgICBjb25zdCBwcm90b2NvbFJlZ2V4ID0gL15bYS16MC05XSs6XFwvXFwvL1xuICAgIGNvbnN0IGRlZmF1bHRQcm90b2NvbCA9ICdodHRwOi8vJ1xuICAgIGlmIChwcm90b2NvbFJlZ2V4LnRlc3QodXJsKSkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0UHJvdG9jb2wgKyB1cmxcbiAgfVxuXG4gIGdldE1ldGEgKHVybCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5wb3N0KCd1cmwvbWV0YScsIHsgdXJsIH0pXG4gICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKCdbVVJMXSBFcnJvcjonKVxuICAgICAgICAgIHRoaXMudXBweS5sb2cocmVzLmVycm9yKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHRoZSBmaWxlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgICB9KVxuICB9XG5cbiAgYWRkRmlsZSAodXJsKSB7XG4gICAgdXJsID0gdGhpcy5hZGRQcm90b2NvbFRvVVJMKHVybClcbiAgICBpZiAoIXRoaXMuY2hlY2tJZkNvcnJlY3RVUkwodXJsKSkge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW1VSTF0gSW5jb3JyZWN0IFVSTCBlbnRlcmVkOiAke3VybH1gKVxuICAgICAgdGhpcy51cHB5LmluZm8odGhpcy5pMThuKCdlbnRlckNvcnJlY3RVcmwnKSwgJ2Vycm9yJywgNDAwMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldE1ldGEodXJsKVxuICAgICAgLnRoZW4oKG1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgdGFnRmlsZSA9IHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgbmFtZTogdGhpcy5nZXRGaWxlTmFtZUZyb21VcmwodXJsKSxcbiAgICAgICAgICB0eXBlOiBtZXRhLnR5cGUsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgc2l6ZTogbWV0YS5zaXplLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNSZW1vdGU6IHRydWUsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICAgICAgICB1cmw6IGAke3RoaXMuaG9zdG5hbWV9L3VybC9nZXRgLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICBmaWxlSWQ6IHVybCxcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogdGhpcy5jbGllbnQub3B0cyxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWdGaWxlXG4gICAgICB9KVxuICAgICAgLnRoZW4oKHRhZ0ZpbGUpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZygnW1VybF0gQWRkaW5nIHJlbW90ZSBmaWxlJylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51cHB5LmFkZEZpbGUodGFnRmlsZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlcnJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB0aGlzLnVwcHkuaW5mbyh7XG4gICAgICAgICAgbWVzc2FnZTogdGhpcy5pMThuKCdmYWlsZWRUb0ZldGNoJyksXG4gICAgICAgICAgZGV0YWlsczogZXJyLFxuICAgICAgICB9LCAnZXJyb3InLCA0MDAwKVxuICAgICAgICByZXR1cm4gZXJyXG4gICAgICB9KVxuICB9XG5cbiAgaGFuZGxlUm9vdERyb3AgKGUpIHtcbiAgICBmb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsKGUuZGF0YVRyYW5zZmVyLCAnZHJvcCcsICh1cmwpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coYFtVUkxdIEFkZGluZyBmaWxlIGZyb20gZHJvcHBlZCB1cmw6ICR7dXJsfWApXG4gICAgICB0aGlzLmFkZEZpbGUodXJsKVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVSb290UGFzdGUgKGUpIHtcbiAgICBmb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsKGUuY2xpcGJvYXJkRGF0YSwgJ3Bhc3RlJywgKHVybCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW1VSTF0gQWRkaW5nIGZpbGUgZnJvbSBwYXN0ZWQgdXJsOiAke3VybH1gKVxuICAgICAgdGhpcy5hZGRGaWxlKHVybClcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiA8VXJsVUkgaTE4bj17dGhpcy5pMThufSBhZGRGaWxlPXt0aGlzLmFkZEZpbGV9IC8+XG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG59XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RvQXJyYXknKVxuXG4vKlxuICBTSVRVQVRJT05cblxuICAgIDEuIENyb3NzLWJyb3dzZXIgZGF0YVRyYW5zZmVyLml0ZW1zXG5cbiAgICAgIHBhc3RlIGluIGNocm9tZSBbQ29weSBJbWFnZV06XG4gICAgICAwOiB7a2luZDogXCJmaWxlXCIsIHR5cGU6IFwiaW1hZ2UvcG5nXCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L2h0bWxcIn1cbiAgICAgIHBhc3RlIGluIHNhZmFyaSBbQ29weSBJbWFnZV06XG4gICAgICAwOiB7a2luZDogXCJmaWxlXCIsIHR5cGU6IFwiaW1hZ2UvcG5nXCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L2h0bWxcIn1cbiAgICAgIDI6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvcGxhaW5cIn1cbiAgICAgIDM6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIHBhc3RlIGluIGZpcmVmb3ggW0NvcHkgSW1hZ2VdOlxuICAgICAgMDoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG5cbiAgICAgIHBhc3RlIGluIGNocm9tZSBbQ29weSBJbWFnZSBBZGRyZXNzXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvcGxhaW5cIn1cbiAgICAgIHBhc3RlIGluIHNhZmFyaSBbQ29weSBJbWFnZSBBZGRyZXNzXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvcGxhaW5cIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIHBhc3RlIGluIGZpcmVmb3ggW0NvcHkgSW1hZ2UgQWRkcmVzc106XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG5cbiAgICAgIGRyb3AgaW4gY2hyb21lIFtmcm9tIGJyb3dzZXJdOlxuICAgICAgMDoge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC91cmktbGlzdFwifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG4gICAgICBkcm9wIGluIHNhZmFyaSBbZnJvbSBicm93c2VyXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvaHRtbFwifVxuICAgICAgMjoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgZHJvcCBpbiBmaXJlZm94IFtmcm9tIGJyb3dzZXJdOlxuICAgICAgMDoge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC91cmktbGlzdFwifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC94LW1vei11cmxcIn1cbiAgICAgIDI6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvcGxhaW5cIn1cblxuICAgIDIuIFdlIGNhbiBkZXRlcm1pbmUgaWYgaXQncyBhICdjb3B5cGFzdGUnIG9yIGEgJ2Ryb3AnLCBidXQgd2UgY2FuJ3QgZGlzY2VybiBiZXR3ZWVuIFtDb3B5IEltYWdlXSBhbmQgW0NvcHkgSW1hZ2UgQWRkcmVzc10uXG5cbiAgQ09OQ0xVU0lPTlxuXG4gICAgMS4gJ3Bhc3RlJyAoW0NvcHkgSW1hZ2VdIG9yIFtDb3B5IEltYWdlIEFkZHJlc3NdLCB3ZSBjYW4ndCBkaXNjZXJuIGJldHdlZW4gdGhlc2UgdHdvKVxuICAgICAgRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlcmUgaXMgJ2ZpbGUnIGl0ZW0uIC5oYW5kbGVQYXN0ZSBpbiB0aGUgRGFzaGJvYXJkUGx1Z2luIHdpbGwgZGVhbCB3aXRoIGFsbCAnZmlsZScgaXRlbXMuXG4gICAgICBJZiB0aGVyZSBhcmUgbm8gJ2ZpbGUnIGl0ZW1zIC0gaGFuZGxlICd0ZXh0L3BsYWluJyBpdGVtcy5cblxuICAgIDIuICdkcm9wJ1xuICAgICAgVGFrZSAndGV4dC91cmktbGlzdCcgaXRlbXMuIFNhZmFyaSBoYXMgYW4gYWRkaXRpb25hbCBpdGVtIG9mIC5raW5kID09PSAnZmlsZScsIGFuZCB5b3UgbWF5IHdvcnJ5IGFib3V0IHRoZSBpdGVtIGJlaW5nIGR1cGxpY2F0ZWQgKGZpcnN0IGJ5IERhc2hib2FyZFBsdWdpbiwgYW5kIHRoZW4gYnkgVXJsUGx1Z2luLCBub3cpLCBidXQgZG9uJ3QuIERpcmVjdG9yeSBoYW5kbGluZyBjb2RlIHdvbid0IHBheSBhdHRlbnRpb24gdG8gdGhpcyBwYXJ0aWN1bGFyIGl0ZW0gb2Yga2luZCAnZmlsZScuXG4qL1xuXG4vKipcbiAqIEZpbmRzIGFsbCBsaW5rcyBkcm9wcGVkL3Bhc3RlZCBmcm9tIG9uZSBicm93c2VyIHdpbmRvdyB0byBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhVHJhbnNmZXIgLSBEYXRhVHJhbnNmZXIgaW5zdGFuY2UsIGUuZy4gZS5jbGlwYm9hcmREYXRhLCBvciBlLmRhdGFUcmFuc2ZlclxuICogQHBhcmFtIHtzdHJpbmd9IGlzRHJvcE9yUGFzdGUgLSBlaXRoZXIgJ2Ryb3AnIG9yICdwYXN0ZSdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gKHVybFN0cmluZykgPT4ge31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsIChkYXRhVHJhbnNmZXIsIGlzRHJvcE9yUGFzdGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGl0ZW1zID0gdG9BcnJheShkYXRhVHJhbnNmZXIuaXRlbXMpXG5cbiAgbGV0IHVybEl0ZW1zXG5cbiAgc3dpdGNoIChpc0Ryb3BPclBhc3RlKSB7XG4gICAgY2FzZSAncGFzdGUnOiB7XG4gICAgICBjb25zdCBhdExlYXN0T25lRmlsZUlzRHJhZ2dlZCA9IGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGl0ZW0ua2luZCA9PT0gJ2ZpbGUnKVxuICAgICAgaWYgKGF0TGVhc3RPbmVGaWxlSXNEcmFnZ2VkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXJsSXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+XG4gICAgICAgIGl0ZW0ua2luZCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAmJiBpdGVtLnR5cGUgPT09ICd0ZXh0L3BsYWluJylcblxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnZHJvcCc6IHtcbiAgICAgIHVybEl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PlxuICAgICAgICBpdGVtLmtpbmQgPT09ICdzdHJpbmcnXG4gICAgICAgICYmIGl0ZW0udHlwZSA9PT0gJ3RleHQvdXJpLWxpc3QnKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpc0Ryb3BPclBhc3RlIG11c3QgYmUgZWl0aGVyICdkcm9wJyBvciAncGFzdGUnLCBidXQgaXQncyAke2lzRHJvcE9yUGFzdGV9YClcbiAgICB9XG4gIH1cblxuICB1cmxJdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaXRlbS5nZXRBc1N0cmluZygodXJsU3RyaW5nKSA9PlxuICAgICAgY2FsbGJhY2sodXJsU3RyaW5nKSlcbiAgfSlcbn1cbiIsIi8qKlxuICogQ3JlYXRlIGEgd3JhcHBlciBhcm91bmQgYW4gZXZlbnQgZW1pdHRlciB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kIHRvIHJlbW92ZVxuICogYWxsIGV2ZW50cyB0aGF0IHdlcmUgYWRkZWQgdXNpbmcgdGhlIHdyYXBwZWQgZW1pdHRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFdmVudFRyYWNrZXIge1xuICBjb25zdHJ1Y3RvciAoZW1pdHRlcikge1xuICAgIHRoaXMuX2V2ZW50cyA9IFtdXG4gICAgdGhpcy5fZW1pdHRlciA9IGVtaXR0ZXJcbiAgfVxuXG4gIG9uIChldmVudCwgZm4pIHtcbiAgICB0aGlzLl9ldmVudHMucHVzaChbZXZlbnQsIGZuXSlcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5vbihldmVudCwgZm4pXG4gIH1cblxuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKChbZXZlbnQsIGZuXSkgPT4ge1xuICAgICAgdGhpcy5fZW1pdHRlci5vZmYoZXZlbnQsIGZuKVxuICAgIH0pXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAnYVtocmVmXTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnYXJlYVtocmVmXTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdpZnJhbWU6bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ29iamVjdDpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnZW1iZWQ6bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG5dXG4iLCJjbGFzcyBOZXR3b3JrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChlcnJvciwgeGhyID0gbnVsbCkge1xuICAgIHN1cGVyKGBUaGlzIGxvb2tzIGxpa2UgYSBuZXR3b3JrIGVycm9yLCB0aGUgZW5kcG9pbnQgbWlnaHQgYmUgYmxvY2tlZCBieSBhbiBpbnRlcm5ldCBwcm92aWRlciBvciBhIGZpcmV3YWxsLlxcblxcblNvdXJjZSBlcnJvcjogWyR7ZXJyb3J9XWApXG5cbiAgICB0aGlzLmlzTmV0d29ya0Vycm9yID0gdHJ1ZVxuICAgIHRoaXMucmVxdWVzdCA9IHhoclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya0Vycm9yXG4iLCJjb25zdCBmaW5kSW5kZXggPSByZXF1aXJlKCcuL2ZpbmRJbmRleCcpXG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbmNlbEVycm9yICgpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQ2FuY2VsbGVkJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSYXRlTGltaXRlZFF1ZXVlIHtcbiAgY29uc3RydWN0b3IgKGxpbWl0KSB7XG4gICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgbGltaXQgPT09IDApIHtcbiAgICAgIHRoaXMubGltaXQgPSBJbmZpbml0eVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpbWl0ID0gbGltaXRcbiAgICB9XG5cbiAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzID0gMFxuICAgIHRoaXMucXVldWVkSGFuZGxlcnMgPSBbXVxuICB9XG5cbiAgX2NhbGwgKGZuKSB7XG4gICAgdGhpcy5hY3RpdmVSZXF1ZXN0cyArPSAxXG5cbiAgICBsZXQgZG9uZSA9IGZhbHNlXG5cbiAgICBsZXQgY2FuY2VsQWN0aXZlXG4gICAgdHJ5IHtcbiAgICAgIGNhbmNlbEFjdGl2ZSA9IGZuKClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiAoKSA9PiB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm5cbiAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy5hY3RpdmVSZXF1ZXN0cyAtPSAxXG4gICAgICAgIGNhbmNlbEFjdGl2ZSgpXG4gICAgICAgIHRoaXMuX3F1ZXVlTmV4dCgpXG4gICAgICB9LFxuXG4gICAgICBkb25lOiAoKSA9PiB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm5cbiAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy5hY3RpdmVSZXF1ZXN0cyAtPSAxXG4gICAgICAgIHRoaXMuX3F1ZXVlTmV4dCgpXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIF9xdWV1ZU5leHQgKCkge1xuICAgIC8vIERvIGl0IHNvb24gYnV0IG5vdCBpbW1lZGlhdGVseSwgdGhpcyBhbGxvd3MgY2xlYXJpbmcgb3V0IHRoZSBlbnRpcmUgcXVldWUgc3luY2hyb25vdXNseVxuICAgIC8vIG9uZSBieSBvbmUgd2l0aG91dCBjb250aW51b3VzbHkgX2FkdmFuY2luZ18gaXQgKGFuZCBzdGFydGluZyBuZXcgdGFza3MgYmVmb3JlIGltbWVkaWF0ZWx5XG4gICAgLy8gYWJvcnRpbmcgdGhlbSlcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuX25leHQoKVxuICAgIH0pXG4gIH1cblxuICBfbmV4dCAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVxdWVzdHMgPj0gdGhpcy5saW1pdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLnF1ZXVlZEhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIG5leHQgcmVxdWVzdCwgYW5kIHVwZGF0ZSB0aGUgYWJvcnQvZG9uZSBoYW5kbGVyc1xuICAgIC8vIHNvIHRoYXQgY2FuY2VsbGluZyBpdCBkb2VzIHRoZSBSaWdodCBUaGluZyAoYW5kIGRvZXNuJ3QganVzdCB0cnlcbiAgICAvLyB0byBkZXF1ZXVlIGFuIGFscmVhZHktcnVubmluZyByZXF1ZXN0KS5cbiAgICBjb25zdCBuZXh0ID0gdGhpcy5xdWV1ZWRIYW5kbGVycy5zaGlmdCgpXG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2NhbGwobmV4dC5mbilcbiAgICBuZXh0LmFib3J0ID0gaGFuZGxlci5hYm9ydFxuICAgIG5leHQuZG9uZSA9IGhhbmRsZXIuZG9uZVxuICB9XG5cbiAgX3F1ZXVlIChmbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgIGZuLFxuICAgICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHkgfHwgMCxcbiAgICAgIGFib3J0OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlcXVldWUoaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkb25lOiAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1hcmsgYSBxdWV1ZWQgcmVxdWVzdCBhcyBkb25lOiB0aGlzIGluZGljYXRlcyBhIGJ1ZycpXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHRoaXMucXVldWVkSGFuZGxlcnMsIChvdGhlcikgPT4ge1xuICAgICAgcmV0dXJuIGhhbmRsZXIucHJpb3JpdHkgPiBvdGhlci5wcmlvcml0eVxuICAgIH0pXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5xdWV1ZWRIYW5kbGVycy5wdXNoKGhhbmRsZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVldWVkSGFuZGxlcnMuc3BsaWNlKGluZGV4LCAwLCBoYW5kbGVyKVxuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlclxuICB9XG5cbiAgX2RlcXVldWUgKGhhbmRsZXIpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWVkSGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMucXVldWVkSGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxuXG4gIHJ1biAoZm4sIHF1ZXVlT3B0aW9ucykge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlcXVlc3RzIDwgdGhpcy5saW1pdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGwoZm4pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9xdWV1ZShmbiwgcXVldWVPcHRpb25zKVxuICB9XG5cbiAgd3JhcFByb21pc2VGdW5jdGlvbiAoZm4sIHF1ZXVlT3B0aW9ucykge1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgbGV0IHF1ZXVlZFJlcXVlc3RcbiAgICAgIGNvbnN0IG91dGVyUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdCA9IHRoaXMucnVuKCgpID0+IHtcbiAgICAgICAgICBsZXQgY2FuY2VsRXJyb3JcbiAgICAgICAgICBsZXQgaW5uZXJQcm9taXNlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlubmVyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShmbiguLi5hcmdzKSlcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlubmVyUHJvbWlzZSA9IFByb21pc2UucmVqZWN0KGVycilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbm5lclByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGNhbmNlbEVycm9yKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcXVldWVkUmVxdWVzdC5kb25lKClcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbEVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChjYW5jZWxFcnJvcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxFcnJvciA9IGNyZWF0ZUNhbmNlbEVycm9yKClcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHF1ZXVlT3B0aW9ucylcbiAgICAgIH0pXG5cbiAgICAgIG91dGVyUHJvbWlzZS5hYm9ydCA9ICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRlclByb21pc2VcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IGhhcyA9IHJlcXVpcmUoJy4vaGFzUHJvcGVydHknKVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgc3RyaW5ncyB3aXRoIGludGVycG9sYXRpb24gJiBwbHVyYWxpemF0aW9uIHN1cHBvcnQuXG4gKiBFeHRlbnNpYmxlIHdpdGggY3VzdG9tIGRpY3Rpb25hcmllcyBhbmQgcGx1cmFsaXphdGlvbiBmdW5jdGlvbnMuXG4gKlxuICogQm9ycm93cyBoZWF2aWx5IGZyb20gYW5kIGluc3BpcmVkIGJ5IFBvbHlnbG90IGh0dHBzOi8vZ2l0aHViLmNvbS9haXJibmIvcG9seWdsb3QuanMsXG4gKiBiYXNpY2FsbHkgYSBzdHJpcHBlZC1kb3duIHZlcnNpb24gb2YgaXQuIERpZmZlcmVuY2VzOiBwbHVyYWxpemF0aW9uIGZ1bmN0aW9ucyBhcmUgbm90IGhhcmRjb2RlZFxuICogYW5kIGNhbiBiZSBlYXNpbHkgYWRkZWQgYW1vbmcgd2l0aCBkaWN0aW9uYXJpZXMsIG5lc3RlZCBvYmplY3RzIGFyZSB1c2VkIGZvciBwbHVyYWxpemF0aW9uXG4gKiBhcyBvcHBvc2VkIHRvIGB8fHx8YCBkZWxpbWV0ZXJcbiAqXG4gKiBVc2FnZSBleGFtcGxlOiBgdHJhbnNsYXRvci50cmFuc2xhdGUoJ2ZpbGVzX2Nob3NlbicsIHtzbWFydF9jb3VudDogM30pYFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFRyYW5zbGF0b3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R8QXJyYXk8b2JqZWN0Pn0gbG9jYWxlcyAtIGxvY2FsZSBvciBsaXN0IG9mIGxvY2FsZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobG9jYWxlcykge1xuICAgIHRoaXMubG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge30sXG4gICAgICBwbHVyYWxpemUgKG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9LFxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGxvY2FsZXMpKSB7XG4gICAgICBsb2NhbGVzLmZvckVhY2goKGxvY2FsZSkgPT4gdGhpcy5fYXBwbHkobG9jYWxlKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXBwbHkobG9jYWxlcylcbiAgICB9XG4gIH1cblxuICBfYXBwbHkgKGxvY2FsZSkge1xuICAgIGlmICghbG9jYWxlIHx8ICFsb2NhbGUuc3RyaW5ncykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcHJldkxvY2FsZSA9IHRoaXMubG9jYWxlXG4gICAgdGhpcy5sb2NhbGUgPSB7IC4uLnByZXZMb2NhbGUsIHN0cmluZ3M6IHsgLi4ucHJldkxvY2FsZS5zdHJpbmdzLCAuLi5sb2NhbGUuc3RyaW5ncyB9IH1cbiAgICB0aGlzLmxvY2FsZS5wbHVyYWxpemUgPSBsb2NhbGUucGx1cmFsaXplIHx8IHByZXZMb2NhbGUucGx1cmFsaXplXG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSBzdHJpbmcgd2l0aCBwbGFjZWhvbGRlciB2YXJpYWJsZXMgbGlrZSBgJXtzbWFydF9jb3VudH0gZmlsZSBzZWxlY3RlZGBcbiAgICogYW5kIHJlcGxhY2VzIGl0IHdpdGggdmFsdWVzIGZyb20gb3B0aW9ucyBge3NtYXJ0X2NvdW50OiA1fWBcbiAgICpcbiAgICogQGxpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9wb2x5Z2xvdC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAqIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9wb2x5Z2xvdC5qcy9ibG9iL21hc3Rlci9saWIvcG9seWdsb3QuanMjTDI5OVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGhyYXNlIHRoYXQgbmVlZHMgaW50ZXJwb2xhdGlvbiwgd2l0aCBwbGFjZWhvbGRlcnNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgd2l0aCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVwbGFjZSBwbGFjZWhvbGRlcnNcbiAgICogQHJldHVybnMge2FueVtdfSBpbnRlcnBvbGF0ZWRcbiAgICovXG4gIGludGVycG9sYXRlIChwaHJhc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNwbGl0LCByZXBsYWNlIH0gPSBTdHJpbmcucHJvdG90eXBlXG4gICAgY29uc3QgZG9sbGFyUmVnZXggPSAvXFwkL2dcbiAgICBjb25zdCBkb2xsYXJCaWxsc1lhbGwgPSAnJCQkJCdcbiAgICBsZXQgaW50ZXJwb2xhdGVkID0gW3BocmFzZV1cblxuICAgIGZvciAoY29uc3QgYXJnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChhcmcgIT09ICdfJyAmJiBoYXMob3B0aW9ucywgYXJnKSkge1xuICAgICAgICAvLyBFbnN1cmUgcmVwbGFjZW1lbnQgdmFsdWUgaXMgZXNjYXBlZCB0byBwcmV2ZW50IHNwZWNpYWwgJC1wcmVmaXhlZFxuICAgICAgICAvLyByZWdleCByZXBsYWNlIHRva2Vucy4gdGhlIFwiJCQkJFwiIGlzIG5lZWRlZCBiZWNhdXNlIGVhY2ggXCIkXCIgbmVlZHMgdG9cbiAgICAgICAgLy8gYmUgZXNjYXBlZCB3aXRoIFwiJFwiIGl0c2VsZiwgYW5kIHdlIG5lZWQgdHdvIGluIHRoZSByZXN1bHRpbmcgb3V0cHV0LlxuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBvcHRpb25zW2FyZ11cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2UuY2FsbChvcHRpb25zW2FyZ10sIGRvbGxhclJlZ2V4LCBkb2xsYXJCaWxsc1lhbGwpXG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgY3JlYXRlIGEgbmV3IGBSZWdFeHBgIGVhY2ggdGltZSBpbnN0ZWFkIG9mIHVzaW5nIGEgbW9yZS1lZmZpY2llbnRcbiAgICAgICAgLy8gc3RyaW5nIHJlcGxhY2Ugc28gdGhhdCB0aGUgc2FtZSBhcmd1bWVudCBjYW4gYmUgcmVwbGFjZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgLy8gaW4gdGhlIHNhbWUgcGhyYXNlLlxuICAgICAgICBpbnRlcnBvbGF0ZWQgPSBpbnNlcnRSZXBsYWNlbWVudChpbnRlcnBvbGF0ZWQsIG5ldyBSZWdFeHAoYCVcXFxceyR7YXJnfVxcXFx9YCwgJ2cnKSwgcmVwbGFjZW1lbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVycG9sYXRlZFxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0UmVwbGFjZW1lbnQgKHNvdXJjZSwgcngsIHJlcGxhY2VtZW50KSB7XG4gICAgICBjb25zdCBuZXdQYXJ0cyA9IFtdXG4gICAgICBzb3VyY2UuZm9yRWFjaCgoY2h1bmspID0+IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgc291cmNlIGNvbnRhaW5zIG11bHRpcGxlIHBsYWNlaG9sZGVycyBmb3IgaW50ZXJwb2xhdGlvbixcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSBjaHVua3MgdGhhdCBhcmUgbm90IHN0cmluZ3MsIGJlY2F1c2UgdGhvc2VcbiAgICAgICAgLy8gY2FuIGJlIEpTWCBvYmplY3RzIGFuZCB3aWxsIGJlIG90aGVyd2lzZSBpbmNvcnJlY3RseSB0dXJuZWQgaW50byBzdHJpbmdzLlxuICAgICAgICAvLyBXaXRob3V0IHRoaXMgY29uZGl0aW9uIHdl4oCZZCBnZXQgdGhpczogW29iamVjdCBPYmplY3RdIGhlbGxvIFtvYmplY3QgT2JqZWN0XSBteSA8YnV0dG9uPlxuICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBuZXdQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICB9XG5cbiAgICAgICAgc3BsaXQuY2FsbChjaHVuaywgcngpLmZvckVhY2goKHJhdywgaSwgbGlzdCkgPT4ge1xuICAgICAgICAgIGlmIChyYXcgIT09ICcnKSB7XG4gICAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHJhdylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJbnRlcmxhY2Ugd2l0aCB0aGUgYHJlcGxhY2VtZW50YCB2YWx1ZVxuICAgICAgICAgIGlmIChpIDwgbGlzdC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHJlcGxhY2VtZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gbmV3UGFydHNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIHRyYW5zbGF0ZSBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB3aXRoIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCBsYXRlciB0byByZXBsYWNlIHBsYWNlaG9sZGVycyBpbiBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ30gdHJhbnNsYXRlZCAoYW5kIGludGVycG9sYXRlZClcbiAgICovXG4gIHRyYW5zbGF0ZSAoa2V5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlQXJyYXkoa2V5LCBvcHRpb25zKS5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRyYW5zbGF0aW9uIGFuZCByZXR1cm4gdGhlIHRyYW5zbGF0ZWQgYW5kIGludGVycG9sYXRlZCBwYXJ0cyBhcyBhbiBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB3aXRoIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byByZXBsYWNlIHBsYWNlaG9sZGVyc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSB0cmFuc2xhdGVkIGFuZCBpbnRlcnBvbGF0ZWQgcGFydHMsIGluIG9yZGVyLlxuICAgKi9cbiAgdHJhbnNsYXRlQXJyYXkgKGtleSwgb3B0aW9ucykge1xuICAgIGlmICghaGFzKHRoaXMubG9jYWxlLnN0cmluZ3MsIGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBzdHJpbmc6ICR7a2V5fWApXG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5sb2NhbGUuc3RyaW5nc1trZXldXG4gICAgY29uc3QgaGFzUGx1cmFsRm9ybXMgPSB0eXBlb2Ygc3RyaW5nID09PSAnb2JqZWN0J1xuXG4gICAgaWYgKGhhc1BsdXJhbEZvcm1zKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zbWFydF9jb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgcGx1cmFsID0gdGhpcy5sb2NhbGUucGx1cmFsaXplKG9wdGlvbnMuc21hcnRfY291bnQpXG4gICAgICAgIHJldHVybiB0aGlzLmludGVycG9sYXRlKHN0cmluZ1twbHVyYWxdLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gdXNlIGEgc3RyaW5nIHdpdGggcGx1cmFsIGZvcm1zLCBidXQgbm8gdmFsdWUgd2FzIGdpdmVuIGZvciAle3NtYXJ0X2NvdW50fScpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGUoc3RyaW5nLCBvcHRpb25zKVxuICB9XG59XG4iLCJjb25zdCBkYXRhVVJJdG9CbG9iID0gcmVxdWlyZSgnLi9kYXRhVVJJdG9CbG9iJylcblxuLyoqXG4gKiBTYXZlIGEgPGNhbnZhcz4gZWxlbWVudCdzIGNvbnRlbnQgdG8gYSBCbG9iIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbnZhc1RvQmxvYiAoY2FudmFzLCB0eXBlLCBxdWFsaXR5KSB7XG4gIGlmIChjYW52YXMudG9CbG9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjYW52YXMudG9CbG9iKHJlc29sdmUsIHR5cGUsIHF1YWxpdHkpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgcmV0dXJuIGRhdGFVUkl0b0Jsb2IoY2FudmFzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KSwge30pXG4gIH0pXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRhdGFVUkl0b0Jsb2IgKGRhdGFVUkksIG9wdHMsIHRvRmlsZSkge1xuICAvLyBnZXQgdGhlIGJhc2U2NCBkYXRhXG4gIGNvbnN0IGRhdGEgPSBkYXRhVVJJLnNwbGl0KCcsJylbMV1cblxuICAvLyB1c2VyIG1heSBwcm92aWRlIG1pbWUgdHlwZSwgaWYgbm90IGdldCBpdCBmcm9tIGRhdGEgVVJJXG4gIGxldCBtaW1lVHlwZSA9IG9wdHMubWltZVR5cGUgfHwgZGF0YVVSSS5zcGxpdCgnLCcpWzBdLnNwbGl0KCc6JylbMV0uc3BsaXQoJzsnKVswXVxuXG4gIC8vIGRlZmF1bHQgdG8gcGxhaW4vdGV4dCBpZiBkYXRhIFVSSSBoYXMgbm8gbWltZVR5cGVcbiAgaWYgKG1pbWVUeXBlID09IG51bGwpIHtcbiAgICBtaW1lVHlwZSA9ICdwbGFpbi90ZXh0J1xuICB9XG5cbiAgY29uc3QgYmluYXJ5ID0gYXRvYihkYXRhKVxuICBjb25zdCBhcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXkucHVzaChiaW5hcnkuY2hhckNvZGVBdChpKSlcbiAgfVxuXG4gIGxldCBieXRlc1xuICB0cnkge1xuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQ29udmVydCB0byBhIEZpbGU/XG4gIGlmICh0b0ZpbGUpIHtcbiAgICByZXR1cm4gbmV3IEZpbGUoW2J5dGVzXSwgb3B0cy5uYW1lIHx8ICcnLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IoW2J5dGVzXSwgeyB0eXBlOiBtaW1lVHlwZSB9KVxufVxuIiwiY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCdsb2Rhc2gudGhyb3R0bGUnKVxuXG5mdW5jdGlvbiBfZW1pdFNvY2tldFByb2dyZXNzICh1cGxvYWRlciwgcHJvZ3Jlc3NEYXRhLCBmaWxlKSB7XG4gIGNvbnN0IHsgcHJvZ3Jlc3MsIGJ5dGVzVXBsb2FkZWQsIGJ5dGVzVG90YWwgfSA9IHByb2dyZXNzRGF0YVxuICBpZiAocHJvZ3Jlc3MpIHtcbiAgICB1cGxvYWRlci51cHB5LmxvZyhgVXBsb2FkIHByb2dyZXNzOiAke3Byb2dyZXNzfWApXG4gICAgdXBsb2FkZXIudXBweS5lbWl0KCd1cGxvYWQtcHJvZ3Jlc3MnLCBmaWxlLCB7XG4gICAgICB1cGxvYWRlcixcbiAgICAgIGJ5dGVzVXBsb2FkZWQsXG4gICAgICBieXRlc1RvdGFsLFxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZShfZW1pdFNvY2tldFByb2dyZXNzLCAzMDAsIHtcbiAgbGVhZGluZzogdHJ1ZSxcbiAgdHJhaWxpbmc6IHRydWUsXG59KVxuIiwiY29uc3QgTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnLi9OZXR3b3JrRXJyb3InKVxuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIHdpbmRvdy5mZXRjaCB0aGF0IHRocm93cyBhIE5ldHdvcmtFcnJvciB3aGVuIGFwcHJvcHJpYXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmV0Y2hXaXRoTmV0d29ya0Vycm9yICguLi5vcHRpb25zKSB7XG4gIHJldHVybiBmZXRjaCguLi5vcHRpb25zKVxuICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH0pXG59XG4iLCJjb25zdCBpc0RPTUVsZW1lbnQgPSByZXF1aXJlKCcuL2lzRE9NRWxlbWVudCcpXG5cbi8qKlxuICogRmluZCBvbmUgb3IgbW9yZSBET00gZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheXxudWxsfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmRBbGxET01FbGVtZW50cyAoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudCkpXG4gICAgcmV0dXJuIGVsZW1lbnRzLmxlbmd0aCA+IDAgPyBlbGVtZW50cyA6IG51bGxcbiAgfVxuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgaXNET01FbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtlbGVtZW50XVxuICB9XG59XG4iLCJjb25zdCBpc0RPTUVsZW1lbnQgPSByZXF1aXJlKCcuL2lzRE9NRWxlbWVudCcpXG5cbi8qKlxuICogRmluZCBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZXxzdHJpbmd9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtOb2RlfG51bGx9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmluZERPTUVsZW1lbnQgKGVsZW1lbnQsIGNvbnRleHQgPSBkb2N1bWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvcihlbGVtZW50KVxuICB9XG5cbiAgaWYgKGlzRE9NRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50XG4gIH1cbn1cbiIsIi8qKlxuICogQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCBwb255ZmlsbCBmb3Igb2xkIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmluZEluZGV4IChhcnJheSwgcHJlZGljYXRlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldKSkgcmV0dXJuIGlcbiAgfVxuICByZXR1cm4gLTFcbn1cbiIsIi8qKlxuICogVGFrZXMgYSBmaWxlIG9iamVjdCBhbmQgdHVybnMgaXQgaW50byBmaWxlSUQsIGJ5IGNvbnZlcnRpbmcgZmlsZS5uYW1lIHRvIGxvd2VyY2FzZSxcbiAqIHJlbW92aW5nIGV4dHJhIGNoYXJhY3RlcnMgYW5kIGFkZGluZyB0eXBlLCBzaXplIGFuZCBsYXN0TW9kaWZpZWRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZmlsZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGZpbGVJRFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlRmlsZUlEIChmaWxlKSB7XG4gIC8vIEl0J3MgdGVtcHRpbmcgdG8gZG8gYFtpdGVtc10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKWAgaGVyZSwgYnV0IHRoYXRcbiAgLy8gaXMgc2xvd2VyISBzaW1wbGUgc3RyaW5nIGNvbmNhdGVuYXRpb24gaXMgZmFzdFxuXG4gIGxldCBpZCA9ICd1cHB5J1xuICBpZiAodHlwZW9mIGZpbGUubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZCArPSBgLSR7ZW5jb2RlRmlsZW5hbWUoZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkpfWBcbiAgfVxuXG4gIGlmIChmaWxlLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlkICs9IGAtJHtmaWxlLnR5cGV9YFxuICB9XG5cbiAgaWYgKGZpbGUubWV0YSAmJiB0eXBlb2YgZmlsZS5tZXRhLnJlbGF0aXZlUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZCArPSBgLSR7ZW5jb2RlRmlsZW5hbWUoZmlsZS5tZXRhLnJlbGF0aXZlUGF0aC50b0xvd2VyQ2FzZSgpKX1gXG4gIH1cblxuICBpZiAoZmlsZS5kYXRhLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlkICs9IGAtJHtmaWxlLmRhdGEuc2l6ZX1gXG4gIH1cbiAgaWYgKGZpbGUuZGF0YS5sYXN0TW9kaWZpZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlkICs9IGAtJHtmaWxlLmRhdGEubGFzdE1vZGlmaWVkfWBcbiAgfVxuXG4gIHJldHVybiBpZFxufVxuXG5mdW5jdGlvbiBlbmNvZGVGaWxlbmFtZSAobmFtZSkge1xuICBsZXQgc3VmZml4ID0gJydcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvW15BLVowLTldL2lnLCAoY2hhcmFjdGVyKSA9PiB7XG4gICAgc3VmZml4ICs9IGAtJHtlbmNvZGVDaGFyYWN0ZXIoY2hhcmFjdGVyKX1gXG4gICAgcmV0dXJuICcvJ1xuICB9KSArIHN1ZmZpeFxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaGFyYWN0ZXIgKGNoYXJhY3Rlcikge1xuICByZXR1cm4gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMzIpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJ5dGVzUmVtYWluaW5nIChmaWxlUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGZpbGVQcm9ncmVzcy5ieXRlc1RvdGFsIC0gZmlsZVByb2dyZXNzLmJ5dGVzVXBsb2FkZWRcbn1cbiIsImNvbnN0IHdlYmtpdEdldEFzRW50cnlBcGkgPSByZXF1aXJlKCcuL3V0aWxzL3dlYmtpdEdldEFzRW50cnlBcGkvaW5kZXgnKVxuY29uc3QgZmFsbGJhY2tBcGkgPSByZXF1aXJlKCcuL3V0aWxzL2ZhbGxiYWNrQXBpJylcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBhcnJheSBvZiBkcm9wcGVkIGZpbGVzIChpZiBhIGZvbGRlciBpcyBkcm9wcGVkLCBhbmQgYnJvd3NlciBzdXBwb3J0cyBmb2xkZXIgcGFyc2luZyAtIHByb21pc2UgcmVzb2x2ZXMgdG8gdGhlIGZsYXQgYXJyYXkgb2YgYWxsIGZpbGVzIGluIGFsbCBkaXJlY3RvcmllcykuXG4gKiBFYWNoIGZpbGUgaGFzIC5yZWxhdGl2ZVBhdGggcHJvcCBhcHBlbmRlZCB0byBpdCAoZS5nLiBcIi9kb2NzL1ByYWd1ZS90aWNrZXRfZnJvbV9wcmFndWVfdG9fdWZhLnBkZlwiKSBpZiBicm93c2VyIHN1cHBvcnRzIGl0LiBPdGhlcndpc2UgaXQncyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtEYXRhVHJhbnNmZXJ9IGRhdGFUcmFuc2ZlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gbG9nRHJvcEVycm9yIC0gYSBmdW5jdGlvbiB0aGF0J3MgY2FsbGVkIGV2ZXJ5IHRpbWUgc29tZSBmb2xkZXIgb3Igc29tZSBmaWxlIGVycm9yIG91dCAoZS5nLiBiZWNhdXNlIG9mIHRoZSBmb2xkZXIgbmFtZSBiZWluZyB0b28gbG9uZyBvbiBXaW5kb3dzKS4gTm90aWNlIHRoYXQgcmVzdWx0aW5nIHByb21pc2Ugd2lsbCBhbHdheXMgYmUgcmVzb2x2ZWQgYW55d2F5LlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIEFycmF5PEZpbGU+XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RHJvcHBlZEZpbGVzIChkYXRhVHJhbnNmZXIsIHsgbG9nRHJvcEVycm9yID0gKCkgPT4ge30gfSA9IHt9KSB7XG4gIC8vIEdldCBhbGwgZmlsZXMgZnJvbSBhbGwgc3ViZGlycy4gV29ya3MgKGF0IGxlYXN0KSBpbiBDaHJvbWUsIE1vemlsbGEsIGFuZCBTYWZhcmlcbiAgaWYgKGRhdGFUcmFuc2Zlci5pdGVtcyAmJiBkYXRhVHJhbnNmZXIuaXRlbXNbMF0gJiYgJ3dlYmtpdEdldEFzRW50cnknIGluIGRhdGFUcmFuc2Zlci5pdGVtc1swXSkge1xuICAgIHJldHVybiB3ZWJraXRHZXRBc0VudHJ5QXBpKGRhdGFUcmFuc2ZlciwgbG9nRHJvcEVycm9yKVxuICAvLyBPdGhlcndpc2UganVzdCByZXR1cm4gYWxsIGZpcnN0LW9yZGVyIGZpbGVzXG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrQXBpKGRhdGFUcmFuc2Zlcilcbn1cbiIsImNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCcuLi8uLi90b0FycmF5JylcblxuLy8gLmZpbGVzIGZhbGxiYWNrLCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmFsbGJhY2tBcGkgKGRhdGFUcmFuc2Zlcikge1xuICBjb25zdCBmaWxlcyA9IHRvQXJyYXkoZGF0YVRyYW5zZmVyLmZpbGVzKVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGVzKVxufVxuIiwiLyoqXG4gKiBSZWN1cnNpdmUgZnVuY3Rpb24sIGNhbGxzIHRoZSBvcmlnaW5hbCBjYWxsYmFjaygpIHdoZW4gdGhlIGRpcmVjdG9yeSBpcyBlbnRpcmVseSBwYXJzZWQuXG4gKlxuICogQHBhcmFtIHtGaWxlU3lzdGVtRGlyZWN0b3J5UmVhZGVyfSBkaXJlY3RvcnlSZWFkZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG9sZEVudHJpZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxvZ0Ryb3BFcnJvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsZWQgd2l0aCAoWyBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIGluIHRoYXQgZGlyZWN0b3J5UmVhZGVyIF0pXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkgKGRpcmVjdG9yeVJlYWRlciwgb2xkRW50cmllcywgbG9nRHJvcEVycm9yLCB7IG9uU3VjY2VzcyB9KSB7XG4gIGRpcmVjdG9yeVJlYWRlci5yZWFkRW50cmllcyhcbiAgICAoZW50cmllcykgPT4ge1xuICAgICAgY29uc3QgbmV3RW50cmllcyA9IFsuLi5vbGRFbnRyaWVzLCAuLi5lbnRyaWVzXVxuICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBGaWxlU3lzdGVtIEFQSSBzcGVjLCBnZXRGaWxlc0FuZERpcmVjdG9yaWVzRnJvbURpcmVjdG9yeSgpIG11c3QgYmUgY2FsbGVkIHVudGlsIGl0IGNhbGxzIHRoZSBvblN1Y2Nlc3Mgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBnZXRGaWxlc0FuZERpcmVjdG9yaWVzRnJvbURpcmVjdG9yeShkaXJlY3RvcnlSZWFkZXIsIG5ld0VudHJpZXMsIGxvZ0Ryb3BFcnJvciwgeyBvblN1Y2Nlc3MgfSlcbiAgICAgICAgfSwgMClcbiAgICAgIC8vIERvbmUgaXRlcmF0aW5nIHRoaXMgcGFydGljdWxhciBkaXJlY3RvcnlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uU3VjY2VzcyhuZXdFbnRyaWVzKVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gTWFrZSBzdXJlIHdlIHJlc29sdmUgb24gZXJyb3IgYW55d2F5LCBpdCdzIGZpbmUgaWYgb25seSBvbmUgZGlyZWN0b3J5IGNvdWxkbid0IGJlIHBhcnNlZCFcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIGxvZ0Ryb3BFcnJvcihlcnJvcilcbiAgICAgIG9uU3VjY2VzcyhvbGRFbnRyaWVzKVxuICAgIH1cbiAgKVxufVxuIiwiLyoqXG4gKiBHZXQgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgRmlsZUVudHJ5I2Z1bGxQYXRoLCBiZWNhdXNlIEZpbGUjd2Via2l0UmVsYXRpdmVQYXRoIGlzIGFsd2F5cyAnJywgYXQgbGVhc3Qgb25Ecm9wLlxuICpcbiAqIEBwYXJhbSB7RmlsZUVudHJ5fSBmaWxlRW50cnlcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IC0gaWYgZmlsZSBpcyBub3QgaW4gYSBmb2xkZXIgLSByZXR1cm4gbnVsbCAodGhpcyBpcyB0byBiZSBjb25zaXN0ZW50IHdpdGggLnJlbGF0aXZlUGF0aC1zIG9mIGZpbGVzIHNlbGVjdGVkIGZyb20gTXkgRGV2aWNlKS4gSWYgZmlsZSBpcyBpbiBhIGZvbGRlciAtIHJldHVybiBpdHMgZnVsbFBhdGgsIGUuZy4gJy9zaW1wc29ucy9oaS5qcGVnJy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBhdGggKGZpbGVFbnRyeSkge1xuICAvLyBmaWxlRW50cnkuZnVsbFBhdGggLSBcIi9zaW1wc29ucy9oaS5qcGVnXCIgb3IgdW5kZWZpbmVkIChmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0KVxuICAvLyBmaWxlRW50cnkubmFtZSAtIFwiaGkuanBlZ1wiXG4gIGlmICghZmlsZUVudHJ5LmZ1bGxQYXRoIHx8IGZpbGVFbnRyeS5mdWxsUGF0aCA9PT0gYC8ke2ZpbGVFbnRyeS5uYW1lfWApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHJldHVybiBmaWxlRW50cnkuZnVsbFBhdGhcbn1cbiIsImNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCcuLi8uLi8uLi90b0FycmF5JylcbmNvbnN0IGdldFJlbGF0aXZlUGF0aCA9IHJlcXVpcmUoJy4vZ2V0UmVsYXRpdmVQYXRoJylcbmNvbnN0IGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5ID0gcmVxdWlyZSgnLi9nZXRGaWxlc0FuZERpcmVjdG9yaWVzRnJvbURpcmVjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2Via2l0R2V0QXNFbnRyeUFwaSAoZGF0YVRyYW5zZmVyLCBsb2dEcm9wRXJyb3IpIHtcbiAgY29uc3QgZmlsZXMgPSBbXVxuXG4gIGNvbnN0IHJvb3RQcm9taXNlcyA9IFtdXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZXNvbHZlZCBwcm9taXNlLCB3aGVuIDpmaWxlcyBhcnJheSBpcyBlbmhhbmNlZFxuICAgKlxuICAgKiBAcGFyYW0geyhGaWxlU3lzdGVtRmlsZUVudHJ5fEZpbGVTeXN0ZW1EaXJlY3RvcnlFbnRyeSl9IGVudHJ5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGVtcHR5IHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIDpmaWxlcyBpcyBlbmhhbmNlZCB3aXRoIGEgZmlsZVxuICAgKi9cbiAgY29uc3QgY3JlYXRlUHJvbWlzZVRvQWRkRmlsZU9yUGFyc2VEaXJlY3RvcnkgPSAoZW50cnkpID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIC8vIFRoaXMgaXMgYSBiYXNlIGNhbGxcbiAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5ldyBGaWxlIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byByZWFkIHRoZSBmaWxlLlxuICAgICAgICBlbnRyeS5maWxlKFxuICAgICAgICAgIChmaWxlKSA9PiB7XG4gICAgICAgICAgICBmaWxlLnJlbGF0aXZlUGF0aCA9IGdldFJlbGF0aXZlUGF0aChlbnRyeSlcbiAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSlcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHJlc29sdmUgb24gZXJyb3IgYW55d2F5LCBpdCdzIGZpbmUgaWYgb25seSBvbmUgZmlsZSBjb3VsZG4ndCBiZSByZWFkIVxuICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgbG9nRHJvcEVycm9yKGVycm9yKVxuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAvLyBUaGlzIGlzIGEgcmVjdXJzaXZlIGNhbGxcbiAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0b3J5UmVhZGVyID0gZW50cnkuY3JlYXRlUmVhZGVyKClcbiAgICAgICAgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoZGlyZWN0b3J5UmVhZGVyLCBbXSwgbG9nRHJvcEVycm9yLCB7XG4gICAgICAgICAgb25TdWNjZXNzOiAoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBlbnRyaWVzLm1hcCgoZW50cnkpID0+IGNyZWF0ZVByb21pc2VUb0FkZEZpbGVPclBhcnNlRGlyZWN0b3J5KGVudHJ5KSlcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHJlc29sdmUoKSlcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgLy8gRm9yIGVhY2ggZHJvcHBlZCBpdGVtLCAtIG1ha2Ugc3VyZSBpdCdzIGEgZmlsZS9kaXJlY3RvcnksIGFuZCBzdGFydCBkZWVwZW5pbmcgaW4hXG4gIHRvQXJyYXkoZGF0YVRyYW5zZmVyLml0ZW1zKVxuICAgIC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpXG4gICAgICAvLyA6ZW50cnkgY2FuIGJlIG51bGwgd2hlbiB3ZSBkcm9wIHRoZSB1cmwgZS5nLlxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHJvb3RQcm9taXNlcy5wdXNoKGNyZWF0ZVByb21pc2VUb0FkZEZpbGVPclBhcnNlRGlyZWN0b3J5KGVudHJ5KSlcbiAgICAgIH1cbiAgICB9KVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChyb290UHJvbWlzZXMpXG4gICAgLnRoZW4oKCkgPT4gZmlsZXMpXG59XG4iLCIvKipcbiAqIFRha2VzIGEgZnVsbCBmaWxlbmFtZSBzdHJpbmcgYW5kIHJldHVybnMgYW4gb2JqZWN0IHtuYW1lLCBleHRlbnNpb259XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bGxGaWxlTmFtZVxuICogQHJldHVybnMge29iamVjdH0ge25hbWUsIGV4dGVuc2lvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaWxlTmFtZUFuZEV4dGVuc2lvbiAoZnVsbEZpbGVOYW1lKSB7XG4gIGNvbnN0IGxhc3REb3QgPSBmdWxsRmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKVxuICAvLyB0aGVzZSBjb3VudCBhcyBubyBleHRlbnNpb246IFwibm8tZG90XCIsIFwidHJhaWxpbmctZG90LlwiXG4gIGlmIChsYXN0RG90ID09PSAtMSB8fCBsYXN0RG90ID09PSBmdWxsRmlsZU5hbWUubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBmdWxsRmlsZU5hbWUsXG4gICAgICBleHRlbnNpb246IHVuZGVmaW5lZCxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBmdWxsRmlsZU5hbWUuc2xpY2UoMCwgbGFzdERvdCksXG4gICAgZXh0ZW5zaW9uOiBmdWxsRmlsZU5hbWUuc2xpY2UobGFzdERvdCArIDEpLFxuICB9XG59XG4iLCJjb25zdCBnZXRGaWxlTmFtZUFuZEV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24nKVxuY29uc3QgbWltZVR5cGVzID0gcmVxdWlyZSgnLi9taW1lVHlwZXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVUeXBlIChmaWxlKSB7XG4gIGxldCBmaWxlRXh0ZW5zaW9uID0gZmlsZS5uYW1lID8gZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24oZmlsZS5uYW1lKS5leHRlbnNpb24gOiBudWxsXG4gIGZpbGVFeHRlbnNpb24gPSBmaWxlRXh0ZW5zaW9uID8gZmlsZUV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpIDogbnVsbFxuXG4gIGlmIChmaWxlLnR5cGUpIHtcbiAgICAvLyBpZiBtaW1lIHR5cGUgaXMgc2V0IGluIHRoZSBmaWxlIG9iamVjdCBhbHJlYWR5LCB1c2UgdGhhdFxuICAgIHJldHVybiBmaWxlLnR5cGVcbiAgfSBpZiAoZmlsZUV4dGVuc2lvbiAmJiBtaW1lVHlwZXNbZmlsZUV4dGVuc2lvbl0pIHtcbiAgICAvLyBlbHNlLCBzZWUgaWYgd2UgY2FuIG1hcCBleHRlbnNpb24gdG8gYSBtaW1lIHR5cGVcbiAgICByZXR1cm4gbWltZVR5cGVzW2ZpbGVFeHRlbnNpb25dXG4gIH1cbiAgLy8gaWYgYWxsIGZhaWxzLCBmYWxsIGJhY2sgdG8gYSBnZW5lcmljIGJ5dGUgc3RyZWFtIHR5cGVcbiAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG59XG4iLCIvLyBUT0RPIENoZWNrIHdoaWNoIHR5cGVzIGFyZSBhY3R1YWxseSBzdXBwb3J0ZWQgaW4gYnJvd3NlcnMuIENocm9tZSBsaWtlcyB3ZWJtXG4vLyBmcm9tIG15IHRlc3RpbmcsIGJ1dCB3ZSBtYXkgbmVlZCBtb3JlLlxuLy8gV2UgY291bGQgdXNlIGEgbGlicmFyeSBidXQgdGhleSB0ZW5kIHRvIGNvbnRhaW4gZG96ZW5zIG9mIEtCcyBvZiBtYXBwaW5ncyxcbi8vIG1vc3Qgb2Ygd2hpY2ggd2lsbCBnbyB1bnVzZWQsIHNvIG5vdCBzdXJlIGlmIHRoYXQncyB3b3J0aCBpdC5cbmNvbnN0IG1pbWVUb0V4dGVuc2lvbnMgPSB7XG4gICdhdWRpby9tcDMnOiAnbXAzJyxcbiAgJ2F1ZGlvL21wNCc6ICdtcDQnLFxuICAnYXVkaW8vb2dnJzogJ29nZycsXG4gICdhdWRpby93ZWJtJzogJ3dlYm0nLFxuICAnaW1hZ2UvZ2lmJzogJ2dpZicsXG4gICdpbWFnZS9oZWljJzogJ2hlaWMnLFxuICAnaW1hZ2UvaGVpZic6ICdoZWlmJyxcbiAgJ2ltYWdlL2pwZWcnOiAnanBnJyxcbiAgJ2ltYWdlL3BuZyc6ICdwbmcnLFxuICAnaW1hZ2Uvc3ZnK3htbCc6ICdzdmcnLFxuICAndmlkZW8vbXA0JzogJ21wNCcsXG4gICd2aWRlby9vZ2cnOiAnb2d2JyxcbiAgJ3ZpZGVvL3F1aWNrdGltZSc6ICdtb3YnLFxuICAndmlkZW8vd2VibSc6ICd3ZWJtJyxcbiAgJ3ZpZGVvL3gtbWF0cm9za2EnOiAnbWt2JyxcbiAgJ3ZpZGVvL3gtbXN2aWRlbyc6ICdhdmknLFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVUeXBlRXh0ZW5zaW9uIChtaW1lVHlwZSkge1xuICAvLyBSZW1vdmUgdGhlIDsgYml0IGluICd2aWRlby94LW1hdHJvc2thO2NvZGVjcz1hdmMxJ1xuICBtaW1lVHlwZSA9IG1pbWVUeXBlLnJlcGxhY2UoLzsuKiQvLCAnJylcbiAgcmV0dXJuIG1pbWVUb0V4dGVuc2lvbnNbbWltZVR5cGVdIHx8IG51bGxcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U29ja2V0SG9zdCAodXJsKSB7XG4gIC8vIGdldCB0aGUgaG9zdCBkb21haW5cbiAgdmFyIHJlZ2V4ID0gL14oPzpodHRwcz86XFwvXFwvfFxcL1xcLyk/KD86W15AXFxuXStAKT8oPzp3d3dcXC4pPyhbXlxcbl0rKS9pXG4gIHZhciBob3N0ID0gcmVnZXguZXhlYyh1cmwpWzFdXG4gIHZhciBzb2NrZXRQcm90b2NvbCA9IC9eaHR0cDpcXC9cXC8vaS50ZXN0KHVybCkgPyAnd3MnIDogJ3dzcydcblxuICByZXR1cm4gYCR7c29ja2V0UHJvdG9jb2x9Oi8vJHtob3N0fWBcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U3BlZWQgKGZpbGVQcm9ncmVzcykge1xuICBpZiAoIWZpbGVQcm9ncmVzcy5ieXRlc1VwbG9hZGVkKSByZXR1cm4gMFxuXG4gIGNvbnN0IHRpbWVFbGFwc2VkID0gKG5ldyBEYXRlKCkpIC0gZmlsZVByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgY29uc3QgdXBsb2FkU3BlZWQgPSBmaWxlUHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZCAvICh0aW1lRWxhcHNlZCAvIDEwMDApXG4gIHJldHVybiB1cGxvYWRTcGVlZFxufVxuIiwiLyoqXG4gKiBHZXQgdGhlIGRlY2xhcmVkIHRleHQgZGlyZWN0aW9uIGZvciBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudFxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VGV4dERpcmVjdGlvbiAoZWxlbWVudCkge1xuICAvLyBUaGVyZSBpcyBhbm90aGVyIHdheSB0byBkZXRlcm1pbmUgdGV4dCBkaXJlY3Rpb24gdXNpbmcgZ2V0Q29tcHV0ZWRTdHlsZSgpLCBhcyBkb25lIGhlcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wZW5jaWwtanMvdGV4dC1kaXJlY3Rpb24vYmxvYi8yYTIzNWNlOTUwODliMzE4NWFjZWMzYjUxMzEzY2JiYTkyMWIzODExL3RleHQtZGlyZWN0aW9uLmpzXG4gIC8vXG4gIC8vIFdlIGRvIG5vdCB1c2UgdGhhdCBhcHByb2FjaCBiZWNhdXNlIHdlIGFyZSBpbnRlcmVzdGVkIHNwZWNpZmljYWxseSBpbiB0aGUgX2RlY2xhcmVkXyB0ZXh0IGRpcmVjdGlvbi5cbiAgLy8gSWYgbm8gdGV4dCBkaXJlY3Rpb24gaXMgZGVjbGFyZWQsIHdlIGhhdmUgdG8gcHJvdmlkZSBvdXIgb3duIGV4cGxpY2l0IHRleHQgZGlyZWN0aW9uIHNvIG91clxuICAvLyBiaWRpcmVjdGlvbmFsIENTUyBzdHlsZSBzaGVldHMgd29yay5cbiAgd2hpbGUgKGVsZW1lbnQgJiYgIWVsZW1lbnQuZGlyKSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZVxuICB9XG4gIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5kaXIgOiB1bmRlZmluZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0RGlyZWN0aW9uXG4iLCIvKipcbiAqIFJldHVybnMgYSB0aW1lc3RhbXAgaW4gdGhlIGZvcm1hdCBvZiBgaG91cnM6bWludXRlczpzZWNvbmRzYFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFRpbWVTdGFtcCAoKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoKVxuICB2YXIgaG91cnMgPSBwYWQoZGF0ZS5nZXRIb3VycygpLnRvU3RyaW5nKCkpXG4gIHZhciBtaW51dGVzID0gcGFkKGRhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkpXG4gIHZhciBzZWNvbmRzID0gcGFkKGRhdGUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkpXG4gIHJldHVybiBgJHtob3Vyc306JHttaW51dGVzfToke3NlY29uZHN9YFxufVxuXG4vKipcbiAqIEFkZHMgemVybyB0byBzdHJpbmdzIHNob3J0ZXIgdGhhbiB0d28gY2hhcmFjdGVyc1xuICovXG5mdW5jdGlvbiBwYWQgKHN0cikge1xuICByZXR1cm4gc3RyLmxlbmd0aCAhPT0gMiA/IDAgKyBzdHIgOiBzdHJcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzIChvYmplY3QsIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KVxufVxuIiwiLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBET00gZWxlbWVudC4gRHVjay10eXBpbmcgYmFzZWQgb24gYG5vZGVUeXBlYC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRE9NRWxlbWVudCAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERVxufVxuIiwiLyoqXG4gKiBDaGVja3MgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgRHJhZyAmIERyb3AgKG5vdCBzdXBwb3J0ZWQgb24gbW9iaWxlIGRldmljZXMsIGZvciBleGFtcGxlKS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RyYWdEcm9wU3VwcG9ydGVkICgpIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICBpZiAoISgnZHJhZ2dhYmxlJyBpbiBkaXYpIHx8ICEoJ29uZHJhZ3N0YXJ0JyBpbiBkaXYgJiYgJ29uZHJvcCcgaW4gZGl2KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCEoJ0Zvcm1EYXRhJyBpbiB3aW5kb3cpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoISgnRmlsZVJlYWRlcicgaW4gd2luZG93KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsImZ1bmN0aW9uIGlzTmV0d29ya0Vycm9yICh4aHIpIHtcbiAgaWYgKCF4aHIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gKHhoci5yZWFkeVN0YXRlICE9PSAwICYmIHhoci5yZWFkeVN0YXRlICE9PSA0KSB8fCB4aHIuc3RhdHVzID09PSAwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOZXR3b3JrRXJyb3JcbiIsIi8qKlxuICogQ2hlY2sgaWYgYSBVUkwgc3RyaW5nIGlzIGFuIG9iamVjdCBVUkwgZnJvbSBgVVJMLmNyZWF0ZU9iamVjdFVSTGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPYmplY3RVUkwgKHVybCkge1xuICByZXR1cm4gdXJsLmluZGV4T2YoJ2Jsb2I6JykgPT09IDBcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmV2aWV3U3VwcG9ydGVkIChmaWxlVHlwZSkge1xuICBpZiAoIWZpbGVUeXBlKSByZXR1cm4gZmFsc2VcbiAgY29uc3QgZmlsZVR5cGVTcGVjaWZpYyA9IGZpbGVUeXBlLnNwbGl0KCcvJylbMV1cbiAgLy8gbGlzdCBvZiBpbWFnZXMgdGhhdCBicm93c2VycyBjYW4gcHJldmlld1xuICBpZiAoL14oanBlP2d8Z2lmfHBuZ3xzdmd8c3ZnXFwreG1sfGJtcHx3ZWJwfGF2aWYpJC8udGVzdChmaWxlVHlwZVNwZWNpZmljKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCIvLyBfX19XaHkgbm90IGFkZCB0aGUgbWltZS10eXBlcyBwYWNrYWdlP1xuLy8gICAgSXQncyAxOS43a0IgZ3ppcHBlZCwgYW5kIHdlIG9ubHkgbmVlZCBtaW1lIHR5cGVzIGZvciB3ZWxsLWtub3duIGV4dGVuc2lvbnMgKGZvciBmaWxlIHByZXZpZXdzKS5cbi8vIF9fX1doZXJlIHRvIHRha2UgbmV3IGV4dGVuc2lvbnMgZnJvbT9cbi8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvbWltZS1kYi9ibG9iL21hc3Rlci9kYi5qc29uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtZDogJ3RleHQvbWFya2Rvd24nLFxuICBtYXJrZG93bjogJ3RleHQvbWFya2Rvd24nLFxuICBtcDQ6ICd2aWRlby9tcDQnLFxuICBtcDM6ICdhdWRpby9tcDMnLFxuICBzdmc6ICdpbWFnZS9zdmcreG1sJyxcbiAganBnOiAnaW1hZ2UvanBlZycsXG4gIHBuZzogJ2ltYWdlL3BuZycsXG4gIGdpZjogJ2ltYWdlL2dpZicsXG4gIGhlaWM6ICdpbWFnZS9oZWljJyxcbiAgaGVpZjogJ2ltYWdlL2hlaWYnLFxuICB5YW1sOiAndGV4dC95YW1sJyxcbiAgeW1sOiAndGV4dC95YW1sJyxcbiAgY3N2OiAndGV4dC9jc3YnLFxuICB0c3Y6ICd0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzJyxcbiAgdGFiOiAndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcycsXG4gIGF2aTogJ3ZpZGVvL3gtbXN2aWRlbycsXG4gIG1rczogJ3ZpZGVvL3gtbWF0cm9za2EnLFxuICBta3Y6ICd2aWRlby94LW1hdHJvc2thJyxcbiAgbW92OiAndmlkZW8vcXVpY2t0aW1lJyxcbiAgZG9jOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgZG9jbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLmRvY3VtZW50Lm1hY3JvZW5hYmxlZC4xMicsXG4gIGRvY3g6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gIGRvdDogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gIGRvdG06ICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInLFxuICBkb3R4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGUnLFxuICB4bGE6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bGFtOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsYzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHhsZjogJ2FwcGxpY2F0aW9uL3gteGxpZmYreG1sJyxcbiAgeGxtOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGxzOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGxzYjogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9lbmFibGVkLjEyJyxcbiAgeGxzbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5tYWNyb2VuYWJsZWQuMTInLFxuICB4bHN4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnLFxuICB4bHQ6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bHRtOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsdHg6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50ZW1wbGF0ZScsXG4gIHhsdzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHR4dDogJ3RleHQvcGxhaW4nLFxuICB0ZXh0OiAndGV4dC9wbGFpbicsXG4gIGNvbmY6ICd0ZXh0L3BsYWluJyxcbiAgbG9nOiAndGV4dC9wbGFpbicsXG4gIHBkZjogJ2FwcGxpY2F0aW9uL3BkZicsXG4gIHppcDogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICc3eic6ICdhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWQnLFxuICByYXI6ICdhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkJyxcbiAgdGFyOiAnYXBwbGljYXRpb24veC10YXInLFxuICBnejogJ2FwcGxpY2F0aW9uL2d6aXAnLFxuICBkbWc6ICdhcHBsaWNhdGlvbi94LWFwcGxlLWRpc2tpbWFnZScsXG59XG4iLCJjb25zdCBzZWNvbmRzVG9UaW1lID0gcmVxdWlyZSgnLi9zZWNvbmRzVG9UaW1lJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcmV0dHlFVEEgKHNlY29uZHMpIHtcbiAgY29uc3QgdGltZSA9IHNlY29uZHNUb1RpbWUoc2Vjb25kcylcblxuICAvLyBPbmx5IGRpc3BsYXkgaG91cnMgYW5kIG1pbnV0ZXMgaWYgdGhleSBhcmUgZ3JlYXRlciB0aGFuIDAgYnV0IGFsd2F5c1xuICAvLyBkaXNwbGF5IG1pbnV0ZXMgaWYgaG91cnMgaXMgYmVpbmcgZGlzcGxheWVkXG4gIC8vIERpc3BsYXkgYSBsZWFkaW5nIHplcm8gaWYgdGhlIHRoZXJlIGlzIGEgcHJlY2VkaW5nIHVuaXQ6IDFtIDA1cywgYnV0IDVzXG4gIGNvbnN0IGhvdXJzU3RyID0gdGltZS5ob3VycyA/IGAke3RpbWUuaG91cnN9aCBgIDogJydcbiAgY29uc3QgbWludXRlc1ZhbCA9IHRpbWUuaG91cnMgPyAoYDAke3RpbWUubWludXRlc31gKS5zdWJzdHIoLTIpIDogdGltZS5taW51dGVzXG4gIGNvbnN0IG1pbnV0ZXNTdHIgPSBtaW51dGVzVmFsID8gYCR7bWludXRlc1ZhbH1tYCA6ICcnXG4gIGNvbnN0IHNlY29uZHNWYWwgPSBtaW51dGVzVmFsID8gKGAwJHt0aW1lLnNlY29uZHN9YCkuc3Vic3RyKC0yKSA6IHRpbWUuc2Vjb25kc1xuICBjb25zdCBzZWNvbmRzU3RyID0gdGltZS5ob3VycyA/ICcnIDogKG1pbnV0ZXNWYWwgPyBgICR7c2Vjb25kc1ZhbH1zYCA6IGAke3NlY29uZHNWYWx9c2ApXG5cbiAgcmV0dXJuIGAke2hvdXJzU3RyfSR7bWludXRlc1N0cn0ke3NlY29uZHNTdHJ9YFxufVxuIiwiY29uc3QgZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24gPSByZXF1aXJlKCcuL2dldEZpbGVOYW1lQW5kRXh0ZW5zaW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZW1vdGVGaWxlT2JqVG9Mb2NhbCAoZmlsZSkge1xuICByZXR1cm4ge1xuICAgIC4uLmZpbGUsXG4gICAgdHlwZTogZmlsZS5taW1lVHlwZSxcbiAgICBleHRlbnNpb246IGZpbGUubmFtZSA/IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uKGZpbGUubmFtZSkuZXh0ZW5zaW9uIDogbnVsbCxcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZWNvbmRzVG9UaW1lIChyYXdTZWNvbmRzKSB7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihyYXdTZWNvbmRzIC8gMzYwMCkgJSAyNFxuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihyYXdTZWNvbmRzIC8gNjApICUgNjBcbiAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IocmF3U2Vjb25kcyAlIDYwKVxuXG4gIHJldHVybiB7IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlIChwcm9taXNlcykge1xuICBjb25zdCByZXNvbHV0aW9ucyA9IFtdXG4gIGNvbnN0IHJlamVjdGlvbnMgPSBbXVxuICBmdW5jdGlvbiByZXNvbHZlZCAodmFsdWUpIHtcbiAgICByZXNvbHV0aW9ucy5wdXNoKHZhbHVlKVxuICB9XG4gIGZ1bmN0aW9uIHJlamVjdGVkIChlcnJvcikge1xuICAgIHJlamVjdGlvbnMucHVzaChlcnJvcilcbiAgfVxuXG4gIGNvbnN0IHdhaXQgPSBQcm9taXNlLmFsbChcbiAgICBwcm9taXNlcy5tYXAoKHByb21pc2UpID0+IHByb21pc2UudGhlbihyZXNvbHZlZCwgcmVqZWN0ZWQpKVxuICApXG5cbiAgcmV0dXJuIHdhaXQudGhlbigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3NmdWw6IHJlc29sdXRpb25zLFxuICAgICAgZmFpbGVkOiByZWplY3Rpb25zLFxuICAgIH1cbiAgfSlcbn1cbiIsIi8qKlxuICogQ29udmVydHMgbGlzdCBpbnRvIGFycmF5XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9BcnJheSAobGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCB8fCBbXSwgMClcbn1cbiIsIi8qKlxuICogVHJ1bmNhdGVzIGEgc3RyaW5nIHRvIHRoZSBnaXZlbiBudW1iZXIgb2YgY2hhcnMgKG1heExlbmd0aCkgYnkgaW5zZXJ0aW5nICcuLi4nIGluIHRoZSBtaWRkbGUgb2YgdGhhdCBzdHJpbmcuXG4gKiBQYXJ0aWFsbHkgdGFrZW4gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTcyMzI3NC8zMTkyNDcwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBzdHJpbmcgdG8gYmUgdHJ1bmNhdGVkXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuZ3RoIC0gbWF4aW11bSBzaXplIG9mIHRoZSByZXN1bHRpbmcgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRydW5jYXRlU3RyaW5nIChzdHJpbmcsIG1heExlbmd0aCkge1xuICBjb25zdCBzZXBhcmF0b3IgPSAnLi4uJ1xuXG4gIC8vIFJldHVybiBvcmlnaW5hbCBzdHJpbmcgaWYgaXQncyBhbHJlYWR5IHNob3J0ZXIgdGhhbiBtYXhMZW5ndGhcbiAgaWYgKHN0cmluZy5sZW5ndGggPD0gbWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0cmluZ1xuICAvLyBSZXR1cm4gdHJ1bmNhdGVkIHN1YnN0cmluZyB3aXRob3V0ICcuLi4nIGlmIHN0cmluZyBjYW4ndCBiZSBtZWFuaW5nZnVsbHkgdHJ1bmNhdGVkXG4gIH0gaWYgKG1heExlbmd0aCA8PSBzZXBhcmF0b3IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgbWF4TGVuZ3RoKVxuICAvLyBSZXR1cm4gdHJ1bmNhdGVkIHN0cmluZyBkaXZpZGVkIGluIGhhbGYgYnkgJy4uLidcbiAgfVxuICBjb25zdCBjaGFyc1RvU2hvdyA9IG1heExlbmd0aCAtIHNlcGFyYXRvci5sZW5ndGhcbiAgY29uc3QgZnJvbnRDaGFycyA9IE1hdGguY2VpbChjaGFyc1RvU2hvdyAvIDIpXG4gIGNvbnN0IGJhY2tDaGFycyA9IE1hdGguZmxvb3IoY2hhcnNUb1Nob3cgLyAyKVxuXG4gIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIGZyb250Q2hhcnMpICsgc2VwYXJhdG9yICsgc3RyaW5nLnN1YnN0cihzdHJpbmcubGVuZ3RoIC0gYmFja0NoYXJzKVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS93ZWJjYW1cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlVwcHkgcGx1Z2luIHRoYXQgdGFrZXMgcGhvdG9zIG9yIHJlY29yZHMgdmlkZW9zIHVzaW5nIHRoZSBkZXZpY2UncyBjYW1lcmEuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuOC4xMVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwid2ViY2FtXCIsXG4gICAgXCJwaWN0dXJlXCIsXG4gICAgXCJwaG90b1wiLFxuICAgIFwidmlkZW9cIixcbiAgICBcInJlY29yZFwiLFxuICAgIFwibWVkaWFyZWNvcmRlclwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBmaWxsPVwiIzAwOTdEQ1wiIHdpZHRoPVwiNjZcIiBoZWlnaHQ9XCI1NVwiIHZpZXdCb3g9XCIwIDAgNjYgNTVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNNTcuMyA4LjQzM2M0LjU5IDAgOC4xIDMuNTEgOC4xIDguMXYyOS43YzAgNC41OS0zLjUxIDguMS04LjEgOC4xSDguN2MtNC41OSAwLTguMS0zLjUxLTguMS04LjF2LTI5LjdjMC00LjU5IDMuNTEtOC4xIDguMS04LjFoOS40NWw0LjU5LTcuMDJjLjU0LS41NCAxLjM1LTEuMDggMi4xNi0xLjA4aDE2LjJjLjgxIDAgMS42Mi41NCAyLjE2IDEuMDhsNC41OSA3LjAyaDkuNDV6TTMzIDE0LjY0Yy04LjYyIDAtMTUuMzkzIDYuNzczLTE1LjM5MyAxNS4zOTMgMCA4LjYyIDYuNzczIDE1LjM5MyAxNS4zOTMgMTUuMzkzIDguNjIgMCAxNS4zOTMtNi43NzMgMTUuMzkzLTE1LjM5MyAwLTguNjItNi43NzMtMTUuMzkzLTE1LjM5My0xNS4zOTN6TTMzIDQwYy01LjY0OCAwLTkuOTY2LTQuMzE5LTkuOTY2LTkuOTY3IDAtNS42NDcgNC4zMTgtOS45NjYgOS45NjYtOS45NjZzOS45NjYgNC4zMTkgOS45NjYgOS45NjZDNDIuOTY2IDM1LjY4MSAzOC42NDggNDAgMzMgNDB6XCIgZmlsbFJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUganN4LWExMXkvbWVkaWEtaGFzLWNhcHRpb24gKi9cbmNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgU25hcHNob3RCdXR0b24gPSByZXF1aXJlKCcuL1NuYXBzaG90QnV0dG9uJylcbmNvbnN0IFJlY29yZEJ1dHRvbiA9IHJlcXVpcmUoJy4vUmVjb3JkQnV0dG9uJylcbmNvbnN0IFJlY29yZGluZ0xlbmd0aCA9IHJlcXVpcmUoJy4vUmVjb3JkaW5nTGVuZ3RoJylcbmNvbnN0IFZpZGVvU291cmNlU2VsZWN0ID0gcmVxdWlyZSgnLi9WaWRlb1NvdXJjZVNlbGVjdCcpXG5jb25zdCBTdWJtaXRCdXR0b24gPSByZXF1aXJlKCcuL1N1Ym1pdEJ1dHRvbicpXG5jb25zdCBEaXNjYXJkQnV0dG9uID0gcmVxdWlyZSgnLi9EaXNjYXJkQnV0dG9uJylcblxuZnVuY3Rpb24gaXNNb2RlQXZhaWxhYmxlIChtb2RlcywgbW9kZSkge1xuICByZXR1cm4gbW9kZXMuaW5kZXhPZihtb2RlKSAhPT0gLTFcbn1cblxuY2xhc3MgQ2FtZXJhU2NyZWVuIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIGNvbnN0IHsgb25Gb2N1cyB9ID0gdGhpcy5wcm9wc1xuICAgIG9uRm9jdXMoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIGNvbnN0IHsgb25TdG9wIH0gPSB0aGlzLnByb3BzXG4gICAgb25TdG9wKClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjLFxuICAgICAgcmVjb3JkZWRWaWRlbyxcbiAgICAgIHJlY29yZGluZyxcbiAgICAgIG1vZGVzLFxuICAgICAgc3VwcG9ydHNSZWNvcmRpbmcsXG4gICAgICB2aWRlb1NvdXJjZXMsXG4gICAgICBzaG93VmlkZW9Tb3VyY2VEcm9wZG93bixcbiAgICAgIHNob3dSZWNvcmRpbmdMZW5ndGgsXG4gICAgICBvblN1Ym1pdCxcbiAgICAgIGkxOG4sXG4gICAgICBtaXJyb3IsXG4gICAgICBvblNuYXBzaG90LFxuICAgICAgb25TdGFydFJlY29yZGluZyxcbiAgICAgIG9uU3RvcFJlY29yZGluZyxcbiAgICAgIG9uRGlzY2FyZFJlY29yZGVkVmlkZW8sXG4gICAgICByZWNvcmRpbmdMZW5ndGhTZWNvbmRzLFxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCBoYXNSZWNvcmRlZFZpZGVvID0gISFyZWNvcmRlZFZpZGVvXG4gICAgY29uc3Qgc2hvdWxkU2hvd1JlY29yZEJ1dHRvbiA9ICFoYXNSZWNvcmRlZFZpZGVvICYmIHN1cHBvcnRzUmVjb3JkaW5nICYmIChcbiAgICAgIGlzTW9kZUF2YWlsYWJsZShtb2RlcywgJ3ZpZGVvLW9ubHknKVxuICAgICAgfHwgaXNNb2RlQXZhaWxhYmxlKG1vZGVzLCAnYXVkaW8tb25seScpXG4gICAgICB8fCBpc01vZGVBdmFpbGFibGUobW9kZXMsICd2aWRlby1hdWRpbycpXG4gICAgKVxuICAgIGNvbnN0IHNob3VsZFNob3dTbmFwc2hvdEJ1dHRvbiA9ICFoYXNSZWNvcmRlZFZpZGVvICYmIGlzTW9kZUF2YWlsYWJsZShtb2RlcywgJ3BpY3R1cmUnKVxuICAgIGNvbnN0IHNob3VsZFNob3dSZWNvcmRpbmdMZW5ndGggPSBzdXBwb3J0c1JlY29yZGluZyAmJiBzaG93UmVjb3JkaW5nTGVuZ3RoXG4gICAgY29uc3Qgc2hvdWxkU2hvd1ZpZGVvU291cmNlRHJvcGRvd24gPSBzaG93VmlkZW9Tb3VyY2VEcm9wZG93biAmJiB2aWRlb1NvdXJjZXMgJiYgdmlkZW9Tb3VyY2VzLmxlbmd0aCA+IDFcblxuICAgIGNvbnN0IHZpZGVvUHJvcHMgPSB7XG4gICAgICBwbGF5c2lubGluZTogdHJ1ZSxcbiAgICB9XG5cbiAgICBpZiAocmVjb3JkZWRWaWRlbykge1xuICAgICAgdmlkZW9Qcm9wcy5tdXRlZCA9IGZhbHNlXG4gICAgICB2aWRlb1Byb3BzLmNvbnRyb2xzID0gdHJ1ZVxuICAgICAgdmlkZW9Qcm9wcy5zcmMgPSByZWNvcmRlZFZpZGVvXG5cbiAgICAgIC8vIHJlc2V0IHNyY09iamVjdCBpbiBkb20uIElmIG5vdCByZXNldHRlZCwgc3RyZWFtIHN0aWNrcyBpbiBlbGVtZW50XG4gICAgICBpZiAodGhpcy52aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvUHJvcHMubXV0ZWQgPSB0cnVlXG4gICAgICB2aWRlb1Byb3BzLmF1dG9wbGF5ID0gdHJ1ZVxuICAgICAgdmlkZW9Qcm9wcy5zcmNPYmplY3QgPSBzcmNcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5IHVwcHktV2ViY2FtLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXZpZGVvQ29udGFpbmVyXCI+XG4gICAgICAgICAgPHZpZGVvXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmV0dXJuLWFzc2lnbiAqL1xuICAgICAgICAgICAgcmVmPXsodmlkZW9FbGVtZW50KSA9PiAodGhpcy52aWRlb0VsZW1lbnQgPSB2aWRlb0VsZW1lbnQpfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgdXBweS1XZWJjYW0tdmlkZW8gICR7bWlycm9yID8gJ3VwcHktV2ViY2FtLXZpZGVvLS1taXJyb3JlZCcgOiAnJ31gfVxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1wcm9wcy1uby1zcHJlYWRpbmcgKi9cbiAgICAgICAgICAgIHsuLi52aWRlb1Byb3BzfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLWZvb3RlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tdmlkZW9Tb3VyY2VDb250YWluZXJcIj5cbiAgICAgICAgICAgIHtzaG91bGRTaG93VmlkZW9Tb3VyY2VEcm9wZG93blxuICAgICAgICAgICAgICA/IFZpZGVvU291cmNlU2VsZWN0KHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgIDogbnVsbH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLWJ1dHRvbkNvbnRhaW5lclwiPlxuICAgICAgICAgICAge3Nob3VsZFNob3dTbmFwc2hvdEJ1dHRvbiAmJiA8U25hcHNob3RCdXR0b24gb25TbmFwc2hvdD17b25TbmFwc2hvdH0gaTE4bj17aTE4bn0gLz59XG5cbiAgICAgICAgICAgIHtzaG91bGRTaG93UmVjb3JkQnV0dG9uICYmIChcbiAgICAgICAgICAgICAgPFJlY29yZEJ1dHRvblxuICAgICAgICAgICAgICAgIHJlY29yZGluZz17cmVjb3JkaW5nfVxuICAgICAgICAgICAgICAgIG9uU3RhcnRSZWNvcmRpbmc9e29uU3RhcnRSZWNvcmRpbmd9XG4gICAgICAgICAgICAgICAgb25TdG9wUmVjb3JkaW5nPXtvblN0b3BSZWNvcmRpbmd9XG4gICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgIHtoYXNSZWNvcmRlZFZpZGVvICYmIDxTdWJtaXRCdXR0b24gb25TdWJtaXQ9e29uU3VibWl0fSBpMThuPXtpMThufSAvPn1cblxuICAgICAgICAgICAge2hhc1JlY29yZGVkVmlkZW8gJiYgPERpc2NhcmRCdXR0b24gb25EaXNjYXJkPXtvbkRpc2NhcmRSZWNvcmRlZFZpZGVvfSBpMThuPXtpMThufSAvPn1cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHtzaG91bGRTaG93UmVjb3JkaW5nTGVuZ3RoICYmIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tcmVjb3JkaW5nTGVuZ3RoXCI+XG4gICAgICAgICAgICAgIDxSZWNvcmRpbmdMZW5ndGggcmVjb3JkaW5nTGVuZ3RoU2Vjb25kcz17cmVjb3JkaW5nTGVuZ3RoU2Vjb25kc30gaTE4bj17aTE4bn0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhU2NyZWVuXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmZ1bmN0aW9uIERpc2NhcmRCdXR0b24gKHsgb25EaXNjYXJkLCBpMThuIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVdlYmNhbS1idXR0b25cIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICB0aXRsZT17aTE4bignZGlzY2FyZFJlY29yZGVkRmlsZScpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bignZGlzY2FyZFJlY29yZGVkRmlsZScpfVxuICAgICAgb25DbGljaz17b25EaXNjYXJkfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIDxzdmdcbiAgICAgICAgd2lkdGg9XCIxM1wiXG4gICAgICAgIGhlaWdodD1cIjEzXCJcbiAgICAgICAgdmlld0JveD1cIjAgMCAxMyAxM1wiXG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCJcbiAgICAgID5cbiAgICAgICAgPGcgZmlsbD1cIiNGRkZcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTS40OTYgMTEuMzY3TDExLjEwMy43NmwxLjQxNCAxLjQxNEwxLjkxMSAxMi43ODF6XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTExLjEwNCAxMi43ODJMLjQ5NyAyLjE3NSAxLjkxMS43NmwxMC42MDcgMTAuNjA2elwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzY2FyZEJ1dHRvblxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tcGVybWlzc29uc1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVdlYmNhbS1wZXJtaXNzb25zSWNvblwiPntwcm9wcy5pY29uKCl9PC9kaXY+XG4gICAgICA8aDEgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tdGl0bGVcIj57cHJvcHMuaGFzQ2FtZXJhID8gcHJvcHMuaTE4bignYWxsb3dBY2Nlc3NUaXRsZScpIDogcHJvcHMuaTE4bignbm9DYW1lcmFUaXRsZScpfTwvaDE+XG4gICAgICA8cD57cHJvcHMuaGFzQ2FtZXJhID8gcHJvcHMuaTE4bignYWxsb3dBY2Nlc3NEZXNjcmlwdGlvbicpIDogcHJvcHMuaTE4bignbm9DYW1lcmFEZXNjcmlwdGlvbicpfTwvcD5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFJlY29yZEJ1dHRvbiAoeyByZWNvcmRpbmcsIG9uU3RhcnRSZWNvcmRpbmcsIG9uU3RvcFJlY29yZGluZywgaTE4biB9KSB7XG4gIGlmIChyZWNvcmRpbmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVdlYmNhbS1idXR0b25cIlxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgdGl0bGU9e2kxOG4oJ3N0b3BSZWNvcmRpbmcnKX1cbiAgICAgICAgYXJpYS1sYWJlbD17aTE4bignc3RvcFJlY29yZGluZycpfVxuICAgICAgICBvbkNsaWNrPXtvblN0b3BSZWNvcmRpbmd9XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgID5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgICAgICAgICA8cmVjdCB4PVwiMTVcIiB5PVwiMTVcIiB3aWR0aD1cIjcwXCIgaGVpZ2h0PVwiNzBcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgdGl0bGU9e2kxOG4oJ3N0YXJ0UmVjb3JkaW5nJyl9XG4gICAgICBhcmlhLWxhYmVsPXtpMThuKCdzdGFydFJlY29yZGluZycpfVxuICAgICAgb25DbGljaz17b25TdGFydFJlY29yZGluZ31cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiPlxuICAgICAgICA8Y2lyY2xlIGN4PVwiNTBcIiBjeT1cIjUwXCIgcj1cIjQwXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBmb3JtYXRTZWNvbmRzID0gcmVxdWlyZSgnLi9mb3JtYXRTZWNvbmRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWNvcmRpbmdMZW5ndGggKHsgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kcywgaTE4biB9KSB7XG4gIGNvbnN0IGZvcm1hdHRlZFJlY29yZGluZ0xlbmd0aFNlY29uZHMgPSBmb3JtYXRTZWNvbmRzKHJlY29yZGluZ0xlbmd0aFNlY29uZHMpXG5cbiAgcmV0dXJuIChcbiAgICA8c3BhbiBhcmlhLWxhYmVsPXtpMThuKCdyZWNvcmRpbmdMZW5ndGgnLCB7IHJlY29yZGluZ19sZW5ndGg6IGZvcm1hdHRlZFJlY29yZGluZ0xlbmd0aFNlY29uZHMgfSl9PlxuICAgICAge2Zvcm1hdHRlZFJlY29yZGluZ0xlbmd0aFNlY29uZHN9XG4gICAgPC9zcGFuPlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBDYW1lcmFJY29uID0gcmVxdWlyZSgnLi9DYW1lcmFJY29uJylcblxubW9kdWxlLmV4cG9ydHMgPSAoeyBvblNuYXBzaG90LCBpMThuIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVdlYmNhbS1idXR0b24gdXBweS1XZWJjYW0tYnV0dG9uLS1waWN0dXJlXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgdGl0bGU9e2kxOG4oJ3Rha2VQaWN0dXJlJyl9XG4gICAgICBhcmlhLWxhYmVsPXtpMThuKCd0YWtlUGljdHVyZScpfVxuICAgICAgb25DbGljaz17b25TbmFwc2hvdH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICB7Q2FtZXJhSWNvbigpfVxuICAgIDwvYnV0dG9uPlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmZ1bmN0aW9uIFN1Ym1pdEJ1dHRvbiAoeyBvblN1Ym1pdCwgaTE4biB9KSB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uIHVwcHktV2ViY2FtLWJ1dHRvbi0tc3VibWl0XCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgdGl0bGU9e2kxOG4oJ3N1Ym1pdFJlY29yZGVkRmlsZScpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bignc3VibWl0UmVjb3JkZWRGaWxlJyl9XG4gICAgICBvbkNsaWNrPXtvblN1Ym1pdH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICA8c3ZnXG4gICAgICAgIHdpZHRoPVwiMTJcIlxuICAgICAgICBoZWlnaHQ9XCI5XCJcbiAgICAgICAgdmlld0JveD1cIjAgMCAxMiA5XCJcbiAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIlxuICAgICAgPlxuICAgICAgICA8cGF0aCBmaWxsPVwiI2ZmZlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIGQ9XCJNMTAuNjYgMEwxMiAxLjMxIDQuMTM2IDkgMCA0Ljk1NmwxLjM0LTEuMzFMNC4xMzYgNi4zOHpcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdWJtaXRCdXR0b25cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAoeyBjdXJyZW50RGV2aWNlSWQsIHZpZGVvU291cmNlcywgb25DaGFuZ2VWaWRlb1NvdXJjZSB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVdlYmNhbS12aWRlb1NvdXJjZVwiPlxuICAgICAgPHNlbGVjdFxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1XZWJjYW0tdmlkZW9Tb3VyY2Utc2VsZWN0XCJcbiAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT4geyBvbkNoYW5nZVZpZGVvU291cmNlKGV2ZW50LnRhcmdldC52YWx1ZSkgfX1cbiAgICAgID5cbiAgICAgICAge3ZpZGVvU291cmNlcy5tYXAoKHZpZGVvU291cmNlKSA9PiAoXG4gICAgICAgICAgPG9wdGlvblxuICAgICAgICAgICAga2V5PXt2aWRlb1NvdXJjZS5kZXZpY2VJZH1cbiAgICAgICAgICAgIHZhbHVlPXt2aWRlb1NvdXJjZS5kZXZpY2VJZH1cbiAgICAgICAgICAgIHNlbGVjdGVkPXt2aWRlb1NvdXJjZS5kZXZpY2VJZCA9PT0gY3VycmVudERldmljZUlkfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt2aWRlb1NvdXJjZS5sYWJlbH1cbiAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgKSl9XG4gICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiLyoqXG4gKiBUYWtlcyBhbiBJbnRlZ2VyIHZhbHVlIG9mIHNlY29uZHMgKGUuZy4gODMpIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAnMToyMycpLlxuICpcbiAqIEBwYXJhbSB7SW50ZWdlcn0gc2Vjb25kc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGZvcm1hdHRlZCBzZWNvbmRzIChlLmcuICcxOjIzJyBmb3IgMSBtaW51dGUgYW5kIDIzIHNlY29uZHMpXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvcm1hdFNlY29uZHMgKHNlY29uZHMpIHtcbiAgcmV0dXJuIGAke01hdGguZmxvb3IoXG4gICAgc2Vjb25kcyAvIDYwXG4gICl9OiR7U3RyaW5nKHNlY29uZHMgJSA2MCkucGFkU3RhcnQoMiwgMCl9YFxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IGdldEZpbGVUeXBlRXh0ZW5zaW9uID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVUeXBlRXh0ZW5zaW9uJylcbmNvbnN0IG1pbWVUeXBlcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9taW1lVHlwZXMnKVxuY29uc3QgY2FudmFzVG9CbG9iID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2NhbnZhc1RvQmxvYicpXG5jb25zdCBzdXBwb3J0c01lZGlhUmVjb3JkZXIgPSByZXF1aXJlKCcuL3N1cHBvcnRzTWVkaWFSZWNvcmRlcicpXG5jb25zdCBDYW1lcmFJY29uID0gcmVxdWlyZSgnLi9DYW1lcmFJY29uJylcbmNvbnN0IENhbWVyYVNjcmVlbiA9IHJlcXVpcmUoJy4vQ2FtZXJhU2NyZWVuJylcbmNvbnN0IFBlcm1pc3Npb25zU2NyZWVuID0gcmVxdWlyZSgnLi9QZXJtaXNzaW9uc1NjcmVlbicpXG5jb25zdCBwYWNrYWdlSnNvblZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbi8qKlxuICogTm9ybWFsaXplIGEgTUlNRSB0eXBlIG9yIGZpbGUgZXh0ZW5zaW9uIGludG8gYSBNSU1FIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVUeXBlIC0gTUlNRSB0eXBlIG9yIGEgZmlsZSBleHRlbnNpb24gcHJlZml4ZWQgd2l0aCBgLmAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIE1JTUUgdHlwZSBvciBgdW5kZWZpbmVkYCBpZiB0aGUgZmlsZVR5cGUgaXMgYW4gZXh0ZW5zaW9uIGFuZCBpcyBub3Qga25vd24uXG4gKi9cbmZ1bmN0aW9uIHRvTWltZVR5cGUgKGZpbGVUeXBlKSB7XG4gIGlmIChmaWxlVHlwZVswXSA9PT0gJy4nKSB7XG4gICAgcmV0dXJuIG1pbWVUeXBlc1tmaWxlVHlwZS5zbGljZSgxKV1cbiAgfVxuICByZXR1cm4gZmlsZVR5cGVcbn1cblxuLyoqXG4gKiBJcyB0aGlzIE1JTUUgdHlwZSBhIHZpZGVvP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIE1JTUUgdHlwZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZpZGVvTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIHJldHVybiAvXnZpZGVvXFwvW14qXSskLy50ZXN0KG1pbWVUeXBlKVxufVxuXG4vKipcbiAqIElzIHRoaXMgTUlNRSB0eXBlIGFuIGltYWdlP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIE1JTUUgdHlwZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ltYWdlTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIHJldHVybiAvXmltYWdlXFwvW14qXSskLy50ZXN0KG1pbWVUeXBlKVxufVxuXG4vKipcbiAqIFNldHVwIGdldFVzZXJNZWRpYSwgd2l0aCBwb2x5ZmlsbCBmb3Igb2xkZXIgYnJvd3NlcnNcbiAqIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXRVc2VyTWVkaWFcbiAqL1xuZnVuY3Rpb24gZ2V0TWVkaWFEZXZpY2VzICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gIH1cblxuICBjb25zdCBnZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWFcbiAgaWYgKCFnZXRVc2VyTWVkaWEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRVc2VyTWVkaWEgKG9wdHMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGdldFVzZXJNZWRpYS5jYWxsKG5hdmlnYXRvciwgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4vKipcbiAqIFdlYmNhbVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFdlYmNhbSBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcGFja2FnZUpzb25WZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMubWVkaWFEZXZpY2VzID0gZ2V0TWVkaWFEZXZpY2VzKClcbiAgICB0aGlzLnN1cHBvcnRzVXNlck1lZGlhID0gISF0aGlzLm1lZGlhRGV2aWNlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICB0aGlzLnByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL2h0dHBzL2kpID8gJ2h0dHBzJyA6ICdodHRwJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1dlYmNhbSdcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdDYW1lcmEnXG4gICAgdGhpcy50eXBlID0gJ2FjcXVpcmVyJ1xuICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBudWxsXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiMwM0JGRUZcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTIyIDExYzEuMTMzIDAgMiAuODY3IDIgMnY3LjMzM2MwIDEuMTM0LS44NjcgMi0yIDJIMTBjLTEuMTMzIDAtMi0uODY2LTItMlYxM2MwLTEuMTMzLjg2Ny0yIDItMmgyLjMzM2wxLjEzNC0xLjczM0MxMy42IDkuMTMzIDEzLjggOSAxNCA5aDRjLjIgMCAuNC4xMzMuNTMzLjI2N0wxOS42NjcgMTFIMjJ6bS02IDEuNTMzYTMuNzY0IDMuNzY0IDAgMCAwLTMuOCAzLjhjMCAyLjEyOSAxLjY3MiAzLjgwMSAzLjggMy44MDFzMy44LTEuNjcyIDMuOC0zLjhjMC0yLjEzLTEuNjcyLTMuODAxLTMuOC0zLjgwMXptMCA2LjI2MWMtMS4zOTUgMC0yLjQ2LTEuMDY2LTIuNDYtMi40NiAwLTEuMzk1IDEuMDY1LTIuNDYxIDIuNDYtMi40NjFzMi40NiAxLjA2NiAyLjQ2IDIuNDZjMCAxLjM5NS0xLjA2NSAyLjQ2MS0yLjQ2IDIuNDYxelwiIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBzbWlsZTogJ1NtaWxlIScsXG4gICAgICAgIHRha2VQaWN0dXJlOiAnVGFrZSBhIHBpY3R1cmUnLFxuICAgICAgICBzdGFydFJlY29yZGluZzogJ0JlZ2luIHZpZGVvIHJlY29yZGluZycsXG4gICAgICAgIHN0b3BSZWNvcmRpbmc6ICdTdG9wIHZpZGVvIHJlY29yZGluZycsXG4gICAgICAgIGFsbG93QWNjZXNzVGl0bGU6ICdQbGVhc2UgYWxsb3cgYWNjZXNzIHRvIHlvdXIgY2FtZXJhJyxcbiAgICAgICAgYWxsb3dBY2Nlc3NEZXNjcmlwdGlvbjogJ0luIG9yZGVyIHRvIHRha2UgcGljdHVyZXMgb3IgcmVjb3JkIHZpZGVvIHdpdGggeW91ciBjYW1lcmEsIHBsZWFzZSBhbGxvdyBjYW1lcmEgYWNjZXNzIGZvciB0aGlzIHNpdGUuJyxcbiAgICAgICAgbm9DYW1lcmFUaXRsZTogJ0NhbWVyYSBOb3QgQXZhaWxhYmxlJyxcbiAgICAgICAgbm9DYW1lcmFEZXNjcmlwdGlvbjogJ0luIG9yZGVyIHRvIHRha2UgcGljdHVyZXMgb3IgcmVjb3JkIHZpZGVvLCBwbGVhc2UgY29ubmVjdCBhIGNhbWVyYSBkZXZpY2UnLFxuICAgICAgICByZWNvcmRpbmdTdG9wcGVkTWF4U2l6ZTogJ1JlY29yZGluZyBzdG9wcGVkIGJlY2F1c2UgdGhlIGZpbGUgc2l6ZSBpcyBhYm91dCB0byBleGNlZWQgdGhlIGxpbWl0JyxcbiAgICAgICAgcmVjb3JkaW5nTGVuZ3RoOiAnUmVjb3JkaW5nIGxlbmd0aCAle3JlY29yZGluZ19sZW5ndGh9JyxcbiAgICAgICAgc3VibWl0UmVjb3JkZWRGaWxlOiAnU3VibWl0IHJlY29yZGVkIGZpbGUnLFxuICAgICAgICBkaXNjYXJkUmVjb3JkZWRGaWxlOiAnRGlzY2FyZCByZWNvcmRlZCBmaWxlJyxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgb25CZWZvcmVTbmFwc2hvdDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICBjb3VudGRvd246IGZhbHNlLFxuICAgICAgbW9kZXM6IFtcbiAgICAgICAgJ3ZpZGVvLWF1ZGlvJyxcbiAgICAgICAgJ3ZpZGVvLW9ubHknLFxuICAgICAgICAnYXVkaW8tb25seScsXG4gICAgICAgICdwaWN0dXJlJyxcbiAgICAgIF0sXG4gICAgICBtaXJyb3I6IHRydWUsXG4gICAgICBzaG93VmlkZW9Tb3VyY2VEcm9wZG93bjogZmFsc2UsXG4gICAgICBmYWNpbmdNb2RlOiAndXNlcicsXG4gICAgICBwcmVmZXJyZWRJbWFnZU1pbWVUeXBlOiBudWxsLFxuICAgICAgcHJlZmVycmVkVmlkZW9NaW1lVHlwZTogbnVsbCxcbiAgICAgIHNob3dSZWNvcmRpbmdMZW5ndGg6IGZhbHNlLFxuICAgIH1cblxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG5cbiAgICB0aGlzLmluc3RhbGwgPSB0aGlzLmluc3RhbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUgPSB0aGlzLnNldFBsdWdpblN0YXRlLmJpbmQodGhpcylcblxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLy8gQ2FtZXJhIGNvbnRyb2xzXG4gICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RvcCA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpXG4gICAgdGhpcy50YWtlU25hcHNob3QgPSB0aGlzLnRha2VTbmFwc2hvdC5iaW5kKHRoaXMpXG4gICAgdGhpcy5zdGFydFJlY29yZGluZyA9IHRoaXMuc3RhcnRSZWNvcmRpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RvcFJlY29yZGluZyA9IHRoaXMuc3RvcFJlY29yZGluZy5iaW5kKHRoaXMpXG4gICAgdGhpcy5kaXNjYXJkUmVjb3JkZWRWaWRlbyA9IHRoaXMuZGlzY2FyZFJlY29yZGVkVmlkZW8uYmluZCh0aGlzKVxuICAgIHRoaXMuc3VibWl0ID0gdGhpcy5zdWJtaXQuYmluZCh0aGlzKVxuICAgIHRoaXMub25lVHdvVGhyZWVTbWlsZSA9IHRoaXMub25lVHdvVGhyZWVTbWlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5mb2N1cyA9IHRoaXMuZm9jdXMuYmluZCh0aGlzKVxuICAgIHRoaXMuY2hhbmdlVmlkZW9Tb3VyY2UgPSB0aGlzLmNoYW5nZVZpZGVvU291cmNlLmJpbmQodGhpcylcblxuICAgIHRoaXMud2ViY2FtQWN0aXZlID0gZmFsc2VcblxuICAgIGlmICh0aGlzLm9wdHMuY291bnRkb3duKSB7XG4gICAgICB0aGlzLm9wdHMub25CZWZvcmVTbmFwc2hvdCA9IHRoaXMub25lVHdvVGhyZWVTbWlsZVxuICAgIH1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgaGFzQ2FtZXJhOiBmYWxzZSxcbiAgICAgIGNhbWVyYVJlYWR5OiBmYWxzZSxcbiAgICAgIGNhbWVyYUVycm9yOiBudWxsLFxuICAgICAgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCxcbiAgICAgIHZpZGVvU291cmNlczogW10sXG4gICAgICBjdXJyZW50RGV2aWNlSWQ6IG51bGwsXG4gICAgfSlcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICBzdXBlci5zZXRPcHRpb25zKHtcbiAgICAgIC4uLm5ld09wdHMsXG4gICAgICB2aWRlb0NvbnN0cmFpbnRzOiB7XG4gICAgICAgIC8vIE1heSBiZSB1bmRlZmluZWQgYnV0IC4uLiBoYW5kbGVzIHRoYXRcbiAgICAgICAgLi4udGhpcy5vcHRzLnZpZGVvQ29uc3RyYWludHMsXG4gICAgICAgIC4uLm5ld09wdHM/LnZpZGVvQ29uc3RyYWludHMsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgfVxuXG4gIGkxOG5Jbml0ICgpIHtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihbdGhpcy5kZWZhdWx0TG9jYWxlLCB0aGlzLnVwcHkubG9jYWxlLCB0aGlzLm9wdHMubG9jYWxlXSlcbiAgICB0aGlzLmkxOG4gPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlLmJpbmQodGhpcy50cmFuc2xhdG9yKVxuICAgIHRoaXMuaTE4bkFycmF5ID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZUFycmF5LmJpbmQodGhpcy50cmFuc2xhdG9yKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoKSAvLyBzbyB0aGF0IFVJIHJlLXJlbmRlcnMgYW5kIHdlIHNlZSB0aGUgdXBkYXRlZCBsb2NhbGVcbiAgfVxuXG4gIGhhc0NhbWVyYUNoZWNrICgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWFEZXZpY2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihkZXZpY2VzID0+IHtcbiAgICAgIHJldHVybiBkZXZpY2VzLnNvbWUoZGV2aWNlID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpXG4gICAgfSlcbiAgfVxuXG4gIGlzQXVkaW9Pbmx5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzLm1vZGVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm9wdHMubW9kZXNbMF0gPT09ICdhdWRpby1vbmx5J1xuICB9XG5cbiAgZ2V0Q29uc3RyYWludHMgKGRldmljZUlkID0gbnVsbCkge1xuICAgIGNvbnN0IGFjY2VwdHNBdWRpbyA9IHRoaXMub3B0cy5tb2Rlcy5pbmRleE9mKCd2aWRlby1hdWRpbycpICE9PSAtMVxuICAgICAgfHwgdGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ2F1ZGlvLW9ubHknKSAhPT0gLTFcbiAgICBjb25zdCBhY2NlcHRzVmlkZW8gPSAhdGhpcy5pc0F1ZGlvT25seSgpXG4gICAgICAgICYmICh0aGlzLm9wdHMubW9kZXMuaW5kZXhPZigndmlkZW8tYXVkaW8nKSAhPT0gLTFcbiAgICAgICAgICB8fCB0aGlzLm9wdHMubW9kZXMuaW5kZXhPZigndmlkZW8tb25seScpICE9PSAtMVxuICAgICAgICAgIHx8IHRoaXMub3B0cy5tb2Rlcy5pbmRleE9mKCdwaWN0dXJlJykgIT09IC0xKVxuXG4gICAgY29uc3QgdmlkZW9Db25zdHJhaW50cyA9IHtcbiAgICAgIC4uLih0aGlzLm9wdHMudmlkZW9Db25zdHJhaW50cyA/PyB7IGZhY2luZ01vZGU6IHRoaXMub3B0cy5mYWNpbmdNb2RlIH0pLFxuICAgICAgLy8gZmFjaW5nTW9kZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgZGV2aWNlSWQsIGFuZCBub3QgbmVlZGVkXG4gICAgICAvLyB3aGVuIHNwZWNpZmljIGRldmljZSBpcyBzZWxlY3RlZFxuICAgICAgLi4uKGRldmljZUlkID8geyBkZXZpY2VJZCwgZmFjaW5nTW9kZTogbnVsbCB9IDoge30pLFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpbzogYWNjZXB0c0F1ZGlvLFxuICAgICAgdmlkZW86IGFjY2VwdHNWaWRlbyA/IHZpZGVvQ29uc3RyYWludHMgOiBmYWxzZSxcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgc3RhcnQgKG9wdGlvbnMgPSBudWxsKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzVXNlck1lZGlhKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXZWJjYW0gYWNjZXNzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICB9XG5cbiAgICB0aGlzLndlYmNhbUFjdGl2ZSA9IHRydWVcbiAgICB0aGlzLm9wdHMubWlycm9yID0gdHJ1ZVxuXG4gICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmdldENvbnN0cmFpbnRzKG9wdGlvbnMgJiYgb3B0aW9ucy5kZXZpY2VJZCA/IG9wdGlvbnMuZGV2aWNlSWQgOiBudWxsKVxuXG4gICAgdGhpcy5oYXNDYW1lcmFDaGVjaygpLnRoZW4oaGFzQ2FtZXJhID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBoYXNDYW1lcmEsXG4gICAgICB9KVxuXG4gICAgICAvLyBhc2sgdXNlciBmb3IgYWNjZXNzIHRvIHRoZWlyIGNhbWVyYVxuICAgICAgcmV0dXJuIHRoaXMubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAgICAgLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtXG5cbiAgICAgICAgICBsZXQgY3VycmVudERldmljZUlkID0gbnVsbFxuICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMuaXNBdWRpb09ubHkoKSA/IHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpIDogc3RyZWFtLmdldFZpZGVvVHJhY2tzKClcblxuICAgICAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5kZXZpY2VJZCkge1xuICAgICAgICAgICAgY3VycmVudERldmljZUlkID0gdHJhY2tzWzBdLmdldFNldHRpbmdzKCkuZGV2aWNlSWRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0cmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkID09PSBvcHRpb25zLmRldmljZUlkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERldmljZUlkID0gdHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc291cmNlcyBub3csIHNvIHdlIGNhbiBhY2Nlc3MgdGhlIG5hbWVzLlxuICAgICAgICAgIHRoaXMudXBkYXRlVmlkZW9Tb3VyY2VzKClcblxuICAgICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAgICAgY3VycmVudERldmljZUlkLFxuICAgICAgICAgICAgY2FtZXJhUmVhZHk6IHRydWUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICAgIGNhbWVyYVJlYWR5OiBmYWxzZSxcbiAgICAgICAgICAgIGNhbWVyYUVycm9yOiBlcnIsXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyhlcnIubWVzc2FnZSwgJ2Vycm9yJylcbiAgICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBnZXRNZWRpYVJlY29yZGVyT3B0aW9ucyAoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9XG5cbiAgICAvLyBUcnkgdG8gdXNlIHRoZSBgb3B0cy5wcmVmZXJyZWRWaWRlb01pbWVUeXBlYCBvciBvbmUgb2YgdGhlIGBhbGxvd2VkRmlsZVR5cGVzYCBmb3IgdGhlIHJlY29yZGluZy5cbiAgICAvLyBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgaXQsIHdlJ2xsIGZhbGwgYmFjayB0byB0aGUgYnJvd3NlciBkZWZhdWx0IGluc3RlYWQuXG4gICAgLy8gU2FmYXJpIGRvZXNuJ3QgaGF2ZSB0aGUgYGlzVHlwZVN1cHBvcnRlZGAgQVBJLlxuICAgIGlmIChNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgeyByZXN0cmljdGlvbnMgfSA9IHRoaXMudXBweS5vcHRzXG4gICAgICBsZXQgcHJlZmVycmVkVmlkZW9NaW1lVHlwZXMgPSBbXVxuICAgICAgaWYgKHRoaXMub3B0cy5wcmVmZXJyZWRWaWRlb01pbWVUeXBlKSB7XG4gICAgICAgIHByZWZlcnJlZFZpZGVvTWltZVR5cGVzID0gW3RoaXMub3B0cy5wcmVmZXJyZWRWaWRlb01pbWVUeXBlXVxuICAgICAgfSBlbHNlIGlmIChyZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcykge1xuICAgICAgICBwcmVmZXJyZWRWaWRlb01pbWVUeXBlcyA9IHJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzLm1hcCh0b01pbWVUeXBlKS5maWx0ZXIoaXNWaWRlb01pbWVUeXBlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWx0ZXJTdXBwb3J0ZWRUeXBlcyA9IChjYW5kaWRhdGVUeXBlKSA9PiBNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZChjYW5kaWRhdGVUeXBlKVxuICAgICAgICAmJiBnZXRGaWxlVHlwZUV4dGVuc2lvbihjYW5kaWRhdGVUeXBlKVxuICAgICAgY29uc3QgYWNjZXB0YWJsZU1pbWVUeXBlcyA9IHByZWZlcnJlZFZpZGVvTWltZVR5cGVzLmZpbHRlcihmaWx0ZXJTdXBwb3J0ZWRUeXBlcylcblxuICAgICAgaWYgKGFjY2VwdGFibGVNaW1lVHlwZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgb3B0aW9ucy5taW1lVHlwZSA9IGFjY2VwdGFibGVNaW1lVHlwZXNbMF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgc3RhcnRSZWNvcmRpbmcgKCkge1xuICAgIC8vIG9ubHkgdXNlZCBpZiBzdXBwb3J0c01lZGlhUmVjb3JkZXIoKSByZXR1cm5lZCB0cnVlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICB0aGlzLnJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIodGhpcy5zdHJlYW0sIHRoaXMuZ2V0TWVkaWFSZWNvcmRlck9wdGlvbnMoKSlcbiAgICB0aGlzLnJlY29yZGluZ0NodW5rcyA9IFtdXG4gICAgbGV0IHN0b3BwaW5nQmVjYXVzZU9mTWF4U2l6ZSA9IGZhbHNlXG4gICAgdGhpcy5yZWNvcmRlci5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGluZ0NodW5rcy5wdXNoKGV2ZW50LmRhdGEpXG5cbiAgICAgIGNvbnN0IHsgcmVzdHJpY3Rpb25zIH0gPSB0aGlzLnVwcHkub3B0c1xuICAgICAgaWYgKHRoaXMucmVjb3JkaW5nQ2h1bmtzLmxlbmd0aCA+IDFcbiAgICAgICAgICAmJiByZXN0cmljdGlvbnMubWF4RmlsZVNpemUgIT0gbnVsbFxuICAgICAgICAgICYmICFzdG9wcGluZ0JlY2F1c2VPZk1heFNpemUpIHtcbiAgICAgICAgY29uc3QgdG90YWxTaXplID0gdGhpcy5yZWNvcmRpbmdDaHVua3MucmVkdWNlKChhY2MsIGNodW5rKSA9PiBhY2MgKyBjaHVuay5zaXplLCAwKVxuICAgICAgICAvLyBFeGNsdWRlIHRoZSBpbml0aWFsIGNodW5rIGZyb20gdGhlIGF2ZXJhZ2Ugc2l6ZSBjYWxjdWxhdGlvbiBiZWNhdXNlIGl0IGlzIGxpa2VseSB0byBiZSBhIHZlcnkgc21hbGwgb3V0bGllclxuICAgICAgICBjb25zdCBhdmVyYWdlQ2h1bmtTaXplID0gKHRvdGFsU2l6ZSAtIHRoaXMucmVjb3JkaW5nQ2h1bmtzWzBdLnNpemUpIC8gKHRoaXMucmVjb3JkaW5nQ2h1bmtzLmxlbmd0aCAtIDEpXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkRW5kQ2h1bmtTaXplID0gYXZlcmFnZUNodW5rU2l6ZSAqIDNcbiAgICAgICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KDAsIHJlc3RyaWN0aW9ucy5tYXhGaWxlU2l6ZSAtIGV4cGVjdGVkRW5kQ2h1bmtTaXplKVxuXG4gICAgICAgIGlmICh0b3RhbFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgc3RvcHBpbmdCZWNhdXNlT2ZNYXhTaXplID0gdHJ1ZVxuICAgICAgICAgIHRoaXMudXBweS5pbmZvKHRoaXMuaTE4bigncmVjb3JkaW5nU3RvcHBlZE1heFNpemUnKSwgJ3dhcm5pbmcnLCA0MDAwKVxuICAgICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gdXNlIGEgXCJ0aW1lIHNsaWNlXCIgb2YgNTAwbXM6IG9uZGF0YWF2YWlsYWJsZSB3aWxsIGJlIGNhbGxlZCBlYWNoIDUwMG1zXG4gICAgLy8gc21hbGxlciB0aW1lIHNsaWNlcyBtZWFuIHdlIGNhbiBtb3JlIGFjY3VyYXRlbHkgY2hlY2sgdGhlIG1heCBmaWxlIHNpemUgcmVzdHJpY3Rpb25cbiAgICB0aGlzLnJlY29yZGVyLnN0YXJ0KDUwMClcblxuICAgIGlmICh0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aCkge1xuICAgICAgLy8gU3RhcnQgdGhlIHJlY29yZGluZ0xlbmd0aFRpbWVyIGlmIHdlIGFyZSBzaG93aW5nIHRoZSByZWNvcmRpbmcgbGVuZ3RoLlxuICAgICAgdGhpcy5yZWNvcmRpbmdMZW5ndGhUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFJlY29yZGluZ0xlbmd0aCA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5yZWNvcmRpbmdMZW5ndGhTZWNvbmRzXG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyByZWNvcmRpbmdMZW5ndGhTZWNvbmRzOiBjdXJyZW50UmVjb3JkaW5nTGVuZ3RoICsgMSB9KVxuICAgICAgfSwgMTAwMClcbiAgICB9XG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGlzUmVjb3JkaW5nOiB0cnVlLFxuICAgIH0pXG4gIH1cblxuICBzdG9wUmVjb3JkaW5nICgpIHtcbiAgICBjb25zdCBzdG9wcGVkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkZXIuYWRkRXZlbnRMaXN0ZW5lcignc3RvcCcsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgICAgdGhpcy5yZWNvcmRlci5zdG9wKClcblxuICAgICAgaWYgKHRoaXMub3B0cy5zaG93UmVjb3JkaW5nTGVuZ3RoKSB7XG4gICAgICAgIC8vIFN0b3AgdGhlIHJlY29yZGluZ0xlbmd0aFRpbWVyIGlmIHdlIGFyZSBzaG93aW5nIHRoZSByZWNvcmRpbmcgbGVuZ3RoLlxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMucmVjb3JkaW5nTGVuZ3RoVGltZXIpXG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyByZWNvcmRpbmdMZW5ndGhTZWNvbmRzOiAwIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBzdG9wcGVkLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGlzUmVjb3JkaW5nOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpcy5nZXRWaWRlbygpXG4gICAgfSkudGhlbigoZmlsZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jYXB0dXJlZE1lZGlhRmlsZSA9IGZpbGVcbiAgICAgICAgLy8gY3JlYXRlIG9iamVjdCB1cmwgZm9yIGNhcHR1cmUgcmVzdWx0IHByZXZpZXdcbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgICByZWNvcmRlZFZpZGVvOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUuZGF0YSksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMub3B0cy5taXJyb3IgPSBmYWxzZVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIExvZ2dpbmcgdGhlIGVycm9yLCBleGVwdCByZXN0cmljdGlvbnMsIHdoaWNoIGlzIGhhbmRsZWQgaW4gQ29yZVxuICAgICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIGRpc2NhcmRSZWNvcmRlZFZpZGVvICgpIHtcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkZWRWaWRlbzogbnVsbCB9KVxuICAgIHRoaXMub3B0cy5taXJyb3IgPSB0cnVlXG4gICAgdGhpcy5jYXB0dXJlZE1lZGlhRmlsZSA9IG51bGxcbiAgfVxuXG4gIHN1Ym1pdCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmNhcHR1cmVkTWVkaWFGaWxlKSB7XG4gICAgICAgIHRoaXMudXBweS5hZGRGaWxlKHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBMb2dnaW5nIHRoZSBlcnJvciwgZXhlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIsICdlcnJvcicpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLnN0b3AoKVxuICAgICAgfSlcbiAgICAgIHRoaXMuc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgdHJhY2suc3RvcCgpXG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLndlYmNhbUFjdGl2ZSA9IGZhbHNlXG4gICAgdGhpcy5zdHJlYW0gPSBudWxsXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICByZWNvcmRlZFZpZGVvOiBudWxsLFxuICAgIH0pXG4gIH1cblxuICBnZXRWaWRlb0VsZW1lbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy51cHB5LVdlYmNhbS12aWRlbycpXG4gIH1cblxuICBvbmVUd29UaHJlZVNtaWxlICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGNvdW50ID0gdGhpcy5vcHRzLmNvdW50ZG93blxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgIGNvbnN0IGNvdW50RG93biA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLndlYmNhbUFjdGl2ZSkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY291bnREb3duKVxuICAgICAgICAgIHRoaXMuY2FwdHVyZUluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdXZWJjYW0gaXMgbm90IGFjdGl2ZScpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgIHRoaXMudXBweS5pbmZvKGAke2NvdW50fS4uLmAsICd3YXJuaW5nJywgODAwKVxuICAgICAgICAgIGNvdW50LS1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGNvdW50RG93bilcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyh0aGlzLmkxOG4oJ3NtaWxlJyksICdzdWNjZXNzJywgMTUwMClcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgMTUwMClcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMClcbiAgICB9KVxuICB9XG5cbiAgdGFrZVNuYXBzaG90ICgpIHtcbiAgICBpZiAodGhpcy5jYXB0dXJlSW5Qcm9ncmVzcykgcmV0dXJuXG5cbiAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gdHJ1ZVxuXG4gICAgdGhpcy5vcHRzLm9uQmVmb3JlU25hcHNob3QoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgPyBlcnIubWVzc2FnZSA6IGVyclxuICAgICAgdGhpcy51cHB5LmluZm8obWVzc2FnZSwgJ2Vycm9yJywgNTAwMClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYG9uQmVmb3JlU25hcHNob3Q6ICR7bWVzc2FnZX1gKSlcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmdldEltYWdlKClcbiAgICB9KS50aGVuKCh0YWdGaWxlKSA9PiB7XG4gICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudXBweS5hZGRGaWxlKHRhZ0ZpbGUpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gTG9nZ2luZyB0aGUgZXJyb3IsIGV4Y2VwdCByZXN0cmljdGlvbnMsIHdoaWNoIGlzIGhhbmRsZWQgaW4gQ29yZVxuICAgICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuY2FwdHVyZUluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9KVxuICB9XG5cbiAgZ2V0SW1hZ2UgKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5nZXRWaWRlb0VsZW1lbnQoKVxuICAgIGlmICghdmlkZW8pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vIHZpZGVvIGVsZW1lbnQgZm91bmQsIGxpa2VseSBkdWUgdG8gdGhlIFdlYmNhbSB0YWIgYmVpbmcgY2xvc2VkLicpKVxuICAgIH1cblxuICAgIGNvbnN0IHdpZHRoID0gdmlkZW8udmlkZW9XaWR0aFxuICAgIGNvbnN0IGhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0XG5cbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMClcblxuICAgIGNvbnN0IHsgcmVzdHJpY3Rpb25zIH0gPSB0aGlzLnVwcHkub3B0c1xuICAgIGxldCBwcmVmZXJyZWRJbWFnZU1pbWVUeXBlcyA9IFtdXG4gICAgaWYgKHRoaXMub3B0cy5wcmVmZXJyZWRJbWFnZU1pbWVUeXBlKSB7XG4gICAgICBwcmVmZXJyZWRJbWFnZU1pbWVUeXBlcyA9IFt0aGlzLm9wdHMucHJlZmVycmVkSW1hZ2VNaW1lVHlwZV1cbiAgICB9IGVsc2UgaWYgKHJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzKSB7XG4gICAgICBwcmVmZXJyZWRJbWFnZU1pbWVUeXBlcyA9IHJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzLm1hcCh0b01pbWVUeXBlKS5maWx0ZXIoaXNJbWFnZU1pbWVUeXBlKVxuICAgIH1cblxuICAgIGNvbnN0IG1pbWVUeXBlID0gcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXNbMF0gfHwgJ2ltYWdlL2pwZWcnXG4gICAgY29uc3QgZXh0ID0gZ2V0RmlsZVR5cGVFeHRlbnNpb24obWltZVR5cGUpIHx8ICdqcGcnXG4gICAgY29uc3QgbmFtZSA9IGBjYW0tJHtEYXRlLm5vdygpfS4ke2V4dH1gXG5cbiAgICByZXR1cm4gY2FudmFzVG9CbG9iKGNhbnZhcywgbWltZVR5cGUpLnRoZW4oKGJsb2IpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGF0YTogbmV3IEJsb2IoW2Jsb2JdLCB7IHR5cGU6IG1pbWVUeXBlIH0pLFxuICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZ2V0VmlkZW8gKCkge1xuICAgIC8vIFNvbWV0aW1lcyBpbiBpT1MgU2FmYXJpLCBCbG9icyAoZXNwZWNpYWxseSB0aGUgZmlyc3QgQmxvYiBpbiB0aGUgcmVjb3JkaW5nQ2h1bmtzIEFycmF5KVxuICAgIC8vIGhhdmUgZW1wdHkgJ3R5cGUnIGF0dHJpYnV0ZXMgKGUuZy4gJycpIHNvIHdlIG5lZWQgdG8gZmluZCBhIEJsb2IgdGhhdCBoYXMgYSBkZWZpbmVkICd0eXBlJ1xuICAgIC8vIGF0dHJpYnV0ZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgTUlNRSB0eXBlLlxuICAgIGNvbnN0IG1pbWVUeXBlID0gdGhpcy5yZWNvcmRpbmdDaHVua3MuZmluZChibG9iID0+IGJsb2IudHlwZT8ubGVuZ3RoID4gMCkudHlwZVxuXG4gICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGdldEZpbGVUeXBlRXh0ZW5zaW9uKG1pbWVUeXBlKVxuXG4gICAgaWYgKCFmaWxlRXh0ZW5zaW9uKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBDb3VsZCBub3QgcmV0cmlldmUgcmVjb3JkaW5nOiBVbnN1cHBvcnRlZCBtZWRpYSB0eXBlIFwiJHttaW1lVHlwZX1cImApKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBgd2ViY2FtLSR7RGF0ZS5ub3coKX0uJHtmaWxlRXh0ZW5zaW9ufWBcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IodGhpcy5yZWNvcmRpbmdDaHVua3MsIHsgdHlwZTogbWltZVR5cGUgfSlcbiAgICBjb25zdCBmaWxlID0ge1xuICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgbmFtZSxcbiAgICAgIGRhdGE6IG5ldyBCbG9iKFtibG9iXSwgeyB0eXBlOiBtaW1lVHlwZSB9KSxcbiAgICAgIHR5cGU6IG1pbWVUeXBlLFxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmlsZSlcbiAgfVxuXG4gIGZvY3VzICgpIHtcbiAgICBpZiAoIXRoaXMub3B0cy5jb3VudGRvd24pIHJldHVyblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmluZm8odGhpcy5pMThuKCdzbWlsZScpLCAnc3VjY2VzcycsIDE1MDApXG4gICAgfSwgMTAwMClcbiAgfVxuXG4gIGNoYW5nZVZpZGVvU291cmNlIChkZXZpY2VJZCkge1xuICAgIHRoaXMuc3RvcCgpXG4gICAgdGhpcy5zdGFydCh7IGRldmljZUlkIH0pXG4gIH1cblxuICB1cGRhdGVWaWRlb1NvdXJjZXMgKCkge1xuICAgIHRoaXMubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGRldmljZXMgPT4ge1xuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIHZpZGVvU291cmNlczogZGV2aWNlcy5maWx0ZXIoKGRldmljZSkgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0JyksXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGlmICghdGhpcy53ZWJjYW1BY3RpdmUpIHtcbiAgICAgIHRoaXMuc3RhcnQoKVxuICAgIH1cblxuICAgIGNvbnN0IHdlYmNhbVN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICBpZiAoIXdlYmNhbVN0YXRlLmNhbWVyYVJlYWR5IHx8ICF3ZWJjYW1TdGF0ZS5oYXNDYW1lcmEpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxQZXJtaXNzaW9uc1NjcmVlblxuICAgICAgICAgIGljb249e0NhbWVyYUljb259XG4gICAgICAgICAgaTE4bj17dGhpcy5pMThufVxuICAgICAgICAgIGhhc0NhbWVyYT17d2ViY2FtU3RhdGUuaGFzQ2FtZXJhfVxuICAgICAgICAvPlxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q2FtZXJhU2NyZWVuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtcHJvcHMtbm8tc3ByZWFkaW5nXG4gICAgICAgIHsuLi53ZWJjYW1TdGF0ZX1cbiAgICAgICAgb25DaGFuZ2VWaWRlb1NvdXJjZT17dGhpcy5jaGFuZ2VWaWRlb1NvdXJjZX1cbiAgICAgICAgb25TbmFwc2hvdD17dGhpcy50YWtlU25hcHNob3R9XG4gICAgICAgIG9uU3RhcnRSZWNvcmRpbmc9e3RoaXMuc3RhcnRSZWNvcmRpbmd9XG4gICAgICAgIG9uU3RvcFJlY29yZGluZz17dGhpcy5zdG9wUmVjb3JkaW5nfVxuICAgICAgICBvbkRpc2NhcmRSZWNvcmRlZFZpZGVvPXt0aGlzLmRpc2NhcmRSZWNvcmRlZFZpZGVvfVxuICAgICAgICBvblN1Ym1pdD17dGhpcy5zdWJtaXR9XG4gICAgICAgIG9uRm9jdXM9e3RoaXMuZm9jdXN9XG4gICAgICAgIG9uU3RvcD17dGhpcy5zdG9wfVxuICAgICAgICBpMThuPXt0aGlzLmkxOG59XG4gICAgICAgIG1vZGVzPXt0aGlzLm9wdHMubW9kZXN9XG4gICAgICAgIHNob3dSZWNvcmRpbmdMZW5ndGg9e3RoaXMub3B0cy5zaG93UmVjb3JkaW5nTGVuZ3RofVxuICAgICAgICBzaG93VmlkZW9Tb3VyY2VEcm9wZG93bj17dGhpcy5vcHRzLnNob3dWaWRlb1NvdXJjZURyb3Bkb3dufVxuICAgICAgICBzdXBwb3J0c1JlY29yZGluZz17c3VwcG9ydHNNZWRpYVJlY29yZGVyKCl9XG4gICAgICAgIHJlY29yZGluZz17d2ViY2FtU3RhdGUuaXNSZWNvcmRpbmd9XG4gICAgICAgIG1pcnJvcj17dGhpcy5vcHRzLm1pcnJvcn1cbiAgICAgICAgc3JjPXt0aGlzLnN0cmVhbX1cbiAgICAgIC8+XG4gICAgKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBjYW1lcmFSZWFkeTogZmFsc2UsXG4gICAgICByZWNvcmRpbmdMZW5ndGhTZWNvbmRzOiAwLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWVkaWFEZXZpY2VzKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZpZGVvU291cmNlcygpXG5cbiAgICAgIHRoaXMubWVkaWFEZXZpY2VzLm9uZGV2aWNlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZGVvU291cmNlcygpXG5cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgbGV0IHJlc3RhcnRTdHJlYW0gPSB0cnVlXG5cbiAgICAgICAgICBjb25zdCB7IHZpZGVvU291cmNlcywgY3VycmVudERldmljZUlkIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcblxuICAgICAgICAgIHZpZGVvU291cmNlcy5mb3JFYWNoKCh2aWRlb1NvdXJjZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREZXZpY2VJZCA9PT0gdmlkZW9Tb3VyY2UuZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgcmVzdGFydFN0cmVhbSA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChyZXN0YXJ0U3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgICAgICAgdGhpcy5zdGFydCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgIHRoaXMuc3RvcCgpXG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwb3J0c01lZGlhUmVjb3JkZXIgKCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wYXQvY29tcGF0ICovXG4gIHJldHVybiB0eXBlb2YgTWVkaWFSZWNvcmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiAhIU1lZGlhUmVjb3JkZXIucHJvdG90eXBlXG4gICAgJiYgdHlwZW9mIE1lZGlhUmVjb3JkZXIucHJvdG90eXBlLnN0YXJ0ID09PSAnZnVuY3Rpb24nXG4gIC8qIGVzbGludC1lbmFibGUgY29tcGF0L2NvbXBhdCAqL1xufVxuIiwiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTgsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkXG4gKi9cblxuOyhmdW5jdGlvbihyb290KSB7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL15cXG4rLyxcbiAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICBmZW5jZXM6IC9eIHswLDN9KGB7Myx9fH57Myx9KShbXmB+XFxuXSopXFxuKD86fChbXFxzXFxTXSo/KVxcbikoPzogezAsM31cXDFbfmBdKiAqKD86XFxuK3wkKXwkKS8sXG4gIGhyOiAvXiB7MCwzfSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXCogKil7Myx9KSg/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pICsoW15cXG5dKj8pKD86ICsjKyk/ICooPzpcXG4rfCQpLyxcbiAgYmxvY2txdW90ZTogL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLyxcbiAgbGlzdDogL14oIHswLDN9KShidWxsKSBbXFxzXFxTXSs/KD86aHJ8ZGVmfFxcbnsyLH0oPyEgKSg/IVxcMWJ1bGwgKVxcbip8XFxzKiQpLyxcbiAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz5cXFxcbionIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8+XFxcXG4qJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+XFxcXG4qJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzpcXFxcbnsyLH18JCknIC8vICg2KVxuICAgICsgJ3w8KD8hc2NyaXB0fHByZXxzdHlsZSkoW2Etel1bXFxcXHctXSopKD86YXR0cmlidXRlKSo/ICovPz4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/OlxcXFxuezIsfXwkKScgLy8gKDcpIG9wZW4gdGFnXG4gICAgKyAnfDwvKD8hc2NyaXB0fHByZXxzdHlsZSlbYS16XVtcXFxcdy1dKlxcXFxzKj4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/OlxcXFxuezIsfXwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsXG4gIGRlZjogL14gezAsM31cXFsobGFiZWwpXFxdOiAqXFxuPyAqPD8oW15cXHM+XSspPj8oPzooPzogK1xcbj8gKnwgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gIG5wdGFibGU6IG5vb3AsXG4gIHRhYmxlOiBub29wLFxuICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgLy8gcmVnZXggdGVtcGxhdGUsIHBsYWNlaG9sZGVycyB3aWxsIGJlIHJlcGxhY2VkIGFjY29yZGluZyB0byBkaWZmZXJlbnQgcGFyYWdyYXBoXG4gIC8vIGludGVycnVwdGlvbiBydWxlcyBvZiBjb21tb25tYXJrIGFuZCB0aGUgb3JpZ2luYWwgbWFya2Rvd24gc3BlYzpcbiAgX3BhcmFncmFwaDogL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sKVteXFxuXSspKikvLFxuICB0ZXh0OiAvXlteXFxuXSsvXG59O1xuXG5ibG9jay5fbGFiZWwgPSAvKD8hXFxzKlxcXSkoPzpcXFxcW1xcW1xcXV18W15cXFtcXF1dKSsvO1xuYmxvY2suX3RpdGxlID0gLyg/OlwiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCdbXidcXG5dKig/OlxcblteJ1xcbl0rKSpcXG4/J3xcXChbXigpXSpcXCkpLztcbmJsb2NrLmRlZiA9IGVkaXQoYmxvY2suZGVmKVxuICAucmVwbGFjZSgnbGFiZWwnLCBibG9jay5fbGFiZWwpXG4gIC5yZXBsYWNlKCd0aXRsZScsIGJsb2NrLl90aXRsZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGR7MSw5fVxcLikvO1xuYmxvY2suaXRlbSA9IC9eKCAqKShidWxsKSA/W15cXG5dKig/Olxcbig/IVxcMWJ1bGwgPylbXlxcbl0qKSovO1xuYmxvY2suaXRlbSA9IGVkaXQoYmxvY2suaXRlbSwgJ2dtJylcbiAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2subGlzdCA9IGVkaXQoYmxvY2subGlzdClcbiAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKVxuICAucmVwbGFjZSgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suX3RhZyA9ICdhZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbidcbiAgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJ1xuICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgKyAnfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxtZXRhfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb24nXG4gICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInXG4gICsgJ3x0cmFja3x1bCc7XG5ibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8tLT4vO1xuYmxvY2suaHRtbCA9IGVkaXQoYmxvY2suaHRtbCwgJ2knKVxuICAucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KVxuICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZylcbiAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gKycpXG4gIC5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXggaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfXx+ezMsfSlbXmBcXFxcbl0qXFxcXG4nKVxuICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXwhLS0pJylcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5ibG9ja3F1b3RlID0gZWRpdChibG9jay5ibG9ja3F1b3RlKVxuICAucmVwbGFjZSgncGFyYWdyYXBoJywgYmxvY2sucGFyYWdyYXBoKVxuICAuZ2V0UmVnZXgoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IG1lcmdlKHt9LCBibG9jayk7XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIG5wdGFibGU6IC9eICooW158XFxuIF0uKlxcfC4qKVxcbiAqKFstOl0rICpcXHxbLXwgOl0qKSg/OlxcbigoPzouKltePlxcbiBdLiooPzpcXG58JCkpKilcXG4qfCQpLyxcbiAgdGFibGU6IC9eICpcXHwoLispXFxuICpcXHw/KCAqWy06XStbLXwgOl0qKSg/OlxcbigoPzogKltePlxcbiBdLiooPzpcXG58JCkpKilcXG4qfCQpL1xufSk7XG5cbi8qKlxuICogUGVkYW50aWMgZ3JhbW1hciAob3JpZ2luYWwgSm9obiBHcnViZXIncyBsb29zZSBtYXJrZG93biBzcGVjaWZpY2F0aW9uKVxuICovXG5cbmJsb2NrLnBlZGFudGljID0gbWVyZ2Uoe30sIGJsb2NrLm5vcm1hbCwge1xuICBodG1sOiBlZGl0KFxuICAgICdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKSdcbiAgICArICd8PCh0YWcpW1xcXFxzXFxcXFNdKz88L1xcXFwxPiAqKD86XFxcXG57Mix9fFxcXFxzKiQpJyAvLyBjbG9zZWQgdGFnXG4gICAgKyAnfDx0YWcoPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8XFxcXHNbXlxcJ1wiLz5cXFxcc10qKSo/Lz8+ICooPzpcXFxcbnsyLH18XFxcXHMqJCkpJylcbiAgICAucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KVxuICAgIC5yZXBsYWNlKC90YWcvZywgJyg/ISg/OidcbiAgICAgICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInXG4gICAgICArICd8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKSdcbiAgICAgICsgJ1xcXFxiKVxcXFx3Kyg/ITp8W15cXFxcd1xcXFxzQF0qQClcXFxcYicpXG4gICAgLmdldFJlZ2V4KCksXG4gIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKig/OiMrICopPyg/Olxcbit8JCkvLFxuICBmZW5jZXM6IG5vb3AsIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gIHBhcmFncmFwaDogZWRpdChibG9jay5ub3JtYWwuX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJylcbiAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnfGZlbmNlcycsICcnKVxuICAgIC5yZXBsYWNlKCd8bGlzdCcsICcnKVxuICAgIC5yZXBsYWNlKCd8aHRtbCcsICcnKVxuICAgIC5nZXRSZWdleCgpXG59KTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5ydWxlcyA9IGJsb2NrLm5vcm1hbDtcblxuICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgdGhpcy5ydWxlcyA9IGJsb2NrLnBlZGFudGljO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICB0aGlzLnJ1bGVzID0gYmxvY2suZ2ZtO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIEJsb2NrIFJ1bGVzXG4gKi9cblxuTGV4ZXIucnVsZXMgPSBibG9jaztcblxuLyoqXG4gKiBTdGF0aWMgTGV4IE1ldGhvZFxuICovXG5cbkxleGVyLmxleCA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucykge1xuICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbn07XG5cbi8qKlxuICogUHJlcHJvY2Vzc2luZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbihzcmMpIHtcbiAgc3JjID0gc3JjXG4gICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpXG4gICAgLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpXG4gICAgLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKVxuICAgIC5yZXBsYWNlKC9cXHUyNDI0L2csICdcXG4nKTtcblxuICByZXR1cm4gdGhpcy50b2tlbihzcmMsIHRydWUpO1xufTtcblxuLyoqXG4gKiBMZXhpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUudG9rZW4gPSBmdW5jdGlvbihzcmMsIHRvcCkge1xuICBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpO1xuICB2YXIgbmV4dCxcbiAgICAgIGxvb3NlLFxuICAgICAgY2FwLFxuICAgICAgYnVsbCxcbiAgICAgIGIsXG4gICAgICBpdGVtLFxuICAgICAgbGlzdFN0YXJ0LFxuICAgICAgbGlzdEl0ZW1zLFxuICAgICAgdCxcbiAgICAgIHNwYWNlLFxuICAgICAgaSxcbiAgICAgIHRhZyxcbiAgICAgIGwsXG4gICAgICBpc29yZGVyZWQsXG4gICAgICBpc3Rhc2ssXG4gICAgICBpc2NoZWNrZWQ7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIG5ld2xpbmVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5uZXdsaW5lLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc3BhY2UnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgdmFyIGxhc3RUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIC8vIEFuIGluZGVudGVkIGNvZGUgYmxvY2sgY2Fubm90IGludGVycnVwdCBhIHBhcmFncmFwaC5cbiAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgY2FwWzBdLnRyaW1SaWdodCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gezR9L2dtLCAnJyk7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICBjb2RlQmxvY2tTdHlsZTogJ2luZGVudGVkJyxcbiAgICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgICA/IHJ0cmltKGNhcCwgJ1xcbicpXG4gICAgICAgICAgICA6IGNhcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZlbmNlc1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmZlbmNlcy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpIDogY2FwWzJdLFxuICAgICAgICB0ZXh0OiBjYXBbM10gfHwgJydcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IGNhcFsyXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ucHRhYmxlLmV4ZWMoc3JjKSkge1xuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzKGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdID8gY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW11cbiAgICAgIH07XG5cbiAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtLmNlbGxzW2ldID0gc3BsaXRDZWxscyhpdGVtLmNlbGxzW2ldLCBpdGVtLmhlYWRlci5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaHInXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJsb2NrcXVvdGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ibG9ja3F1b3RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcblxuICAgICAgLy8gUGFzcyBgdG9wYCB0byBrZWVwIHRoZSBjdXJyZW50XG4gICAgICAvLyBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgLy8gaG93IG1hcmtkb3duLnBsIHdvcmtzLlxuICAgICAgdGhpcy50b2tlbihjYXAsIHRvcCk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlzdFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpc3QuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgYnVsbCA9IGNhcFsyXTtcbiAgICAgIGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcblxuICAgICAgbGlzdFN0YXJ0ID0ge1xuICAgICAgICB0eXBlOiAnbGlzdF9zdGFydCcsXG4gICAgICAgIG9yZGVyZWQ6IGlzb3JkZXJlZCxcbiAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsIDogJycsXG4gICAgICAgIGxvb3NlOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaChsaXN0U3RhcnQpO1xuXG4gICAgICAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbS5cbiAgICAgIGNhcCA9IGNhcFswXS5tYXRjaCh0aGlzLnJ1bGVzLml0ZW0pO1xuXG4gICAgICBsaXN0SXRlbXMgPSBbXTtcbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIGwgPSBjYXAubGVuZ3RoO1xuICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjYXBbaV07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgLy8gc28gaXQgaXMgc2VlbiBhcyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXiAqKFsqKy1dfFxcZCtcXC4pICovLCAnJyk7XG5cbiAgICAgICAgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cbiAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgICA/IGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCdeIHsxLCcgKyBzcGFjZSArICd9JywgJ2dtJyksICcnKVxuICAgICAgICAgICAgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgIC8vIEJhY2twZWRhbCBpZiBpdCBkb2VzIG5vdCBiZWxvbmcgaW4gdGhpcyBsaXN0LlxuICAgICAgICBpZiAoaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBiID0gYmxvY2suYnVsbGV0LmV4ZWMoY2FwW2kgKyAxXSlbMF07XG4gICAgICAgICAgaWYgKGJ1bGwubGVuZ3RoID4gMSA/IGIubGVuZ3RoID09PSAxXG4gICAgICAgICAgICA6IChiLmxlbmd0aCA+IDEgfHwgKHRoaXMub3B0aW9ucy5zbWFydExpc3RzICYmIGIgIT09IGJ1bGwpKSkge1xuICAgICAgICAgICAgc3JjID0gY2FwLnNsaWNlKGkgKyAxKS5qb2luKCdcXG4nKSArIHNyYztcbiAgICAgICAgICAgIGkgPSBsIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtIGlzIGxvb3NlIG9yIG5vdC5cbiAgICAgICAgLy8gVXNlOiAvKF58XFxuKSg/ISApW15cXG5dK1xcblxcbig/IVxccyokKS9cbiAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgIGlmICghbG9vc2UpIGxvb3NlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb29zZSkge1xuICAgICAgICAgIGxpc3RTdGFydC5sb29zZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgdGFzayBsaXN0IGl0ZW1zXG4gICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy50ZXN0KGl0ZW0pO1xuICAgICAgICBpc2NoZWNrZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICBpc2NoZWNrZWQgPSBpdGVtWzFdICE9PSAnICc7XG4gICAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXlxcW1sgeFhdXFxdICsvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0ID0ge1xuICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fc3RhcnQnLFxuICAgICAgICAgIHRhc2s6IGlzdGFzayxcbiAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgbG9vc2U6IGxvb3NlXG4gICAgICAgIH07XG5cbiAgICAgICAgbGlzdEl0ZW1zLnB1c2godCk7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godCk7XG5cbiAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgdGhpcy50b2tlbihpdGVtLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2xpc3RfaXRlbV9lbmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobGlzdFN0YXJ0Lmxvb3NlKSB7XG4gICAgICAgIGwgPSBsaXN0SXRlbXMubGVuZ3RoO1xuICAgICAgICBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsaXN0SXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHRtbFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3BhcmFncmFwaCdcbiAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnNhbml0aXplID8gKHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBlc2NhcGUoY2FwWzBdKSkgOiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVmXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5kZWYuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbM10pIGNhcFszXSA9IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpO1xuICAgICAgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0YWddKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLmxpbmtzW3RhZ10gPSB7XG4gICAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGFibGUuZXhlYyhzcmMpKSB7XG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IHNwbGl0Q2VsbHMoY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykpLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10gPyBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXVxuICAgICAgfTtcblxuICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBzcGxpdENlbGxzKFxuICAgICAgICAgICAgaXRlbS5jZWxsc1tpXS5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJyksXG4gICAgICAgICAgICBpdGVtLmhlYWRlci5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxoZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnBhcmFncmFwaC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICA6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGV4dC5leGVjKHNyYykpIHtcbiAgICAgIC8vIFRvcC1sZXZlbCBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZS5cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gIGF1dG9saW5rOiAvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vLFxuICB1cmw6IG5vb3AsXG4gIHRhZzogJ15jb21tZW50J1xuICAgICsgJ3xePC9bYS16QS1aXVtcXFxcdzotXSpcXFxccyo+JyAvLyBzZWxmLWNsb3NpbmcgdGFnXG4gICAgKyAnfF48W2EtekEtWl1bXFxcXHctXSooPzphdHRyaWJ1dGUpKj9cXFxccyovPz4nIC8vIG9wZW4gdGFnXG4gICAgKyAnfF48XFxcXD9bXFxcXHNcXFxcU10qP1xcXFw/PicgLy8gcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiwgZS5nLiA8P3BocCA/PlxuICAgICsgJ3xePCFbYS16QS1aXStcXFxcc1tcXFxcc1xcXFxTXSo/PicgLy8gZGVjbGFyYXRpb24sIGUuZy4gPCFET0NUWVBFIGh0bWw+XG4gICAgKyAnfF48IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nLCAvLyBDREFUQSBzZWN0aW9uXG4gIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgcmVmbGluazogL14hP1xcWyhsYWJlbClcXF1cXFsoPyFcXHMqXFxdKSgoPzpcXFxcW1xcW1xcXV0/fFteXFxbXFxdXFxcXF0pKylcXF0vLFxuICBub2xpbms6IC9eIT9cXFsoPyFcXHMqXFxdKSgoPzpcXFtbXlxcW1xcXV0qXFxdfFxcXFxbXFxbXFxdXXxbXlxcW1xcXV0pKilcXF0oPzpcXFtcXF0pPy8sXG4gIHN0cm9uZzogL15fXyhbXlxcc19dKV9fKD8hXyl8XlxcKlxcKihbXlxccypdKVxcKlxcKig/IVxcKil8Xl9fKFteXFxzXVtcXHNcXFNdKj9bXlxcc10pX18oPyFfKXxeXFwqXFwqKFteXFxzXVtcXHNcXFNdKj9bXlxcc10pXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oW15cXHNfXSlfKD8hXyl8XlxcKihbXlxccyo8XFxbXSlcXCooPyFcXCopfF5fKFteXFxzPF1bXFxzXFxTXSo/W15cXHNfXSlfKD8hX3xbXlxcc3B1bmN0dWF0aW9uXSl8Xl8oW15cXHNfPF1bXFxzXFxTXSo/W15cXHNdKV8oPyFffFteXFxzcHVuY3R1YXRpb25dKXxeXFwqKFteXFxzPFwiXVtcXHNcXFNdKj9bXlxcc1xcKl0pXFwqKD8hXFwqfFteXFxzcHVuY3R1YXRpb25dKXxeXFwqKFteXFxzKlwiPFxcW11bXFxzXFxTXSo/W15cXHNdKVxcKig/IVxcKikvLFxuICBjb2RlOiAvXihgKykoW15gXXxbXmBdW1xcc1xcU10qP1teYF0pXFwxKD8hYCkvLFxuICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3AsXG4gIHRleHQ6IC9eKGArfFteYF0pKD86W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl18XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKXwoPz0gezIsfVxcbikpL1xufTtcblxuLy8gbGlzdCBvZiBwdW5jdHVhdGlvbiBtYXJrcyBmcm9tIGNvbW1vbiBtYXJrIHNwZWNcbi8vIHdpdGhvdXQgYCBhbmQgXSB0byB3b3JrYXJvdW5kIFJ1bGUgMTcgKGlubGluZSBjb2RlIGJsb2Nrcy9saW5rcylcbmlubGluZS5fcHVuY3R1YXRpb24gPSAnIVwiIyQlJlxcJygpKissXFxcXC0uLzo7PD0+P0BcXFxcW15fe3x9fic7XG5pbmxpbmUuZW0gPSBlZGl0KGlubGluZS5lbSkucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcblxuaW5saW5lLl9lc2NhcGVzID0gL1xcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pL2c7XG5cbmlubGluZS5fc2NoZW1lID0gL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vO1xuaW5saW5lLl9lbWFpbCA9IC9bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyhAKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrKD8hWy1fXSkvO1xuaW5saW5lLmF1dG9saW5rID0gZWRpdChpbmxpbmUuYXV0b2xpbmspXG4gIC5yZXBsYWNlKCdzY2hlbWUnLCBpbmxpbmUuX3NjaGVtZSlcbiAgLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLl9lbWFpbClcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5fYXR0cmlidXRlID0gL1xccytbYS16QS1aOl9dW1xcdy46LV0qKD86XFxzKj1cXHMqXCJbXlwiXSpcInxcXHMqPVxccyonW14nXSonfFxccyo9XFxzKlteXFxzXCInPTw+YF0rKT8vO1xuXG5pbmxpbmUudGFnID0gZWRpdChpbmxpbmUudGFnKVxuICAucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KVxuICAucmVwbGFjZSgnYXR0cmlidXRlJywgaW5saW5lLl9hdHRyaWJ1dGUpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX2xhYmVsID0gLyg/OlxcW1teXFxbXFxdXSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG5pbmxpbmUuX2hyZWYgPSAvPCg/OlxcXFxbPD5dP3xbXlxcczw+XFxcXF0pKj58W15cXHNcXHgwMC1cXHgxZl0qLztcbmlubGluZS5fdGl0bGUgPSAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLztcblxuaW5saW5lLmxpbmsgPSBlZGl0KGlubGluZS5saW5rKVxuICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAucmVwbGFjZSgnaHJlZicsIGlubGluZS5faHJlZilcbiAgLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5yZWZsaW5rID0gZWRpdChpbmxpbmUucmVmbGluaylcbiAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgLmdldFJlZ2V4KCk7XG5cbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLm5vcm1hbCA9IG1lcmdlKHt9LCBpbmxpbmUpO1xuXG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLnBlZGFudGljID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgc3Ryb25nOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXyl8XlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopLyxcbiAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgIC5nZXRSZWdleCgpLFxuICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAuZ2V0UmVnZXgoKVxufSk7XG5cbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmdmbSA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIGVzY2FwZTogZWRpdChpbmxpbmUuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgX2V4dGVuZGVkX2VtYWlsOiAvW0EtWmEtejAtOS5fKy1dKyhAKVthLXpBLVowLTktX10rKD86XFwuW2EtekEtWjAtOS1fXSpbYS16QS1aMC05XSkrKD8hWy1fXSkvLFxuICB1cmw6IC9eKCg/OmZ0cHxodHRwcz8pOlxcL1xcL3x3d3dcXC4pKD86W2EtekEtWjAtOVxcLV0rXFwuPykrW15cXHM8XSp8XmVtYWlsLyxcbiAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl9+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl9+KV0rKD8hJCkpKy8sXG4gIGRlbDogL15+Kyg/PVxcUykoW1xcc1xcU10qP1xcUyl+Ky8sXG4gIHRleHQ6IC9eKGArfFteYF0pKD86W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5dfFxcYl98aHR0cHM/OlxcL1xcL3xmdHA6XFwvXFwvfHd3d1xcLnwkKXxbXiBdKD89IHsyLH1cXG4pfFteYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dKD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSl8KD89IHsyLH1cXG58W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSkvXG59KTtcblxuaW5saW5lLmdmbS51cmwgPSBlZGl0KGlubGluZS5nZm0udXJsLCAnaScpXG4gIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5nZm0uX2V4dGVuZGVkX2VtYWlsKVxuICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuYnJlYWtzID0gbWVyZ2Uoe30sIGlubGluZS5nZm0sIHtcbiAgYnI6IGVkaXQoaW5saW5lLmJyKS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpLFxuICB0ZXh0OiBlZGl0KGlubGluZS5nZm0udGV4dClcbiAgICAucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJylcbiAgICAucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKVxuICAgIC5nZXRSZWdleCgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUgTGV4ZXIgJiBDb21waWxlclxuICovXG5cbmZ1bmN0aW9uIElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLmxpbmtzID0gbGlua3M7XG4gIHRoaXMucnVsZXMgPSBpbmxpbmUubm9ybWFsO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcigpO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKCF0aGlzLmxpbmtzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbnMgYXJyYXkgcmVxdWlyZXMgYSBgbGlua3NgIHByb3BlcnR5LicpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgIHRoaXMucnVsZXMgPSBpbmxpbmUucGVkYW50aWM7XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmJyZWFrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5nZm07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIElubGluZSBSdWxlc1xuICovXG5cbklubGluZUxleGVyLnJ1bGVzID0gaW5saW5lO1xuXG4vKipcbiAqIFN0YXRpYyBMZXhpbmcvQ29tcGlsaW5nIE1ldGhvZFxuICovXG5cbklubGluZUxleGVyLm91dHB1dCA9IGZ1bmN0aW9uKHNyYywgbGlua3MsIG9wdGlvbnMpIHtcbiAgdmFyIGlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucyk7XG4gIHJldHVybiBpbmxpbmUub3V0cHV0KHNyYyk7XG59O1xuXG4vKipcbiAqIExleGluZy9Db21waWxpbmdcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBvdXQgPSAnJyxcbiAgICAgIGxpbmssXG4gICAgICB0ZXh0LFxuICAgICAgaHJlZixcbiAgICAgIHRpdGxlLFxuICAgICAgY2FwLFxuICAgICAgcHJldkNhcFplcm87XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIGVzY2FwZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVzY2FwZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50YWcuZXhlYyhzcmMpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pblJhd0Jsb2NrICYmIC9ePChwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pblJhd0Jsb2NrICYmIC9ePFxcLyhwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKVxuICAgICAgICA6IGNhcFswXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgdmFyIGxhc3RQYXJlbkluZGV4ID0gZmluZENsb3NpbmdCcmFja2V0KGNhcFsyXSwgJygpJyk7XG4gICAgICBpZiAobGFzdFBhcmVuSW5kZXggPiAtMSkge1xuICAgICAgICB2YXIgbGlua0xlbiA9IDQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICB9XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgaHJlZiA9IGNhcFsyXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgbGluayA9IC9eKFteJ1wiXSpbXlxcc10pXFxzKyhbJ1wiXSkoLiopXFwyLy5leGVjKGhyZWYpO1xuXG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpdGxlID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgfVxuICAgICAgaHJlZiA9IGhyZWYudHJpbSgpLnJlcGxhY2UoL148KFtcXHNcXFNdKik+JC8sICckMScpO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgaHJlZjogSW5saW5lTGV4ZXIuZXNjYXBlcyhocmVmKSxcbiAgICAgICAgdGl0bGU6IElubGluZUxleGVyLmVzY2FwZXModGl0bGUpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBsaW5rID0gdGhpcy5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHNyYyA9IGNhcFswXS5zdWJzdHJpbmcoMSkgKyBzcmM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0cm9uZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnN0cm9uZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoY2FwWzRdIHx8IGNhcFszXSB8fCBjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBlbVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVtLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmVtKHRoaXMub3V0cHV0KGNhcFs2XSB8fCBjYXBbNV0gfHwgY2FwWzRdIHx8IGNhcFszXSB8fCBjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLnRyaW0oKSwgdHJ1ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYnJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ici5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5icigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmRlbCh0aGlzLm91dHB1dChjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGF1dG9saW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYXV0b2xpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUodGhpcy5tYW5nbGUoY2FwWzFdKSk7XG4gICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB1cmwgKGdmbSlcbiAgICBpZiAoIXRoaXMuaW5MaW5rICYmIChjYXAgPSB0aGlzLnJ1bGVzLnVybC5leGVjKHNyYykpKSB7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICBkbyB7XG4gICAgICAgICAgcHJldkNhcFplcm8gPSBjYXBbMF07XG4gICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKVswXTtcbiAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgaHJlZiA9ICdodHRwOi8vJyArIHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKHRoaXMuaW5SYXdCbG9jaykge1xuICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50ZXh0KHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/ICh0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSkpIDogY2FwWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRleHQoZXNjYXBlKHRoaXMuc21hcnR5cGFudHMoY2FwWzBdKSkpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbklubGluZUxleGVyLmVzY2FwZXMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiB0ZXh0ID8gdGV4dC5yZXBsYWNlKElubGluZUxleGVyLnJ1bGVzLl9lc2NhcGVzLCAnJDEnKSA6IHRleHQ7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgTGlua1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXRMaW5rID0gZnVuY3Rpb24oY2FwLCBsaW5rKSB7XG4gIHZhciBocmVmID0gbGluay5ocmVmLFxuICAgICAgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcblxuICByZXR1cm4gY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnXG4gICAgPyB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgdGl0bGUsIHRoaXMub3V0cHV0KGNhcFsxXSkpXG4gICAgOiB0aGlzLnJlbmRlcmVyLmltYWdlKGhyZWYsIHRpdGxlLCBlc2NhcGUoY2FwWzFdKSk7XG59O1xuXG4vKipcbiAqIFNtYXJ0eXBhbnRzIFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5zbWFydHlwYW50cyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMpIHJldHVybiB0ZXh0O1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufTtcblxuLyoqXG4gKiBNYW5nbGUgTGlua3NcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUubWFuZ2xlID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5tYW5nbGUpIHJldHVybiB0ZXh0O1xuICB2YXIgb3V0ID0gJycsXG4gICAgICBsID0gdGV4dC5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGNoO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuXG5mdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xufVxuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uKGNvZGUsIGluZm9zdHJpbmcsIGVzY2FwZWQpIHtcbiAgdmFyIGxhbmcgPSAoaW5mb3N0cmluZyB8fCAnJykubWF0Y2goL1xcUyovKVswXTtcbiAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChjb2RlLCBsYW5nKTtcbiAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBvdXQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFsYW5nKSB7XG4gICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgKyAnPC9jb2RlPjwvcHJlPic7XG4gIH1cblxuICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeFxuICAgICsgZXNjYXBlKGxhbmcsIHRydWUpXG4gICAgKyAnXCI+J1xuICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJsb2NrcXVvdGUgPSBmdW5jdGlvbihxdW90ZSkge1xuICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oaHRtbCkge1xuICByZXR1cm4gaHRtbDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5oZWFkaW5nID0gZnVuY3Rpb24odGV4dCwgbGV2ZWwsIHJhdywgc2x1Z2dlcikge1xuICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcklkcykge1xuICAgIHJldHVybiAnPGgnXG4gICAgICArIGxldmVsXG4gICAgICArICcgaWQ9XCInXG4gICAgICArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXhcbiAgICAgICsgc2x1Z2dlci5zbHVnKHJhdylcbiAgICAgICsgJ1wiPidcbiAgICAgICsgdGV4dFxuICAgICAgKyAnPC9oJ1xuICAgICAgKyBsZXZlbFxuICAgICAgKyAnPlxcbic7XG4gIH1cbiAgLy8gaWdub3JlIElEc1xuICByZXR1cm4gJzxoJyArIGxldmVsICsgJz4nICsgdGV4dCArICc8L2gnICsgbGV2ZWwgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKGJvZHksIG9yZGVyZWQsIHN0YXJ0KSB7XG4gIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnLFxuICAgICAgc3RhcnRhdHQgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRhdHQgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdGl0ZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGxpPicgKyB0ZXh0ICsgJzwvbGk+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jaGVja2JveCA9IGZ1bmN0aW9uKGNoZWNrZWQpIHtcbiAgcmV0dXJuICc8aW5wdXQgJ1xuICAgICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJylcbiAgICArICdkaXNhYmxlZD1cIlwiIHR5cGU9XCJjaGVja2JveFwiJ1xuICAgICsgKHRoaXMub3B0aW9ucy54aHRtbCA/ICcgLycgOiAnJylcbiAgICArICc+ICc7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucGFyYWdyYXBoID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxwPicgKyB0ZXh0ICsgJzwvcD5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24oaGVhZGVyLCBib2R5KSB7XG4gIGlmIChib2R5KSBib2R5ID0gJzx0Ym9keT4nICsgYm9keSArICc8L3Rib2R5Pic7XG5cbiAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICsgJzx0aGVhZD5cXG4nXG4gICAgKyBoZWFkZXJcbiAgICArICc8L3RoZWFkPlxcbidcbiAgICArIGJvZHlcbiAgICArICc8L3RhYmxlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVyb3cgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZWNlbGwgPSBmdW5jdGlvbihjb250ZW50LCBmbGFncykge1xuICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICB2YXIgdGFnID0gZmxhZ3MuYWxpZ25cbiAgICA/ICc8JyArIHR5cGUgKyAnIGFsaWduPVwiJyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICA6ICc8JyArIHR5cGUgKyAnPic7XG4gIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG4vLyBzcGFuIGxldmVsIHJlbmRlcmVyXG5SZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGVzcGFuID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICB2YXIgb3V0ID0gJzxhIGhyZWY9XCInICsgZXNjYXBlKGhyZWYpICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiB0ZXh0O1xufTtcblxuLyoqXG4gKiBUZXh0UmVuZGVyZXJcbiAqIHJldHVybnMgb25seSB0aGUgdGV4dHVhbCBwYXJ0IG9mIHRoZSB0b2tlblxuICovXG5cbmZ1bmN0aW9uIFRleHRSZW5kZXJlcigpIHt9XG5cbi8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLnN0cm9uZyA9XG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmVtID1cblRleHRSZW5kZXJlci5wcm90b3R5cGUuY29kZXNwYW4gPVxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5kZWwgPVxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dDtcbn07XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUubGluayA9XG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgcmV0dXJuICcnICsgdGV4dDtcbn07XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuYnIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyKCk7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdGhpcy5zbHVnZ2VyID0gbmV3IFNsdWdnZXIoKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gKi9cblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyYyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExvb3BcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIHRoaXMuaW5saW5lID0gbmV3IElubGluZUxleGVyKHNyYy5saW5rcywgdGhpcy5vcHRpb25zKTtcbiAgLy8gdXNlIGFuIElubGluZUxleGVyIHdpdGggYSBUZXh0UmVuZGVyZXIgdG8gZXh0cmFjdCBwdXJlIHRleHRcbiAgdGhpcy5pbmxpbmVUZXh0ID0gbmV3IElubGluZUxleGVyKFxuICAgIHNyYy5saW5rcyxcbiAgICBtZXJnZSh7fSwgdGhpcy5vcHRpb25zLCB7IHJlbmRlcmVyOiBuZXcgVGV4dFJlbmRlcmVyKCkgfSlcbiAgKTtcbiAgdGhpcy50b2tlbnMgPSBzcmMucmV2ZXJzZSgpO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgd2hpbGUgKHRoaXMubmV4dCgpKSB7XG4gICAgb3V0ICs9IHRoaXMudG9rKCk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudG9rZW4gPSB0aGlzLnRva2Vucy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMudG9rZW47XG59O1xuXG4vKipcbiAqIFByZXZpZXcgTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMDtcbn07XG5cbi8qKlxuICogUGFyc2UgVGV4dCBUb2tlbnNcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYm9keSA9IHRoaXMudG9rZW4udGV4dDtcblxuICB3aGlsZSAodGhpcy5wZWVrKCkudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYm9keSArPSAnXFxuJyArIHRoaXMubmV4dCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pbmxpbmUub3V0cHV0KGJvZHkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBDdXJyZW50IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS50b2sgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLnRva2VuLnR5cGUpIHtcbiAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY2FzZSAnaHInOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgIH1cbiAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaGVhZGluZyhcbiAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCksXG4gICAgICAgIHRoaXMudG9rZW4uZGVwdGgsXG4gICAgICAgIHVuZXNjYXBlKHRoaXMuaW5saW5lVGV4dC5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSksXG4gICAgICAgIHRoaXMuc2x1Z2dlcik7XG4gICAgfVxuICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jb2RlKHRoaXMudG9rZW4udGV4dCxcbiAgICAgICAgdGhpcy50b2tlbi5sYW5nLFxuICAgICAgICB0aGlzLnRva2VuLmVzY2FwZWQpO1xuICAgIH1cbiAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgIHZhciBoZWFkZXIgPSAnJyxcbiAgICAgICAgICBib2R5ID0gJycsXG4gICAgICAgICAgaSxcbiAgICAgICAgICByb3csXG4gICAgICAgICAgY2VsbCxcbiAgICAgICAgICBqO1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGNlbGwgPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLmhlYWRlcltpXSksXG4gICAgICAgICAgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSB0aGlzLnRva2VuLmNlbGxzW2ldO1xuXG4gICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQocm93W2pdKSxcbiAgICAgICAgICAgIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25bal0gfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdibG9ja3F1b3RlX3N0YXJ0Jzoge1xuICAgICAgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2Jsb2NrcXVvdGVfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3Rfc3RhcnQnOiB7XG4gICAgICBib2R5ID0gJyc7XG4gICAgICB2YXIgb3JkZXJlZCA9IHRoaXMudG9rZW4ub3JkZXJlZCxcbiAgICAgICAgICBzdGFydCA9IHRoaXMudG9rZW4uc3RhcnQ7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgIGJvZHkgPSAnJztcbiAgICAgIHZhciBsb29zZSA9IHRoaXMudG9rZW4ubG9vc2U7XG4gICAgICB2YXIgY2hlY2tlZCA9IHRoaXMudG9rZW4uY2hlY2tlZDtcbiAgICAgIHZhciB0YXNrID0gdGhpcy50b2tlbi50YXNrO1xuXG4gICAgICBpZiAodGhpcy50b2tlbi50YXNrKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5jaGVja2JveChjaGVja2VkKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9ICFsb29zZSAmJiB0aGlzLnRva2VuLnR5cGUgPT09ICd0ZXh0J1xuICAgICAgICAgID8gdGhpcy5wYXJzZVRleHQoKVxuICAgICAgICAgIDogdGhpcy50b2soKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGJvZHksIHRhc2ssIGNoZWNrZWQpO1xuICAgIH1cbiAgICBjYXNlICdodG1sJzoge1xuICAgICAgLy8gVE9ETyBwYXJzZSBpbmxpbmUgY29udGVudCBpZiBwYXJhbWV0ZXIgbWFya2Rvd249MVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHRtbCh0aGlzLnRva2VuLnRleHQpO1xuICAgIH1cbiAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VUZXh0KCkpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB2YXIgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdGhpcy50b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyTXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTbHVnZ2VyIGdlbmVyYXRlcyBoZWFkZXIgaWRcbiAqL1xuXG5mdW5jdGlvbiBTbHVnZ2VyKCkge1xuICB0aGlzLnNlZW4gPSB7fTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyB0byB1bmlxdWUgaWRcbiAqL1xuXG5TbHVnZ2VyLnByb3RvdHlwZS5zbHVnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIHNsdWcgPSB2YWx1ZVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnRyaW0oKVxuICAgIC5yZXBsYWNlKC9bXFx1MjAwMC1cXHUyMDZGXFx1MkUwMC1cXHUyRTdGXFxcXCchXCIjJCUmKCkqKywuLzo7PD0+P0BbXFxdXmB7fH1+XS9nLCAnJylcbiAgICAucmVwbGFjZSgvXFxzL2csICctJyk7XG5cbiAgaWYgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgIHZhciBvcmlnaW5hbFNsdWcgPSBzbHVnO1xuICAgIGRvIHtcbiAgICAgIHRoaXMuc2VlbltvcmlnaW5hbFNsdWddKys7XG4gICAgICBzbHVnID0gb3JpZ2luYWxTbHVnICsgJy0nICsgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z107XG4gICAgfSB3aGlsZSAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKTtcbiAgfVxuICB0aGlzLnNlZW5bc2x1Z10gPSAwO1xuXG4gIHJldHVybiBzbHVnO1xufTtcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICBpZiAoZW5jb2RlKSB7XG4gICAgaWYgKGVzY2FwZS5lc2NhcGVUZXN0LnRlc3QoaHRtbCkpIHtcbiAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlLmVzY2FwZVJlcGxhY2UsIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBlc2NhcGUucmVwbGFjZW1lbnRzW2NoXTsgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlc2NhcGUuZXNjYXBlVGVzdE5vRW5jb2RlLnRlc3QoaHRtbCkpIHtcbiAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlLmVzY2FwZVJlcGxhY2VOb0VuY29kZSwgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIGVzY2FwZS5yZXBsYWNlbWVudHNbY2hdOyB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaHRtbDtcbn1cblxuZXNjYXBlLmVzY2FwZVRlc3QgPSAvWyY8PlwiJ10vO1xuZXNjYXBlLmVzY2FwZVJlcGxhY2UgPSAvWyY8PlwiJ10vZztcbmVzY2FwZS5yZXBsYWNlbWVudHMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG5cbmVzY2FwZS5lc2NhcGVUZXN0Tm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvO1xuZXNjYXBlLmVzY2FwZVJlcGxhY2VOb0VuY29kZSA9IC9bPD5cIiddfCYoPyEjP1xcdys7KS9nO1xuXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIC8vIGV4cGxpY2l0bHkgbWF0Y2ggZGVjaW1hbCwgaGV4LCBhbmQgbmFtZWQgSFRNTCBlbnRpdGllc1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKC8mKCMoPzpcXGQrKXwoPzojeFswLTlBLUZhLWZdKyl8KD86XFx3KykpOz8vaWcsIGZ1bmN0aW9uKF8sIG4pIHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVkaXQocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZSB8fCByZWdleDtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvKF58W15cXFtdKVxcXi9nLCAnJDEnKTtcbiAgICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRSZWdleDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsZWFuVXJsKHNhbml0aXplLCBiYXNlLCBocmVmKSB7XG4gIGlmIChzYW5pdGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3Ol0vZywgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGJhc2UgJiYgIW9yaWdpbkluZGVwZW5kZW50VXJsLnRlc3QoaHJlZikpIHtcbiAgICBocmVmID0gcmVzb2x2ZVVybChiYXNlLCBocmVmKTtcbiAgfVxuICB0cnkge1xuICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaHJlZjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlLCBocmVmKSB7XG4gIGlmICghYmFzZVVybHNbJyAnICsgYmFzZV0pIHtcbiAgICAvLyB3ZSBjYW4gaWdub3JlIGV2ZXJ5dGhpbmcgaW4gYmFzZSBhZnRlciB0aGUgbGFzdCBzbGFzaCBvZiBpdHMgcGF0aCBjb21wb25lbnQsXG4gICAgLy8gYnV0IHdlIG1pZ2h0IG5lZWQgdG8gYWRkIF90aGF0X1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tM1xuICAgIGlmICgvXlteOl0rOlxcLypbXi9dKiQvLnRlc3QoYmFzZSkpIHtcbiAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gYmFzZSArICcvJztcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZVVybHNbJyAnICsgYmFzZV0gPSBydHJpbShiYXNlLCAnLycsIHRydWUpO1xuICAgIH1cbiAgfVxuICBiYXNlID0gYmFzZVVybHNbJyAnICsgYmFzZV07XG5cbiAgaWYgKGhyZWYuc2xpY2UoMCwgMikgPT09ICcvLycpIHtcbiAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC86W1xcc1xcU10qLywgJzonKSArIGhyZWY7XG4gIH0gZWxzZSBpZiAoaHJlZi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiBiYXNlLnJlcGxhY2UoLyg6XFwvKlteL10qKVtcXHNcXFNdKi8sICckMScpICsgaHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZSArIGhyZWY7XG4gIH1cbn1cbnZhciBiYXNlVXJscyA9IHt9O1xudmFyIG9yaWdpbkluZGVwZW5kZW50VXJsID0gL14kfF5bYS16XVthLXowLTkrLi1dKjp8Xls/I10vaTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5ub29wLmV4ZWMgPSBub29wO1xuXG5mdW5jdGlvbiBtZXJnZShvYmopIHtcbiAgdmFyIGkgPSAxLFxuICAgICAgdGFyZ2V0LFxuICAgICAga2V5O1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBzcGxpdENlbGxzKHRhYmxlUm93LCBjb3VudCkge1xuICAvLyBlbnN1cmUgdGhhdCBldmVyeSBjZWxsLWRlbGltaXRpbmcgcGlwZSBoYXMgYSBzcGFjZVxuICAvLyBiZWZvcmUgaXQgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBhbiBlc2NhcGVkIHBpcGVcbiAgdmFyIHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCBmdW5jdGlvbihtYXRjaCwgb2Zmc2V0LCBzdHIpIHtcbiAgICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGN1cnIgPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlICgtLWN1cnIgPj0gMCAmJiBzdHJbY3Vycl0gPT09ICdcXFxcJykgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgIC8vIG9kZCBudW1iZXIgb2Ygc2xhc2hlcyBtZWFucyB8IGlzIGVzY2FwZWRcbiAgICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICAgIHJldHVybiAnfCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8LyksXG4gICAgICBpID0gMDtcblxuICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICBjZWxscy5zcGxpY2UoY291bnQpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudCkgY2VsbHMucHVzaCgnJyk7XG4gIH1cblxuICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGlzIGlnbm9yZWQgcGVyIHRoZSBnZm0gc3BlY1xuICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTtcbiAgfVxuICByZXR1cm4gY2VsbHM7XG59XG5cbi8vIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4vLyAvYyokLyBpcyB2dWxuZXJhYmxlIHRvIFJFRE9TLlxuLy8gaW52ZXJ0OiBSZW1vdmUgc3VmZml4IG9mIG5vbi1jIGNoYXJzIGluc3RlYWQuIERlZmF1bHQgZmFsc2V5LlxuZnVuY3Rpb24gcnRyaW0oc3RyLCBjLCBpbnZlcnQpIHtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICB2YXIgc3VmZkxlbiA9IDA7XG5cbiAgLy8gU3RlcCBsZWZ0IHVudGlsIHdlIGZhaWwgdG8gbWF0Y2ggdGhlIGludmVydCBjb25kaXRpb24uXG4gIHdoaWxlIChzdWZmTGVuIDwgc3RyLmxlbmd0aCkge1xuICAgIHZhciBjdXJyQ2hhciA9IHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIHN1ZmZMZW4gLSAxKTtcbiAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgc3VmZkxlbisrO1xuICAgIH0gZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICBzdWZmTGVuKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIHN0ci5sZW5ndGggLSBzdWZmTGVuKTtcbn1cblxuZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KHN0ciwgYikge1xuICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBsZXZlbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgIGxldmVsKys7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMV0pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpIHtcbiAgaWYgKG9wdCAmJiBvcHQuc2FuaXRpemUgJiYgIW9wdC5zaWxlbnQpIHtcbiAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBzYW5pdGl6ZSBhbmQgc2FuaXRpemVyIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjcuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vbWFya2VkLmpzLm9yZy8jL1VTSU5HX0FEVkFOQ0VELm1kI29wdGlvbnMnKTtcbiAgfVxufVxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5cbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgLy8gdGhyb3cgZXJyb3IgaW4gY2FzZSBvZiBub24gc3RyaW5nIGlucHV0XG4gIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgfVxuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnXG4gICAgICArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoY2FsbGJhY2sgfHwgdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IG9wdC5oaWdobGlnaHQsXG4gICAgICAgIHRva2VucyxcbiAgICAgICAgcGVuZGluZyxcbiAgICAgICAgaSA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgfVxuXG4gICAgcGVuZGluZyA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH1cblxuICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcblxuICAgICAgcmV0dXJuIGVyclxuICAgICAgICA/IGNhbGxiYWNrKGVycilcbiAgICAgICAgOiBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgIH07XG5cbiAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgIGlmICghcGVuZGluZykgcmV0dXJuIGRvbmUoKTtcblxuICAgIGZvciAoOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdjb2RlJykge1xuICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24oZXJyLCBjb2RlKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICBpZiAoY29kZSA9PSBudWxsIHx8IGNvZGUgPT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbi50ZXh0ID0gY29kZTtcbiAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKHRva2Vuc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdCkgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24ob3B0KTtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKExleGVyLmxleChzcmMsIG9wdCksIG9wdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG4gICAgaWYgKChvcHQgfHwgbWFya2VkLmRlZmF1bHRzKS5zaWxlbnQpIHtcbiAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+J1xuICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgKyAnPC9wcmU+JztcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBtZXJnZShtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZ2V0RGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBiYXNlVXJsOiBudWxsLFxuICAgIGJyZWFrczogZmFsc2UsXG4gICAgZ2ZtOiB0cnVlLFxuICAgIGhlYWRlcklkczogdHJ1ZSxcbiAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICBtYW5nbGU6IHRydWUsXG4gICAgcGVkYW50aWM6IGZhbHNlLFxuICAgIHJlbmRlcmVyOiBuZXcgUmVuZGVyZXIoKSxcbiAgICBzYW5pdGl6ZTogZmFsc2UsXG4gICAgc2FuaXRpemVyOiBudWxsLFxuICAgIHNpbGVudDogZmFsc2UsXG4gICAgc21hcnRMaXN0czogZmFsc2UsXG4gICAgc21hcnR5cGFudHM6IGZhbHNlLFxuICAgIHhodG1sOiBmYWxzZVxuICB9O1xufTtcblxubWFya2VkLmRlZmF1bHRzID0gbWFya2VkLmdldERlZmF1bHRzKCk7XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubWFya2VkLlBhcnNlciA9IFBhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBQYXJzZXIucGFyc2U7XG5cbm1hcmtlZC5SZW5kZXJlciA9IFJlbmRlcmVyO1xubWFya2VkLlRleHRSZW5kZXJlciA9IFRleHRSZW5kZXJlcjtcblxubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5cbm1hcmtlZC5JbmxpbmVMZXhlciA9IElubGluZUxleGVyO1xubWFya2VkLmlubGluZUxleGVyID0gSW5saW5lTGV4ZXIub3V0cHV0O1xuXG5tYXJrZWQuU2x1Z2dlciA9IFNsdWdnZXI7XG5cbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IG1hcmtlZDtcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIG1hcmtlZDsgfSk7XG59IGVsc2Uge1xuICByb290Lm1hcmtlZCA9IG1hcmtlZDtcbn1cbn0pKHRoaXMgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKSk7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbmNvbnN0IG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpXG5jb25zdCBkcmFnZHJvcCA9IHJlcXVpcmUoJ2RyYWctZHJvcCcpXG4vLyBBZGQgUm9ib2RvZyBKUy4gSXQgaXMgYWR2aXNhYmxlIHRvIGluc3RhbGwgUm9ib2RvZyBmcm9tIG5wbS95YXJuLlxuLy8gQnV0IGZvciBleHBlcmltZW50aW5nLCB5b3UgY2FuIHVzZSBhbHNvIFRyYW5zbG9hZGl04oCZcyBDRE4sIEVkZ2x5OlxuLy8gPHNjcmlwdCBzcmM9XCJodHRwczovL3JlbGVhc2VzLnRyYW5zbG9hZGl0LmNvbS91cHB5L3JvYm9kb2cvdjEuMTAuMTEvcm9ib2RvZy5taW4uanNcIj48L3NjcmlwdD5cbmNvbnN0IHJvYm9kb2cgPSByZXF1aXJlKCdAdXBweS9yb2JvZG9nJylcblxuY29uc3QgVFJBTlNMT0FESVRfRVhBTVBMRV9LRVkgPSAnMzVjMWFlZDAzZjUwMTFlOTgyYjZhZmU4MjU5OWI2YTAnXG5jb25zdCBUUkFOU0xPQURJVF9FWEFNUExFX1RFTVBMQVRFID0gJzBiMmVlMmJjMjVkYzQzNjE5NzAwYzJjZTBhNzUxNjRhJ1xuXG4vKipcbiAqIEEgdGV4dGFyZWEgZm9yIG1hcmtkb3duIHRleHQsIHdpdGggc3VwcG9ydCBmb3IgZmlsZSBhdHRhY2htZW50cy5cbiAqXG4gKiAjIyBVc2FnZVxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKVxuICogY29uc3QgbWR0eHQgPSBuZXcgTWFya2Rvd25UZXh0YXJlYShlbGVtZW50KVxuICogbWR0eHQuaW5zdGFsbCgpXG4gKiBgYGBcbiAqL1xuY2xhc3MgTWFya2Rvd25UZXh0YXJlYSB7XG4gIGNvbnN0cnVjdG9yIChlbGVtZW50KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuY29udHJvbHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuY29udHJvbHMuY2xhc3NMaXN0LmFkZCgnbWR0eHQtY29udHJvbHMnKVxuICAgIHRoaXMudXBsb2FkTGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgdGhpcy51cGxvYWRMaW5lLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKVxuICAgIHRoaXMudXBsb2FkTGluZS5jbGFzc0xpc3QuYWRkKCdmb3JtLXVwbG9hZCcpXG5cbiAgICB0aGlzLnVwbG9hZExpbmUuYXBwZW5kQ2hpbGQoXG4gICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVGFwIGhlcmUgdG8gdXBsb2FkIGFuIGF0dGFjaG1lbnQnKSlcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpc1xuICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnbWR0eHQnKVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgZWxlbWVudClcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuY29udHJvbHMpXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy51cGxvYWRMaW5lKVxuXG4gICAgdGhpcy5zZXR1cFVwbG9hZExpbmUoKVxuICAgIHRoaXMuc2V0dXBUZXh0YXJlYURyb3AoKVxuICB9XG5cbiAgc2V0dXBUZXh0YXJlYURyb3AgKCkge1xuICAgIGRyYWdkcm9wKHRoaXMuZWxlbWVudCwgKGZpbGVzKSA9PiB7XG4gICAgICB0aGlzLnVwbG9hZEZpbGVzKGZpbGVzKVxuICAgIH0pXG4gIH1cblxuICBzZXR1cFVwbG9hZExpbmUgKCkge1xuICAgIHRoaXMudXBsb2FkTGluZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMucGlja0ZpbGVzKClcbiAgICB9KVxuICB9XG5cbiAgcmVwb3J0VXBsb2FkRXJyb3IgKGVycikge1xuICAgIHRoaXMudXBsb2FkTGluZS5jbGFzc0xpc3QuYWRkKCdlcnJvcicpXG4gICAgY29uc3QgbWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgIG1lc3NhZ2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZXJyLm1lc3NhZ2UpKVxuICAgIHRoaXMudXBsb2FkTGluZS5pbnNlcnRDaGlsZChtZXNzYWdlLCB0aGlzLnVwbG9hZExpbmUuZmlyc3RDaGlsZClcbiAgfVxuXG4gIHVucmVwb3J0VXBsb2FkRXJyb3IgKCkge1xuICAgIHRoaXMudXBsb2FkTGluZS5jbGFzc0xpc3QucmVtb3ZlKCdlcnJvcicpXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMudXBsb2FkTGluZS5xdWVyeVNlbGVjdG9yKCdtZXNzYWdlJylcbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy51cGxvYWRMaW5lLnJlbW92ZUNoaWxkKG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0QXR0YWNobWVudHMgKGF0dGFjaG1lbnRzKSB7XG4gICAgYXR0YWNobWVudHMuZm9yRWFjaCgoYXR0YWNobWVudCkgPT4ge1xuICAgICAgY29uc3QgeyBmaWxlLCB0aHVtYiB9ID0gYXR0YWNobWVudFxuICAgICAgY29uc3QgbGluayA9IGBcXG5bTEFCRUxdKCR7ZmlsZS5zc2xfdXJsfSlcXG5gXG4gICAgICBjb25zdCBsYWJlbFRleHQgPSBgVmlldyBGaWxlICR7ZmlsZS5iYXNlbmFtZX1gXG4gICAgICBpZiAodGh1bWIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnZhbHVlICs9IGxpbmsucmVwbGFjZSgnTEFCRUwnLCBgIVske2xhYmVsVGV4dH1dKCR7dGh1bWIuc3NsX3VybH0pYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC52YWx1ZSArPSBsaW5rLnJlcGxhY2UoJ0xBQkVMJywgbGFiZWxUZXh0KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBtYXRjaEZpbGVzQW5kVGh1bWJzIChyZXN1bHRzKSB7XG4gICAgY29uc3QgZmlsZXNCeUlkID0ge31cbiAgICBjb25zdCB0aHVtYnNCeUlkID0ge31cblxuICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0LnN0ZXBOYW1lID09PSAndGh1bWJuYWlscycpIHtcbiAgICAgICAgdGh1bWJzQnlJZFtyZXN1bHQub3JpZ2luYWxfaWRdID0gcmVzdWx0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlc0J5SWRbcmVzdWx0Lm9yaWdpbmFsX2lkXSA9IHJlc3VsdFxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlsZXNCeUlkKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gZmlsZXNCeUlkW2tleV1cbiAgICAgIGNvbnN0IHRodW1iID0gdGh1bWJzQnlJZFtrZXldXG4gICAgICBhY2MucHVzaCh7IGZpbGUsIHRodW1iIH0pXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgW10pXG4gIH1cblxuICB1cGxvYWRGaWxlcyAoZmlsZXMpIHtcbiAgICByb2JvZG9nLnVwbG9hZChmaWxlcywge1xuICAgICAgd2FpdEZvckVuY29kaW5nOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGF1dGg6IHsga2V5OiBUUkFOU0xPQURJVF9FWEFNUExFX0tFWSB9LFxuICAgICAgICB0ZW1wbGF0ZV9pZDogVFJBTlNMT0FESVRfRVhBTVBMRV9URU1QTEFURVxuICAgICAgfVxuICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuXG4gICAgICB0aGlzLmluc2VydEF0dGFjaG1lbnRzKFxuICAgICAgICB0aGlzLm1hdGNoRmlsZXNBbmRUaHVtYnMocmVzdWx0LnJlc3VsdHMpXG4gICAgICApXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICB0aGlzLnJlcG9ydFVwbG9hZEVycm9yKGVycilcbiAgICB9KVxuICB9XG5cbiAgcGlja0ZpbGVzICgpIHtcbiAgICByb2JvZG9nLnBpY2soe1xuICAgICAgd2FpdEZvckVuY29kaW5nOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGF1dGg6IHsga2V5OiBUUkFOU0xPQURJVF9FWEFNUExFX0tFWSB9LFxuICAgICAgICB0ZW1wbGF0ZV9pZDogVFJBTlNMT0FESVRfRVhBTVBMRV9URU1QTEFURVxuICAgICAgfSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAnd2ViY2FtJyxcbiAgICAgICAgJ3VybCcsXG4gICAgICAgICdpbnN0YWdyYW0nLFxuICAgICAgICAnZ29vZ2xlLWRyaXZlJyxcbiAgICAgICAgJ2Ryb3Bib3gnXG4gICAgICBdXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm5cbiAgICAgIHRoaXMuaW5zZXJ0QXR0YWNobWVudHMoXG4gICAgICAgIHRoaXMubWF0Y2hGaWxlc0FuZFRodW1icyhyZXN1bHQucmVzdWx0cylcbiAgICAgIClcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIHRoaXMucmVwb3J0VXBsb2FkRXJyb3IoZXJyKVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgdGV4dGFyZWEgPSBuZXcgTWFya2Rvd25UZXh0YXJlYShcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI25ldyB0ZXh0YXJlYScpKVxudGV4dGFyZWEuaW5zdGFsbCgpXG5cbmZ1bmN0aW9uIHJlbmRlclNuaXBwZXQgKHRpdGxlLCB0ZXh0KSB7XG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NuaXBwZXQnKVxuICBjb25zdCBuZXdTbmlwcGV0ID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0cnVlKVxuICBjb25zdCB0aXRsZUVsID0gbmV3U25pcHBldC5xdWVyeVNlbGVjdG9yKCcuc25pcHBldC10aXRsZScpXG4gIGNvbnN0IGNvbnRlbnRFbCA9IG5ld1NuaXBwZXQucXVlcnlTZWxlY3RvcignLnNuaXBwZXQtY29udGVudCcpXG5cbiAgdGl0bGVFbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aXRsZSkpXG4gIGNvbnRlbnRFbC5pbm5lckhUTUwgPSBtYXJrZWQodGV4dClcblxuICBjb25zdCBsaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NuaXBwZXRzJylcbiAgbGlzdC5pbnNlcnRCZWZvcmUobmV3U25pcHBldCwgbGlzdC5maXJzdENoaWxkKVxufVxuXG5mdW5jdGlvbiBzYXZlU25pcHBldCAodGl0bGUsIHRleHQpIHtcbiAgY29uc3QgaWQgPSBwYXJzZUludChsb2NhbFN0b3JhZ2UubnVtU25pcHBldHMgfHwgMCwgMTApXG4gIGxvY2FsU3RvcmFnZVtgc25pcHBldF8ke2lkfWBdID0gSlNPTi5zdHJpbmdpZnkoeyB0aXRsZSwgdGV4dCB9KVxuICBsb2NhbFN0b3JhZ2UubnVtU25pcHBldHMgPSBpZCArIDFcbn1cblxuZnVuY3Rpb24gbG9hZFNuaXBwZXRzICgpIHtcbiAgZm9yIChsZXQgaWQgPSAwOyBsb2NhbFN0b3JhZ2VbYHNuaXBwZXRfJHtpZH1gXSAhPSBudWxsOyBpZCArPSAxKSB7XG4gICAgY29uc3QgeyB0aXRsZSwgdGV4dCB9ID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2VbYHNuaXBwZXRfJHtpZH1gXSlcbiAgICByZW5kZXJTbmlwcGV0KHRpdGxlLCB0ZXh0KVxuICB9XG59XG5cbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNuZXcnKS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCAoZXZlbnQpID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gIGNvbnN0IHRpdGxlID0gZXZlbnQudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9XCJ0aXRsZVwiXScpLnZhbHVlIHx8XG4gICAgJ1VubmFtZWQgU25pcHBldCdcbiAgY29uc3QgdGV4dCA9IHRleHRhcmVhLmVsZW1lbnQudmFsdWVcblxuICBzYXZlU25pcHBldCh0aXRsZSwgdGV4dClcbiAgcmVuZGVyU25pcHBldCh0aXRsZSwgdGV4dClcblxuICBldmVudC50YXJnZXQucXVlcnlTZWxlY3RvcignaW5wdXQnKS52YWx1ZSA9ICcnXG4gIGV2ZW50LnRhcmdldC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpLnZhbHVlID0gJydcbn0pXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICBsb2FkU25pcHBldHMoKVxufSlcbiJdfQ==
